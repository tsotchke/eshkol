;;; core/list/higher_order.esk
;;; Higher-order list functions

(provide map1 map2 map3 fold fold-right for-each any every)

;;; map1: Apply proc to each element of a single list
;;; (map1 double '(1 2 3)) => (2 4 6)
(define (map1 proc lst)
  (if (null? lst)
      '()
      (cons (proc (car lst))
            (map1 proc (cdr lst)))))

;;; map2: Apply proc to corresponding elements of two lists
;;; (map2 + '(1 2 3) '(10 20 30)) => (11 22 33)
(define (map2 proc lst1 lst2)
  (if (null? lst1)
      '()
      (if (null? lst2)
          '()
          (cons (proc (car lst1) (car lst2))
                (map2 proc (cdr lst1) (cdr lst2))))))

;;; map3: Apply proc to corresponding elements of three lists
;;; (map3 (lambda (a b c) (+ a b c)) '(1 2) '(10 20) '(100 200)) => (111 222)
(define (map3 proc lst1 lst2 lst3)
  (if (null? lst1)
      '()
      (if (null? lst2)
          '()
          (if (null? lst3)
              '()
              (cons (proc (car lst1) (car lst2) (car lst3))
                    (map3 proc (cdr lst1) (cdr lst2) (cdr lst3)))))))

;;; fold: Left fold (foldl)
;;; Applies proc to accumulator and each element from left to right
;;; (fold + 0 '(1 2 3 4)) => 10
(define (fold proc init lst)
  (if (null? lst)
      init
      (fold proc (proc init (car lst)) (cdr lst))))

;;; fold-right: Right fold (foldr)
;;; Applies proc to each element and accumulator from right to left
;;; (fold-right cons '() '(1 2 3)) => (1 2 3)
(define (fold-right proc init lst)
  (if (null? lst)
      init
      (proc (car lst) (fold-right proc init (cdr lst)))))

;;; for-each: Apply proc to each element for side effects
;;; Returns undefined (void)
(define (for-each proc lst)
  (if (null? lst)
      #f
      (begin
        (proc (car lst))
        (for-each proc (cdr lst)))))

;;; any: Return #t if any element satisfies predicate
;;; (any even? '(1 3 4 5)) => #t
(define (any pred lst)
  (if (null? lst)
      #f
      (if (pred (car lst))
          #t
          (any pred (cdr lst)))))

;;; every: Return #t if all elements satisfy predicate
;;; (every even? '(2 4 6)) => #t
(define (every pred lst)
  (if (null? lst)
      #t
      (if (pred (car lst))
          (every pred (cdr lst))
          #f)))
