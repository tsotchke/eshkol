/*
 * Copyright (C) tsotchke
 *
 * SPDX-License-Identifier: MIT
 *
 */
#include "eshkol/eshkol.h"
#include <eshkol/llvm_backend.h>
#include <eshkol/logger.h>
#include "../core/arena_memory.h"

#ifdef ESHKOL_LLVM_BACKEND_ENABLED

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/raw_os_ostream.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/TargetParser/Host.h>
#include <llvm/TargetParser/Triple.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Target/TargetOptions.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/CodeGen/CommandFlags.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/Transforms/InstCombine/InstCombine.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Scalar/GVN.h>
#include <llvm/IR/GlobalValue.h>

#include <memory>
#include <map>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <cctype>
#include <stack>
#include <unistd.h>

using namespace llvm;

// Global storage for LLVM contexts to ensure proper lifetime management
struct EshkolLLVMModule {
    std::unique_ptr<LLVMContext> context;
    std::unique_ptr<Module> module;
    
    EshkolLLVMModule(std::unique_ptr<Module> mod, std::unique_ptr<LLVMContext> ctx) 
        : context(std::move(ctx)), module(std::move(mod)) {}
};

static std::map<LLVMModuleRef, std::unique_ptr<EshkolLLVMModule>> g_llvm_modules;

// REPL MODE: Global symbol persistence across CodeGenerator instances
// When REPL mode is enabled, symbols persist across evaluations
namespace {
    bool g_repl_mode_enabled = false;
    std::map<std::string, uint64_t> g_repl_symbol_addresses;     // var_name -> JIT address
    std::map<std::string, uint64_t> g_repl_function_addresses;   // func_name -> JIT address
    std::map<std::string, size_t> g_repl_function_arities;       // func_name -> arity
    std::map<std::string, std::string> g_repl_lambda_names;      // var_name -> lambda_name (e.g., "square" -> "lambda_0")
    std::map<std::string, uint64_t> g_repl_sexpr_values;         // sexpr_name -> s-expression pointer value
    std::map<std::string, std::vector<std::string>> g_repl_lambda_captures;  // lambda_name -> capture variable names
    bool g_repl_displaySExprList_created = false;                // Track if displaySExprList has been created in JIT
    std::mutex g_repl_mutex;  // Thread safety for REPL symbol access
}

// TypedValue structure to carry both LLVM value and type information
struct TypedValue {
    Value* llvm_value;              // LLVM IR value
    eshkol_value_type_t type;       // Our type tag from eshkol.h
    bool is_exact;                  // Scheme exactness tracking
    uint8_t flags;                  // Additional flags (e.g., indirect reference flag)

    // Flag constants
    static constexpr uint8_t FLAG_INDIRECT = 0x01;  // Value is address of global to load from

    TypedValue() : llvm_value(nullptr), type(ESHKOL_VALUE_NULL), is_exact(true), flags(0) {}
    TypedValue(Value* val, eshkol_value_type_t t, bool exact = true, uint8_t f = 0)
        : llvm_value(val), type(t), is_exact(exact), flags(f) {}

    // Helper methods
    bool isInt64() const { return type == ESHKOL_VALUE_INT64; }
    bool isDouble() const { return type == ESHKOL_VALUE_DOUBLE; }
    bool isNull() const { return type == ESHKOL_VALUE_NULL; }
    bool isIndirect() const { return (flags & FLAG_INDIRECT) != 0; }
};

// OPTION 3: Deferred Lambda S-Expression Generation
// Structure to track lambdas that need S-expression generation
struct LambdaSExprMetadata {
    const eshkol_operations_t* lambda_ast;
    std::string lambda_name;
};

// Global vector to accumulate lambdas during compilation
static std::vector<LambdaSExprMetadata> pending_lambda_sexprs;

// Track the most recently generated lambda name for codegenList
static std::string last_generated_lambda_name;

// HOMOICONIC FIX: Map lambda Function* pointers to their S-expression global names
// This allows codegenList to find the correct S-expression for each inline lambda
static std::map<Function*, std::string> lambda_sexpr_map;

class EshkolLLVMCodeGen {
private:
    std::unique_ptr<LLVMContext> context;
    std::unique_ptr<Module> module;
    std::unique_ptr<IRBuilder<>> builder;
    
    // Tagged value struct type for LLVM IR
    StructType* tagged_value_type;
    
    // Dual number struct type for forward-mode automatic differentiation
    StructType* dual_number_type;
    
    // PHASE 3: AD node struct type for reverse-mode automatic differentiation
    StructType* ad_node_type;
    
    // JACOBIAN SEGFAULT FIX: Tensor struct type as class member (shared by all functions)
    // This prevents LLVM IR name conflicts and type mismatches in nested operations
    StructType* tensor_type;
    
    // PHASE 3: Current tape for reverse-mode AD
    Value* current_tape_ptr;
    size_t next_node_id;
    
    std::map<std::string, Value*> symbol_table;
    std::map<std::string, Value*> global_symbol_table; // Persistent global symbols
    std::map<std::string, Function*> function_table;
    
    // Current function being generated
    Function* current_function;
    BasicBlock* main_entry;
    
    // Arena management for list operations - GLOBAL ARENA ARCHITECTURE
    GlobalVariable* global_arena; // Global arena pointer (shared across all scopes)
    size_t arena_scope_depth; // Track nested arena scopes
    
    // PHASE 1 AUTODIFF FIX: Global AD mode flag for runtime context detection
    GlobalVariable* ad_mode_active; // Global flag: true when executing in AD context

    // PHASE 1 AUTODIFF FIX: Global tape pointer for runtime graph recording
    GlobalVariable* current_ad_tape; // Global tape pointer: set by gradient/jacobian/etc operators

    // NESTED GRADIENT FIX: Tape stack for arbitrary-depth nested gradients
    // Allows inner gradients to save/restore outer gradient context
    static const size_t MAX_TAPE_DEPTH = 32; // Support up to 32 levels of nesting
    GlobalVariable* ad_tape_stack;  // Array of tape pointers [MAX_TAPE_DEPTH]
    GlobalVariable* ad_tape_depth;  // Current stack depth (0 = no active gradient)

    // DOUBLE BACKWARD: Storage for outer AD node when in nested gradient
    // Used to connect inner gradient's result to outer's computation graph
    GlobalVariable* outer_ad_node_storage;  // Pointer to outer AD node (or null if not nested)
    GlobalVariable* outer_ad_node_to_inner; // Maps outer AD node to inner variable node
    GlobalVariable* outer_grad_accumulator; // AD node accumulating gradient on outer tape
    GlobalVariable* inner_var_node_ptr;     // Pointer to the inner variable node (for matching)
    GlobalVariable* gradient_x_degree;      // Polynomial degree of gradient in x (for double backward)

    // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes for arbitrary depth nesting
    GlobalVariable* outer_ad_node_stack;    // Array of outer AD node pointers [MAX_TAPE_DEPTH]
    GlobalVariable* outer_ad_node_depth;    // Current depth in the outer AD node stack
    
    Function* arena_create_func;
    Function* arena_destroy_func;
    Function* arena_allocate_func;
    Function* arena_push_scope_func;
    Function* arena_pop_scope_func;
    Function* arena_allocate_cons_cell_func;
    
    // Tagged cons cell function declarations
    Function* arena_allocate_tagged_cons_cell_func;
    Function* arena_tagged_cons_get_int64_func;
    Function* arena_tagged_cons_get_double_func;
    Function* arena_tagged_cons_get_ptr_func;
    Function* arena_tagged_cons_set_int64_func;
    Function* arena_tagged_cons_set_double_func;
    Function* arena_tagged_cons_set_ptr_func;
    Function* arena_tagged_cons_set_null_func;
    Function* arena_tagged_cons_get_type_func;
    
    // Phase 3B: Direct tagged_value access functions
    Function* arena_tagged_cons_set_tagged_value_func;
    Function* arena_tagged_cons_get_tagged_value_func;
    
    // Phase 3: Tape management function declarations for reverse-mode AD
    Function* arena_allocate_tape_func;
    Function* arena_tape_add_node_func;
    Function* arena_tape_reset_func;
    Function* arena_tape_get_node_func;
    Function* arena_tape_get_node_count_func;
    
    // Phase 3: AD node allocation function declarations
    Function* arena_allocate_ad_node_func;
    
    // List operation function declarations (clean, non-redundant)
    Function* length_impl_func;
    Function* append_impl_func;
    Function* reverse_impl_func;
    Function* list_ref_impl_func;
    Function* list_tail_impl_func;
    
    // Nested S-expression display helper (N-depth recursive)
    Function* display_sexpr_list_func;
    // Recursive tensor display helper (N-dimensional nested structure)
    Function* display_tensor_recursive_func;
    
    
public:
    EshkolLLVMCodeGen(const char* module_name) {
        context = std::make_unique<LLVMContext>();
        module = std::make_unique<Module>(module_name, *context);
        builder = std::make_unique<IRBuilder<>>(*context);
        current_function = nullptr;
        global_arena = nullptr; // Will be created in generateIR()
        arena_scope_depth = 0; // Initialize arena scope tracking
        ad_mode_active = nullptr; // Will be created in generateIR()
        ad_tape_stack = nullptr; // Will be created in generateIR()
        ad_tape_depth = nullptr; // Will be created in generateIR()
        
        // Initialize tagged value struct type: {uint8_t type, uint8_t flags, uint16_t reserved, union data}
        std::vector<Type*> tagged_value_fields;
        tagged_value_fields.push_back(Type::getInt8Ty(*context));   // Field 0: type (offset 0)
        tagged_value_fields.push_back(Type::getInt8Ty(*context));   // Field 1: flags (offset 1)
        tagged_value_fields.push_back(Type::getInt16Ty(*context));  // Field 2: reserved (offset 2)
        tagged_value_fields.push_back(Type::getInt32Ty(*context));  // Field 3: PADDING for 8-byte alignment (offset 4)
        tagged_value_fields.push_back(Type::getInt64Ty(*context));  // Field 4: data union (offset 8, 8 bytes)
        tagged_value_type = StructType::create(*context, tagged_value_fields, "eshkol_tagged_value");
        
        // Set target triple
        module->setTargetTriple(Triple(sys::getDefaultTargetTriple()));
        
        // Initialize LLVM targets
        InitializeAllTargetInfos();
        InitializeAllTargets();
        InitializeAllTargetMCs();
        InitializeAllAsmParsers();
        InitializeAllAsmPrinters();
    }
    
    std::pair<std::unique_ptr<Module>, std::unique_ptr<LLVMContext>> generateIR(const eshkol_ast_t* asts, size_t num_asts) {
        try {
            // Create global arena variable (shared across all functions and scopes)
            global_arena = new GlobalVariable(
                *module,
                PointerType::getUnqual(*context),
                false, // not constant
                GlobalValue::InternalLinkage, // Internal linkage - defined in this module
                ConstantPointerNull::get(PointerType::getUnqual(*context)), // Initialize to null
                "__global_arena"
            );
            eshkol_debug("Created global arena variable: __global_arena");
            
            // PHASE 1 AUTODIFF FIX: Create global AD mode flag
            // CRITICAL BUG FIX: In REPL mode, use ExternalLinkage to share flag across JIT modules
            // This allows lambdas compiled in one module to see AD mode set by another module
            // Without this fix, gradient calls on the same function with different vectors crash
            if (g_repl_mode_enabled) {
                ad_mode_active = new GlobalVariable(
                    *module,
                    Type::getInt1Ty(*context),
                    false, // not constant
                    GlobalValue::ExternalLinkage, // External - shared across REPL modules
                    nullptr, // External - no initializer (defined in arena_memory.cpp)
                    "__ad_mode_active"
                );
            } else {
                ad_mode_active = new GlobalVariable(
                    *module,
                    Type::getInt1Ty(*context),
                    false, // not constant
                    GlobalValue::InternalLinkage, // Internal linkage for compiled mode
                    ConstantInt::get(Type::getInt1Ty(*context), 0), // Initialize to false
                    "__ad_mode_active"
                );
                eshkol_debug("Created global AD mode flag: __ad_mode_active (initialized to false)");
            }

            // PHASE 1 AUTODIFF FIX: Create global tape pointer
            // In REPL mode, use ExternalLinkage to share tape across JIT modules
            // In compiler mode, use InternalLinkage with null initializer
            if (g_repl_mode_enabled) {
                current_ad_tape = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false, // not constant
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - no initializer (registered by REPL JIT)
                    "__current_ad_tape"
                );
                eshkol_debug("Created global AD tape pointer: __current_ad_tape (external for REPL cross-module sharing)");
            } else {
                current_ad_tape = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false, // not constant
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)), // Initialize to null
                    "__current_ad_tape"
                );
                eshkol_debug("Created global AD tape pointer: __current_ad_tape (initialized to null)");
            }

            // NESTED GRADIENT FIX: Create tape stack and depth counter
            // These enable arbitrary-depth nested gradient operations
            ArrayType* tape_stack_type = ArrayType::get(PointerType::getUnqual(*context), MAX_TAPE_DEPTH);

            if (g_repl_mode_enabled) {
                // REPL mode: external linkage for cross-module sharing
                ad_tape_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__ad_tape_stack"
                );
                ad_tape_depth = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__ad_tape_depth"
                );

                // DOUBLE BACKWARD: Create outer AD node storage globals (external for REPL)
                outer_ad_node_storage = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__outer_ad_node_storage"
                );
                outer_ad_node_to_inner = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__outer_ad_node_to_inner"
                );
                outer_grad_accumulator = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_grad_accumulator"
                );
                inner_var_node_ptr = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__inner_var_node_ptr"
                );
                gradient_x_degree = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__gradient_x_degree"
                );

                // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes
                outer_ad_node_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,  // Same type as tape stack (array of pointers)
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_ad_node_stack"
                );
                outer_ad_node_depth = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_ad_node_depth"
                );
                eshkol_debug("Created tape stack globals (external for REPL)");
            } else {
                // Compiler mode: internal linkage with zero initializers
                std::vector<Constant*> null_tapes(MAX_TAPE_DEPTH,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)));
                ad_tape_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantArray::get(tape_stack_type, null_tapes),
                    "__ad_tape_stack"
                );
                ad_tape_depth = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(Type::getInt64Ty(*context), 0),
                    "__ad_tape_depth"
                );

                // DOUBLE BACKWARD: Create outer AD node storage globals (internal with null init)
                outer_ad_node_storage = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_ad_node_storage"
                );
                outer_ad_node_to_inner = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_ad_node_to_inner"
                );
                outer_grad_accumulator = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_grad_accumulator"
                );
                inner_var_node_ptr = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__inner_var_node_ptr"
                );
                gradient_x_degree = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(Type::getInt64Ty(*context), 0),
                    "__gradient_x_degree"
                );
                // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes
                outer_ad_node_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantArray::get(tape_stack_type, null_tapes),
                    "__outer_ad_node_stack"
                );
                outer_ad_node_depth = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(Type::getInt64Ty(*context), 0),
                    "__outer_ad_node_depth"
                );
                eshkol_debug("Created tape stack globals (internal with zero init)");
            }

            // Create built-in function declarations
            createBuiltinFunctions();

            // SAFE ORDER: Function declarations → Function bodies → Global variables in main()
            // Global variables (including lambdas) are processed ONLY in main function context
            // This avoids issues with processing lambdas without a function context
            
            // Step 1: Create function declarations FIRST
            for (size_t i = 0; i < num_asts; i++) {
                if (asts[i].type == ESHKOL_OP && asts[i].operation.op == ESHKOL_DEFINE_OP) {
                    if (asts[i].operation.define_op.is_function) {
                        // Create function declaration
                        createFunctionDeclaration(&asts[i]);
                    }
                }
            }
            eshkol_debug("Created all function declarations");
            
            // Step 2: Generate function definitions
            for (size_t i = 0; i < num_asts; i++) {
                if (asts[i].type == ESHKOL_OP && asts[i].operation.op == ESHKOL_DEFINE_OP &&
                    asts[i].operation.define_op.is_function) {
                    codegenAST(&asts[i]);
                }
            }
            
            // Global variable definitions are now handled in the main function context
            // to avoid issues with parentless instructions
            
            // Check if there's a user-defined main function
            bool has_user_main = function_table.find("main") != function_table.end();
            
            if (!has_user_main) {
                // No user main - create main function wrapper for top-level expressions
                createMainWrapper();
                
                // Then generate code for top-level expressions in main
                if (main_entry) {
                    builder->SetInsertPoint(main_entry);
                    current_function = function_table["main"];

                    // CRITICAL FIX: Process ALL expressions in source order to preserve execution semantics
                    // Only function definitions are pre-compiled (declarations, not runtime operations)
                    // Non-function defines (like file handles) and regular expressions must execute in order
                    for (size_t i = 0; i < num_asts; i++) {
                        bool is_function_def = (asts[i].type == ESHKOL_OP &&
                                               asts[i].operation.op == ESHKOL_DEFINE_OP &&
                                               asts[i].operation.define_op.is_function);

                        // Skip function definitions - they were already compiled in pass 1
                        if (!is_function_def) {
                            codegenAST(&asts[i]);

                            // After each expression that might define a lambda, generate its S-expression
                            // This ensures S-expressions are available immediately after the define
                            if (!pending_lambda_sexprs.empty()) {
                                fprintf(stderr, "[TOP-LEVEL] Generating S-expressions for %zu pending lambdas\n",
                                        pending_lambda_sexprs.size());
                                for (size_t j = 0; j < pending_lambda_sexprs.size(); j++) {
                                    const auto& meta = pending_lambda_sexprs[j];
                                    fprintf(stderr, "[TOP-LEVEL] Processing lambda %zu: %s\n", j, meta.lambda_name.c_str());

                                    Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);

                                    // Create or get global variable for this lambda's S-expression
                                    std::string sexpr_key = meta.lambda_name + "_sexpr";
                                    GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                                    if (!sexpr_global) {
                                        sexpr_global = new GlobalVariable(
                                            *module, Type::getInt64Ty(*context), false,
                                            GlobalValue::ExternalLinkage,
                                            ConstantInt::get(Type::getInt64Ty(*context), 0),
                                            sexpr_key
                                        );
                                    }

                                    // DEBUG: Add runtime printf to show value being stored
                                    Function* printf_func = module->getFunction("printf");
                                    if (!printf_func) {
                                        FunctionType* printf_type = FunctionType::get(
                                            Type::getInt32Ty(*context),
                                            {PointerType::getUnqual(*context)},
                                            true);  // varargs
                                        printf_func = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
                                    }
                                    Value* fmt = builder->CreateGlobalStringPtr(("[RUNTIME] Storing sexpr " + meta.lambda_name + ": %lld\n").c_str());
                                    builder->CreateCall(printf_func, {fmt, sexpr_ptr});

                                    builder->CreateStore(sexpr_ptr, sexpr_global);

                                    // Add to global symbol table for display lookup
                                    global_symbol_table[sexpr_key] = sexpr_global;
                                    eshkol_debug("Generated S-expression for lambda %s", meta.lambda_name.c_str());

                                    // Also create variable alias if this lambda was bound to a variable
                                    // CRITICAL FIX: Search for which variable maps to this lambda function
                                    // The variable is stored as "varname_func" -> Function*, where Function->getName() == meta.lambda_name
                                    Function* lambda_func = module->getFunction(meta.lambda_name);
                                    if (lambda_func) {
                                        for (auto& entry : global_symbol_table) {
                                            // Look for keys ending in "_func"
                                            if (entry.first.length() > 5 &&
                                                entry.first.substr(entry.first.length() - 5) == "_func" &&
                                                entry.second == lambda_func) {
                                                // Found the variable that maps to this lambda
                                                std::string var_name = entry.first.substr(0, entry.first.length() - 5);
                                                std::string var_sexpr_key = var_name + "_sexpr";
                                                GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                                                if (!var_sexpr_global) {
                                                    var_sexpr_global = new GlobalVariable(
                                                        *module, Type::getInt64Ty(*context), false,
                                                        GlobalValue::ExternalLinkage,
                                                        ConstantInt::get(Type::getInt64Ty(*context), 0),
                                                        var_sexpr_key
                                                    );
                                                }
                                                Value* lambda_sexpr_val = builder->CreateLoad(Type::getInt64Ty(*context), sexpr_global);
                                                builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                                                global_symbol_table[var_sexpr_key] = var_sexpr_global;
                                                eshkol_debug("Created variable alias: %s -> %s", var_sexpr_key.c_str(), sexpr_key.c_str());
                                                break;  // Found the mapping, exit loop
                                            }
                                        }
                                    }
                                }

                                // Clear pending list after generation
                                pending_lambda_sexprs.clear();
                            }
                        }
                    }
                    
                    // Add terminator to main function if it doesn't have one
                    if (!builder->GetInsertBlock()->getTerminator()) {
                        // GLOBAL ARENA FIX: Cleanup arena before return (SKIP IN REPL MODE)
                        // In REPL mode, s-expressions need to persist across evaluations
                        if (!g_repl_mode_enabled) {
                            Value* arena_to_destroy = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                            builder->CreateCall(arena_destroy_func, {arena_to_destroy});
                            eshkol_debug("Added global arena cleanup before main return (top-level expressions)");
                        } else {
                            eshkol_debug("Skipped arena cleanup in REPL mode to preserve s-expressions (top-level)");
                        }

                        builder->CreateRet(ConstantInt::get(Type::getInt32Ty(*context), 0));
                    }
                }
            } else {
                // User has defined main - just create wrapper (globals already processed above)
                createMainWrapper();
            }
            
            // Verify the module
            std::string error_str;
            std::string ir_str;
            raw_string_ostream error_stream(error_str);
            raw_string_ostream ir_stream(ir_str);
            if (verifyModule(*module, &error_stream)) {
                module->print(ir_stream, nullptr);
                eshkol_error("LLVM module verification failed: %s", error_str.c_str());
                eshkol_debug("LLVM IR:\n%s", ir_str.c_str());
                return std::make_pair(nullptr, nullptr);
            }

            // Transfer ownership of both module and context
            return std::make_pair(std::move(module), std::move(context));
            
        } catch (const std::exception& e) {
            eshkol_error("Exception in LLVM code generation: %s", e.what());
            return std::make_pair(nullptr, nullptr);
        }
    }
    
private:
    void createBuiltinFunctions() {
        // malloc function declaration for dynamic allocation
        std::vector<Type*> malloc_args;
        malloc_args.push_back(Type::getInt64Ty(*context)); // size_t size

        FunctionType* malloc_type = FunctionType::get(
            PointerType::getUnqual(*context), // return void*
            malloc_args,
            false // not varargs
        );

        Function* malloc_func = Function::Create(
            malloc_type,
            Function::ExternalLinkage,
            "malloc",
            module.get()
        );

        function_table["malloc"] = malloc_func;

        // printf function declaration
        std::vector<Type*> printf_args;
        printf_args.push_back(PointerType::getUnqual(*context)); // const char* format
        
        FunctionType* printf_type = FunctionType::get(
            Type::getInt32Ty(*context), // return int
            printf_args,
            true // varargs
        );
        
        Function* printf_func = Function::Create(
            printf_type,
            Function::ExternalLinkage,
            "printf",
            module.get()
        );
        
        function_table["printf"] = printf_func;

        // sin function declaration (from libm)
        std::vector<Type*> sin_args;
        sin_args.push_back(Type::getDoubleTy(*context)); // double x

        FunctionType* sin_type = FunctionType::get(
            Type::getDoubleTy(*context), // return double
            sin_args,
            false // not varargs
        );

        Function* sin_func = Function::Create(
            sin_type,
            Function::ExternalLinkage,
            "sin",
            module.get()
        );

        function_table["sin"] = sin_func;

        // cos function declaration (from libm)
        std::vector<Type*> cos_args;
        cos_args.push_back(Type::getDoubleTy(*context)); // double x

        FunctionType* cos_type = FunctionType::get(
            Type::getDoubleTy(*context), // return double
            cos_args,
            false // not varargs
        );

        Function* cos_func = Function::Create(
            cos_type,
            Function::ExternalLinkage,
            "cos",
            module.get()
        );

        function_table["cos"] = cos_func;

        // sqrt function declaration (from libm)
        std::vector<Type*> sqrt_args;
        sqrt_args.push_back(Type::getDoubleTy(*context)); // double x

        FunctionType* sqrt_type = FunctionType::get(
            Type::getDoubleTy(*context), // return double
            sqrt_args,
            false // not varargs
        );

        Function* sqrt_func = Function::Create(
            sqrt_type,
            Function::ExternalLinkage,
            "sqrt",
            module.get()
        );

        function_table["sqrt"] = sqrt_func;

        // pow function declaration (from libm)
        std::vector<Type*> pow_args;
        pow_args.push_back(Type::getDoubleTy(*context)); // double base
        pow_args.push_back(Type::getDoubleTy(*context)); // double exponent

        FunctionType* pow_type = FunctionType::get(
            Type::getDoubleTy(*context), // return double
            pow_args,
            false // not varargs
        );

        Function* pow_func = Function::Create(
            pow_type,
            Function::ExternalLinkage,
            "pow",
            module.get()
        );

        function_table["pow"] = pow_func;

        // exit function declaration (from stdlib.h)
        std::vector<Type*> exit_args;
        exit_args.push_back(Type::getInt32Ty(*context)); // int status

        FunctionType* exit_type = FunctionType::get(
            Type::getVoidTy(*context), // returns void (actually noreturn)
            exit_args,
            false // not varargs
        );

        Function* exit_func = Function::Create(
            exit_type,
            Function::ExternalLinkage,
            "exit",
            module.get()
        );
        exit_func->addFnAttr(Attribute::NoReturn);

        function_table["exit"] = exit_func;

        // ============================================================================
        // FILE I/O FUNCTIONS (from stdio.h)
        // ============================================================================

        // fopen: FILE* fopen(const char* filename, const char* mode)
        std::vector<Type*> fopen_args;
        fopen_args.push_back(PointerType::get(*context, 0));  // filename
        fopen_args.push_back(PointerType::get(*context, 0));  // mode
        FunctionType* fopen_type = FunctionType::get(
            PointerType::get(*context, 0), fopen_args, false);
        Function* fopen_func = Function::Create(
            fopen_type, Function::ExternalLinkage, "fopen", module.get());
        function_table["fopen"] = fopen_func;

        // fclose: int fclose(FILE* stream)
        std::vector<Type*> fclose_args;
        fclose_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fclose_type = FunctionType::get(
            Type::getInt32Ty(*context), fclose_args, false);
        Function* fclose_func = Function::Create(
            fclose_type, Function::ExternalLinkage, "fclose", module.get());
        function_table["fclose"] = fclose_func;

        // fgets: char* fgets(char* str, int n, FILE* stream)
        std::vector<Type*> fgets_args;
        fgets_args.push_back(PointerType::get(*context, 0));  // str
        fgets_args.push_back(Type::getInt32Ty(*context));      // n
        fgets_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fgets_type = FunctionType::get(
            PointerType::get(*context, 0), fgets_args, false);
        Function* fgets_func = Function::Create(
            fgets_type, Function::ExternalLinkage, "fgets", module.get());
        function_table["fgets"] = fgets_func;

        // feof: int feof(FILE* stream)
        std::vector<Type*> feof_args;
        feof_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* feof_type = FunctionType::get(
            Type::getInt32Ty(*context), feof_args, false);
        Function* feof_func = Function::Create(
            feof_type, Function::ExternalLinkage, "feof", module.get());
        function_table["feof"] = feof_func;

        // fputs: int fputs(const char* str, FILE* stream)
        std::vector<Type*> fputs_args;
        fputs_args.push_back(PointerType::get(*context, 0));  // str
        fputs_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fputs_type = FunctionType::get(
            Type::getInt32Ty(*context), fputs_args, false);
        Function* fputs_func = Function::Create(
            fputs_type, Function::ExternalLinkage, "fputs", module.get());
        function_table["fputs"] = fputs_func;

        // fputc: int fputc(int c, FILE* stream)
        std::vector<Type*> fputc_args;
        fputc_args.push_back(Type::getInt32Ty(*context));      // c
        fputc_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fputc_type = FunctionType::get(
            Type::getInt32Ty(*context), fputc_args, false);
        Function* fputc_func = Function::Create(
            fputc_type, Function::ExternalLinkage, "fputc", module.get());
        function_table["fputc"] = fputc_func;

        // strlen: size_t strlen(const char* str)
        std::vector<Type*> strlen_args;
        strlen_args.push_back(PointerType::get(*context, 0));  // str
        FunctionType* strlen_type = FunctionType::get(
            Type::getInt64Ty(*context), strlen_args, false);
        Function* strlen_func = Function::Create(
            strlen_type, Function::ExternalLinkage, "strlen", module.get());
        function_table["strlen"] = strlen_func;

        // ============================================================================
        // COMPREHENSIVE C STANDARD MATH FUNCTIONS
        // ============================================================================

        // Helper to declare a single-arg math function (double -> double)
        auto declareUnaryMathFunc = [this](const char* name) {
            std::vector<Type*> args = {Type::getDoubleTy(*context)};
            FunctionType* type = FunctionType::get(Type::getDoubleTy(*context), args, false);
            Function* func = Function::Create(type, Function::ExternalLinkage, name, module.get());
            function_table[name] = func;
        };

        // Helper to declare a two-arg math function (double, double -> double)
        auto declareBinaryMathFunc = [this](const char* name) {
            std::vector<Type*> args = {Type::getDoubleTy(*context), Type::getDoubleTy(*context)};
            FunctionType* type = FunctionType::get(Type::getDoubleTy(*context), args, false);
            Function* func = Function::Create(type, Function::ExternalLinkage, name, module.get());
            function_table[name] = func;
        };

        // Trigonometric functions
        declareUnaryMathFunc("tan");
        declareUnaryMathFunc("asin");
        declareUnaryMathFunc("acos");
        declareUnaryMathFunc("atan");
        declareBinaryMathFunc("atan2");

        // Hyperbolic functions
        declareUnaryMathFunc("sinh");
        declareUnaryMathFunc("cosh");
        declareUnaryMathFunc("tanh");
        declareUnaryMathFunc("asinh");
        declareUnaryMathFunc("acosh");
        declareUnaryMathFunc("atanh");

        // Logarithmic
        declareUnaryMathFunc("log10");
        declareUnaryMathFunc("log2");

        // Numeric/rounding functions
        declareUnaryMathFunc("fabs");   // absolute value
        declareUnaryMathFunc("floor");
        declareUnaryMathFunc("ceil");
        declareUnaryMathFunc("round");
        declareUnaryMathFunc("trunc");
        declareBinaryMathFunc("fmod");  // modulo for floats
        declareBinaryMathFunc("remainder");  // IEEE remainder
        declareBinaryMathFunc("fmin");
        declareBinaryMathFunc("fmax");
        declareUnaryMathFunc("cbrt");   // cube root

        // Initialize dual number struct type for forward-mode automatic differentiation
        std::vector<Type*> dual_fields;
        dual_fields.push_back(Type::getDoubleTy(*context));  // value
        dual_fields.push_back(Type::getDoubleTy(*context));  // derivative
        dual_number_type = StructType::create(*context, dual_fields, "dual_number");
        
        eshkol_debug("Created dual_number LLVM type");
        
        // PHASE 3: Initialize AD node struct type for reverse-mode automatic differentiation
        // Structure: {ad_node_type_t type, double value, double gradient, ad_node* input1, ad_node* input2, size_t id}
        std::vector<Type*> ad_node_fields;
        ad_node_fields.push_back(Type::getInt32Ty(*context));  // ad_node_type_t type (enum, 4 bytes)
        ad_node_fields.push_back(Type::getDoubleTy(*context));  // double value
        ad_node_fields.push_back(Type::getDoubleTy(*context));  // double gradient
        ad_node_fields.push_back(PointerType::getUnqual(*context));  // ad_node* input1
        ad_node_fields.push_back(PointerType::getUnqual(*context));  // ad_node* input2
        ad_node_fields.push_back(Type::getInt64Ty(*context));  // size_t id
        ad_node_type = StructType::create(*context, ad_node_fields, "ad_node");
        
        // Initialize tape state
        current_tape_ptr = nullptr;
        next_node_id = 0;
        
        eshkol_debug("Created ad_node LLVM type for reverse-mode AD");
        
        // JACOBIAN SEGFAULT FIX: Create tensor type ONCE as class member
        // Structure: {dimensions*, num_dimensions, elements*, total_elements}
        std::vector<Type*> tensor_fields;
        tensor_fields.push_back(PointerType::getUnqual(*context)); // uint64_t* dimensions
        tensor_fields.push_back(Type::getInt64Ty(*context));       // uint64_t num_dimensions
        tensor_fields.push_back(PointerType::getUnqual(*context)); // double* elements
        tensor_fields.push_back(Type::getInt64Ty(*context));       // uint64_t total_elements
        tensor_type = StructType::create(*context, tensor_fields, "tensor");
        
        eshkol_debug("Created tensor LLVM type (shared by all operations)");

        // Arena management function declarations
        createArenaFunctions();
    }
    
    void createArenaFunctions() {
        // arena_create function declaration: arena_t* arena_create(size_t default_block_size)
        std::vector<Type*> arena_create_args;
        arena_create_args.push_back(Type::getInt64Ty(*context)); // size_t default_block_size

        FunctionType* arena_create_type = FunctionType::get(
            PointerType::getUnqual(*context), // return arena_t*
            arena_create_args,
            false // not varargs
        );

        arena_create_func = Function::Create(
            arena_create_type,
            Function::ExternalLinkage,
            "arena_create",
            module.get()
        );

        function_table["arena_create"] = arena_create_func;

        // arena_destroy function declaration: void arena_destroy(arena_t* arena)
        std::vector<Type*> arena_destroy_args;
        arena_destroy_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena

        FunctionType* arena_destroy_type = FunctionType::get(
            Type::getVoidTy(*context), // return void
            arena_destroy_args,
            false // not varargs
        );

        arena_destroy_func = Function::Create(
            arena_destroy_type,
            Function::ExternalLinkage,
            "arena_destroy",
            module.get()
        );

        function_table["arena_destroy"] = arena_destroy_func;

        // arena_allocate function declaration: void* arena_allocate(arena_t* arena, size_t size)
        std::vector<Type*> arena_allocate_args;
        arena_allocate_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena
        arena_allocate_args.push_back(Type::getInt64Ty(*context)); // size_t size

        FunctionType* arena_allocate_type = FunctionType::get(
            PointerType::getUnqual(*context), // return void*
            arena_allocate_args,
            false // not varargs
        );

        arena_allocate_func = Function::Create(
            arena_allocate_type,
            Function::ExternalLinkage,
            "arena_allocate",
            module.get()
        );

        function_table["arena_allocate"] = arena_allocate_func;

        // arena_push_scope function declaration: void arena_push_scope(arena_t* arena)
        std::vector<Type*> arena_push_scope_args;
        arena_push_scope_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena

        FunctionType* arena_push_scope_type = FunctionType::get(
            Type::getVoidTy(*context), // return void
            arena_push_scope_args,
            false // not varargs
        );

        arena_push_scope_func = Function::Create(
            arena_push_scope_type,
            Function::ExternalLinkage,
            "arena_push_scope",
            module.get()
        );

        function_table["arena_push_scope"] = arena_push_scope_func;

        // arena_pop_scope function declaration: void arena_pop_scope(arena_t* arena)
        std::vector<Type*> arena_pop_scope_args;
        arena_pop_scope_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena

        FunctionType* arena_pop_scope_type = FunctionType::get(
            Type::getVoidTy(*context), // return void
            arena_pop_scope_args,
            false // not varargs
        );

        arena_pop_scope_func = Function::Create(
            arena_pop_scope_type,
            Function::ExternalLinkage,
            "arena_pop_scope",
            module.get()
        );

        function_table["arena_pop_scope"] = arena_pop_scope_func;

        // arena_allocate_cons_cell function declaration: arena_cons_cell_t* arena_allocate_cons_cell(arena_t* arena)
        std::vector<Type*> arena_allocate_cons_cell_args;
        arena_allocate_cons_cell_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena

        FunctionType* arena_allocate_cons_cell_type = FunctionType::get(
            PointerType::getUnqual(*context), // return arena_cons_cell_t*
            arena_allocate_cons_cell_args,
            false // not varargs
        );

        arena_allocate_cons_cell_func = Function::Create(
            arena_allocate_cons_cell_type,
            Function::ExternalLinkage,
            "arena_allocate_cons_cell",
            module.get()
        );

        function_table["arena_allocate_cons_cell"] = arena_allocate_cons_cell_func;

        // arena_allocate_tagged_cons_cell function: arena_tagged_cons_cell_t* arena_allocate_tagged_cons_cell(arena_t* arena)
        std::vector<Type*> arena_allocate_tagged_cons_cell_args;
        arena_allocate_tagged_cons_cell_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena

        FunctionType* arena_allocate_tagged_cons_cell_type = FunctionType::get(
            PointerType::getUnqual(*context), // return arena_tagged_cons_cell_t*
            arena_allocate_tagged_cons_cell_args,
            false // not varargs
        );

        arena_allocate_tagged_cons_cell_func = Function::Create(
            arena_allocate_tagged_cons_cell_type,
            Function::ExternalLinkage,
            "arena_allocate_tagged_cons_cell",
            module.get()
        );

        function_table["arena_allocate_tagged_cons_cell"] = arena_allocate_tagged_cons_cell_func;

        // arena_tagged_cons_get_int64 function: int64_t arena_tagged_cons_get_int64(const arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> arena_tagged_cons_get_int64_args;
        arena_tagged_cons_get_int64_args.push_back(PointerType::getUnqual(*context)); // const arena_tagged_cons_cell_t* cell
        arena_tagged_cons_get_int64_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr

        FunctionType* arena_tagged_cons_get_int64_type = FunctionType::get(
            Type::getInt64Ty(*context), // return int64_t
            arena_tagged_cons_get_int64_args,
            false
        );

        arena_tagged_cons_get_int64_func = Function::Create(
            arena_tagged_cons_get_int64_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_get_int64",
            module.get()
        );

        function_table["arena_tagged_cons_get_int64"] = arena_tagged_cons_get_int64_func;

        // arena_tagged_cons_get_double function: double arena_tagged_cons_get_double(const arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> arena_tagged_cons_get_double_args;
        arena_tagged_cons_get_double_args.push_back(PointerType::getUnqual(*context)); // const arena_tagged_cons_cell_t* cell
        arena_tagged_cons_get_double_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr

        FunctionType* arena_tagged_cons_get_double_type = FunctionType::get(
            Type::getDoubleTy(*context), // return double
            arena_tagged_cons_get_double_args,
            false
        );

        arena_tagged_cons_get_double_func = Function::Create(
            arena_tagged_cons_get_double_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_get_double",
            module.get()
        );

        function_table["arena_tagged_cons_get_double"] = arena_tagged_cons_get_double_func;

        // arena_tagged_cons_get_ptr function: uint64_t arena_tagged_cons_get_ptr(const arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> arena_tagged_cons_get_ptr_args;
        arena_tagged_cons_get_ptr_args.push_back(PointerType::getUnqual(*context)); // const arena_tagged_cons_cell_t* cell
        arena_tagged_cons_get_ptr_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr

        FunctionType* arena_tagged_cons_get_ptr_type = FunctionType::get(
            Type::getInt64Ty(*context), // return uint64_t
            arena_tagged_cons_get_ptr_args,
            false
        );

        arena_tagged_cons_get_ptr_func = Function::Create(
            arena_tagged_cons_get_ptr_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_get_ptr",
            module.get()
        );

        function_table["arena_tagged_cons_get_ptr"] = arena_tagged_cons_get_ptr_func;

        // arena_tagged_cons_set_int64 function: void arena_tagged_cons_set_int64(arena_tagged_cons_cell_t* cell, bool is_cdr, int64_t value, uint8_t type)
        std::vector<Type*> arena_tagged_cons_set_int64_args;
        arena_tagged_cons_set_int64_args.push_back(PointerType::getUnqual(*context)); // arena_tagged_cons_cell_t* cell
        arena_tagged_cons_set_int64_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr
        arena_tagged_cons_set_int64_args.push_back(Type::getInt64Ty(*context)); // int64_t value
        arena_tagged_cons_set_int64_args.push_back(Type::getInt8Ty(*context)); // uint8_t type

        FunctionType* arena_tagged_cons_set_int64_type = FunctionType::get(
            Type::getVoidTy(*context),
            arena_tagged_cons_set_int64_args,
            false
        );

        arena_tagged_cons_set_int64_func = Function::Create(
            arena_tagged_cons_set_int64_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_set_int64",
            module.get()
        );

        function_table["arena_tagged_cons_set_int64"] = arena_tagged_cons_set_int64_func;

        // arena_tagged_cons_set_double function: void arena_tagged_cons_set_double(arena_tagged_cons_cell_t* cell, bool is_cdr, double value, uint8_t type)
        std::vector<Type*> arena_tagged_cons_set_double_args;
        arena_tagged_cons_set_double_args.push_back(PointerType::getUnqual(*context)); // arena_tagged_cons_cell_t* cell
        arena_tagged_cons_set_double_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr
        arena_tagged_cons_set_double_args.push_back(Type::getDoubleTy(*context)); // double value
        arena_tagged_cons_set_double_args.push_back(Type::getInt8Ty(*context)); // uint8_t type

        FunctionType* arena_tagged_cons_set_double_type = FunctionType::get(
            Type::getVoidTy(*context),
            arena_tagged_cons_set_double_args,
            false
        );

        arena_tagged_cons_set_double_func = Function::Create(
            arena_tagged_cons_set_double_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_set_double",
            module.get()
        );

        function_table["arena_tagged_cons_set_double"] = arena_tagged_cons_set_double_func;

        // arena_tagged_cons_set_ptr function: void arena_tagged_cons_set_ptr(arena_tagged_cons_cell_t* cell, bool is_cdr, uint64_t value, uint8_t type)
        std::vector<Type*> arena_tagged_cons_set_ptr_args;
        arena_tagged_cons_set_ptr_args.push_back(PointerType::getUnqual(*context)); // arena_tagged_cons_cell_t* cell
        arena_tagged_cons_set_ptr_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr
        arena_tagged_cons_set_ptr_args.push_back(Type::getInt64Ty(*context)); // uint64_t value
        arena_tagged_cons_set_ptr_args.push_back(Type::getInt8Ty(*context)); // uint8_t type

        FunctionType* arena_tagged_cons_set_ptr_type = FunctionType::get(
            Type::getVoidTy(*context),
            arena_tagged_cons_set_ptr_args,
            false
        );

        arena_tagged_cons_set_ptr_func = Function::Create(
            arena_tagged_cons_set_ptr_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_set_ptr",
            module.get()
        );

        function_table["arena_tagged_cons_set_ptr"] = arena_tagged_cons_set_ptr_func;

        // arena_tagged_cons_set_null function: void arena_tagged_cons_set_null(arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> arena_tagged_cons_set_null_args;
        arena_tagged_cons_set_null_args.push_back(PointerType::getUnqual(*context)); // arena_tagged_cons_cell_t* cell
        arena_tagged_cons_set_null_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr

        FunctionType* arena_tagged_cons_set_null_type = FunctionType::get(
            Type::getVoidTy(*context),
            arena_tagged_cons_set_null_args,
            false
        );

        arena_tagged_cons_set_null_func = Function::Create(
            arena_tagged_cons_set_null_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_set_null",
            module.get()
        );

        function_table["arena_tagged_cons_set_null"] = arena_tagged_cons_set_null_func;

        // arena_tagged_cons_get_type function: uint8_t arena_tagged_cons_get_type(const arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> arena_tagged_cons_get_type_args;
        arena_tagged_cons_get_type_args.push_back(PointerType::getUnqual(*context)); // const arena_tagged_cons_cell_t* cell
        arena_tagged_cons_get_type_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr

        FunctionType* arena_tagged_cons_get_type_type = FunctionType::get(
            Type::getInt8Ty(*context), // return uint8_t
            arena_tagged_cons_get_type_args,
            false
        );

        arena_tagged_cons_get_type_func = Function::Create(
            arena_tagged_cons_get_type_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_get_type",
            module.get()
        );

        function_table["arena_tagged_cons_get_type"] = arena_tagged_cons_get_type_func;
        
        // Phase 3B: arena_tagged_cons_set_tagged_value function:
        // void arena_tagged_cons_set_tagged_value(arena_tagged_cons_cell_t* cell, bool is_cdr, const eshkol_tagged_value_t* value)
        std::vector<Type*> set_tagged_value_args;
        set_tagged_value_args.push_back(PointerType::getUnqual(*context)); // arena_tagged_cons_cell_t* cell
        set_tagged_value_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr
        set_tagged_value_args.push_back(PointerType::getUnqual(*context)); // const eshkol_tagged_value_t* value
        
        FunctionType* set_tagged_value_type = FunctionType::get(
            Type::getVoidTy(*context),
            set_tagged_value_args,
            false
        );
        
        arena_tagged_cons_set_tagged_value_func = Function::Create(
            set_tagged_value_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_set_tagged_value",
            module.get()
        );
        
        function_table["arena_tagged_cons_set_tagged_value"] = arena_tagged_cons_set_tagged_value_func;
        
        // Phase 3B: arena_tagged_cons_get_tagged_value function:
        // eshkol_tagged_value_t arena_tagged_cons_get_tagged_value(const arena_tagged_cons_cell_t* cell, bool is_cdr)
        std::vector<Type*> get_tagged_value_args;
        get_tagged_value_args.push_back(PointerType::getUnqual(*context)); // const arena_tagged_cons_cell_t* cell
        get_tagged_value_args.push_back(Type::getInt1Ty(*context)); // bool is_cdr
        
        FunctionType* get_tagged_value_type = FunctionType::get(
            tagged_value_type, // return eshkol_tagged_value_t
            get_tagged_value_args,
            false
        );
        
        arena_tagged_cons_get_tagged_value_func = Function::Create(
            get_tagged_value_type,
            Function::ExternalLinkage,
            "arena_tagged_cons_get_tagged_value",
            module.get()
        );
        
        function_table["arena_tagged_cons_get_tagged_value"] = arena_tagged_cons_get_tagged_value_func;
        
        // PHASE 3: Tape management function declarations for reverse-mode automatic differentiation
        
        // arena_allocate_tape: ad_tape_t* arena_allocate_tape(arena_t* arena, size_t initial_capacity)
        std::vector<Type*> allocate_tape_args;
        allocate_tape_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena
        allocate_tape_args.push_back(Type::getInt64Ty(*context)); // size_t initial_capacity
        
        FunctionType* allocate_tape_type = FunctionType::get(
            PointerType::getUnqual(*context), // return ad_tape_t*
            allocate_tape_args,
            false
        );
        
        arena_allocate_tape_func = Function::Create(
            allocate_tape_type,
            Function::ExternalLinkage,
            "arena_allocate_tape",
            module.get()
        );
        
        function_table["arena_allocate_tape"] = arena_allocate_tape_func;
        
        // arena_tape_add_node: void arena_tape_add_node(ad_tape_t* tape, ad_node_t* node)
        std::vector<Type*> tape_add_node_args;
        tape_add_node_args.push_back(PointerType::getUnqual(*context)); // ad_tape_t* tape
        tape_add_node_args.push_back(PointerType::getUnqual(*context)); // ad_node_t* node
        
        FunctionType* tape_add_node_type = FunctionType::get(
            Type::getVoidTy(*context),
            tape_add_node_args,
            false
        );
        
        arena_tape_add_node_func = Function::Create(
            tape_add_node_type,
            Function::ExternalLinkage,
            "arena_tape_add_node",
            module.get()
        );
        
        function_table["arena_tape_add_node"] = arena_tape_add_node_func;
        
        // arena_tape_reset: void arena_tape_reset(ad_tape_t* tape)
        std::vector<Type*> tape_reset_args;
        tape_reset_args.push_back(PointerType::getUnqual(*context)); // ad_tape_t* tape
        
        FunctionType* tape_reset_type = FunctionType::get(
            Type::getVoidTy(*context),
            tape_reset_args,
            false
        );
        
        arena_tape_reset_func = Function::Create(
            tape_reset_type,
            Function::ExternalLinkage,
            "arena_tape_reset",
            module.get()
        );
        
        function_table["arena_tape_reset"] = arena_tape_reset_func;
        
        // arena_allocate_ad_node: ad_node_t* arena_allocate_ad_node(arena_t* arena)
        std::vector<Type*> allocate_ad_node_args;
        allocate_ad_node_args.push_back(PointerType::getUnqual(*context)); // arena_t* arena
        
        FunctionType* allocate_ad_node_type = FunctionType::get(
            PointerType::getUnqual(*context), // return ad_node_t*
            allocate_ad_node_args,
            false
        );
        
        arena_allocate_ad_node_func = Function::Create(
            allocate_ad_node_type,
            Function::ExternalLinkage,
            "arena_allocate_ad_node",
            module.get()
        );
        
        function_table["arena_allocate_ad_node"] = arena_allocate_ad_node_func;
        
        // arena_tape_get_node: ad_node_t* arena_tape_get_node(const ad_tape_t* tape, size_t index)
        std::vector<Type*> tape_get_node_args;
        tape_get_node_args.push_back(PointerType::getUnqual(*context)); // const ad_tape_t* tape
        tape_get_node_args.push_back(Type::getInt64Ty(*context)); // size_t index
        
        FunctionType* tape_get_node_type = FunctionType::get(
            PointerType::getUnqual(*context), // return ad_node_t*
            tape_get_node_args,
            false
        );
        
        arena_tape_get_node_func = Function::Create(
            tape_get_node_type,
            Function::ExternalLinkage,
            "arena_tape_get_node",
            module.get()
        );
        
        function_table["arena_tape_get_node"] = arena_tape_get_node_func;
        
        // arena_tape_get_node_count: size_t arena_tape_get_node_count(const ad_tape_t* tape)
        std::vector<Type*> tape_get_node_count_args;
        tape_get_node_count_args.push_back(PointerType::getUnqual(*context)); // const ad_tape_t* tape
        
        FunctionType* tape_get_node_count_type = FunctionType::get(
            Type::getInt64Ty(*context), // return size_t
            tape_get_node_count_args,
            false
        );
        
        arena_tape_get_node_count_func = Function::Create(
            tape_get_node_count_type,
            Function::ExternalLinkage,
            "arena_tape_get_node_count",
            module.get()
        );
        
        function_table["arena_tape_get_node_count"] = arena_tape_get_node_count_func;
        
        eshkol_debug("Created tape management function declarations for reverse-mode AD");
        
        // Create nested S-expression display helper (N-depth recursive)
        createDisplaySExprListFunction();
    }
    
    void createDisplaySExprListFunction() {
        // Recursive helper function for displaying nested S-expressions at arbitrary depth
        // Signature: void displaySExprList(int64_t list_ptr, int32_t depth)

        std::vector<Type*> params;
        params.push_back(Type::getInt64Ty(*context));  // list_ptr
        params.push_back(Type::getInt32Ty(*context));  // depth

        FunctionType* func_type = FunctionType::get(
            Type::getVoidTy(*context),  // returns void
            params,
            false  // not varargs
        );

        // REPL MODE: Check if function was already created in a previous module
        if (g_repl_mode_enabled && g_repl_displaySExprList_created) {
            // Function already exists in JIT - create declaration only
            display_sexpr_list_func = Function::Create(
                func_type,
                GlobalValue::ExternalLinkage,
                "displaySExprList",
                module.get()
            );
            return;  // Don't create the body again
        }

        // REPL MODE: Use ExternalLinkage so function can be shared across modules
        GlobalValue::LinkageTypes linkage = g_repl_mode_enabled ?
            GlobalValue::ExternalLinkage : GlobalValue::InternalLinkage;

        display_sexpr_list_func = Function::Create(
            func_type,
            linkage,
            "displaySExprList",
            module.get()
        );

        // Mark as created in REPL mode
        if (g_repl_mode_enabled) {
            g_repl_displaySExprList_created = true;
        }

        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", display_sexpr_list_func);
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        builder->SetInsertPoint(entry);
        
        // Get parameters
        auto arg_it = display_sexpr_list_func->arg_begin();
        Value* list_ptr_param = &*arg_it++;
        list_ptr_param->setName("list_ptr");
        Value* depth_param = &*arg_it;
        depth_param->setName("depth");
        
        Function* printf_func = function_table["printf"];
        
        // DEPTH LIMIT CHECK (prevent infinite loops from circular structures)
        Value* max_depth = ConstantInt::get(Type::getInt32Ty(*context), 20);
        Value* depth_exceeded = builder->CreateICmpUGT(depth_param, max_depth);
        
        BasicBlock* depth_ok = BasicBlock::Create(*context, "depth_ok", display_sexpr_list_func);
        BasicBlock* depth_exceeded_block = BasicBlock::Create(*context, "depth_exceeded", display_sexpr_list_func);
        BasicBlock* func_exit = BasicBlock::Create(*context, "func_exit", display_sexpr_list_func);
        
        builder->CreateCondBr(depth_exceeded, depth_exceeded_block, depth_ok);
        
        // Depth exceeded: print warning and return
        builder->SetInsertPoint(depth_exceeded_block);
        builder->CreateCall(printf_func, {codegenString("[depth-limit-exceeded]")});
        builder->CreateBr(func_exit);
        
        // Depth OK: continue with display
        builder->SetInsertPoint(depth_ok);
        
        // Print opening parenthesis
        builder->CreateCall(printf_func, {codegenString("(")});
        
        // Initialize loop state
        Value* current = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "current");
        Value* is_first = builder->CreateAlloca(Type::getInt1Ty(*context), nullptr, "is_first");
        builder->CreateStore(list_ptr_param, current);
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), is_first);
        
        // Create loop blocks
        BasicBlock* loop_cond = BasicBlock::Create(*context, "loop_cond", display_sexpr_list_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "loop_body", display_sexpr_list_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "loop_exit", display_sexpr_list_func);
        
        builder->CreateBr(loop_cond);
        
        // Loop condition: while current != null
        builder->SetInsertPoint(loop_cond);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current);
        Value* not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(not_null, loop_body, loop_exit);
        
        // Loop body: display element
        builder->SetInsertPoint(loop_body);
        
        // Add spacing before non-first elements
        Value* first_flag = builder->CreateLoad(Type::getInt1Ty(*context), is_first);
        BasicBlock* skip_space = BasicBlock::Create(*context, "skip_space", display_sexpr_list_func);
        BasicBlock* add_space = BasicBlock::Create(*context, "add_space", display_sexpr_list_func);
        BasicBlock* display_elem = BasicBlock::Create(*context, "display_elem", display_sexpr_list_func);
        
        builder->CreateCondBr(first_flag, skip_space, add_space);
        
        builder->SetInsertPoint(add_space);
        builder->CreateCall(printf_func, {codegenString(" ")});
        builder->CreateBr(display_elem);
        
        builder->SetInsertPoint(skip_space);
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), is_first);
        builder->CreateBr(display_elem);
        
        // Display element - extract car and check type
        builder->SetInsertPoint(display_elem);
        Value* car_tagged = extractCarAsTaggedValue(current_val);
        Value* car_type = getTaggedValueType(car_tagged);
        Value* car_base = builder->CreateAnd(car_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // Type branching: CONS_PTR, STRING_PTR, DOUBLE, or INT64
        Value* car_is_ptr = builder->CreateICmpEQ(car_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* car_is_string = builder->CreateICmpEQ(car_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
        Value* car_is_double = builder->CreateICmpEQ(car_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

        BasicBlock* check_ptr = BasicBlock::Create(*context, "check_ptr", display_sexpr_list_func);
        BasicBlock* check_string_ptr = BasicBlock::Create(*context, "check_string_ptr", display_sexpr_list_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "check_double", display_sexpr_list_func);
        BasicBlock* display_string = BasicBlock::Create(*context, "display_string", display_sexpr_list_func);
        BasicBlock* display_symbol = BasicBlock::Create(*context, "display_symbol", display_sexpr_list_func);
        BasicBlock* display_nested = BasicBlock::Create(*context, "display_nested_rec", display_sexpr_list_func);
        BasicBlock* display_double = BasicBlock::Create(*context, "display_double", display_sexpr_list_func);
        BasicBlock* display_int = BasicBlock::Create(*context, "display_int", display_sexpr_list_func);
        BasicBlock* elem_done = BasicBlock::Create(*context, "elem_done", display_sexpr_list_func);

        builder->CreateCondBr(car_is_ptr, check_ptr, check_string_ptr);

        // Check if STRING_PTR (symbols like variable names: x, y, etc.)
        builder->SetInsertPoint(check_string_ptr);
        builder->CreateCondBr(car_is_string, display_symbol, check_double);

        // Display symbol (STRING_PTR) - variable names like x, y, n, etc.
        builder->SetInsertPoint(display_symbol);
        Value* symbol_ptr_int = unpackInt64FromTaggedValue(car_tagged);
        Value* symbol_ptr = builder->CreateIntToPtr(symbol_ptr_int, builder->getPtrTy());
        builder->CreateCall(printf_func, {codegenString("%s"), symbol_ptr});
        builder->CreateBr(elem_done);
        
        // Check if CONS_PTR is string or nested list using ASCII heuristic
        builder->SetInsertPoint(check_ptr);
        Value* car_ptr_int = unpackInt64FromTaggedValue(car_tagged);
        Value* car_ptr = builder->CreateIntToPtr(car_ptr_int, builder->getPtrTy());
        
        // String detection: check pointer range and first byte
        Value* ptr_reasonable = builder->CreateICmpUGT(car_ptr_int,
            ConstantInt::get(Type::getInt64Ty(*context), 1000));
        Value* ptr_not_huge = builder->CreateICmpULT(car_ptr_int,
            ConstantInt::get(Type::getInt64Ty(*context), 0x7FFFFFFFFFFFFFFFULL));
        Value* ptr_in_range = builder->CreateAnd(ptr_reasonable, ptr_not_huge);
        
        BasicBlock* check_ascii = BasicBlock::Create(*context, "check_ascii", display_sexpr_list_func);
        builder->CreateCondBr(ptr_in_range, check_ascii, display_nested);
        
        builder->SetInsertPoint(check_ascii);
        Value* first_byte = builder->CreateLoad(Type::getInt8Ty(*context), car_ptr);
        Value* is_printable = builder->CreateAnd(
            builder->CreateICmpUGE(first_byte, ConstantInt::get(Type::getInt8Ty(*context), 32)),
            builder->CreateICmpULE(first_byte, ConstantInt::get(Type::getInt8Ty(*context), 126)));
        builder->CreateCondBr(is_printable, display_string, display_nested);
        
        // Display string symbol (operators like "+", "*", "sin", etc.)
        builder->SetInsertPoint(display_string);
        builder->CreateCall(printf_func, {codegenString("%s"), car_ptr});
        builder->CreateBr(elem_done);
        
        // Display nested list - RECURSIVE CALL for N-depth support!
        builder->SetInsertPoint(display_nested);
        Value* next_depth = builder->CreateAdd(depth_param, ConstantInt::get(Type::getInt32Ty(*context), 1));
        builder->CreateCall(display_sexpr_list_func, {car_ptr_int, next_depth});  // Recursion!
        builder->CreateBr(elem_done);
        
        // Display double
        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(car_is_double, display_double, display_int);
        
        builder->SetInsertPoint(display_double);
        Value* car_double_val = unpackDoubleFromTaggedValue(car_tagged);
        builder->CreateCall(printf_func, {codegenString("%g"), car_double_val});
        builder->CreateBr(elem_done);
        
        // Display int
        builder->SetInsertPoint(display_int);
        Value* car_int_val = unpackInt64FromTaggedValue(car_tagged);
        builder->CreateCall(printf_func, {codegenString("%lld"), car_int_val});
        builder->CreateBr(elem_done);
        
        // Move to next element (cdr traversal)
        builder->SetInsertPoint(elem_done);
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_cdr});
        Value* cdr_base = builder->CreateAnd(cdr_type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* cdr_is_ptr = builder->CreateICmpEQ(cdr_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        
        BasicBlock* cdr_ptr = BasicBlock::Create(*context, "cdr_ptr", display_sexpr_list_func);
        BasicBlock* cdr_end = BasicBlock::Create(*context, "cdr_end", display_sexpr_list_func);
        
        builder->CreateCondBr(cdr_is_ptr, cdr_ptr, cdr_end);
        
        builder->SetInsertPoint(cdr_ptr);
        Value* next_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(next_ptr, current);
        builder->CreateBr(loop_cond);
        
        builder->SetInsertPoint(cdr_end);
        builder->CreateCondBr(cdr_is_null, loop_exit, loop_exit);
        
        // Loop exit: close parenthesis and return
        builder->SetInsertPoint(loop_exit);
        builder->CreateCall(printf_func, {codegenString(")")});
        builder->CreateBr(func_exit);
        
        builder->SetInsertPoint(func_exit);
        builder->CreateRetVoid();
        
        // Restore insertion point
        builder->restoreIP(old_point);
        
        function_table["displaySExprList"] = display_sexpr_list_func;
        eshkol_debug("Created recursive N-depth S-expression display helper function");
    }
    
    void createDisplayTensorRecursiveFunction() {
        // Recursive helper function for displaying tensors with proper dimensional nesting
        // Signature: void displayTensorRecursive(double* elements, uint64_t* dims, uint64_t num_dims, uint64_t current_dim, uint64_t offset)
        
        
        std::vector<Type*> params;
        params.push_back(PointerType::getUnqual(*context));  // double* elements
        params.push_back(PointerType::getUnqual(*context));  // uint64_t* dims
        params.push_back(Type::getInt64Ty(*context));        // uint64_t num_dims
        params.push_back(Type::getInt64Ty(*context));        // uint64_t current_dim
        params.push_back(Type::getInt64Ty(*context));        // uint64_t offset
        
        FunctionType* func_type = FunctionType::get(
            Type::getVoidTy(*context),
            params,
            false  // not varargs
        );
        
        display_tensor_recursive_func = Function::Create(
            func_type,
            Function::InternalLinkage,
            "displayTensorRecursive",
            module.get()
        );
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", display_tensor_recursive_func);
        
        // Save old insertion point
        IRBuilderBase::InsertPoint old_ip = builder->saveIP();
        builder->SetInsertPoint(entry);
        
        // Get parameters
        auto arg_it = display_tensor_recursive_func->arg_begin();
        Value* elements = &*arg_it++;
        elements->setName("elements");
        Value* dims = &*arg_it++;
        dims->setName("dims");
        Value* num_dims = &*arg_it++;
        num_dims->setName("num_dims");
        Value* current_dim = &*arg_it++;
        current_dim->setName("current_dim");
        Value* offset = &*arg_it;
        offset->setName("offset");
        
        Function* printf_func = function_table["printf"];
        
        // Check: current_dim == num_dims - 1? (base case)
        Value* num_dims_minus_1 = builder->CreateSub(num_dims, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* is_base_case = builder->CreateICmpEQ(current_dim, num_dims_minus_1);
        
        BasicBlock* base_case = BasicBlock::Create(*context, "base_case", display_tensor_recursive_func);
        BasicBlock* recursive_case = BasicBlock::Create(*context, "recursive_case", display_tensor_recursive_func);
        BasicBlock* func_exit = BasicBlock::Create(*context, "exit", display_tensor_recursive_func);
        
        builder->CreateCondBr(is_base_case, base_case, recursive_case);
        
        // === BASE CASE: Print innermost dimension ===
        builder->SetInsertPoint(base_case);
        builder->CreateCall(printf_func, {codegenString("(")});
        
        // Get dimension size at current_dim
        Value* dim_size_ptr = builder->CreateGEP(Type::getInt64Ty(*context), dims, current_dim);
        Value* dim_size = builder->CreateLoad(Type::getInt64Ty(*context), dim_size_ptr);
        
        // Loop: print elements
        BasicBlock* base_loop_cond = BasicBlock::Create(*context, "base_loop_cond", display_tensor_recursive_func);
        BasicBlock* base_loop_body = BasicBlock::Create(*context, "base_loop_body", display_tensor_recursive_func);
        BasicBlock* base_loop_exit = BasicBlock::Create(*context, "base_loop_exit", display_tensor_recursive_func);
        
        Value* base_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "base_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), base_i);
        builder->CreateBr(base_loop_cond);
        
        builder->SetInsertPoint(base_loop_cond);
        Value* i_val = builder->CreateLoad(Type::getInt64Ty(*context), base_i);
        Value* i_less = builder->CreateICmpULT(i_val, dim_size);
        builder->CreateCondBr(i_less, base_loop_body, base_loop_exit);
        
        builder->SetInsertPoint(base_loop_body);
        // Add space before non-first elements
        Value* i_is_zero = builder->CreateICmpEQ(i_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* skip_space = BasicBlock::Create(*context, "skip_space", display_tensor_recursive_func);
        BasicBlock* print_space = BasicBlock::Create(*context, "print_space", display_tensor_recursive_func);
        BasicBlock* print_elem = BasicBlock::Create(*context, "print_elem", display_tensor_recursive_func);
        
        builder->CreateCondBr(i_is_zero, skip_space, print_space);
        
        builder->SetInsertPoint(print_space);
        builder->CreateCall(printf_func, {codegenString(" ")});
        builder->CreateBr(print_elem);
        
        builder->SetInsertPoint(skip_space);
        builder->CreateBr(print_elem);
        
        builder->SetInsertPoint(print_elem);
        // Print element at offset + i
        Value* elem_idx = builder->CreateAdd(offset, i_val);
        Value* elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), elements, elem_idx);
        Value* elem_val = builder->CreateLoad(Type::getDoubleTy(*context), elem_ptr);
        builder->CreateCall(printf_func, {codegenString("%g"), elem_val});
        
        // Increment i
        Value* i_next = builder->CreateAdd(i_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(i_next, base_i);
        builder->CreateBr(base_loop_cond);
        
        builder->SetInsertPoint(base_loop_exit);
        builder->CreateCall(printf_func, {codegenString(")")});
        builder->CreateBr(func_exit);
        
        // === RECURSIVE CASE: Process outer dimension ===
        builder->SetInsertPoint(recursive_case);
        builder->CreateCall(printf_func, {codegenString("(")});
        
        // Calculate stride = product of dims[current_dim+1..num_dims-1]
        Value* stride = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "stride");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), stride);
        
        // Compute stride using loop
        Value* next_dim = builder->CreateAdd(current_dim, ConstantInt::get(Type::getInt64Ty(*context), 1));
        
        BasicBlock* stride_loop_cond = BasicBlock::Create(*context, "stride_cond", display_tensor_recursive_func);
        BasicBlock* stride_loop_body = BasicBlock::Create(*context, "stride_body", display_tensor_recursive_func);
        BasicBlock* stride_loop_exit = BasicBlock::Create(*context, "stride_exit", display_tensor_recursive_func);
        
        Value* k = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "k");
        builder->CreateStore(next_dim, k);
        builder->CreateBr(stride_loop_cond);
        
        builder->SetInsertPoint(stride_loop_cond);
        Value* k_val = builder->CreateLoad(Type::getInt64Ty(*context), k);
        Value* k_less = builder->CreateICmpULT(k_val, num_dims);
        builder->CreateCondBr(k_less, stride_loop_body, stride_loop_exit);
        
        builder->SetInsertPoint(stride_loop_body);
        Value* dim_k_ptr = builder->CreateGEP(Type::getInt64Ty(*context), dims, k_val);
        Value* dim_k = builder->CreateLoad(Type::getInt64Ty(*context), dim_k_ptr);
        Value* current_stride = builder->CreateLoad(Type::getInt64Ty(*context), stride);
        Value* new_stride = builder->CreateMul(current_stride, dim_k);
        builder->CreateStore(new_stride, stride);
        Value* k_next = builder->CreateAdd(k_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(k_next, k);
        builder->CreateBr(stride_loop_cond);
        
        builder->SetInsertPoint(stride_loop_exit);
        Value* final_stride = builder->CreateLoad(Type::getInt64Ty(*context), stride);
        
        // Get current dimension size
        Value* curr_dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), dims, current_dim);
        Value* curr_dim_size = builder->CreateLoad(Type::getInt64Ty(*context), curr_dim_ptr);
        
        // Loop over current dimension, recursing for each slice
        BasicBlock* rec_loop_cond = BasicBlock::Create(*context, "rec_loop_cond", display_tensor_recursive_func);
        BasicBlock* rec_loop_body = BasicBlock::Create(*context, "rec_loop_body", display_tensor_recursive_func);
        BasicBlock* rec_loop_exit = BasicBlock::Create(*context, "rec_loop_exit", display_tensor_recursive_func);
        
        Value* rec_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "rec_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), rec_i);
        builder->CreateBr(rec_loop_cond);
        
        builder->SetInsertPoint(rec_loop_cond);
        Value* i_val_rec = builder->CreateLoad(Type::getInt64Ty(*context), rec_i);
        Value* i_less_rec = builder->CreateICmpULT(i_val_rec, curr_dim_size);
        builder->CreateCondBr(i_less_rec, rec_loop_body, rec_loop_exit);
        
        builder->SetInsertPoint(rec_loop_body);
        // Add space before non-first slices
        Value* i_is_zero_rec = builder->CreateICmpEQ(i_val_rec, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* skip_space_rec = BasicBlock::Create(*context, "skip_space_rec", display_tensor_recursive_func);
        BasicBlock* print_space_rec = BasicBlock::Create(*context, "print_space_rec", display_tensor_recursive_func);
        BasicBlock* make_recursive_call = BasicBlock::Create(*context, "recursive_call", display_tensor_recursive_func);
        
        builder->CreateCondBr(i_is_zero_rec, skip_space_rec, print_space_rec);
        
        builder->SetInsertPoint(print_space_rec);
        builder->CreateCall(printf_func, {codegenString(" ")});
        builder->CreateBr(make_recursive_call);
        
        builder->SetInsertPoint(skip_space_rec);
        builder->CreateBr(make_recursive_call);
        
        builder->SetInsertPoint(make_recursive_call);
        // RECURSIVE CALL: Process next dimension at offset + i*stride
        Value* new_offset = builder->CreateAdd(offset, builder->CreateMul(i_val_rec, final_stride));
        builder->CreateCall(display_tensor_recursive_func, {
            elements,
            dims,
            num_dims,
            next_dim,
            new_offset
        });
        
        // Increment i
        Value* i_next_rec = builder->CreateAdd(i_val_rec, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(i_next_rec, rec_i);
        builder->CreateBr(rec_loop_cond);
        
        builder->SetInsertPoint(rec_loop_exit);
        builder->CreateCall(printf_func, {codegenString(")")});
        builder->CreateBr(func_exit);
        
        // Exit point
        builder->SetInsertPoint(func_exit);
        builder->CreateRetVoid();
        
        // Restore insertion point
        builder->restoreIP(old_ip);
        
        function_table["displayTensorRecursive"] = display_tensor_recursive_func;
        eshkol_debug("Created recursive N-dimensional tensor display helper function");
    }
    
    void createFunctionDeclaration(const eshkol_ast_t* ast) {
        if (ast->type != ESHKOL_OP || ast->operation.op != ESHKOL_DEFINE_OP || 
            !ast->operation.define_op.is_function) {
            return;
        }
        
        const char* func_name = ast->operation.define_op.name;
        uint64_t num_params = ast->operation.define_op.num_params;
        
        // Create polymorphic function type - all parameters and return type are tagged_value
        std::vector<Type*> param_types(num_params, tagged_value_type);
        FunctionType* func_type = FunctionType::get(
            tagged_value_type, // return tagged_value
            param_types,
            false // not varargs
        );
        
        Function* function = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );
        
        // Set parameter names
        if (ast->operation.define_op.parameters) {
            auto arg_it = function->arg_begin();
            for (uint64_t i = 0; i < num_params && arg_it != function->arg_end(); ++i, ++arg_it) {
                if (ast->operation.define_op.parameters[i].type == ESHKOL_VAR &&
                    ast->operation.define_op.parameters[i].variable.id) {
                    arg_it->setName(ast->operation.define_op.parameters[i].variable.id);
                }
            }
        }
        
        registerContextFunction(func_name, function);
        eshkol_debug("Created polymorphic function declaration: %s with %llu tagged_value parameters",
                    func_name, (unsigned long long)num_params);
    }
    
    void createMainWrapper() {
        // Check if main function exists
        Function* main_func = function_table["main"];
        if (main_func) {
            // Rename the Scheme main function first to avoid name conflict
            main_func->setName("scheme_main");
            
            // Create C-style main function that calls Scheme main
            FunctionType* c_main_type = FunctionType::get(Type::getInt32Ty(*context), false);
            Function* c_main = Function::Create(c_main_type, Function::ExternalLinkage, "main", module.get());
            
            main_entry = BasicBlock::Create(*context, "entry", c_main);
            
            // OPTION 3: Generate S-expressions for all lambdas BEFORE any code runs
            // This ensures S-expressions are available when lambdas are displayed
            if (!pending_lambda_sexprs.empty()) {
                // Start at entry block, initialize arena
                builder->SetInsertPoint(main_entry);

                // REPL MODE FIX: Use shared arena instead of creating new one
                Value* arena_ptr;
                if (g_repl_mode_enabled) {
                    // Load the shared arena pointer from external symbol (single load)
                    GlobalVariable* shared_arena_ref = new GlobalVariable(
                        *module,
                        PointerType::getUnqual(*context),
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer (external)
                        "__repl_shared_arena"
                    );
                    arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                    eshkol_debug("Loaded shared REPL arena");
                } else {
                    // Normal mode: create new arena
                    Value* arena_size = ConstantInt::get(Type::getInt64Ty(*context), 8192);
                    arena_ptr = builder->CreateCall(arena_create_func, {arena_size});
                    eshkol_debug("Created new arena in main wrapper");
                }
                builder->CreateStore(arena_ptr, global_arena);
                
                // Generate S-expressions now that arena is ready
                fprintf(stderr, "[COMPILE] Generating deferred lambda S-expressions for %zu lambdas\n", pending_lambda_sexprs.size());

                for (size_t i = 0; i < pending_lambda_sexprs.size(); i++) {
                    const auto& meta = pending_lambda_sexprs[i];
                    fprintf(stderr, "[COMPILE] Processing lambda %zu: %s\n", i, meta.lambda_name.c_str());
                    
                    Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);
                    
                    // Create or get global variable for this lambda's S-expression
                    // Use ExternalLinkage for runtime resolution by display code
                    std::string sexpr_key = meta.lambda_name + "_sexpr";
                    GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                    if (!sexpr_global) {
                        sexpr_global = new GlobalVariable(
                            *module, Type::getInt64Ty(*context), false,
                            GlobalValue::ExternalLinkage,  // CRITICAL: External linkage for runtime lookup
                            ConstantInt::get(Type::getInt64Ty(*context), 0),
                            sexpr_key
                        );
                    }
                    builder->CreateStore(sexpr_ptr, sexpr_global);

                    // DEBUG: Add runtime printf to show S-expression value being stored
                    Function* printf_func = module->getFunction("printf");
                    if (!printf_func) {
                        FunctionType* printf_type = FunctionType::get(
                            Type::getInt32Ty(*context),
                            {PointerType::getUnqual(*context)},
                            true);  // varargs
                        printf_func = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
                    }
                    Value* fmt_str = builder->CreateGlobalStringPtr("[RUNTIME] Storing S-expr for %s: ptr=%lld\\n");
                    Value* lambda_name_str = builder->CreateGlobalStringPtr(meta.lambda_name.c_str());
                    builder->CreateCall(printf_func, {fmt_str, lambda_name_str, sexpr_ptr});

                    // Add to global symbol table for display lookup
                    global_symbol_table[sexpr_key] = sexpr_global;
                    eshkol_debug("Generated S-expression for lambda %s", meta.lambda_name.c_str());
                }

                // Clear pending list after generation
                pending_lambda_sexprs.clear();

                // CRITICAL: Create S-expression aliases for variable-bound lambdas
                // Scan symbol_table for lambda function references (var_func) and create var_sexpr aliases
                for (const auto& entry : global_symbol_table) {
                    if (entry.first.length() > 5 &&
                        entry.first.substr(entry.first.length() - 5) == "_func" &&
                        entry.second && isa<Function>(entry.second)) {
                        
                        Function* func = dyn_cast<Function>(entry.second);
                        std::string func_name = func->getName().str();
                        
                        // Extract variable name from "varname_func"
                        std::string var_name = entry.first.substr(0, entry.first.length() - 5);
                        
                        // Look for lambda S-expression: lambda_N_sexpr
                        std::string lambda_sexpr_key = func_name + "_sexpr";
                        auto lambda_sexpr_it = global_symbol_table.find(lambda_sexpr_key);
                        
                        if (lambda_sexpr_it != global_symbol_table.end()) {
                            // Create or get alias global variable
                            std::string var_sexpr_key = var_name + "_sexpr";
                            GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                            if (!var_sexpr_global) {
                                var_sexpr_global = new GlobalVariable(
                                    *module, Type::getInt64Ty(*context), false,
                                    GlobalValue::ExternalLinkage,
                                    ConstantInt::get(Type::getInt64Ty(*context), 0),
                                    var_sexpr_key
                                );
                            }
                            
                            // CRITICAL: Initialize alias with lambda S-expression value AT RUNTIME
                            Value* lambda_sexpr_val = builder->CreateLoad(Type::getInt64Ty(*context),
                                                                          lambda_sexpr_it->second);
                            builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                            
                            global_symbol_table[var_sexpr_key] = var_sexpr_global;
                            eshkol_debug("Initialized S-expression alias: %s = value from %s",
                                        var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                        }
                    }
                }
            } else {
                // No lambdas - just initialize arena at entry
                builder->SetInsertPoint(main_entry);

                // REPL MODE FIX: Use shared arena instead of creating new one
                Value* arena_ptr;
                if (g_repl_mode_enabled) {
                    // Load the shared arena pointer from external symbol (single load)
                    GlobalVariable* shared_arena_ref = new GlobalVariable(
                        *module,
                        PointerType::getUnqual(*context),
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer (external)
                        "__repl_shared_arena"
                    );
                    arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                    eshkol_debug("Loaded shared REPL arena (no lambdas case)");
                } else {
                    // Normal mode: create new arena
                    Value* arena_size = ConstantInt::get(Type::getInt64Ty(*context), 8192);
                    arena_ptr = builder->CreateCall(arena_create_func, {arena_size});
                    eshkol_debug("Created new arena in main wrapper");
                }
                builder->CreateStore(arena_ptr, global_arena);
            }
            
            // Call scheme_main
            Value* result = builder->CreateCall(main_func);
            
            // CRITICAL FIX: scheme_main returns tagged_value, need to unpack to int64 first
            Value* result_int64 = unpackInt64FromTaggedValue(result);

            // GLOBAL ARENA FIX: Cleanup arena before return (SKIP IN REPL MODE)
            // In REPL mode, s-expressions need to persist across evaluations
            if (!g_repl_mode_enabled) {
                Value* arena_to_destroy = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                builder->CreateCall(arena_destroy_func, {arena_to_destroy});
                eshkol_debug("Added global arena cleanup before main return");
            } else {
                eshkol_debug("Skipped arena cleanup in REPL mode to preserve s-expressions");
            }
            
            // Convert result to int32 and return
            Value* int32_result = builder->CreateTrunc(result_int64, Type::getInt32Ty(*context));
            builder->CreateRet(int32_result);
            
            function_table["main"] = c_main;
        } else {
            eshkol_debug("No main function found, creating main for top-level expressions");
            // Create main function for top-level expressions
            FunctionType* main_type = FunctionType::get(Type::getInt32Ty(*context), false);
            main_func = Function::Create(main_type, Function::ExternalLinkage, "main", module.get());
            
            main_entry = BasicBlock::Create(*context, "entry", main_func);
            // Don't set terminator yet - we'll add expressions and then terminate
            
            function_table["main"] = main_func;

            // REPL MODE FIX: Use shared arena instead of creating new one
            builder->SetInsertPoint(main_entry);
            Value* arena_ptr;
            if (g_repl_mode_enabled) {
                // Load the shared arena pointer from external symbol (single load)
                GlobalVariable* shared_arena_ref = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,  // not constant
                    GlobalValue::ExternalLinkage,
                    nullptr,  // no initializer (external)
                    "__repl_shared_arena"
                );
                arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                eshkol_debug("Loaded shared REPL arena (top-level expressions case)");
            } else {
                // Normal mode: create new arena
                Value* arena_size = ConstantInt::get(Type::getInt64Ty(*context), 8192);
                arena_ptr = builder->CreateCall(arena_create_func, {arena_size});
                eshkol_debug("Created new arena in main (top-level expressions case)");
            }
            builder->CreateStore(arena_ptr, global_arena);

            // NOTE: S-expression generation for top-level expressions is handled in generateIR()
            // after createMainWrapper() returns. This avoids creating orphaned basic blocks
            // that would lack terminators. See lines 305-373 in generateIR().
        }
    }
    
    void initializeArena() {
        // DEPRECATED: Arena initialization is now handled globally in createMainWrapper()
        // This function is kept for compatibility but does nothing
        // All functions now share the global arena automatically
        eshkol_debug("initializeArena() called but using global arena (no-op)");
    }
    
    Value* getArenaPtr() {
        // GLOBAL ARENA FIX: Load arena pointer from global variable
        // This allows all functions and scopes to share the same arena
        if (!global_arena) {
            eshkol_error("Global arena not initialized!");
            return nullptr;
        }
        return builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
    }
    
    // Production-grade arena scope tracking helpers
    void arenaTrackedPushScope() {
        Value* arena_ptr = getArenaPtr();
        if (arena_ptr) {
            builder->CreateCall(arena_push_scope_func, {arena_ptr});
            arena_scope_depth++;
            eshkol_debug("Arena scope pushed (depth: %zu)", arena_scope_depth);
        }
    }
    
    void arenaTrackedPopScope() {
        if (arena_scope_depth > 0) {
            Value* arena_ptr = getArenaPtr();
            if (arena_ptr) {
                builder->CreateCall(arena_pop_scope_func, {arena_ptr});
                arena_scope_depth--;
                eshkol_debug("Arena scope popped (depth: %zu)", arena_scope_depth);
            }
        } else {
            eshkol_warn("Attempted to pop arena scope with depth 0");
        }
    }
    
    void arenaForceCleanup() {
        if (arena_scope_depth > 0) {
            eshkol_debug("Force cleaning %zu arena scopes", arena_scope_depth);
            Value* arena_ptr = getArenaPtr();
            if (arena_ptr) {
                while (arena_scope_depth > 0) {
                    builder->CreateCall(arena_pop_scope_func, {arena_ptr});
                    arena_scope_depth--;
                }
            }
            eshkol_debug("Arena scope cleanup complete (depth: %zu)", arena_scope_depth);
        }
    }
    
    // Mixed type arithmetic helper functions
    TypedValue promoteInt64ToDouble(const TypedValue& int64_val) {
        if (!int64_val.isInt64()) return int64_val;
        
        Value* double_val = builder->CreateSIToFP(int64_val.llvm_value, Type::getDoubleTy(*context));
        return TypedValue(double_val, ESHKOL_VALUE_DOUBLE, false); // Promoted values are inexact
    }
    
    std::pair<TypedValue, TypedValue> promoteToCommonType(const TypedValue& left, const TypedValue& right) {
        // Handle NULL types - treat as int64(0)
        if (left.isNull() && right.isNull()) {
            TypedValue zero_left(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_INT64, true);
            TypedValue zero_right(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_INT64, true);
            return {zero_left, zero_right};
        }
        if (left.isNull()) {
            TypedValue zero_left(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_INT64, true);
            return {zero_left, right};
        }
        if (right.isNull()) {
            TypedValue zero_right(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_INT64, true);
            return {left, zero_right};
        }
        
        // Both int64: no promotion needed
        if (left.isInt64() && right.isInt64()) {
            return {left, right};
        }
        
        // Both double: no promotion needed
        if (left.isDouble() && right.isDouble()) {
            return {left, right};
        }
        
        // Mixed types: promote to double
        if (left.isInt64() && right.isDouble()) {
            return {promoteInt64ToDouble(left), right};
        }
        
        if (left.isDouble() && right.isInt64()) {
            return {left, promoteInt64ToDouble(right)};
        }
        
        // Error case: unsupported type combination
        eshkol_error("Unsupported type combination in arithmetic: %d and %d", left.type, right.type);
        return {left, right};
    }
    
    TypedValue generateMixedArithmetic(const std::string& operation, const TypedValue& left, const TypedValue& right) {
        auto [promoted_left, promoted_right] = promoteToCommonType(left, right);
        
        Value* result_val = nullptr;
        bool result_exact = promoted_left.is_exact && promoted_right.is_exact;
        
        if (promoted_left.isInt64() && promoted_right.isInt64()) {
            // Pure integer arithmetic
            if (operation == "add") {
                result_val = builder->CreateAdd(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "sub") {
                result_val = builder->CreateSub(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "mul") {
                result_val = builder->CreateMul(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "div") {
                // Division always promotes to double in Scheme
                auto double_left = promoteInt64ToDouble(promoted_left);
                auto double_right = promoteInt64ToDouble(promoted_right);
                result_val = builder->CreateFDiv(double_left.llvm_value, double_right.llvm_value);
                return TypedValue(result_val, ESHKOL_VALUE_DOUBLE, false); // Division is inexact
            }
            return TypedValue(result_val, ESHKOL_VALUE_INT64, result_exact);
        } else {
            // Floating-point arithmetic (both operands are now double)
            if (operation == "add") {
                result_val = builder->CreateFAdd(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "sub") {
                result_val = builder->CreateFSub(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "mul") {
                result_val = builder->CreateFMul(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "div") {
                result_val = builder->CreateFDiv(promoted_left.llvm_value, promoted_right.llvm_value);
            }
            return TypedValue(result_val, ESHKOL_VALUE_DOUBLE, false); // Mixed arithmetic is inexact
        }
    }
    
    // Convert TypedValue back to raw Value* for compatibility
    Value* typedValueToLLVM(const TypedValue& typed_val) {
        return typed_val.llvm_value;
    }
    
    // Create TypedValue from AST node
    TypedValue codegenTypedAST(const eshkol_ast_t* ast) {
        if (!ast) return TypedValue();
        
        switch (ast->type) {
            case ESHKOL_INT64:
                return TypedValue(
                    ConstantInt::get(Type::getInt64Ty(*context), ast->int64_val),
                    ESHKOL_VALUE_INT64,
                    true  // Integer literals are exact
                );
                
            case ESHKOL_DOUBLE:
                return TypedValue(
                    ConstantFP::get(Type::getDoubleTy(*context), ast->double_val),
                    ESHKOL_VALUE_DOUBLE,
                    false  // Double literals are inexact
                );

            case ESHKOL_CHAR:
                return TypedValue(
                    ConstantInt::get(Type::getInt64Ty(*context), ast->int64_val),
                    ESHKOL_VALUE_CHAR,
                    true  // Character literals are exact
                );

            case ESHKOL_OP: {
                // Check if this is an operation that returns a typed pointer
                if (ast->operation.op == ESHKOL_CALL_OP && ast->operation.call_op.func &&
                    ast->operation.call_op.func->type == ESHKOL_VAR && ast->operation.call_op.func->variable.id) {
                    std::string func_name = ast->operation.call_op.func->variable.id;

                    // Operations that return cons pointers (or null for empty list)
                    if (func_name == "list" || func_name == "cons" || func_name == "cdr") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        // Check if it's a null pointer (empty list)
                        if (ConstantInt* ci = dyn_cast<ConstantInt>(val)) {
                            if (ci->isZero()) {
                                return TypedValue(val, ESHKOL_VALUE_NULL, true);
                            }
                        }
                        return TypedValue(val, ESHKOL_VALUE_CONS_PTR, true);
                    }

                    // Operations that return scheme vector pointers
                    if (func_name == "vector" || func_name == "make-vector") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_VECTOR_PTR, true);
                    }

                    // Operations that return tensor pointers
                    if (func_name == "gradient" || func_name == "jacobian") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_TENSOR_PTR, true);
                    }

                    // CLOSURE FIX: Check if callee is a lambda that returns a lambda
                    // This handles cases like (make-adder 5) where make-adder returns lambda_1
                    auto callee_it = global_symbol_table.find(func_name + "_func");
                    if (callee_it != global_symbol_table.end() && callee_it->second) {
                        Function* callee_func = dyn_cast<Function>(callee_it->second);
                        if (callee_func) {
                            std::string callee_lambda_name = callee_func->getName().str();
                            if (callee_lambda_name.find("lambda_") == 0) {
                                // This callee is a lambda - check if it returns another lambda
                                // by looking for lambda_N+1 in function_table
                                std::string num_str = callee_lambda_name.substr(7);
                                try {
                                    int callee_num = std::stoi(num_str);
                                    std::string inner_lambda_name = "lambda_" + std::to_string(callee_num + 1);
                                    if (function_table.find(inner_lambda_name) != function_table.end()) {
                                        // Callee returns a lambda - mark the result appropriately
                                        Value* val = codegenAST(ast);
                                        if (!val) return TypedValue();
                                        return TypedValue(val, ESHKOL_VALUE_LAMBDA_SEXPR, true);
                                    }
                                } catch (...) {}
                            }
                        }
                    }
                }

                // Fall through to default handling for other operations
                [[fallthrough]];
            }

            case ESHKOL_VAR:
            default: {
                // For variables and operations, generate LLVM value and detect type
                Value* val = codegenAST(ast);
                if (!val) return TypedValue();

                // HOMOICONIC FIX: Check if this is a lambda variable by looking for _func entry
                // This handles variables like l1 where symbol_table["l1_func"] exists
                if (ast->type == ESHKOL_VAR && ast->variable.id) {
                    std::string var_name = ast->variable.id;
                    std::string func_key = var_name + "_func";
                    auto func_it = symbol_table.find(func_key);
                    if (func_it == symbol_table.end()) {
                        func_it = global_symbol_table.find(func_key);
                    }
                    if (func_it != symbol_table.end() ||
                        global_symbol_table.find(func_key) != global_symbol_table.end()) {
                        // This variable is a lambda - return with LAMBDA_SEXPR type
                        // The value is an i64 function pointer, which is correct for execution
                        // The type tells list/display to look up the S-expression
                        return TypedValue(val, ESHKOL_VALUE_LAMBDA_SEXPR, true);
                    }
                }

                // Detect type from LLVM Value type
                Type* llvm_type = val->getType();

                // Special handling for tagged_value: return it as-is, type info is in the tagged_value itself
                if (llvm_type == tagged_value_type) {
                    // For tagged_value, we can't extract type at compile time
                    // Return the tagged_value wrapped in TypedValue
                    // The caller must handle this by checking if llvm_value->getType() == tagged_value_type
                    return TypedValue(val, ESHKOL_VALUE_INT64, true);  // Type info is in tagged_value itself
                } else if (llvm_type->isIntegerTy(64)) {
                    return TypedValue(val, ESHKOL_VALUE_INT64, true);
                } else if (llvm_type->isDoubleTy()) {
                    return TypedValue(val, ESHKOL_VALUE_DOUBLE, false);
                } else if (llvm_type->isPointerTy()) {
                    // HOMOICONIC FIX: Handle Function* (lambdas) properly
                    if (isa<Function>(val)) {
                        // Return FUNCTION POINTER (for execution) with LAMBDA_SEXPR type (for display lookup)
                        Value* as_int = builder->CreatePtrToInt(val, Type::getInt64Ty(*context));
                        return TypedValue(as_int, ESHKOL_VALUE_LAMBDA_SEXPR, true);
                    }
                    // Other pointer types - convert to CONS_PTR
                    Value* as_int = builder->CreatePtrToInt(val, Type::getInt64Ty(*context));
                    return TypedValue(as_int, ESHKOL_VALUE_CONS_PTR, true);
                } else {
                    // Non-numeric type (unknown)
                    return TypedValue(val, ESHKOL_VALUE_NULL, true);
                }
            }
        }
    }
    
private:
    // Function context management for isolation
    struct FunctionContext {
        std::map<std::string, Function*> local_functions;
        std::vector<std::string> created_functions;  // Track functions created in this context
    };
    
    std::stack<FunctionContext> function_contexts;
    
    void pushFunctionContext() {
        FunctionContext ctx;
        function_contexts.push(ctx);
        eshkol_debug("Pushed function context (depth: %zu)", function_contexts.size());
    }
    
    void popFunctionContext() {
        if (function_contexts.empty()) {
            eshkol_warn("Attempted to pop function context with no active context");
            return;
        }
        
        FunctionContext& ctx = function_contexts.top();
        
        // Clean up functions created in this context if needed
        for (const std::string& func_name : ctx.created_functions) {
            eshkol_debug("Context cleanup: function %s", func_name.c_str());
            // Note: Don't actually erase from function_table as functions may be reused
            // Just track for debugging purposes
        }
        
        function_contexts.pop();
        eshkol_debug("Popped function context (depth: %zu)", function_contexts.size());
    }
    
    void registerContextFunction(const std::string& name, Function* func) {
        if (!function_contexts.empty()) {
            function_contexts.top().created_functions.push_back(name);
        }
        function_table[name] = func;
    }

    // REPL MODE: Check if a function exists in the global REPL context and create external declaration
    Function* tryResolveReplFunction(const std::string& func_name) {
        // Only check REPL symbols if REPL mode is enabled
        if (!g_repl_mode_enabled) {
            return nullptr;
        }

        std::lock_guard<std::mutex> lock(g_repl_mutex);

        // Check multiple name variations and track which one matched
        std::string actual_func_name;

        // 1. Exact name
        auto it = g_repl_function_addresses.find(func_name);
        if (it != g_repl_function_addresses.end()) {
            actual_func_name = func_name;
        } else {
            // 2. With "_func" suffix for lambda variables
            std::string func_key = func_name + "_func";
            it = g_repl_function_addresses.find(func_key);
            if (it != g_repl_function_addresses.end()) {
                actual_func_name = func_key;
            } else if (func_name.ends_with("_func")) {
                // 3. Try removing "_func" suffix if present
                std::string base_name = func_name.substr(0, func_name.length() - 5);
                it = g_repl_function_addresses.find(base_name);
                if (it != g_repl_function_addresses.end()) {
                    actual_func_name = base_name;
                }
            }
        }

        if (it == g_repl_function_addresses.end()) {
            return nullptr;
        }

        // CRITICAL: If this is a lambda variable (like "square"), resolve to the actual lambda name
        // The JIT only has the lambda function (e.g., "lambda_0"), not the alias (e.g., "square_func")
        std::string jit_symbol_name = actual_func_name;
        auto lambda_it = g_repl_lambda_names.find(func_name);
        if (lambda_it != g_repl_lambda_names.end()) {
            // Found lambda mapping: use the actual lambda name that exists in JIT
            jit_symbol_name = lambda_it->second;
        }

        // Get the function's arity using the actual matched name
        size_t arity = 0;
        auto arity_it = g_repl_function_arities.find(actual_func_name);
        if (arity_it != g_repl_function_arities.end()) {
            arity = arity_it->second;
        }

        // Check if we already have this function in the current module
        Function* extern_func = module->getFunction(jit_symbol_name);
        if (!extern_func) {
            // Function doesn't exist yet - create external declaration
            // All Eshkol functions return eshkol_tagged_value and take tagged_value parameters
            std::vector<Type*> param_types(arity, tagged_value_type);
            FunctionType* func_type = FunctionType::get(
                tagged_value_type,
                param_types,
                false  // NOT varargs - use exact arity
            );

            // CRITICAL: Use the actual JIT symbol name that exists in the JIT, not the requested name
            extern_func = Function::Create(
                func_type,
                Function::ExternalLinkage,
                jit_symbol_name,  // Use the actual JIT symbol name (e.g., "lambda_0")!
                module.get()
            );
        }

        // Register in function table so subsequent lookups find it
        // Register under BOTH the requested name and JIT symbol name for flexibility
        function_table[func_name] = extern_func;
        if (jit_symbol_name != func_name) {
            function_table[jit_symbol_name] = extern_func;
        }
        if (actual_func_name != func_name && actual_func_name != jit_symbol_name) {
            function_table[actual_func_name] = extern_func;
        }

        return extern_func;
    }

    Value* codegenArenaConsCell(Value* car_val, Value* cdr_val) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for cons cell allocation");
            return nullptr;
        }
        
        // Allocate cons cell using arena
        Value* cons_ptr = builder->CreateCall(arena_allocate_cons_cell_func, {arena_ptr});
        
        // Store car value - arena_cons_cell_t has car at offset 0
        Value* car_ptr = builder->CreateStructGEP(
            StructType::get(Type::getInt64Ty(*context), Type::getInt64Ty(*context)), 
            cons_ptr, 0
        );
        builder->CreateStore(car_val, car_ptr);
        
        // Store cdr value - arena_cons_cell_t has cdr at offset 1
        Value* cdr_ptr = builder->CreateStructGEP(
            StructType::get(Type::getInt64Ty(*context), Type::getInt64Ty(*context)), 
            cons_ptr, 1
        );
        builder->CreateStore(cdr_val, cdr_ptr);
        
        // Return pointer to cons cell as int64
        return builder->CreatePtrToInt(cons_ptr, Type::getInt64Ty(*context));
    }
    // Phase 3B: Simplified tagged cons cell allocation - direct tagged_value storage!
    Value* codegenTaggedArenaConsCell(const TypedValue& car_val, const TypedValue& cdr_val) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for tagged cons cell allocation");
            return nullptr;
        }
        
        // Allocate tagged cons cell (32 bytes in Phase 3B) using arena
        Value* cons_ptr = builder->CreateCall(arena_allocate_tagged_cons_cell_func, {arena_ptr});
        
        // Convert TypedValue to tagged_value
        Value* car_tagged = typedValueToTaggedValue(car_val);
        Value* cdr_tagged = typedValueToTaggedValue(cdr_val);
        
        // Store COMPLETE tagged_value structs directly using Phase 3B helpers!
        Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        
        // Phase 3B FIX: Create allocas at function entry to ensure dominance
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        // Create pointers to tagged values for passing by reference
        Value* car_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "car_tagged_ptr");
        Value* cdr_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "cdr_tagged_ptr");
        
        // Restore insertion point for stores and calls
        builder->restoreIP(saved_ip);
        
        builder->CreateStore(car_tagged, car_ptr);
        builder->CreateStore(cdr_tagged, cdr_ptr);
        
        // Direct struct copy - this is the key optimization of Phase 3B!
        builder->CreateCall(arena_tagged_cons_set_tagged_value_func, {cons_ptr, is_car, car_ptr});
        builder->CreateCall(arena_tagged_cons_set_tagged_value_func, {cons_ptr, is_cdr, cdr_ptr});

        // DEBUG: Verify flags were correctly stored in the cons cell
        Function* printf_func4 = module->getFunction("printf");
        if (!printf_func4) {
            FunctionType* printf_type = FunctionType::get(
                Type::getInt32Ty(*context),
                {PointerType::getUnqual(*context)},
                true);
            printf_func4 = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
        }
        // Read back the car from the cons cell
        Function* get_car_func = module->getFunction("arena_tagged_cons_get_tagged_value");
        if (get_car_func) {
            Value* readback_car_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "readback_car");
            builder->CreateCall(get_car_func, {cons_ptr, is_car, readback_car_ptr});
            Value* readback_car = builder->CreateLoad(tagged_value_type, readback_car_ptr);
            Value* readback_flags = getTaggedValueFlags(readback_car);
            Value* fmt_readback = builder->CreateGlobalStringPtr("[CONS-CREATE] Readback car flags=%d\n");
            Value* readback_flags_ext = builder->CreateZExt(readback_flags, Type::getInt32Ty(*context));
            builder->CreateCall(printf_func4, {fmt_readback, readback_flags_ext});
        }

        eshkol_debug("Created tagged cons cell (Phase 3B): car_type=%d, cdr_type=%d", car_val.type, cdr_val.type);

        // Return pointer to cons cell as int64
        return builder->CreatePtrToInt(cons_ptr, Type::getInt64Ty(*context));
    }
    
    // ROBUST SOLUTION: Create cons cell directly from tagged_value with type preservation
    // This stores the VALUE from tagged_value into the cons cell car, preserving the type
    Value* codegenTaggedArenaConsCellFromTaggedValue(Value* car_tagged, Value* cdr_tagged) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for tagged cons cell allocation");
            return nullptr;
        }
        
        // Allocate tagged cons cell
        Value* cons_ptr = builder->CreateCall(arena_allocate_tagged_cons_cell_func, {arena_ptr});
        
        // Extract type from car_tagged
        Value* car_type = getTaggedValueType(car_tagged);
        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // SYMBOLIC DIFF FIX: Check for DOUBLE, all pointer types (CONS_PTR, STRING_PTR, etc.), and INT64
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        // Check all pointer types that should use set_ptr
        Value* car_is_cons = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* car_is_string = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
        Value* car_is_vector = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* car_is_tensor = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* car_is_ad = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* car_is_lambda = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_LAMBDA_SEXPR));
        Value* car_is_ptr = builder->CreateOr(car_is_cons,
            builder->CreateOr(car_is_string,
            builder->CreateOr(car_is_vector,
            builder->CreateOr(car_is_tensor,
            builder->CreateOr(car_is_ad, car_is_lambda)))));
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* car_double = BasicBlock::Create(*context, "cons_car_double", current_func);
        BasicBlock* check_ptr = BasicBlock::Create(*context, "cons_car_check_ptr", current_func);
        BasicBlock* car_ptr = BasicBlock::Create(*context, "cons_car_ptr", current_func);
        BasicBlock* car_int = BasicBlock::Create(*context, "cons_car_int", current_func);
        BasicBlock* car_done = BasicBlock::Create(*context, "cons_car_done", current_func);
        
        Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
        
        builder->CreateCondBr(car_is_double, car_double, check_ptr);
        
        // Store car as double
        builder->SetInsertPoint(car_double);
        Value* car_double_val = unpackDoubleFromTaggedValue(car_tagged);
        builder->CreateCall(arena_tagged_cons_set_double_func,
            {cons_ptr, is_car, car_double_val, car_type});
        builder->CreateBr(car_done);
        
        // Check if CONS_PTR
        builder->SetInsertPoint(check_ptr);
        builder->CreateCondBr(car_is_ptr, car_ptr, car_int);
        
        // Store car as pointer (string symbols, nested lists, etc.)
        builder->SetInsertPoint(car_ptr);
        Value* car_ptr_val = unpackInt64FromTaggedValue(car_tagged);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {cons_ptr, is_car, car_ptr_val, car_type});
        builder->CreateBr(car_done);
        
        // Store car as int64
        builder->SetInsertPoint(car_int);
        Value* car_int_val = unpackInt64FromTaggedValue(car_tagged);
        builder->CreateCall(arena_tagged_cons_set_int64_func,
            {cons_ptr, is_car, car_int_val, car_type});
        builder->CreateBr(car_done);
        
        // Store cdr - SYMBOLIC DIFF FIX: check for NULL, DOUBLE, CONS_PTR, INT64
        builder->SetInsertPoint(car_done);
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        
        // Get cdr type
        Value* cdr_type = getTaggedValueType(cdr_tagged);
        Value* cdr_base_type = builder->CreateAnd(cdr_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        // Check all pointer types that should use set_ptr
        Value* cdr_is_cons = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_string = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
        Value* cdr_is_vector = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* cdr_is_tensor = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* cdr_is_ad = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* cdr_is_lambda = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_LAMBDA_SEXPR));
        Value* cdr_is_ptr = builder->CreateOr(cdr_is_cons,
            builder->CreateOr(cdr_is_string,
            builder->CreateOr(cdr_is_vector,
            builder->CreateOr(cdr_is_tensor,
            builder->CreateOr(cdr_is_ad, cdr_is_lambda)))));
        
        BasicBlock* cdr_null_block = BasicBlock::Create(*context, "cons_cdr_null", current_func);
        BasicBlock* cdr_check_double = BasicBlock::Create(*context, "cons_cdr_check_double", current_func);
        BasicBlock* cdr_double_block = BasicBlock::Create(*context, "cons_cdr_double", current_func);
        BasicBlock* cdr_check_ptr = BasicBlock::Create(*context, "cons_cdr_check_ptr", current_func);
        BasicBlock* cdr_ptr_block = BasicBlock::Create(*context, "cons_cdr_ptr", current_func);
        BasicBlock* cdr_int_block = BasicBlock::Create(*context, "cons_cdr_int", current_func);
        BasicBlock* cdr_done_block = BasicBlock::Create(*context, "cons_cdr_done", current_func);
        
        builder->CreateCondBr(cdr_is_null, cdr_null_block, cdr_check_double);
        
        // Cdr is null - use set_null
        builder->SetInsertPoint(cdr_null_block);
        builder->CreateCall(arena_tagged_cons_set_null_func, {cons_ptr, is_cdr});
        builder->CreateBr(cdr_done_block);
        
        // Check if cdr is double
        builder->SetInsertPoint(cdr_check_double);
        builder->CreateCondBr(cdr_is_double, cdr_double_block, cdr_check_ptr);
        
        // Cdr is double - use set_double
        builder->SetInsertPoint(cdr_double_block);
        Value* cdr_double_val = unpackDoubleFromTaggedValue(cdr_tagged);
        builder->CreateCall(arena_tagged_cons_set_double_func,
            {cons_ptr, is_cdr, cdr_double_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        // Check if CONS_PTR
        builder->SetInsertPoint(cdr_check_ptr);
        builder->CreateCondBr(cdr_is_ptr, cdr_ptr_block, cdr_int_block);
        
        // Cdr is CONS_PTR - use set_ptr (for nested lists in S-expressions!)
        builder->SetInsertPoint(cdr_ptr_block);
        Value* cdr_ptr_val = unpackInt64FromTaggedValue(cdr_tagged);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {cons_ptr, is_cdr, cdr_ptr_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        // Cdr is int64 - use set_int64
        builder->SetInsertPoint(cdr_int_block);
        Value* cdr_int_val = unpackInt64FromTaggedValue(cdr_tagged);
        builder->CreateCall(arena_tagged_cons_set_int64_func,
            {cons_ptr, is_cdr, cdr_int_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        builder->SetInsertPoint(cdr_done_block);
        
        // Return cons cell pointer as int64
        return builder->CreatePtrToInt(cons_ptr, Type::getInt64Ty(*context));
    }
    
    // ===== TAGGED VALUE HELPER FUNCTIONS =====
    // Pack/unpack values to/from eshkol_tagged_value_t structs
    
    Value* packInt64ToTaggedValue(Value* int64_val, bool is_exact = true) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        
        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "tagged_val");
        
        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);
        
        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64), type_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        uint8_t flags = is_exact ? ESHKOL_VALUE_EXACT_FLAG : 0;
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), flags), flags_ptr);
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(Type::getInt16Ty(*context), 0), reserved_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 3);
        builder->CreateStore(int64_val, data_ptr);
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }
    
    Value* packDoubleToTaggedValue(Value* double_val) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        
        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "tagged_val");
        
        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);
        
        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE), type_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INEXACT_FLAG), flags_ptr);
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(Type::getInt16Ty(*context), 0), reserved_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 3);
        Value* double_as_int64 = builder->CreateBitCast(double_val, Type::getInt64Ty(*context));
        builder->CreateStore(double_as_int64, data_ptr);
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }
    
    Value* packPtrToTaggedValue(Value* ptr_val, eshkol_value_type_t type, uint8_t flags = 0) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();

        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }

        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "tagged_val");

        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);

        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), type), type_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), flags), flags_ptr);
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(Type::getInt16Ty(*context), 0), reserved_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 3);

        // CRITICAL FIX: ptr_val might already be i64 (from PtrToInt in codegenTensorOperation)
        // Don't double-convert!
        Value* ptr_as_int64;
        if (ptr_val->getType()->isIntegerTy(64)) {
            // Already i64 - use directly
            ptr_as_int64 = ptr_val;
        } else if (ptr_val->getType()->isPointerTy()) {
            // Is a pointer - convert to i64
            ptr_as_int64 = builder->CreatePtrToInt(ptr_val, Type::getInt64Ty(*context));
        } else {
            // Other type - try to convert
            eshkol_warn("packPtrToTaggedValue: unexpected type, defaulting to 0");
            ptr_as_int64 = ConstantInt::get(Type::getInt64Ty(*context), 0);
        }

        builder->CreateStore(ptr_as_int64, data_ptr);
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }
    Value* packNullToTaggedValue() {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        
        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "tagged_null");
        
        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);
        
        // CRITICAL: Set type to ESHKOL_VALUE_NULL (0), not INT64 (1)!
        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL), type_ptr);
        
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), flags_ptr);
        
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(Type::getInt16Ty(*context), 0), reserved_ptr);
        
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 3);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), data_ptr);
        
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }
    
    
    Value* getTaggedValueType(Value* tagged_val) {
        Value* temp_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "temp_tagged");
        builder->CreateStore(tagged_val, temp_ptr);
        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, temp_ptr, 0);
        return builder->CreateLoad(Type::getInt8Ty(*context), type_ptr);
    }

    Value* getTaggedValueFlags(Value* tagged_val) {
        Value* temp_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "temp_tagged_flags");
        builder->CreateStore(tagged_val, temp_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, temp_ptr, 1);
        return builder->CreateLoad(Type::getInt8Ty(*context), flags_ptr);
    }

    Value* unpackInt64FromTaggedValue(Value* tagged_val) {
        Value* temp_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "temp_tagged");
        builder->CreateStore(tagged_val, temp_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, temp_ptr, 3);
        return builder->CreateLoad(Type::getInt64Ty(*context), data_ptr);
    }
    
    Value* unpackDoubleFromTaggedValue(Value* tagged_val) {
        Value* temp_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "temp_tagged");
        builder->CreateStore(tagged_val, temp_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, temp_ptr, 3);
        Value* data_as_int64 = builder->CreateLoad(Type::getInt64Ty(*context), data_ptr);
        return builder->CreateBitCast(data_as_int64, Type::getDoubleTy(*context));
    }
    
    Value* unpackPtrFromTaggedValue(Value* tagged_val) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        
        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        Value* temp_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "temp_tagged");
        
        // Restore insertion point for the actual operations
        builder->restoreIP(saved_ip);
        
        builder->CreateStore(tagged_val, temp_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, temp_ptr, 3);
        Value* data_as_int64 = builder->CreateLoad(Type::getInt64Ty(*context), data_ptr);
        return builder->CreateIntToPtr(data_as_int64, builder->getPtrTy());
    }

    Value* extractCarAsTaggedValue(Value* cons_ptr_int) {
        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        cons_ptr_int = safeExtractInt64(cons_ptr_int);

        Value* cons_ptr = builder->CreateIntToPtr(cons_ptr_int, builder->getPtrTy());

        Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
        Value* car_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_car});

        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // HOMOICONIC FIX: Check for NULL, DOUBLE, CONS_PTR, STRING_PTR, LAMBDA_SEXPR, INT64
        Value* car_is_null = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* car_is_cons_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* car_is_string_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
        Value* car_is_lambda_sexpr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_LAMBDA_SEXPR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* null_car = BasicBlock::Create(*context, "car_extract_null", current_func);
        BasicBlock* double_car = BasicBlock::Create(*context, "car_extract_double", current_func);
        BasicBlock* check_cons_ptr = BasicBlock::Create(*context, "car_check_cons_ptr", current_func);
        BasicBlock* cons_ptr_car = BasicBlock::Create(*context, "car_extract_cons_ptr", current_func);
        BasicBlock* check_string_ptr = BasicBlock::Create(*context, "car_check_string_ptr", current_func);
        BasicBlock* string_ptr_car = BasicBlock::Create(*context, "car_extract_string_ptr", current_func);
        BasicBlock* check_lambda_sexpr = BasicBlock::Create(*context, "car_check_lambda_sexpr", current_func);
        BasicBlock* lambda_sexpr_car = BasicBlock::Create(*context, "car_extract_lambda_sexpr", current_func);
        BasicBlock* int_car = BasicBlock::Create(*context, "car_extract_int", current_func);
        BasicBlock* merge_car = BasicBlock::Create(*context, "car_merge", current_func);

        BasicBlock* check_double = BasicBlock::Create(*context, "car_check_double", current_func);

        builder->CreateCondBr(car_is_null, null_car, check_double);

        builder->SetInsertPoint(null_car);
        Value* tagged_null = packNullToTaggedValue();
        builder->CreateBr(merge_car);
        BasicBlock* null_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(car_is_double, double_car, check_cons_ptr);

        builder->SetInsertPoint(double_car);
        Value* car_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_car});
        Value* tagged_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(merge_car);
        BasicBlock* double_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_cons_ptr);
        builder->CreateCondBr(car_is_cons_ptr, cons_ptr_car, check_string_ptr);

        builder->SetInsertPoint(cons_ptr_car);
        Value* car_cons_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_car});
        Value* tagged_cons_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_cons_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* cons_ptr_exit = builder->GetInsertBlock();

        // HOMOICONIC FIX: Handle STRING_PTR for symbol names (x, y, +, *, etc.)
        builder->SetInsertPoint(check_string_ptr);
        builder->CreateCondBr(car_is_string_ptr, string_ptr_car, check_lambda_sexpr);

        builder->SetInsertPoint(string_ptr_car);
        Value* car_string_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_car});
        Value* tagged_string_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_string_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_STRING_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* string_ptr_exit = builder->GetInsertBlock();

        // HOMOICONIC FIX: Handle LAMBDA_SEXPR for lambdas stored in lists
        builder->SetInsertPoint(check_lambda_sexpr);
        builder->CreateCondBr(car_is_lambda_sexpr, lambda_sexpr_car, int_car);

        builder->SetInsertPoint(lambda_sexpr_car);
        // CRITICAL FIX: Use arena_tagged_cons_get_tagged_value to preserve flags (FLAG_INDIRECT)
        // This is essential for homoiconic lambda display - flags determine if we need to dereference
        Value* tagged_lambda_ptr = builder->CreateCall(arena_tagged_cons_get_tagged_value_func, {cons_ptr, is_car});
        builder->CreateBr(merge_car);
        BasicBlock* lambda_sexpr_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(int_car);
        Value* car_int64 = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_car});
        Value* tagged_int64 = packInt64ToTaggedValue(car_int64, true);
        builder->CreateBr(merge_car);
        BasicBlock* int_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(merge_car);
        PHINode* car_tagged_phi = builder->CreatePHI(tagged_value_type, 6);
        car_tagged_phi->addIncoming(tagged_null, null_exit);
        car_tagged_phi->addIncoming(tagged_double, double_exit);
        car_tagged_phi->addIncoming(tagged_cons_ptr, cons_ptr_exit);
        car_tagged_phi->addIncoming(tagged_string_ptr, string_ptr_exit);
        car_tagged_phi->addIncoming(tagged_lambda_ptr, lambda_sexpr_exit);
        car_tagged_phi->addIncoming(tagged_int64, int_exit);

        return car_tagged_phi;
    }
    
    Value* extractCdrAsTaggedValue(Value* cons_ptr_int) {
        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        cons_ptr_int = safeExtractInt64(cons_ptr_int);

        Value* cons_ptr = builder->CreateIntToPtr(cons_ptr_int, builder->getPtrTy());
        
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_cdr});
        
        Value* cdr_base_type = builder->CreateAnd(cdr_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // SYMBOLIC DIFF FIX: Check for NULL, DOUBLE, CONS_PTR, INT64 (NULL already handled)
        Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* cdr_is_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* double_cdr = BasicBlock::Create(*context, "cdr_extract_double", current_func);
        BasicBlock* check_ptr_cdr = BasicBlock::Create(*context, "cdr_check_ptr", current_func);
        BasicBlock* ptr_cdr = BasicBlock::Create(*context, "cdr_extract_ptr", current_func);
        BasicBlock* check_null_cdr = BasicBlock::Create(*context, "cdr_check_null", current_func);
        BasicBlock* null_cdr = BasicBlock::Create(*context, "cdr_extract_null", current_func);
        BasicBlock* int_cdr = BasicBlock::Create(*context, "cdr_extract_int", current_func);
        BasicBlock* merge_cdr = BasicBlock::Create(*context, "cdr_merge", current_func);
        
        builder->CreateCondBr(cdr_is_double, double_cdr, check_ptr_cdr);
        
        builder->SetInsertPoint(double_cdr);
        Value* cdr_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_cdr});
        Value* tagged_double_cdr = packDoubleToTaggedValue(cdr_double);
        builder->CreateBr(merge_cdr);
        BasicBlock* double_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_ptr_cdr);
        builder->CreateCondBr(cdr_is_ptr, ptr_cdr, check_null_cdr);
        
        builder->SetInsertPoint(ptr_cdr);
        Value* cdr_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        // SYMBOLIC DIFF FIX: Preserve CONS_PTR type for nested lists!
        Value* tagged_ptr_cdr = packPtrToTaggedValue(
            builder->CreateIntToPtr(cdr_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* ptr_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_null_cdr);
        builder->CreateCondBr(cdr_is_null, null_cdr, int_cdr);
        
        builder->SetInsertPoint(null_cdr);
        Value* tagged_null_cdr = packNullToTaggedValue();
        builder->CreateBr(merge_cdr);
        BasicBlock* null_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(int_cdr);
        Value* cdr_int64 = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_cdr});
        Value* tagged_int64_cdr = packInt64ToTaggedValue(cdr_int64, true);
        builder->CreateBr(merge_cdr);
        BasicBlock* int_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(merge_cdr);
        PHINode* cdr_tagged_phi = builder->CreatePHI(tagged_value_type, 4);
        cdr_tagged_phi->addIncoming(tagged_double_cdr, double_exit);
        cdr_tagged_phi->addIncoming(tagged_ptr_cdr, ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_null_cdr, null_exit);
        cdr_tagged_phi->addIncoming(tagged_int64_cdr, int_exit);
        
        return cdr_tagged_phi;
    }
    
    // Helper to safely extract i64 from possibly-tagged values for ICmp operations
    // CRITICAL: This prevents ICmp type mismatch assertions
    Value* safeExtractInt64(Value* val) {
        if (!val) {
            return ConstantInt::get(Type::getInt64Ty(*context), 0);
        }
        
        Type* val_type = val->getType();
        
        // Already i64 - return as-is
        if (val_type->isIntegerTy(64)) {
            return val;
        }
        
        // If it's a tagged_value struct, unpack the i64 data
        if (val_type == tagged_value_type) {
            return unpackInt64FromTaggedValue(val);
        }
        
        // Other integer types - extend/truncate to i64
        if (val_type->isIntegerTy()) {
            return builder->CreateSExtOrTrunc(val, Type::getInt64Ty(*context));
        }
        
        // Pointer types - convert to i64
        if (val_type->isPointerTy()) {
            return builder->CreatePtrToInt(val, Type::getInt64Ty(*context));
        }
        
        // Float types - convert to i64
        if (val_type->isFloatingPointTy()) {
            return builder->CreateFPToSI(val, Type::getInt64Ty(*context));
        }
        
        // Fallback - return 0
        return ConstantInt::get(Type::getInt64Ty(*context), 0);
    }

    // Helper: Extract car element from cons cell as tagged value (type-safe approach)
    // This avoids ABI issues with returning 16-byte structs from C functions
    Value* extractConsCarAsTaggedValue(Value* cons_ptr) {
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Get car type using arena_tagged_cons_get_type(cell, false)
        Value* is_car_flag = ConstantInt::get(Type::getInt1Ty(*context), 0); // false = car
        Value* car_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_car_flag});

        // Mask out flags to get base type (type & 0x0F)
        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check for DOUBLE, CONS_PTR, INT64
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* car_is_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));

        BasicBlock* double_block = BasicBlock::Create(*context, "extract_double", current_func);
        BasicBlock* check_ptr = BasicBlock::Create(*context, "extract_check_ptr", current_func);
        BasicBlock* ptr_block = BasicBlock::Create(*context, "extract_ptr", current_func);
        BasicBlock* int_block = BasicBlock::Create(*context, "extract_int", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "extract_merge", current_func);

        builder->CreateCondBr(car_is_double, double_block, check_ptr);

        // Extract double car and pack into tagged value
        builder->SetInsertPoint(double_block);
        Value* car_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_car_flag});
        Value* tagged_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(merge_block);
        BasicBlock* double_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_ptr);
        builder->CreateCondBr(car_is_ptr, ptr_block, int_block);

        builder->SetInsertPoint(ptr_block);
        Value* car_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_car_flag});
        Value* tagged_ptr = packPtrToTaggedValue(builder->CreateIntToPtr(car_ptr, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_block);
        BasicBlock* ptr_exit = builder->GetInsertBlock();

        // Extract int64 car and pack into tagged value
        builder->SetInsertPoint(int_block);
        Value* car_int64 = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_car_flag});
        Value* tagged_int64 = packInt64ToTaggedValue(car_int64, true);
        builder->CreateBr(merge_block);
        BasicBlock* int_exit = builder->GetInsertBlock();

        // Merge: return tagged value struct
        builder->SetInsertPoint(merge_block);
        PHINode* car_tagged_phi = builder->CreatePHI(tagged_value_type, 3);
        car_tagged_phi->addIncoming(tagged_double, double_exit);
        car_tagged_phi->addIncoming(tagged_ptr, ptr_exit);
        car_tagged_phi->addIncoming(tagged_int64, int_exit);

        return car_tagged_phi;
    }

    // Robust helper to convert tagged_value to TypedValue with proper runtime type detection
    // This preserves type information through PHI nodes
    TypedValue detectValueType(Value* llvm_val) {
        if (!llvm_val) return TypedValue();
        
        if (llvm_val->getType() == tagged_value_type) {
            // Extract type tag from tagged_value
            Value* type_tag = getTaggedValueType(llvm_val);
            Value* base_type = builder->CreateAnd(type_tag,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            // Check if it's a double
            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            
            // Branch to unpack the correct type
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* double_block = BasicBlock::Create(*context, "detect_double", current_func);
            BasicBlock* int_block = BasicBlock::Create(*context, "detect_int", current_func);
            BasicBlock* merge_block = BasicBlock::Create(*context, "detect_merge", current_func);
            
            builder->CreateCondBr(is_double, double_block, int_block);
            
            // Unpack as double and create TypedValue
            builder->SetInsertPoint(double_block);
            Value* double_val = unpackDoubleFromTaggedValue(llvm_val);
            builder->CreateBr(merge_block);
            BasicBlock* double_exit = builder->GetInsertBlock();
            
            // Unpack as int64 and create TypedValue
            builder->SetInsertPoint(int_block);
            Value* int_val = unpackInt64FromTaggedValue(llvm_val);
            builder->CreateBr(merge_block);
            BasicBlock* int_exit = builder->GetInsertBlock();
            
            // Return TypedValue with int64 value
            // The type will be determined by the cons cell storage
            builder->SetInsertPoint(merge_block);
            PHINode* value_phi = builder->CreatePHI(Type::getInt64Ty(*context), 2);
            // For double, bitcast to int64 for storage
            Value* double_as_int = builder->CreateBitCast(double_val, Type::getInt64Ty(*context));
            value_phi->addIncoming(double_as_int, double_exit);
            value_phi->addIncoming(int_val, int_exit);
            
            // Create type PHI to track whether it's int or double
            PHINode* type_phi = builder->CreatePHI(Type::getInt8Ty(*context), 2);
            type_phi->addIncoming(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE), double_exit);
            type_phi->addIncoming(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64), int_exit);
            
            // Return TypedValue with runtime type - but we can't do this statically
            // For now, assume int64 and let the caller handle conversion
            return TypedValue(value_phi, ESHKOL_VALUE_INT64, true);
        }
        
        Type* val_type = llvm_val->getType();
        if (val_type->isIntegerTy(64)) {
            // CRITICAL FIX: Check if i64 came from PtrToInt (tensor/cons pointers)
            // Distinguish tensor pointers from cons cell pointers using name heuristics
            if (isa<PtrToIntInst>(llvm_val)) {
                PtrToIntInst* ptoi = dyn_cast<PtrToIntInst>(llvm_val);
                if (ptoi) {
                    // Heuristic: tensor operations have specific naming patterns
                    std::string name = ptoi->getName().str();
                    if (name.find("tensor") != std::string::npos ||
                        name.find("vector") != std::string::npos ||
                        name.find("gradient") != std::string::npos ||
                        name.find("jacobian") != std::string::npos ||
                        name.find("hessian") != std::string::npos) {
                        eshkol_debug("detectValueType: i64 from tensor PtrToInt (%s)", name.c_str());
                        return TypedValue(llvm_val, ESHKOL_VALUE_TENSOR_PTR, true);
                    }
                }
                eshkol_debug("detectValueType: i64 from PtrToInt, treating as CONS_PTR");
                return TypedValue(llvm_val, ESHKOL_VALUE_CONS_PTR, true);
            }
            return TypedValue(llvm_val, ESHKOL_VALUE_INT64, true);
        } else if (val_type->isDoubleTy()) {
            return TypedValue(llvm_val, ESHKOL_VALUE_DOUBLE, false);
        } else if (val_type->isPointerTy()) {
            Value* as_int = builder->CreatePtrToInt(llvm_val, Type::getInt64Ty(*context));
            // HOMOICONIC FIX: Check if this is a Function* (lambda)
            if (isa<Function>(llvm_val)) {
                // Return FUNCTION POINTER (for execution) with LAMBDA_SEXPR type (for display lookup)
                // Display code will use var_sexpr alias to find the S-expression
                eshkol_debug("detectValueType: Function* detected, tagging as LAMBDA_SEXPR");
                return TypedValue(as_int, ESHKOL_VALUE_LAMBDA_SEXPR, true);
            }
            return TypedValue(as_int, ESHKOL_VALUE_CONS_PTR, true);
        }
        
        return TypedValue(
            ConstantInt::get(Type::getInt64Ty(*context), 0),
            ESHKOL_VALUE_NULL,
            true
        );
    }
    // Convert TypedValue to tagged_value (AST→IR boundary crossing)
    Value* typedValueToTaggedValue(const TypedValue& tv) {
        // CRITICAL: If already a tagged_value, return as-is (don't double-pack!)
        if (tv.llvm_value && tv.llvm_value->getType() == tagged_value_type) {
            return tv.llvm_value;
        }
        
        if (tv.isInt64()) {
            return packInt64ToTaggedValue(tv.llvm_value, tv.is_exact);
        } else if (tv.isDouble()) {
            return packDoubleToTaggedValue(tv.llvm_value);
        } else if (tv.type == ESHKOL_VALUE_CHAR) {
            return packCharToTaggedValue(tv.llvm_value);
        } else if (tv.type == ESHKOL_VALUE_CONS_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_CONS_PTR);
        } else if (tv.type == ESHKOL_VALUE_VECTOR_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_VECTOR_PTR);
        } else if (tv.type == ESHKOL_VALUE_TENSOR_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_TENSOR_PTR);
        } else if (tv.type == ESHKOL_VALUE_STRING_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_STRING_PTR);
        } else if (tv.type == ESHKOL_VALUE_AD_NODE_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_AD_NODE_PTR);
        } else if (tv.type == ESHKOL_VALUE_LAMBDA_SEXPR) {
            fprintf(stderr, "[typedValueToTaggedValue] LAMBDA_SEXPR with flags=%d\n", (int)tv.flags);
            Value* result = packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_LAMBDA_SEXPR, tv.flags);

            // DEBUG: Verify flags are in the result
            Value* result_flags = getTaggedValueFlags(result);
            Function* printf_func3 = module->getFunction("printf");
            if (!printf_func3) {
                FunctionType* printf_type = FunctionType::get(
                    Type::getInt32Ty(*context),
                    {PointerType::getUnqual(*context)},
                    true);
                printf_func3 = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
            }
            Value* fmt_verify = builder->CreateGlobalStringPtr("[PACK-VERIFY] After packing, flags=%d\n");
            Value* flags_verify_ext = builder->CreateZExt(result_flags, Type::getInt32Ty(*context));
            builder->CreateCall(printf_func3, {fmt_verify, flags_verify_ext});

            return result;
        } else if (tv.isNull()) {
            return packNullToTaggedValue();
        }

        // Fallback: null tagged value
        return packNullToTaggedValue();
    }
    
    // Simple helper to wrap tagged_value in TypedValue (for cons cell creation)
    // This avoids complex control flow by just storing the tagged_value as-is
    TypedValue taggedValueToTypedValue(Value* tagged_val) {
        if (!tagged_val || tagged_val->getType() != tagged_value_type) {
            return TypedValue();
        }
        
        // Simply unpack the int64 data field - we'll let runtime type checking handle it
        // This avoids dominance issues from complex branching
        Value* data = unpackInt64FromTaggedValue(tagged_val);
        
        // For cons cell creation, we just need the raw data
        // The type is preserved in the tagged_value itself
        return TypedValue(data, ESHKOL_VALUE_INT64, true);
    }
    
    // ===== POLYMORPHIC ARITHMETIC FUNCTIONS (Phase 1.3 + Phase 2 Dual Number Support) =====
    // These operate on tagged_value parameters and handle mixed types + dual numbers
    
    Value* polymorphicAdd(Value* left_tagged, Value* right_tagged) {
        if (!left_tagged || !right_tagged) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }

        // Extract type tags
        Value* left_type = getTaggedValueType(left_tagged);
        Value* right_type = getTaggedValueType(right_tagged);

        Value* left_base = builder->CreateAnd(left_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* right_base = builder->CreateAnd(right_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if either operand is a Scheme vector OR tensor - dispatch to vector/tensor arithmetic
        Value* left_is_vector = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* right_is_vector = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* left_is_tensor = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* right_is_tensor = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* any_vector = builder->CreateOr(
            builder->CreateOr(left_is_vector, right_is_vector),
            builder->CreateOr(left_is_tensor, right_is_tensor));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* vector_path = BasicBlock::Create(*context, "add_vector_path", current_func);
        BasicBlock* check_ad = BasicBlock::Create(*context, "add_check_ad", current_func);

        builder->CreateCondBr(any_vector, vector_path, check_ad);

        // Vector/tensor path - use tensor arithmetic (handles both types)
        builder->SetInsertPoint(vector_path);
        Value* vec_result = codegenTensorArithmeticInternal(left_tagged, right_tagged, "add");
        BasicBlock* vector_path_exit = builder->GetInsertBlock();

        // Continue to AD check
        builder->SetInsertPoint(check_ad);

        // PHASE 3/4: Check if either operand is an AD node (reverse-mode)
        Value* left_is_ad = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* right_is_ad = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* any_ad = builder->CreateOr(left_is_ad, right_is_ad);
        
        // PHASE 2: Check if either operand is a dual number (forward-mode)
        Value* left_is_dual = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* right_is_dual = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* any_dual = builder->CreateOr(left_is_dual, right_is_dual);
        
        // Check if either operand is double
        Value* left_is_double = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* right_is_double = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* any_double = builder->CreateOr(left_is_double, right_is_double);

        // Create remaining blocks (current_func already declared above)
        BasicBlock* ad_path = BasicBlock::Create(*context, "add_ad_path", current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, "add_check_dual", current_func);
        BasicBlock* dual_path = BasicBlock::Create(*context, "add_dual_path", current_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "add_check_double", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "add_double_path", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "add_int_path", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "add_merge", current_func);

        // Branch from vector_path to merge
        builder->SetInsertPoint(vector_path_exit);
        builder->CreateBr(merge);

        // Continue from check_ad
        builder->SetInsertPoint(check_ad);
        builder->CreateCondBr(any_ad, ad_path, check_dual);
        
        // PHASE 3/4: AD node path - build computational graph
        builder->SetInsertPoint(ad_path);
        
        // Convert non-AD operands to AD constants
        BasicBlock* left_is_ad_block = BasicBlock::Create(*context, "add_left_is_ad", current_func);
        BasicBlock* left_not_ad_block = BasicBlock::Create(*context, "add_left_not_ad", current_func);
        BasicBlock* left_ad_merge = BasicBlock::Create(*context, "add_left_ad_merge", current_func);
        
        builder->CreateCondBr(left_is_ad, left_is_ad_block, left_not_ad_block);
        
        builder->SetInsertPoint(left_is_ad_block);
        Value* left_ad_ptr = unpackPtrFromTaggedValue(left_tagged);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_not_ad_block);
        Value* left_val = builder->CreateSelect(
            builder->CreateICmpEQ(left_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_ad_const = createADConstant(left_val);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_ad_merge);
        PHINode* left_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        left_ad_node->addIncoming(left_ad_ptr, left_is_ad_block);
        left_ad_node->addIncoming(left_ad_const, left_not_ad_block);
        
        // Same for right operand
        BasicBlock* right_is_ad_block = BasicBlock::Create(*context, "add_right_is_ad", current_func);
        BasicBlock* right_not_ad_block = BasicBlock::Create(*context, "add_right_not_ad", current_func);
        BasicBlock* right_ad_merge = BasicBlock::Create(*context, "add_right_ad_merge", current_func);
        
        builder->CreateCondBr(right_is_ad, right_is_ad_block, right_not_ad_block);
        
        builder->SetInsertPoint(right_is_ad_block);
        Value* right_ad_ptr = unpackPtrFromTaggedValue(right_tagged);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_not_ad_block);
        Value* right_val = builder->CreateSelect(
            builder->CreateICmpEQ(right_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_ad_const = createADConstant(right_val);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_ad_merge);
        PHINode* right_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        right_ad_node->addIncoming(right_ad_ptr, right_is_ad_block);
        right_ad_node->addIncoming(right_ad_const, right_not_ad_block);
        
        // Record ADD operation in computational graph
        Value* result_ad_node = recordADNodeBinary(2, left_ad_node, right_ad_node); // AD_NODE_ADD = 2
        Value* ad_result_tagged = packPtrToTaggedValue(result_ad_node, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(any_dual, dual_path, check_double);
        
        // PHASE 2: Dual number path - use dual arithmetic for automatic differentiation
        builder->SetInsertPoint(dual_path);
        
        // Convert non-dual operands to dual numbers (value, 0.0) - zero derivative for constants
        // FIX: Replace CreateSelect on struct with branching
        BasicBlock* left_is_dual_block = BasicBlock::Create(*context, "add_left_is_dual", current_func);
        BasicBlock* left_not_dual_block = BasicBlock::Create(*context, "add_left_not_dual", current_func);
        BasicBlock* left_merge_block = BasicBlock::Create(*context, "add_left_merge", current_func);
        
        builder->CreateCondBr(left_is_dual, left_is_dual_block, left_not_dual_block);
        
        builder->SetInsertPoint(left_is_dual_block);
        Value* left_dual_value = unpackDualFromTaggedValue(left_tagged);
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_not_dual_block);
        Value* left_as_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_non_dual_value = packDualNumber(left_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_merge_block);
        PHINode* left_dual = builder->CreatePHI(dual_number_type, 2);
        left_dual->addIncoming(left_dual_value, left_is_dual_block);
        left_dual->addIncoming(left_non_dual_value, left_not_dual_block);
        
        // Same for right operand
        BasicBlock* right_is_dual_block = BasicBlock::Create(*context, "add_right_is_dual", current_func);
        BasicBlock* right_not_dual_block = BasicBlock::Create(*context, "add_right_not_dual", current_func);
        BasicBlock* right_merge_block = BasicBlock::Create(*context, "add_right_merge", current_func);
        
        builder->CreateCondBr(right_is_dual, right_is_dual_block, right_not_dual_block);
        
        builder->SetInsertPoint(right_is_dual_block);
        Value* right_dual_value = unpackDualFromTaggedValue(right_tagged);
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_not_dual_block);
        Value* right_as_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_non_dual_value = packDualNumber(right_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_merge_block);
        PHINode* right_dual = builder->CreatePHI(dual_number_type, 2);
        right_dual->addIncoming(right_dual_value, right_is_dual_block);
        right_dual->addIncoming(right_non_dual_value, right_not_dual_block);
        
        Value* dual_result = dualAdd(left_dual, right_dual);
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        BasicBlock* dual_path_exit = builder->GetInsertBlock();
        
        // Check for double (non-dual floating point)
        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(any_double, double_path, int_path);
        
        // Double path: promote both to double and add
        builder->SetInsertPoint(double_path);
        Value* left_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* right_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* double_result = builder->CreateFAdd(left_double, right_double);
        Value* tagged_double_result = packDoubleToTaggedValue(double_result);
        builder->CreateBr(merge);
        
        // Int path: add as int64
        builder->SetInsertPoint(int_path);
        Value* left_int = unpackInt64FromTaggedValue(left_tagged);
        Value* right_int = unpackInt64FromTaggedValue(right_tagged);
        Value* int_result = builder->CreateAdd(left_int, right_int);
        Value* tagged_int_result = packInt64ToTaggedValue(int_result, true);
        builder->CreateBr(merge);
        
        // Merge all paths
        builder->SetInsertPoint(merge);
        PHINode* add_result_phi = builder->CreatePHI(tagged_value_type, 5);
        add_result_phi->addIncoming(vec_result, vector_path_exit);
        add_result_phi->addIncoming(ad_result_tagged, ad_path_exit);
        add_result_phi->addIncoming(tagged_dual_result, dual_path_exit);
        add_result_phi->addIncoming(tagged_double_result, double_path);
        add_result_phi->addIncoming(tagged_int_result, int_path);

        return add_result_phi;
    }
    
    Value* polymorphicSub(Value* left_tagged, Value* right_tagged) {
        if (!left_tagged || !right_tagged) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }

        Value* left_type = getTaggedValueType(left_tagged);
        Value* right_type = getTaggedValueType(right_tagged);

        Value* left_base = builder->CreateAnd(left_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* right_base = builder->CreateAnd(right_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if either operand is a Scheme vector OR tensor - dispatch to vector/tensor arithmetic
        Value* left_is_vector = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* right_is_vector = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* left_is_tensor = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* right_is_tensor = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* any_vector = builder->CreateOr(
            builder->CreateOr(left_is_vector, right_is_vector),
            builder->CreateOr(left_is_tensor, right_is_tensor));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* vector_path = BasicBlock::Create(*context, "sub_vector_path", current_func);
        BasicBlock* check_ad = BasicBlock::Create(*context, "sub_check_ad", current_func);

        builder->CreateCondBr(any_vector, vector_path, check_ad);

        // Vector/tensor path - use tensor arithmetic (handles both types)
        builder->SetInsertPoint(vector_path);
        Value* vec_result = codegenTensorArithmeticInternal(left_tagged, right_tagged, "sub");
        BasicBlock* vector_path_exit = builder->GetInsertBlock();

        // Continue to AD check
        builder->SetInsertPoint(check_ad);

        // PHASE 3/4: Check if either operand is an AD node (reverse-mode)
        Value* left_is_ad = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* right_is_ad = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* any_ad = builder->CreateOr(left_is_ad, right_is_ad);

        // PHASE 2: Check if either operand is a dual number (forward-mode)
        Value* left_is_dual = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* right_is_dual = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* any_dual = builder->CreateOr(left_is_dual, right_is_dual);

        Value* left_is_double = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* right_is_double = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* any_double = builder->CreateOr(left_is_double, right_is_double);

        // Create remaining blocks
        BasicBlock* ad_path = BasicBlock::Create(*context, "sub_ad_path", current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, "sub_check_dual", current_func);
        BasicBlock* dual_path = BasicBlock::Create(*context, "sub_dual_path", current_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "sub_check_double", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "sub_double_path", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "sub_int_path", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "sub_merge", current_func);

        // Branch from vector_path to merge
        builder->SetInsertPoint(vector_path_exit);
        builder->CreateBr(merge);

        // Continue from check_ad
        builder->SetInsertPoint(check_ad);
        builder->CreateCondBr(any_ad, ad_path, check_dual);
        
        // PHASE 3/4: AD node path - build computational graph
        builder->SetInsertPoint(ad_path);
        
        BasicBlock* left_is_ad_block = BasicBlock::Create(*context, "sub_left_is_ad", current_func);
        BasicBlock* left_not_ad_block = BasicBlock::Create(*context, "sub_left_not_ad", current_func);
        BasicBlock* left_ad_merge = BasicBlock::Create(*context, "sub_left_ad_merge", current_func);
        
        builder->CreateCondBr(left_is_ad, left_is_ad_block, left_not_ad_block);
        
        builder->SetInsertPoint(left_is_ad_block);
        Value* left_ad_ptr = unpackPtrFromTaggedValue(left_tagged);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_not_ad_block);
        Value* left_val = builder->CreateSelect(
            builder->CreateICmpEQ(left_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_ad_const = createADConstant(left_val);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_ad_merge);
        PHINode* left_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        left_ad_node->addIncoming(left_ad_ptr, left_is_ad_block);
        left_ad_node->addIncoming(left_ad_const, left_not_ad_block);
        
        BasicBlock* right_is_ad_block = BasicBlock::Create(*context, "sub_right_is_ad", current_func);
        BasicBlock* right_not_ad_block = BasicBlock::Create(*context, "sub_right_not_ad", current_func);
        BasicBlock* right_ad_merge = BasicBlock::Create(*context, "sub_right_ad_merge", current_func);
        
        builder->CreateCondBr(right_is_ad, right_is_ad_block, right_not_ad_block);
        
        builder->SetInsertPoint(right_is_ad_block);
        Value* right_ad_ptr = unpackPtrFromTaggedValue(right_tagged);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_not_ad_block);
        Value* right_val = builder->CreateSelect(
            builder->CreateICmpEQ(right_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_ad_const = createADConstant(right_val);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_ad_merge);
        PHINode* right_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        right_ad_node->addIncoming(right_ad_ptr, right_is_ad_block);
        right_ad_node->addIncoming(right_ad_const, right_not_ad_block);
        
        Value* result_ad_node = recordADNodeBinary(3, left_ad_node, right_ad_node); // AD_NODE_SUB = 3
        Value* ad_result_tagged = packPtrToTaggedValue(result_ad_node, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(any_dual, dual_path, check_double);
        
        // PHASE 2: Dual number path
        builder->SetInsertPoint(dual_path);
        
        // FIX: Replace CreateSelect on struct with branching
        BasicBlock* left_is_dual_block = BasicBlock::Create(*context, "sub_left_is_dual", current_func);
        BasicBlock* left_not_dual_block = BasicBlock::Create(*context, "sub_left_not_dual", current_func);
        BasicBlock* left_merge_block = BasicBlock::Create(*context, "sub_left_merge", current_func);
        
        builder->CreateCondBr(left_is_dual, left_is_dual_block, left_not_dual_block);
        
        builder->SetInsertPoint(left_is_dual_block);
        Value* left_dual_value = unpackDualFromTaggedValue(left_tagged);
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_not_dual_block);
        Value* left_as_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_non_dual_value = packDualNumber(left_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_merge_block);
        PHINode* left_dual = builder->CreatePHI(dual_number_type, 2);
        left_dual->addIncoming(left_dual_value, left_is_dual_block);
        left_dual->addIncoming(left_non_dual_value, left_not_dual_block);
        
        // Same for right operand
        BasicBlock* right_is_dual_block = BasicBlock::Create(*context, "sub_right_is_dual", current_func);
        BasicBlock* right_not_dual_block = BasicBlock::Create(*context, "sub_right_not_dual", current_func);
        BasicBlock* right_merge_block = BasicBlock::Create(*context, "sub_right_merge", current_func);
        
        builder->CreateCondBr(right_is_dual, right_is_dual_block, right_not_dual_block);
        
        builder->SetInsertPoint(right_is_dual_block);
        Value* right_dual_value = unpackDualFromTaggedValue(right_tagged);
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_not_dual_block);
        Value* right_as_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_non_dual_value = packDualNumber(right_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_merge_block);
        PHINode* right_dual = builder->CreatePHI(dual_number_type, 2);
        right_dual->addIncoming(right_dual_value, right_is_dual_block);
        right_dual->addIncoming(right_non_dual_value, right_not_dual_block);
        
        Value* dual_result = dualSub(left_dual, right_dual);
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        BasicBlock* dual_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(any_double, double_path, int_path);
        
        builder->SetInsertPoint(double_path);
        Value* left_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* right_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* double_result = builder->CreateFSub(left_double, right_double);
        Value* tagged_double_result = packDoubleToTaggedValue(double_result);
        builder->CreateBr(merge);
        
        builder->SetInsertPoint(int_path);
        Value* left_int = unpackInt64FromTaggedValue(left_tagged);
        Value* right_int = unpackInt64FromTaggedValue(right_tagged);
        Value* int_result = builder->CreateSub(left_int, right_int);
        Value* tagged_int_result = packInt64ToTaggedValue(int_result, true);
        builder->CreateBr(merge);
        
        // Merge all paths
        builder->SetInsertPoint(merge);
        PHINode* sub_result_phi = builder->CreatePHI(tagged_value_type, 5);
        sub_result_phi->addIncoming(vec_result, vector_path_exit);
        sub_result_phi->addIncoming(ad_result_tagged, ad_path_exit);
        sub_result_phi->addIncoming(tagged_dual_result, dual_path_exit);
        sub_result_phi->addIncoming(tagged_double_result, double_path);
        sub_result_phi->addIncoming(tagged_int_result, int_path);

        return sub_result_phi;
    }

    Value* polymorphicMul(Value* left_tagged, Value* right_tagged) {
        if (!left_tagged || !right_tagged) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }

        Value* left_type = getTaggedValueType(left_tagged);
        Value* right_type = getTaggedValueType(right_tagged);

        Value* left_base = builder->CreateAnd(left_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* right_base = builder->CreateAnd(right_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if either operand is a Scheme vector OR tensor - dispatch to vector/tensor arithmetic
        Value* left_is_vector = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* right_is_vector = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* left_is_tensor = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* right_is_tensor = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* any_vector = builder->CreateOr(
            builder->CreateOr(left_is_vector, right_is_vector),
            builder->CreateOr(left_is_tensor, right_is_tensor));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* vector_path = BasicBlock::Create(*context, "mul_vector_path", current_func);
        BasicBlock* check_ad = BasicBlock::Create(*context, "mul_check_ad", current_func);

        builder->CreateCondBr(any_vector, vector_path, check_ad);

        // Vector/tensor path - use tensor arithmetic (handles both types)
        builder->SetInsertPoint(vector_path);
        Value* vec_result = codegenTensorArithmeticInternal(left_tagged, right_tagged, "mul");
        BasicBlock* vector_path_exit = builder->GetInsertBlock();

        // Continue to AD check
        builder->SetInsertPoint(check_ad);

        // PHASE 3/4: Check if either operand is an AD node (reverse-mode)
        Value* left_is_ad = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* right_is_ad = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* any_ad = builder->CreateOr(left_is_ad, right_is_ad);

        // PHASE 2: Check if either operand is a dual number (forward-mode)
        Value* left_is_dual = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* right_is_dual = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* any_dual = builder->CreateOr(left_is_dual, right_is_dual);

        Value* left_is_double = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* right_is_double = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* any_double = builder->CreateOr(left_is_double, right_is_double);

        // Create remaining blocks
        BasicBlock* ad_path = BasicBlock::Create(*context, "mul_ad_path", current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, "mul_check_dual", current_func);
        BasicBlock* dual_path = BasicBlock::Create(*context, "mul_dual_path", current_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "mul_check_double", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "mul_double_path", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "mul_int_path", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "mul_merge", current_func);

        // Branch from vector_path to merge
        builder->SetInsertPoint(vector_path_exit);
        builder->CreateBr(merge);

        // Continue from check_ad
        builder->SetInsertPoint(check_ad);
        builder->CreateCondBr(any_ad, ad_path, check_dual);
        
        // PHASE 3/4: AD node path - build computational graph
        builder->SetInsertPoint(ad_path);
        
        BasicBlock* left_is_ad_block = BasicBlock::Create(*context, "mul_left_is_ad", current_func);
        BasicBlock* left_not_ad_block = BasicBlock::Create(*context, "mul_left_not_ad", current_func);
        BasicBlock* left_ad_merge = BasicBlock::Create(*context, "mul_left_ad_merge", current_func);
        
        builder->CreateCondBr(left_is_ad, left_is_ad_block, left_not_ad_block);
        
        builder->SetInsertPoint(left_is_ad_block);
        Value* left_ad_ptr = unpackPtrFromTaggedValue(left_tagged);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_not_ad_block);
        Value* left_val = builder->CreateSelect(
            builder->CreateICmpEQ(left_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_ad_const = createADConstant(left_val);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_ad_merge);
        PHINode* left_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        left_ad_node->addIncoming(left_ad_ptr, left_is_ad_block);
        left_ad_node->addIncoming(left_ad_const, left_not_ad_block);
        
        BasicBlock* right_is_ad_block = BasicBlock::Create(*context, "mul_right_is_ad", current_func);
        BasicBlock* right_not_ad_block = BasicBlock::Create(*context, "mul_right_not_ad", current_func);
        BasicBlock* right_ad_merge = BasicBlock::Create(*context, "mul_right_ad_merge", current_func);
        
        builder->CreateCondBr(right_is_ad, right_is_ad_block, right_not_ad_block);
        
        builder->SetInsertPoint(right_is_ad_block);
        Value* right_ad_ptr = unpackPtrFromTaggedValue(right_tagged);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_not_ad_block);
        Value* right_val = builder->CreateSelect(
            builder->CreateICmpEQ(right_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_ad_const = createADConstant(right_val);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_ad_merge);
        PHINode* right_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        right_ad_node->addIncoming(right_ad_ptr, right_is_ad_block);
        right_ad_node->addIncoming(right_ad_const, right_not_ad_block);
        
        Value* result_ad_node = recordADNodeBinary(4, left_ad_node, right_ad_node); // AD_NODE_MUL = 4
        Value* ad_result_tagged = packPtrToTaggedValue(result_ad_node, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(any_dual, dual_path, check_double);
        
        // PHASE 2: Dual number path - use dual multiplication (product rule)
        builder->SetInsertPoint(dual_path);
        
        // FIX: Replace CreateSelect on struct with branching
        BasicBlock* left_is_dual_block = BasicBlock::Create(*context, "mul_left_is_dual", current_func);
        BasicBlock* left_not_dual_block = BasicBlock::Create(*context, "mul_left_not_dual", current_func);
        BasicBlock* left_merge_block = BasicBlock::Create(*context, "mul_left_merge", current_func);
        
        builder->CreateCondBr(left_is_dual, left_is_dual_block, left_not_dual_block);
        
        builder->SetInsertPoint(left_is_dual_block);
        Value* left_dual_value = unpackDualFromTaggedValue(left_tagged);
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_not_dual_block);
        Value* left_as_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_non_dual_value = packDualNumber(left_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_merge_block);
        PHINode* left_dual = builder->CreatePHI(dual_number_type, 2);
        left_dual->addIncoming(left_dual_value, left_is_dual_block);
        left_dual->addIncoming(left_non_dual_value, left_not_dual_block);
        
        // Same for right operand
        BasicBlock* right_is_dual_block = BasicBlock::Create(*context, "mul_right_is_dual", current_func);
        BasicBlock* right_not_dual_block = BasicBlock::Create(*context, "mul_right_not_dual", current_func);
        BasicBlock* right_merge_block = BasicBlock::Create(*context, "mul_right_merge", current_func);
        
        builder->CreateCondBr(right_is_dual, right_is_dual_block, right_not_dual_block);
        
        builder->SetInsertPoint(right_is_dual_block);
        Value* right_dual_value = unpackDualFromTaggedValue(right_tagged);
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_not_dual_block);
        Value* right_as_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_non_dual_value = packDualNumber(right_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_merge_block);
        PHINode* right_dual = builder->CreatePHI(dual_number_type, 2);
        right_dual->addIncoming(right_dual_value, right_is_dual_block);
        right_dual->addIncoming(right_non_dual_value, right_not_dual_block);
        
        Value* dual_result = dualMul(left_dual, right_dual);
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        BasicBlock* dual_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(any_double, double_path, int_path);
        
        builder->SetInsertPoint(double_path);
        Value* left_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* right_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* double_result = builder->CreateFMul(left_double, right_double);
        Value* tagged_double_result = packDoubleToTaggedValue(double_result);
        builder->CreateBr(merge);
        
        builder->SetInsertPoint(int_path);
        Value* left_int = unpackInt64FromTaggedValue(left_tagged);
        Value* right_int = unpackInt64FromTaggedValue(right_tagged);
        Value* int_result = builder->CreateMul(left_int, right_int);
        Value* tagged_int_result = packInt64ToTaggedValue(int_result, true);
        builder->CreateBr(merge);
        
        // Merge all paths
        builder->SetInsertPoint(merge);
        PHINode* mul_result_phi = builder->CreatePHI(tagged_value_type, 5);
        mul_result_phi->addIncoming(vec_result, vector_path_exit);
        mul_result_phi->addIncoming(ad_result_tagged, ad_path_exit);
        mul_result_phi->addIncoming(tagged_dual_result, dual_path_exit);
        mul_result_phi->addIncoming(tagged_double_result, double_path);
        mul_result_phi->addIncoming(tagged_int_result, int_path);

        return mul_result_phi;
    }

    Value* polymorphicDiv(Value* left_tagged, Value* right_tagged) {
        if (!left_tagged || !right_tagged) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }

        // Division always promotes to double per Scheme semantics
        Value* left_type = getTaggedValueType(left_tagged);
        Value* right_type = getTaggedValueType(right_tagged);

        Value* left_base = builder->CreateAnd(left_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* right_base = builder->CreateAnd(right_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if either operand is a Scheme vector OR tensor - dispatch to vector/tensor arithmetic
        Value* left_is_vector = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* right_is_vector = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* left_is_tensor = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* right_is_tensor = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* any_vector = builder->CreateOr(
            builder->CreateOr(left_is_vector, right_is_vector),
            builder->CreateOr(left_is_tensor, right_is_tensor));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* vector_path = BasicBlock::Create(*context, "div_vector_path", current_func);
        BasicBlock* check_ad = BasicBlock::Create(*context, "div_check_ad", current_func);

        builder->CreateCondBr(any_vector, vector_path, check_ad);

        // Vector/tensor path - use tensor arithmetic (handles both types)
        builder->SetInsertPoint(vector_path);
        Value* vec_result = codegenTensorArithmeticInternal(left_tagged, right_tagged, "div");
        BasicBlock* vector_path_exit = builder->GetInsertBlock();

        // Continue to AD check
        builder->SetInsertPoint(check_ad);

        // PHASE 3/4: Check if either operand is an AD node (reverse-mode)
        Value* left_is_ad = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* right_is_ad = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* any_ad = builder->CreateOr(left_is_ad, right_is_ad);

        // PHASE 2: Check if either operand is a dual number (forward-mode)
        Value* left_is_dual = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* right_is_dual = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        Value* any_dual = builder->CreateOr(left_is_dual, right_is_dual);

        Value* left_is_double = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* right_is_double = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

        // Create remaining blocks
        BasicBlock* ad_path = BasicBlock::Create(*context, "div_ad_path", current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, "div_check_dual", current_func);
        BasicBlock* dual_path = BasicBlock::Create(*context, "div_dual_path", current_func);
        BasicBlock* regular_path = BasicBlock::Create(*context, "div_regular_path", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "div_merge", current_func);

        // Branch from vector_path to merge
        builder->SetInsertPoint(vector_path_exit);
        builder->CreateBr(merge);

        // Continue from check_ad
        builder->SetInsertPoint(check_ad);
        builder->CreateCondBr(any_ad, ad_path, check_dual);
        
        // PHASE 3/4: AD node path - build computational graph
        builder->SetInsertPoint(ad_path);
        
        BasicBlock* left_is_ad_block = BasicBlock::Create(*context, "div_left_is_ad", current_func);
        BasicBlock* left_not_ad_block = BasicBlock::Create(*context, "div_left_not_ad", current_func);
        BasicBlock* left_ad_merge = BasicBlock::Create(*context, "div_left_ad_merge", current_func);
        
        builder->CreateCondBr(left_is_ad, left_is_ad_block, left_not_ad_block);
        
        builder->SetInsertPoint(left_is_ad_block);
        Value* left_ad_ptr = unpackPtrFromTaggedValue(left_tagged);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_not_ad_block);
        Value* left_val = builder->CreateSelect(
            builder->CreateICmpEQ(left_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_ad_const = createADConstant(left_val);
        builder->CreateBr(left_ad_merge);
        
        builder->SetInsertPoint(left_ad_merge);
        PHINode* left_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        left_ad_node->addIncoming(left_ad_ptr, left_is_ad_block);
        left_ad_node->addIncoming(left_ad_const, left_not_ad_block);
        
        BasicBlock* right_is_ad_block = BasicBlock::Create(*context, "div_right_is_ad", current_func);
        BasicBlock* right_not_ad_block = BasicBlock::Create(*context, "div_right_not_ad", current_func);
        BasicBlock* right_ad_merge = BasicBlock::Create(*context, "div_right_ad_merge", current_func);
        
        builder->CreateCondBr(right_is_ad, right_is_ad_block, right_not_ad_block);
        
        builder->SetInsertPoint(right_is_ad_block);
        Value* right_ad_ptr = unpackPtrFromTaggedValue(right_tagged);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_not_ad_block);
        Value* right_val = builder->CreateSelect(
            builder->CreateICmpEQ(right_base, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE)),
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_ad_const = createADConstant(right_val);
        builder->CreateBr(right_ad_merge);
        
        builder->SetInsertPoint(right_ad_merge);
        PHINode* right_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2);
        right_ad_node->addIncoming(right_ad_ptr, right_is_ad_block);
        right_ad_node->addIncoming(right_ad_const, right_not_ad_block);
        
        Value* result_ad_node = recordADNodeBinary(5, left_ad_node, right_ad_node); // AD_NODE_DIV = 5
        Value* ad_result_tagged = packPtrToTaggedValue(result_ad_node, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_path_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(any_dual, dual_path, regular_path);
        
        // PHASE 2: Dual number path - use dual division (quotient rule)
        builder->SetInsertPoint(dual_path);
        
        // FIX: Replace CreateSelect on struct with branching
        BasicBlock* left_is_dual_block = BasicBlock::Create(*context, "div_left_is_dual", current_func);
        BasicBlock* left_not_dual_block = BasicBlock::Create(*context, "div_left_not_dual", current_func);
        BasicBlock* left_merge_block = BasicBlock::Create(*context, "div_left_merge", current_func);
        
        builder->CreateCondBr(left_is_dual, left_is_dual_block, left_not_dual_block);
        
        builder->SetInsertPoint(left_is_dual_block);
        Value* left_dual_value = unpackDualFromTaggedValue(left_tagged);
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_not_dual_block);
        Value* left_as_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* left_non_dual_value = packDualNumber(left_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(left_merge_block);
        
        builder->SetInsertPoint(left_merge_block);
        PHINode* left_dual = builder->CreatePHI(dual_number_type, 2);
        left_dual->addIncoming(left_dual_value, left_is_dual_block);
        left_dual->addIncoming(left_non_dual_value, left_not_dual_block);
        
        // Same for right operand
        BasicBlock* right_is_dual_block = BasicBlock::Create(*context, "div_right_is_dual", current_func);
        BasicBlock* right_not_dual_block = BasicBlock::Create(*context, "div_right_not_dual", current_func);
        BasicBlock* right_merge_block = BasicBlock::Create(*context, "div_right_merge", current_func);
        
        builder->CreateCondBr(right_is_dual, right_is_dual_block, right_not_dual_block);
        
        builder->SetInsertPoint(right_is_dual_block);
        Value* right_dual_value = unpackDualFromTaggedValue(right_tagged);
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_not_dual_block);
        Value* right_as_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* right_non_dual_value = packDualNumber(right_as_double, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        builder->CreateBr(right_merge_block);
        
        builder->SetInsertPoint(right_merge_block);
        PHINode* right_dual = builder->CreatePHI(dual_number_type, 2);
        right_dual->addIncoming(right_dual_value, right_is_dual_block);
        right_dual->addIncoming(right_non_dual_value, right_not_dual_block);
        
        Value* dual_result = dualDiv(left_dual, right_dual);
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        BasicBlock* dual_path_exit = builder->GetInsertBlock();
        
        // Regular path: Always convert to double for division
        builder->SetInsertPoint(regular_path);
        Value* left_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* right_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        Value* result = builder->CreateFDiv(left_double, right_double);
        Value* tagged_regular_result = packDoubleToTaggedValue(result);
        builder->CreateBr(merge);
        
        // Merge paths
        builder->SetInsertPoint(merge);
        PHINode* div_result_phi = builder->CreatePHI(tagged_value_type, 4);
        div_result_phi->addIncoming(vec_result, vector_path_exit);
        div_result_phi->addIncoming(ad_result_tagged, ad_path_exit);
        div_result_phi->addIncoming(tagged_dual_result, dual_path_exit);
        div_result_phi->addIncoming(tagged_regular_result, regular_path);

        return div_result_phi;
    }
    
    // ===== POLYMORPHIC COMPARISON FUNCTIONS (Phase 3 Fix) =====
    // Handle mixed-type comparisons with runtime type detection
    
    Value* polymorphicCompare(Value* left_tagged, Value* right_tagged,
                             const std::string& operation) {
        if (!left_tagged || !right_tagged) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }
        
        // Extract type tags
        Value* left_type = getTaggedValueType(left_tagged);
        Value* right_type = getTaggedValueType(right_tagged);
        
        Value* left_base = builder->CreateAnd(left_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* right_base = builder->CreateAnd(right_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // Check if either operand is double
        Value* left_is_double = builder->CreateICmpEQ(left_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* right_is_double = builder->CreateICmpEQ(right_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* any_double = builder->CreateOr(left_is_double, right_is_double);
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* double_path = BasicBlock::Create(*context, "cmp_double_path", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "cmp_int_path", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "cmp_merge", current_func);
        
        builder->CreateCondBr(any_double, double_path, int_path);
        
        // Double path: promote both to double and compare
        builder->SetInsertPoint(double_path);
        Value* left_double = builder->CreateSelect(left_is_double,
            unpackDoubleFromTaggedValue(left_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(left_tagged), Type::getDoubleTy(*context)));
        Value* right_double = builder->CreateSelect(right_is_double,
            unpackDoubleFromTaggedValue(right_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(right_tagged), Type::getDoubleTy(*context)));
        
        Value* double_cmp = nullptr;
        if (operation == "lt") {
            double_cmp = builder->CreateFCmpOLT(left_double, right_double);
        } else if (operation == "gt") {
            double_cmp = builder->CreateFCmpOGT(left_double, right_double);
        } else if (operation == "eq") {
            double_cmp = builder->CreateFCmpOEQ(left_double, right_double);
        } else if (operation == "le") {
            double_cmp = builder->CreateFCmpOLE(left_double, right_double);
        } else if (operation == "ge") {
            double_cmp = builder->CreateFCmpOGE(left_double, right_double);
        }
        Value* double_result_int = builder->CreateZExt(double_cmp, Type::getInt64Ty(*context));
        Value* tagged_double_result = packInt64ToTaggedValue(double_result_int, true);
        builder->CreateBr(merge);
        
        // Int path: compare as int64
        builder->SetInsertPoint(int_path);
        Value* left_int = unpackInt64FromTaggedValue(left_tagged);
        Value* right_int = unpackInt64FromTaggedValue(right_tagged);
        
        Value* int_cmp = nullptr;
        if (operation == "lt") {
            int_cmp = builder->CreateICmpSLT(left_int, right_int);
        } else if (operation == "gt") {
            int_cmp = builder->CreateICmpSGT(left_int, right_int);
        } else if (operation == "ge") {
            int_cmp = builder->CreateICmpSGE(left_int, right_int);
        } else if (operation == "le") {
            int_cmp = builder->CreateICmpSLE(left_int, right_int);
        } else if (operation == "eq") {
            int_cmp = builder->CreateICmpEQ(left_int, right_int);
        }
        Value* int_result_extended = builder->CreateZExt(int_cmp, Type::getInt64Ty(*context));
        Value* tagged_int_result = packInt64ToTaggedValue(int_result_extended, true);
        builder->CreateBr(merge);
        
        // Merge results
        builder->SetInsertPoint(merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2);
        result_phi->addIncoming(tagged_double_result, double_path);
        result_phi->addIncoming(tagged_int_result, int_path);
        
        return result_phi;
    }
    
    
    
    // ===== POLYMORPHIC FUNCTION WRAPPERS (Phase 2.4) =====
    // Create Function* objects that wrap polymorphic arithmetic for use in higher-order functions
    
    Function* polymorphicAdd() {
        std::string func_name = "polymorphic_add_2arg";
        
        // Check if already created
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        // Create function type: (tagged_value, tagged_value) -> tagged_value
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        // Call polymorphic add helper
        Value* result = polymorphicAdd(left, right);
        builder->CreateRet(result);
        
        // Restore insertion point
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicSub() {
        std::string func_name = "polymorphic_sub_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicSub(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicMul() {
        std::string func_name = "polymorphic_mul_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicMul(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicDiv() {
        std::string func_name = "polymorphic_div_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicDiv(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    
    Value* codegenAST(const eshkol_ast_t* ast) {
        if (!ast) return nullptr;

        switch (ast->type) {
            case ESHKOL_INT64:
                return ConstantInt::get(Type::getInt64Ty(*context), ast->int64_val);
                
            case ESHKOL_DOUBLE:
                return ConstantFP::get(Type::getDoubleTy(*context), ast->double_val);
                
            case ESHKOL_STRING: {
                // String literals are packed as tagged values with STRING_PTR type
                Value* str_ptr = codegenString(ast->str_val.ptr);
                return packPtrToTaggedValue(str_ptr, ESHKOL_VALUE_STRING_PTR);
            }
                
            case ESHKOL_VAR:
                return codegenVariable(ast);
                
            case ESHKOL_OP:
                return codegenOperation(&ast->operation);
                
            case ESHKOL_CONS:
                return codegenConsCell(ast);
                
            case ESHKOL_TENSOR:
                return codegenTensor(ast);

            case ESHKOL_CHAR:
                return packCharToTaggedValue(
                    ConstantInt::get(Type::getInt64Ty(*context), ast->int64_val));

            case ESHKOL_NULL:
                return ConstantInt::get(Type::getInt64Ty(*context), 0); // null represented as 0

            default:
                eshkol_warn("Unhandled AST node type: %d", ast->type);
                return nullptr;
        }
    }
    
    Value* codegenString(const char* str) {
        if (!str) return nullptr;
        
        // Create global string constant
        Constant* str_constant = ConstantDataArray::getString(*context, str, true);
        GlobalVariable* global_str = new GlobalVariable(
            *module,
            str_constant->getType(),
            true, // isConstant
            GlobalValue::PrivateLinkage,
            str_constant,
            ".str"
        );
        
        // Return pointer to the string
        return builder->CreatePointerCast(global_str, PointerType::getUnqual(*context));
    }

    Value* codegenVariable(const eshkol_ast_t* ast) {
        if (!ast->variable.id) return nullptr;

        std::string var_name = ast->variable.id;

        if (current_function) {
            for (auto& arg : current_function->args()) {
                if (arg.getName() == var_name) {
                    return &arg;
                }
            }
        }
        
        // Check symbol table
        auto it = symbol_table.find(var_name);
        if (it != symbol_table.end()) {
            Value* var_ptr = it->second;

            // If it's an AllocaInst (local variable), load its value
            if (isa<AllocaInst>(var_ptr)) {
                AllocaInst* alloca = dyn_cast<AllocaInst>(var_ptr);
                return builder->CreateLoad(alloca->getAllocatedType(), var_ptr);
            }
            // If it's a GlobalVariable, load its value
            else if (isa<GlobalVariable>(var_ptr)) {
                GlobalVariable* global = dyn_cast<GlobalVariable>(var_ptr);
                return builder->CreateLoad(global->getValueType(), var_ptr);
            }
            // Otherwise return as-is (for function arguments, etc.)
            else {
                return var_ptr;
            }
        }

        // REPL MODE: Check if variable exists in REPL registries
        // Variables from previous REPL evaluations are stored here
        if (g_repl_mode_enabled) {
            // First check if it's a lambda function (stored in g_repl_function_addresses)
            // Don't hold lock while calling tryResolveReplFunction (it acquires its own lock)
            Function* repl_func = tryResolveReplFunction(var_name);
            if (repl_func) {
                // Return the function pointer - display() will handle s-expression lookup
                return repl_func;
            }

            // Then check if it's a regular variable (stored in g_repl_symbol_addresses)
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            auto repl_it = g_repl_symbol_addresses.find(var_name);
            if (repl_it != g_repl_symbol_addresses.end()) {
                // Variable exists in REPL context - create external global declaration
                GlobalVariable* global_var = module->getGlobalVariable(var_name);
                if (!global_var) {
                    // Create external declaration for this global variable
                    // Use tagged_value type to preserve type information across modules
                    global_var = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer for external declaration
                        var_name
                    );
                }

                // Load and return the value
                return builder->CreateLoad(global_var->getValueType(), global_var);
            }
        }

        eshkol_warn("Undefined variable: %s", var_name.c_str());
        return nullptr;
    }
    
    Value* codegenOperation(const eshkol_operations_t* op) {
        switch (op->op) {
            case ESHKOL_DEFINE_OP:
                return codegenDefine(op);
                
            case ESHKOL_CALL_OP:
                return codegenCall(op);
                
            case ESHKOL_SEQUENCE_OP:
                return codegenSequence(op);
                
            case ESHKOL_EXTERN_OP:
                return codegenExtern(op);

            case ESHKOL_EXTERN_VAR_OP:
                return codegenExternVar(op);

            case ESHKOL_LAMBDA_OP:
                return codegenLambda(op);
                
            case ESHKOL_LET_OP:
            case ESHKOL_LET_STAR_OP:  // let* uses same codegen - sequential bindings
                return codegenLet(op);

            case ESHKOL_LETREC_OP:
                return codegenLetrec(op);

            case ESHKOL_AND_OP:
                return codegenAnd(op);

            case ESHKOL_OR_OP:
                return codegenOr(op);

            case ESHKOL_COND_OP:
                return codegenCond(op);

            case ESHKOL_CASE_OP:
                return codegenCase(op);

            case ESHKOL_DO_OP:
                return codegenDo(op);

            case ESHKOL_WHEN_OP:
                return codegenWhen(op);

            case ESHKOL_UNLESS_OP:
                return codegenUnless(op);

            case ESHKOL_QUOTE_OP:
                // Quote returns the AST as literal data
                if (op->call_op.num_vars > 0) {
                    return codegenQuotedAST(&op->call_op.variables[0]);
                }
                return packNullToTaggedValue();

            case ESHKOL_SET_OP:
                return codegenSet(op);

            case ESHKOL_TENSOR_OP:
                return codegenTensorOperation(op);
                
            case ESHKOL_DIFF_OP:
                return codegenDiff(op);
                
            case ESHKOL_DERIVATIVE_OP:
                return codegenDerivative(op);
                
            case ESHKOL_GRADIENT_OP:
                return codegenGradient(op);
                
            case ESHKOL_JACOBIAN_OP:
                return codegenJacobian(op);
                
            case ESHKOL_HESSIAN_OP:
                return codegenHessian(op);
                
            case ESHKOL_DIVERGENCE_OP:
                return codegenDivergence(op);
                
            case ESHKOL_CURL_OP:
                return codegenCurl(op);
                
            case ESHKOL_LAPLACIAN_OP:
                return codegenLaplacian(op);
                
            case ESHKOL_DIRECTIONAL_DERIV_OP:
                return codegenDirectionalDerivative(op);
                
            default:
                eshkol_warn("Unhandled operation type: %d", op->op);
                return nullptr;
        }
    }
    
    Value* codegenDefine(const eshkol_operations_t* op) {
        const char* name = op->define_op.name;
        if (!name) return nullptr;
        
        if (op->define_op.is_function) {
            return codegenFunctionDefinition(op);
        } else {
            return codegenVariableDefinition(op);
        }
    }
    
    Value* codegenFunctionDefinition(const eshkol_operations_t* op) {
        const char* func_name = op->define_op.name;
        Function* function = function_table[func_name];

        if (!function) {
            eshkol_error("Function %s not found in function_table (nested define not supported - use let+lambda instead)", func_name);
            return nullptr;
        }
        
        // Create basic block for function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", function);
        builder->SetInsertPoint(entry);

        // Set current function
        Function* prev_function = current_function;
        current_function = function;
        
        // GLOBAL ARENA FIX: No per-function arena initialization needed
        // All functions share the global arena initialized in main
        
        // Add parameters to symbol table
        std::map<std::string, Value*> prev_symbols = symbol_table;
        if (op->define_op.parameters) {
            auto arg_it = function->arg_begin();
            for (uint64_t i = 0; i < op->define_op.num_params && arg_it != function->arg_end(); ++i, ++arg_it) {
                if (op->define_op.parameters[i].type == ESHKOL_VAR &&
                    op->define_op.parameters[i].variable.id) {
                    symbol_table[op->define_op.parameters[i].variable.id] = &(*arg_it);
                }
            }
        }
        
        // Generate function body
        Value* body_result = nullptr;
        if (op->define_op.value) {
            body_result = codegenAST(op->define_op.value);
        }
        
        eshkol_debug("Function %s body_result: %p", func_name, body_result);
        
        // Ensure we're still in the correct insertion point
        if (!builder->GetInsertBlock() || builder->GetInsertBlock()->getTerminator()) {
            eshkol_error("Invalid insertion point in function %s", func_name);
            return nullptr;
        }
        
        // Return the result - pack to tagged_value since functions now return tagged_value
        if (body_result) {
            // If body_result is already a tagged_value, return it directly
            if (body_result->getType() == tagged_value_type) {
                builder->CreateRet(body_result);
            }
            // If body_result is a function (lambda), pack as function pointer
            // CRITICAL FIX: Check for null before isa<Function>
            else if (body_result && isa<Function>(body_result)) {
                Function* lambda_func = dyn_cast<Function>(body_result);
                eshkol_debug("Function %s returns lambda %s", func_name, lambda_func->getName().str().c_str());
                
                // Pack function pointer to tagged_value
                Value* func_addr = builder->CreatePtrToInt(lambda_func, Type::getInt64Ty(*context));
                Value* func_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(func_addr, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
                builder->CreateRet(func_tagged);
            }
            // Otherwise, detect type and pack to tagged_value
            else {
                TypedValue typed = detectValueType(body_result);
                Value* tagged = typedValueToTaggedValue(typed);
                builder->CreateRet(tagged);
            }
        } else {
            // Return null tagged value as default
            eshkol_debug("Function %s has no body result, returning null tagged value", func_name);
            Value* null_tagged = packInt64ToTaggedValue(
                ConstantInt::get(Type::getInt64Ty(*context), 0), true);
            builder->CreateRet(null_tagged);
        }

        // CRITICAL FIX (Bug #2): Register function reference for autodiff resolution FIRST
        // Must happen BEFORE symbol_table restoration to ensure it persists
        global_symbol_table[std::string(func_name) + "_func"] = function;
        eshkol_debug("Registered function reference for autodiff in global_symbol_table: %s_func", func_name);

        // Restore previous state - but preserve _func entries added during body execution
        std::map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            // Preserve all entries ending with "_func" (these are function references for autodiff)
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {
                func_refs_to_preserve[entry.first] = entry.second;
                eshkol_debug("Preserving function reference across scope restore: %s", entry.first.c_str());
            }
        }
        
        symbol_table = prev_symbols;
        
        // Re-add preserved function references
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
            global_symbol_table[entry.first] = entry.second;  // Also ensure in global
        }
        
        // Add this function's reference as well
        symbol_table[std::string(func_name) + "_func"] = function;
        
        current_function = prev_function;

        eshkol_debug("Generated function: %s", func_name);

        return function;
    }
    
    Value* codegenVariableDefinition(const eshkol_operations_t* op) {
        const char* var_name = op->define_op.name;
        Value* value = nullptr;
        eshkol_value_type_t value_type = ESHKOL_VALUE_INT64;  // Default type

        if (op->define_op.value) {
            // CRITICAL FIX: Use codegenTypedAST to preserve type information for lists
            TypedValue typed = codegenTypedAST(op->define_op.value);
            value = typed.llvm_value;
            value_type = typed.type;
        }

        if (!value) return nullptr;

        IRBuilderBase::InsertPoint old_point;
        bool had_insertion_point = builder->GetInsertBlock() != nullptr;
        if (had_insertion_point) {
            old_point = builder->saveIP();
        }

        if (current_function) {
            // CRITICAL FIX: Check if we're in __global_init temp function OR REPL mode
            // If so, use GlobalVariable instead of AllocaInst so definitions survive function execution!
            bool is_global_init = (current_function->getName() == "__global_init");
            bool is_repl_eval = g_repl_mode_enabled;  // In REPL mode, always use globals

            // For functions (lambdas), store as int64 pointer
            Type* storage_type = value->getType();
            // CRITICAL FIX: Check for null before isa<Function> to avoid assertion
            if (value && isa<Function>(value)) {
                Function* func = dyn_cast<Function>(value);
                storage_type = Type::getInt64Ty(*context);

                // Store direct function reference for lambda resolution FIRST
                // CRITICAL: Store in BOTH tables to ensure retrieval works
                symbol_table[std::string(var_name) + "_func"] = func;
                global_symbol_table[std::string(var_name) + "_func"] = func;
                eshkol_debug("Stored lambda function reference: %s_func -> %s (in both symbol tables)",
                            var_name, func->getName().str().c_str());

                // OPTION 3: Create S-expression alias GlobalVariable for this variable
                // This allows display(square) to find S-expression via module->getNamedGlobal()
                std::string lambda_name = func->getName().str();
                std::string lambda_sexpr_key = lambda_name + "_sexpr";
                std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                // Check if lambda S-expression global exists
                GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                if (lambda_sexpr_global) {
                    // Create alias global that points to the same S-expression
                    GlobalVariable* var_sexpr_global = new GlobalVariable(
                        *module, Type::getInt64Ty(*context), false,
                        GlobalValue::ExternalLinkage,
                        ConstantInt::get(Type::getInt64Ty(*context), 0),  // Initialize to 0, will be set at runtime
                        var_sexpr_key
                    );

                    // Store a reference to lambda S-expression in the alias
                    // This must be done at runtime in main, not here
                    global_symbol_table[var_sexpr_key] = var_sexpr_global;
                    eshkol_debug("Created S-expression alias global: %s for %s",
                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                }

                value = builder->CreatePtrToInt(func, storage_type);
            }
            // HOMOICONIC FIX: Handle LAMBDA_SEXPR type (value is PtrToInt of Function*)
            // We need to find the corresponding lambda function to create the var_sexpr alias
            else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                Function* matching_lambda = nullptr;

                // Try to recover the original Function* from the PtrToInt instruction
                if (PtrToIntInst* ptoi = dyn_cast<PtrToIntInst>(value)) {
                    Value* ptr_operand = ptoi->getPointerOperand();
                    if (Function* func = dyn_cast<Function>(ptr_operand)) {
                        matching_lambda = func;
                        eshkol_debug("Recovered Function* %s from PtrToIntInst", func->getName().str().c_str());
                    }
                }
                // Handle CallInst (function call results that return lambdas)
                if (!matching_lambda) {
                    if (CallInst* call = dyn_cast<CallInst>(value)) {
                        Function* called_func = call->getCalledFunction();
                        if (called_func) {
                            std::string called_name = called_func->getName().str();
                            if (called_name.find("lambda_") == 0) {
                                // Find the inner lambda this function returns
                                std::string num_str = called_name.substr(7);
                                try {
                                    int called_num = std::stoi(num_str);
                                    std::string inner_name = "lambda_" + std::to_string(called_num + 1);
                                    auto inner_it = function_table.find(inner_name);
                                    if (inner_it != function_table.end()) {
                                        matching_lambda = inner_it->second;
                                        eshkol_debug("Found inner lambda %s for CallInst to %s",
                                                    inner_name.c_str(), called_name.c_str());
                                    }
                                } catch (...) {}
                            }
                        }
                    }
                }
                // Also handle ConstantExpr (used for global function pointers)
                if (!matching_lambda) {
                    if (ConstantExpr* ce = dyn_cast<ConstantExpr>(value)) {
                        if (ce->getOpcode() == Instruction::PtrToInt) {
                            Value* ptr_operand = ce->getOperand(0);
                            if (Function* func = dyn_cast<Function>(ptr_operand)) {
                                matching_lambda = func;
                                eshkol_debug("Recovered Function* %s from ConstantExpr", func->getName().str().c_str());
                            }
                        }
                    }
                }

                // Fallback: find the most recent lambda (for returned lambdas)
                if (!matching_lambda) {
                    int highest_lambda_num = -1;
                    for (auto& func_entry : function_table) {
                        if (func_entry.first.find("lambda_") == 0) {
                            std::string num_str = func_entry.first.substr(7);
                            try {
                                int lambda_num = std::stoi(num_str);
                                if (lambda_num > highest_lambda_num) {
                                    highest_lambda_num = lambda_num;
                                    matching_lambda = func_entry.second;
                                }
                            } catch (...) {}
                        }
                    }
                }

                if (matching_lambda) {
                    std::string lambda_name = matching_lambda->getName().str();
                    std::string lambda_sexpr_key = lambda_name + "_sexpr";
                    std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                    // Store function reference for lambda resolution
                    symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                    global_symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                    eshkol_debug("Stored lambda function reference: %s_func -> %s",
                                var_name, lambda_name.c_str());

                    // Create S-expression alias and copy the value at runtime
                    GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                    if (lambda_sexpr_global) {
                        GlobalVariable* var_sexpr_global = dyn_cast<GlobalVariable>(module->getNamedGlobal(var_sexpr_key));
                        if (!var_sexpr_global) {
                            var_sexpr_global = new GlobalVariable(
                                *module, Type::getInt64Ty(*context), false,
                                GlobalValue::ExternalLinkage,
                                ConstantInt::get(Type::getInt64Ty(*context), 0),
                                var_sexpr_key
                            );
                            global_symbol_table[var_sexpr_key] = var_sexpr_global;
                        }
                        // Generate code to copy lambda_sexpr to var_sexpr at runtime
                        Value* sexpr_value = builder->CreateLoad(Type::getInt64Ty(*context), lambda_sexpr_global);
                        builder->CreateStore(sexpr_value, var_sexpr_global);
                        eshkol_debug("Created S-expression alias (from LAMBDA_SEXPR): %s -> %s",
                                    var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                    }
                }
            }
            if (is_global_init || is_repl_eval) {
                // In __global_init or REPL eval: create GlobalVariable so it survives function execution

                // REPL MODE FIX: Always use tagged_value type for cross-module compatibility
                // This ensures external declarations in other modules can load the correct type
                Value* store_value = value;
                Type* actual_storage_type = storage_type;
                Constant* const_init = nullptr;

                // Pack to tagged_value when:
                // 1. REPL mode (always), OR
                // 2. Global init mode with CONS_PTR or LAMBDA_SEXPR types (for proper list/lambda display)
                bool needs_tagged_packing = is_repl_eval ||
                    (is_global_init && (value_type == ESHKOL_VALUE_CONS_PTR ||
                                        value_type == ESHKOL_VALUE_LAMBDA_SEXPR ||
                                        value_type == ESHKOL_VALUE_TENSOR_PTR));
                if (needs_tagged_packing && storage_type != tagged_value_type) {
                    actual_storage_type = tagged_value_type;

                    // Try to create constant tagged_value for constant inputs
                    // Struct layout: {i8 type, i8 flags, i16 reserved, i64 data}
                    if (auto* const_fp = dyn_cast<ConstantFP>(value)) {
                        // Create constant tagged_value struct for double
                        double dval = const_fp->getValueAPF().convertToDouble();
                        uint64_t bits;
                        memcpy(&bits, &dval, sizeof(double));
                        Constant* type_const = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE);
                        Constant* flags_const = ConstantInt::get(Type::getInt8Ty(*context), 0);
                        Constant* reserved_const = ConstantInt::get(Type::getInt16Ty(*context), 0);
                        Constant* data_const = ConstantInt::get(Type::getInt64Ty(*context), bits);
                        const_init = ConstantStruct::get(
                            dyn_cast<StructType>(tagged_value_type),
                            {type_const, flags_const, reserved_const, data_const});
                        store_value = const_init;
                    } else if (auto* const_int = dyn_cast<ConstantInt>(value)) {
                        // Create constant tagged_value struct for int64
                        int64_t ival = const_int->getSExtValue();
                        Constant* type_const = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64);
                        Constant* flags_const = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_EXACT_FLAG);
                        Constant* reserved_const = ConstantInt::get(Type::getInt16Ty(*context), 0);
                        Constant* data_const = ConstantInt::get(Type::getInt64Ty(*context), ival);
                        const_init = ConstantStruct::get(
                            dyn_cast<StructType>(tagged_value_type),
                            {type_const, flags_const, reserved_const, data_const});
                        store_value = const_init;
                    } else {
                        // Non-constant: pack at runtime with correct type
                        if (storage_type->isDoubleTy()) {
                            store_value = packDoubleToTaggedValue(value);
                        } else if (storage_type->isIntegerTy(64)) {
                            // CRITICAL FIX: Check value_type to properly tag list/cons pointers
                            if (value_type == ESHKOL_VALUE_CONS_PTR) {
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_CONS_PTR);
                            } else if (value_type == ESHKOL_VALUE_TENSOR_PTR) {
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_TENSOR_PTR);
                            } else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                                // HOMOICONIC FIX: Preserve lambda S-expression type
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_LAMBDA_SEXPR);
                            } else {
                                store_value = packInt64ToTaggedValue(value, true);
                            }
                        }
                    }
                }

                Constant* init_value = dyn_cast<Constant>(store_value);

                // FIX: For non-constant values, use UndefValue as initializer and store at runtime
                // This works for both __global_init and REPL mode because GlobalVariable persists
                // beyond function scope, unlike AllocaInst which is destroyed when function returns
                {
                    if (!init_value) {
                        // REPL mode: Use UndefValue, will store at runtime
                        init_value = UndefValue::get(actual_storage_type);
                    }

                    // Use WeakAnyLinkage for REPL variables to allow cross-module access
                    GlobalValue::LinkageTypes linkage = is_repl_eval
                        ? GlobalValue::WeakAnyLinkage
                        : GlobalValue::InternalLinkage;

                    GlobalVariable* global_var = new GlobalVariable(
                        *module,
                        actual_storage_type,
                        false, // not constant
                        linkage,
                        init_value,
                        var_name
                    );

                    // Store actual value if not constant (requires runtime init)
                    if (!dyn_cast<Constant>(store_value)) {
                        builder->CreateStore(store_value, global_var);
                    }

                    symbol_table[var_name] = global_var;
                    global_symbol_table[var_name] = global_var;
                    eshkol_debug("Created GlobalVariable for %s in %s", var_name,
                                is_repl_eval ? "REPL mode" : "__global_init");

                    // HOMOICONIC FIX: Handle returned lambdas (value is tagged_value or not a Function*)
                    // Find the most recently created lambda and create S-expression alias
                    // This allows (display add5) to work after (define add5 (make-adder 5))
                    eshkol_debug("Checking returned lambda handling for %s: value_type=%d, is_tagged=%d, is_i64=%d",
                                var_name, value_type, value->getType() == tagged_value_type, storage_type->isIntegerTy(64));
                    if (value_type != ESHKOL_VALUE_LAMBDA_SEXPR &&
                        (value->getType() == tagged_value_type || storage_type->isIntegerTy(64))) {
                        Function* matching_lambda = nullptr;
                        int highest_lambda_num = -1;

                        for (auto& func_entry : function_table) {
                            if (func_entry.first.find("lambda_") == 0) {
                                std::string num_str = func_entry.first.substr(7);
                                try {
                                    int lambda_num = std::stoi(num_str);
                                    if (lambda_num > highest_lambda_num) {
                                        highest_lambda_num = lambda_num;
                                        matching_lambda = func_entry.second;
                                    }
                                } catch (...) {}
                            }
                        }

                        if (matching_lambda) {
                            std::string lambda_name = matching_lambda->getName().str();
                            std::string lambda_sexpr_key = lambda_name + "_sexpr";
                            std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                            // Store function reference
                            symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                            global_symbol_table[std::string(var_name) + "_func"] = matching_lambda;

                            // Create S-expression alias if not already exists
                            if (!module->getNamedGlobal(var_sexpr_key)) {
                                GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                                if (lambda_sexpr_global) {
                                    GlobalVariable* var_sexpr_global = new GlobalVariable(
                                        *module, Type::getInt64Ty(*context), false,
                                        GlobalValue::ExternalLinkage,
                                        ConstantInt::get(Type::getInt64Ty(*context), 0),
                                        var_sexpr_key
                                    );
                                    global_symbol_table[var_sexpr_key] = var_sexpr_global;
                                    eshkol_debug("Created S-expression alias for returned lambda: %s -> %s",
                                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                                }
                            }
                        }
                    }
                }
            } else {
                // Normal function context: use AllocaInst
                // HOMOICONIC FIX: Pack CONS_PTR, LAMBDA_SEXPR, TENSOR_PTR in tagged_value to preserve type
                Value* store_value = value;
                Type* actual_storage_type = storage_type;
                if ((value_type == ESHKOL_VALUE_CONS_PTR ||
                     value_type == ESHKOL_VALUE_LAMBDA_SEXPR ||
                     value_type == ESHKOL_VALUE_TENSOR_PTR) &&
                    storage_type != tagged_value_type) {
                    actual_storage_type = tagged_value_type;
                    if (value_type == ESHKOL_VALUE_CONS_PTR) {
                        store_value = packPtrToTaggedValue(
                            builder->CreateIntToPtr(value, builder->getPtrTy()),
                            ESHKOL_VALUE_CONS_PTR);
                    } else if (value_type == ESHKOL_VALUE_TENSOR_PTR) {
                        store_value = packPtrToTaggedValue(
                            builder->CreateIntToPtr(value, builder->getPtrTy()),
                            ESHKOL_VALUE_TENSOR_PTR);
                    } else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                        store_value = packPtrToTaggedValue(
                            builder->CreateIntToPtr(value, builder->getPtrTy()),
                            ESHKOL_VALUE_LAMBDA_SEXPR);
                    }
                }
                AllocaInst* variable = builder->CreateAlloca(
                    actual_storage_type,
                    nullptr,
                    var_name
                );
                // Fix alignment mismatch: explicitly set proper alignment for i64
                if (actual_storage_type->isIntegerTy(64)) {
                    variable->setAlignment(Align(8)); // Explicit 8-byte alignment for i64
                }
                builder->CreateStore(store_value, variable);
                symbol_table[var_name] = variable;

                // HOMOICONIC FIX: For returned lambdas in function context, find the matching lambda
                // and create var_func reference so the alias code in main can find it
                // BUT ONLY if _func isn't already set (don't overwrite correct values from LAMBDA_SEXPR branch)
                if ((value->getType() == tagged_value_type || value_type == ESHKOL_VALUE_LAMBDA_SEXPR) &&
                    symbol_table.find(std::string(var_name) + "_func") == symbol_table.end()) {
                    // Find the most recently created lambda (heuristic for returned lambdas)
                    Function* matching_lambda = nullptr;
                    int highest_lambda_num = -1;
                    for (auto& func_entry : function_table) {
                        if (func_entry.first.find("lambda_") == 0) {
                            std::string num_str = func_entry.first.substr(7);
                            try {
                                int lambda_num = std::stoi(num_str);
                                if (lambda_num > highest_lambda_num) {
                                    highest_lambda_num = lambda_num;
                                    matching_lambda = func_entry.second;
                                }
                            } catch (...) {}
                        }
                    }
                    if (matching_lambda) {
                        symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        global_symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        eshkol_debug("Created _func reference for %s -> %s in function context",
                                    var_name, matching_lambda->getName().str().c_str());
                    }
                }
            }
        } else {
            // For global variables, handle function pointers specially
            // CRITICAL FIX: Check for null before isa<Function> to avoid assertion
            if (value && isa<Function>(value)) {
                Function* func = dyn_cast<Function>(value);
                
                // CRITICAL FIX: Store direct function reference FIRST for lambda resolution
                // This MUST happen for global lambdas too!
                symbol_table[std::string(var_name) + "_func"] = func;
                global_symbol_table[std::string(var_name) + "_func"] = func;
                eshkol_debug("Stored GLOBAL lambda function reference: %s_func -> %s (in both tables)",
                            var_name, func->getName().str().c_str());
                
                // OPTION 3: Use same GlobalVariable pointer for alias (no need to create new one)
                std::string lambda_name = func->getName().str();
                std::string lambda_sexpr_key = lambda_name + "_sexpr";
                std::string var_sexpr_key = std::string(var_name) + "_sexpr";
                
                // Check if lambda S-expression GlobalVariable exists
                auto lambda_sexpr_it = global_symbol_table.find(lambda_sexpr_key);
                if (lambda_sexpr_it != global_symbol_table.end()) {
                    // Alias: Both keys point to SAME GlobalVariable instance
                    // This works because global_symbol_table stores Value* pointers
                    global_symbol_table[var_sexpr_key] = lambda_sexpr_it->second;
                    eshkol_debug("Aliased GLOBAL S-expression: %s -> %s (same GlobalVariable ptr)",
                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                }
                
                // Store function pointer as a global variable with proper initialization
                Constant* func_ptr = ConstantExpr::getPtrToInt(func, Type::getInt64Ty(*context));
                GlobalVariable *variable = new GlobalVariable(
                    *module,
                    Type::getInt64Ty(*context), // Store as int64 function pointer
                    false,
                    GlobalValue::WeakAnyLinkage,
                    func_ptr, // Initialize with actual function address
                    var_name
                );
                symbol_table[var_name] = variable;
                global_symbol_table[var_name] = variable; // Also store in global table
                
                eshkol_debug("Created global lambda variable: %s", var_name);
            } else {
                // CRITICAL FIX: GlobalVariable requires Constant initializer
                // For non-constant values, use UndefValue and mark for runtime init
                Constant* init_value = dyn_cast<Constant>(value);
                if (!init_value) {
                    // Non-constant value - use UndefValue as placeholder
                    init_value = UndefValue::get(value->getType());
                    eshkol_debug("Global variable %s has non-constant initializer, will init at runtime", var_name);
                }

                GlobalVariable *variable = new GlobalVariable(
                    *module,
                    value->getType(),
                    false,
                    GlobalValue::WeakAnyLinkage,
                    init_value,  // Always valid Constant now
                    var_name
                );
                symbol_table[var_name] = variable;
                global_symbol_table[var_name] = variable; // Also store in global table

                // CRITICAL FIX: Handle returned lambdas stored in global variables
                // When (define add5 (make-adder 5)) is evaluated, we need to track
                // which lambda function add5 points to so closure calls work correctly
                if (value && value->getType() == tagged_value_type) {
                    // Try to find matching lambda by searching function_table
                    // Use the most recently created lambda (highest lambda_N number)
                    Function* matching_lambda = nullptr;
                    int highest_lambda_num = -1;

                    for (auto& func_entry : function_table) {
                        if (func_entry.first.find("lambda_") == 0) {
                            // Extract lambda number from name
                            std::string num_str = func_entry.first.substr(7);  // Skip "lambda_"
                            try {
                                int lambda_num = std::stoi(num_str);
                                if (lambda_num > highest_lambda_num) {
                                    highest_lambda_num = lambda_num;
                                    matching_lambda = func_entry.second;
                                }
                            } catch (...) {
                                // Skip if number parsing fails
                            }
                        }
                    }

                    if (matching_lambda) {
                        std::string lambda_name = matching_lambda->getName().str();
                        symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        global_symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        eshkol_debug("Global define: stored returned lambda reference %s_func -> %s",
                                   var_name, lambda_name.c_str());

                        // REPL MODE: Register lambda name mapping for cross-evaluation calls
                        if (g_repl_mode_enabled) {
                            eshkol_repl_register_lambda_name(var_name, lambda_name.c_str());
                        }
                    }
                }
            }
        }

        if (had_insertion_point) {
            builder->restoreIP(old_point);
        }

        eshkol_debug("Defined variable: %s", var_name);

        return value;
    }

    // set! - mutate an existing variable
    Value* codegenSet(const eshkol_operations_t* op) {
        const char* var_name = op->set_op.name;
        if (!var_name) {
            eshkol_error("set! requires a variable name");
            return packNullToTaggedValue();
        }

        // Generate code for the new value
        if (!op->set_op.value) {
            eshkol_error("set! requires a value");
            return packNullToTaggedValue();
        }

        TypedValue typed = codegenTypedAST(op->set_op.value);
        Value* new_value = typed.llvm_value;
        if (!new_value) {
            eshkol_error("set!: failed to evaluate value");
            return packNullToTaggedValue();
        }

        // Look up the variable in symbol tables
        Value* var_ptr = nullptr;

        // Check local symbol table first
        auto it = symbol_table.find(var_name);
        if (it != symbol_table.end()) {
            var_ptr = it->second;
        }

        // Check global symbol table
        if (!var_ptr) {
            auto git = global_symbol_table.find(var_name);
            if (git != global_symbol_table.end()) {
                var_ptr = git->second;
            }
        }

        // REPL MODE: Check if variable exists in REPL registries
        if (!var_ptr && g_repl_mode_enabled) {
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            auto repl_it = g_repl_symbol_addresses.find(var_name);
            if (repl_it != g_repl_symbol_addresses.end()) {
                // Variable exists in REPL context - create external global declaration
                GlobalVariable* global_var = module->getGlobalVariable(var_name);
                if (!global_var) {
                    // Create external declaration for this global variable
                    global_var = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer for external declaration
                        var_name
                    );
                }
                var_ptr = global_var;
            }
        }

        if (!var_ptr) {
            eshkol_error("set!: undefined variable '%s'", var_name);
            return packNullToTaggedValue();
        }

        // Determine if var_ptr is a pointer we can store to
        // It should be either a GlobalVariable or an AllocaInst
        if (isa<GlobalVariable>(var_ptr) || isa<AllocaInst>(var_ptr)) {
            // Get the storage type
            Type* store_type = nullptr;
            if (GlobalVariable* gv = dyn_cast<GlobalVariable>(var_ptr)) {
                store_type = gv->getValueType();
            } else if (AllocaInst* ai = dyn_cast<AllocaInst>(var_ptr)) {
                store_type = ai->getAllocatedType();
            }

            // Pack value to tagged_value if storage is tagged_value type
            Value* store_value = new_value;
            if (store_type == tagged_value_type && new_value->getType() != tagged_value_type) {
                // Pack to tagged value
                TypedValue tv = detectValueType(new_value);
                store_value = typedValueToTaggedValue(tv);
            } else if (store_type == Type::getInt64Ty(*context) && new_value->getType() != Type::getInt64Ty(*context)) {
                // Handle i64 storage (for function pointers, etc.)
                if (new_value->getType() == tagged_value_type) {
                    store_value = unpackInt64FromTaggedValue(new_value);
                } else if (new_value->getType()->isDoubleTy()) {
                    store_value = builder->CreateBitCast(new_value, Type::getInt64Ty(*context));
                } else {
                    store_value = builder->CreateBitCast(new_value, Type::getInt64Ty(*context));
                }
            }

            builder->CreateStore(store_value, var_ptr);
            eshkol_debug("set! updated variable: %s", var_name);

            // Return the new value (set! returns an unspecified value, but we return the stored value)
            return new_value->getType() == tagged_value_type ? new_value : typedValueToTaggedValue(typed);
        } else {
            // Variable is not mutable (might be a function argument passed by value)
            eshkol_error("set!: variable '%s' is not mutable (not an alloca or global)", var_name);
            return packNullToTaggedValue();
        }
    }

    Value* codegenCall(const eshkol_operations_t* op) {
        if (!op->call_op.func) {
            return nullptr;
        }
        
        // CRITICAL FIX: Handle inline lambda expressions: ((lambda (x) body) arg)
        // This pattern appears in nested lambda calls and must be supported
        if (op->call_op.func->type == ESHKOL_OP &&
            op->call_op.func->operation.op == ESHKOL_LAMBDA_OP) {
            
            // Generate the inline lambda
            Value* lambda = codegenLambda(&op->call_op.func->operation);
            if (!lambda) {
                eshkol_error("Failed to generate inline lambda in call expression");
                return nullptr;
            }
            
            Function* lambda_func = dyn_cast<Function>(lambda);
            if (!lambda_func) {
                eshkol_error("Inline lambda did not produce a Function");
                return nullptr;
            }
            
            // Generate arguments
            std::vector<Value*> args;
            FunctionType* func_type = lambda_func->getFunctionType();
            
            for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                Value* arg = codegenAST(&op->call_op.variables[i]);
                if (arg && i < func_type->getNumParams()) {
                    Type* expected_type = func_type->getParamType(i);
                    
                    // Pack to tagged_value if needed (lambdas expect tagged_value)
                    if (expected_type == tagged_value_type && arg->getType() != tagged_value_type) {
                        if (arg->getType()->isIntegerTy(64)) {
                            arg = packInt64ToTaggedValue(arg, true);
                        } else if (arg->getType()->isDoubleTy()) {
                            arg = packDoubleToTaggedValue(arg);
                        } else {
                            TypedValue tv = detectValueType(arg);
                            arg = typedValueToTaggedValue(tv);
                        }
                    }
                    
                    args.push_back(arg);
                }
            }
            
            // Call the inline lambda
            return builder->CreateCall(lambda_func, args);
        }
        
        // Handle variable function references (existing code)
        if (op->call_op.func->type != ESHKOL_VAR || !op->call_op.func->variable.id) {
            eshkol_error("Call expression requires variable or inline lambda");
            return nullptr;
        }
        
        std::string func_name = op->call_op.func->variable.id;
        
        // Handle arithmetic operations
        if (func_name == "+") return codegenArithmetic(op, "add");
        if (func_name == "-") return codegenArithmetic(op, "sub");
        if (func_name == "*") return codegenArithmetic(op, "mul");
        if (func_name == "/") return codegenArithmetic(op, "div");

        // Handle comparison operations
        if (func_name == "<") return codegenComparison(op, "lt");
        if (func_name == ">") return codegenComparison(op, "gt");
        if (func_name == "=") return codegenComparison(op, "eq");
        if (func_name == "<=") return codegenComparison(op, "le");
        if (func_name == ">=") return codegenComparison(op, "ge");
        
        // Handle math functions with dual number support (Phase 2)
        if (func_name == "sin") return codegenMathFunction(op, "sin");
        if (func_name == "cos") return codegenMathFunction(op, "cos");
        if (func_name == "exp") return codegenMathFunction(op, "exp");
        if (func_name == "log") return codegenMathFunction(op, "log");

        // Additional trigonometric functions
        if (func_name == "tan") return codegenMathFunction(op, "tan");
        if (func_name == "asin") return codegenMathFunction(op, "asin");
        if (func_name == "acos") return codegenMathFunction(op, "acos");
        if (func_name == "atan") return codegenMathFunction(op, "atan");
        if (func_name == "atan2") return codegenBinaryMathFunction(op, "atan2");

        // Hyperbolic functions
        if (func_name == "sinh") return codegenMathFunction(op, "sinh");
        if (func_name == "cosh") return codegenMathFunction(op, "cosh");
        if (func_name == "tanh") return codegenMathFunction(op, "tanh");
        if (func_name == "asinh") return codegenMathFunction(op, "asinh");
        if (func_name == "acosh") return codegenMathFunction(op, "acosh");
        if (func_name == "atanh") return codegenMathFunction(op, "atanh");

        // Logarithmic functions
        if (func_name == "log10") return codegenMathFunction(op, "log10");
        if (func_name == "log2") return codegenMathFunction(op, "log2");

        // Numeric/rounding functions
        if (func_name == "abs") return codegenMathFunction(op, "fabs");
        if (func_name == "fabs") return codegenMathFunction(op, "fabs");
        if (func_name == "floor") return codegenMathFunction(op, "floor");
        if (func_name == "ceiling") return codegenMathFunction(op, "ceil");
        if (func_name == "ceil") return codegenMathFunction(op, "ceil");
        if (func_name == "round") return codegenMathFunction(op, "round");
        if (func_name == "truncate") return codegenMathFunction(op, "trunc");
        if (func_name == "trunc") return codegenMathFunction(op, "trunc");
        if (func_name == "cbrt") return codegenMathFunction(op, "cbrt");

        // Modulo and remainder
        if (func_name == "modulo" || func_name == "mod" || func_name == "%")
            return codegenModulo(op);
        if (func_name == "remainder") return codegenRemainder(op);
        if (func_name == "quotient") return codegenQuotient(op);
        if (func_name == "gcd") return codegenGCD(op);
        if (func_name == "lcm") return codegenLCM(op);

        // Min/max
        if (func_name == "min") return codegenMinMax(op, true);
        if (func_name == "max") return codegenMinMax(op, false);

        // Expt is an alias for pow
        if (func_name == "expt") return codegenPow(op);

        // Logical operators (short-circuit)
        if (func_name == "and") return codegenAnd(op);
        if (func_name == "or") return codegenOr(op);
        if (func_name == "not") return codegenNot(op);

        // One-armed conditionals
        if (func_name == "when") return codegenWhen(op);
        if (func_name == "unless") return codegenUnless(op);

        // Type predicates
        if (func_name == "number?") {
            // Number is either int64 or double
            // Use codegenTypedAST for proper handling of raw values
            TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
            if (!tv.llvm_value) return nullptr;
            Value* arg = typedValueToTaggedValue(tv);
            Value* type = getTaggedValueType(arg);
            Value* base_type = builder->CreateAnd(type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            Value* is_int = builder->CreateICmpEQ(base_type, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
            Value* is_double = builder->CreateICmpEQ(base_type, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            return packBoolToTaggedValue(builder->CreateOr(is_int, is_double));
        }
        if (func_name == "integer?") return codegenTypePredicate(op, ESHKOL_VALUE_INT64);
        if (func_name == "real?") return codegenTypePredicate(op, ESHKOL_VALUE_DOUBLE);
        if (func_name == "list?") return codegenTypePredicate(op, ESHKOL_VALUE_CONS_PTR);
        if (func_name == "string?") return codegenTypePredicate(op, ESHKOL_VALUE_STRING_PTR);

        // String functions
        if (func_name == "string-length") return codegenStringLength(op);
        if (func_name == "string-ref") return codegenStringRef(op);
        if (func_name == "string-append") return codegenStringAppend(op);
        if (func_name == "substring") return codegenSubstring(op);
        if (func_name == "string=?") return codegenStringCompare(op, "eq");
        if (func_name == "string<?") return codegenStringCompare(op, "lt");
        if (func_name == "string>?") return codegenStringCompare(op, "gt");
        if (func_name == "string<=?") return codegenStringCompare(op, "le");
        if (func_name == "string>=?") return codegenStringCompare(op, "ge");
        if (func_name == "number->string") return codegenNumberToString(op);
        if (func_name == "string->number") return codegenStringToNumber(op);
        if (func_name == "make-string") return codegenMakeString(op);
        if (func_name == "string-set!") return codegenStringSet(op);
        if (func_name == "string->list") return codegenStringToList(op);
        if (func_name == "list->string") return codegenListToString(op);

        // Character functions
        if (func_name == "char?") return codegenTypePredicate(op, ESHKOL_VALUE_CHAR);
        if (func_name == "char->integer") return codegenCharToInteger(op);
        if (func_name == "integer->char") return codegenIntegerToChar(op);
        if (func_name == "char=?") return codegenCharCompare(op, "eq");
        if (func_name == "char<?") return codegenCharCompare(op, "lt");
        if (func_name == "char>?") return codegenCharCompare(op, "gt");
        if (func_name == "char<=?") return codegenCharCompare(op, "le");
        if (func_name == "char>=?") return codegenCharCompare(op, "ge");

        // Numeric predicates
        if (func_name == "positive?") return codegenNumericPredicate(op, "positive?");
        if (func_name == "negative?") return codegenNumericPredicate(op, "negative?");
        if (func_name == "zero?") return codegenNumericPredicate(op, "zero?");
        if (func_name == "even?") return codegenNumericPredicate(op, "even?");
        if (func_name == "odd?") return codegenNumericPredicate(op, "odd?");

        // Equivalence predicates
        if (func_name == "eq?") return codegenEq(op);
        if (func_name == "eqv?") return codegenEqv(op);
        if (func_name == "equal?") return codegenEqual(op);

        // Handle display/newline/error operations
        if (func_name == "display") return codegenDisplay(op);
        if (func_name == "newline") return codegenNewline(op);
        if (func_name == "error") return codegenError(op);

        // Handle file I/O operations
        if (func_name == "open-input-file") return codegenOpenInputFile(op);
        if (func_name == "read-line") return codegenReadLine(op);
        if (func_name == "close-port") return codegenClosePort(op);
        if (func_name == "eof-object?") return codegenEofObject(op);
        if (func_name == "open-output-file") return codegenOpenOutputFile(op);
        if (func_name == "write-string") return codegenWriteString(op);
        if (func_name == "write-line") return codegenWriteLine(op);
        if (func_name == "write-char") return codegenWriteChar(op);
        if (func_name == "flush-output-port") return codegenFlushOutputPort(op);

        // Handle if conditional
        if (func_name == "if") return codegenIfCall(op);
        
        // Handle begin sequence
        if (func_name == "begin") return codegenBegin(op);
        
        // Handle basic list operations
        if (func_name == "cons") return codegenCons(op);
        if (func_name == "car") return codegenCar(op);
        if (func_name == "cdr") return codegenCdr(op);
        if (func_name == "list") return codegenList(op);
        if (func_name == "null?") return codegenNullCheck(op);
        if (func_name == "pair?") return codegenPairCheck(op);
        
        // Handle compound car/cdr operations (2-level)
        if (func_name == "caar") return codegenCompoundCarCdr(op, "aa");
        if (func_name == "cadr") return codegenCompoundCarCdr(op, "ad");
        if (func_name == "cdar") return codegenCompoundCarCdr(op, "da");
        if (func_name == "cddr") return codegenCompoundCarCdr(op, "dd");
        
        // Handle compound car/cdr operations (3-level)
        if (func_name == "caaar") return codegenCompoundCarCdr(op, "aaa");
        if (func_name == "caadr") return codegenCompoundCarCdr(op, "aad");
        if (func_name == "cadar") return codegenCompoundCarCdr(op, "ada");
        if (func_name == "caddr") return codegenCompoundCarCdr(op, "add");
        if (func_name == "cdaar") return codegenCompoundCarCdr(op, "daa");
        if (func_name == "cdadr") return codegenCompoundCarCdr(op, "dad");
        if (func_name == "cddar") return codegenCompoundCarCdr(op, "dda");
        if (func_name == "cdddr") return codegenCompoundCarCdr(op, "ddd");
        
        // Handle compound car/cdr operations (4-level) 
        if (func_name == "caaaar") return codegenCompoundCarCdr(op, "aaaa");
        if (func_name == "caaadr") return codegenCompoundCarCdr(op, "aaad");
        if (func_name == "caadar") return codegenCompoundCarCdr(op, "aada");
        if (func_name == "caaddr") return codegenCompoundCarCdr(op, "aadd");
        if (func_name == "cadaar") return codegenCompoundCarCdr(op, "adaa");
        if (func_name == "cadadr") return codegenCompoundCarCdr(op, "adad");
        if (func_name == "caddar") return codegenCompoundCarCdr(op, "adda");
        if (func_name == "cadddr") return codegenCompoundCarCdr(op, "addd");
        if (func_name == "cdaaar") return codegenCompoundCarCdr(op, "daaa");
        if (func_name == "cdaadr") return codegenCompoundCarCdr(op, "daad");
        if (func_name == "cdadar") return codegenCompoundCarCdr(op, "dada");
        if (func_name == "cdaddr") return codegenCompoundCarCdr(op, "dadd");
        if (func_name == "cddaar") return codegenCompoundCarCdr(op, "ddaa");
        if (func_name == "cddadr") return codegenCompoundCarCdr(op, "ddad");
        if (func_name == "cdddar") return codegenCompoundCarCdr(op, "ddda");
        if (func_name == "cddddr") return codegenCompoundCarCdr(op, "dddd");
        
        // Handle essential list utilities
        if (func_name == "length") return codegenLength(op);
        if (func_name == "append") return codegenAppend(op);
        if (func_name == "reverse") return codegenReverse(op);
        if (func_name == "list-ref") return codegenListRef(op);
        if (func_name == "list-tail") return codegenListTail(op);
        
        // Handle mutable list operations
        if (func_name == "set-car!") return codegenSetCar(op);
        if (func_name == "set-cdr!") return codegenSetCdr(op);
        
        // Handle higher-order list functions
        if (func_name == "map") return codegenMap(op);
        if (func_name == "filter") return codegenFilter(op);
        if (func_name == "fold") return codegenFold(op);
        if (func_name == "fold-right") return codegenFoldRight(op);
        if (func_name == "for-each") return codegenForEach(op);
        if (func_name == "any") return codegenAny(op);
        if (func_name == "every") return codegenEvery(op);
        if (func_name == "apply") return codegenApply(op);

        // Handle member/association functions
        if (func_name == "member") return codegenMember(op, "equal");
        if (func_name == "memq") return codegenMember(op, "eq");
        if (func_name == "memv") return codegenMember(op, "eqv");
        if (func_name == "assoc") return codegenAssoc(op, "equal");
        if (func_name == "assq") return codegenAssoc(op, "eq");
        if (func_name == "assv") return codegenAssoc(op, "eqv");
        
        // Handle advanced list constructors
        if (func_name == "make-list") return codegenMakeList(op);
        if (func_name == "list*") return codegenListStar(op);
        if (func_name == "acons") return codegenAcons(op);
        
        // Handle list processing utilities
        if (func_name == "take") return codegenTake(op);
        if (func_name == "drop") return codegenDrop(op);
        if (func_name == "find") return codegenFind(op);
        if (func_name == "partition") return codegenPartition(op);
        if (func_name == "split-at") return codegenSplitAt(op);
        
        // Handle list removal operations
        if (func_name == "remove") return codegenRemove(op, "equal");
        if (func_name == "remq") return codegenRemove(op, "eq");
        if (func_name == "remv") return codegenRemove(op, "eqv");
        
        // Handle list boundary operations
        if (func_name == "last") return codegenLast(op);
        if (func_name == "last-pair") return codegenLastPair(op);
        
        // Handle tensor operations (numerical arrays)
        if (func_name == "tensor-get") return codegenTensorGet(op);
        if (func_name == "vref") return codegenTensorVectorRef(op);  // Tensor 1D access (AD-aware)
        if (func_name == "tensor-set") return codegenTensorSet(op);

        // Scheme vectors (heterogeneous - can hold any type)
        if (func_name == "vector?") return codegenTypePredicate(op, ESHKOL_VALUE_VECTOR_PTR);
        if (func_name == "make-vector") return codegenMakeVector(op);
        if (func_name == "vector") return codegenVector(op);
        if (func_name == "vector-ref") return codegenSchemeVectorRef(op);
        if (func_name == "vector-set!") return codegenSchemeVectorSet(op);
        if (func_name == "vector-length") return codegenVectorLength(op);
        if (func_name == "tensor-add") return codegenTensorArithmetic(op, "add");
        if (func_name == "tensor-sub") return codegenTensorArithmetic(op, "sub");
        if (func_name == "tensor-mul") return codegenTensorArithmetic(op, "mul");
        if (func_name == "tensor-div") return codegenTensorArithmetic(op, "div");
        if (func_name == "tensor-dot") return codegenTensorDot(op);
        if (func_name == "tensor-shape") return codegenTensorShape(op);
        if (func_name == "tensor-apply") return codegenTensorApply(op);
        if (func_name == "tensor-reduce") {
            // Support both 3-arg (reduce all) and 4-arg (reduce with dimension) versions
            if (op->call_op.num_vars == 3) {
                return codegenTensorReduceAll(op);
            } else {
                return codegenTensorReduceWithDim(op);
            }
        }
        if (func_name == "tensor-reduce-all") return codegenTensorReduceAll(op);

        // ML tensor creation functions
        if (func_name == "zeros") return codegenZeros(op);
        if (func_name == "ones") return codegenOnes(op);
        if (func_name == "eye") return codegenEye(op);
        if (func_name == "arange") return codegenArange(op);
        if (func_name == "linspace") return codegenLinspace(op);

        // ML tensor manipulation functions
        if (func_name == "reshape") return codegenReshape(op);
        if (func_name == "transpose") return codegenTranspose(op);
        if (func_name == "flatten") return codegenFlatten(op);

        // ML linear algebra
        if (func_name == "matmul") return codegenMatmul(op);

        // ML statistics with axis support
        if (func_name == "tensor-sum") return codegenTensorSum(op);
        if (func_name == "tensor-mean") return codegenTensorMean(op);

        // Handle tensor-to-string conversions
        if (func_name == "vector-to-string") return codegenVectorToString(op);
        if (func_name == "matrix-to-string") return codegenMatrixToString(op);
        
        // Handle function calls - check both function table and lambda variables
        Function* callee = function_table[func_name];

        // If not found in function table, check if it's a variable containing a lambda
        if (!callee) {
            // First check if there's a direct function reference
            auto func_it = symbol_table.find(func_name + "_func");
            if (func_it != symbol_table.end() && func_it->second) {
                // CRITICAL FIX: Always try to cast to Function* - we know _func entries should be functions
                callee = dyn_cast<Function>(func_it->second);
            } else {
                func_it = global_symbol_table.find(func_name + "_func");
                if (func_it != global_symbol_table.end() && func_it->second) {
                    callee = dyn_cast<Function>(func_it->second);
                }

                // REPL MODE: Try resolving from global REPL context
                if (!callee) {
                    callee = tryResolveReplFunction(func_name);
                }
                if (!callee) {
                    std::string func_key = func_name + "_func";
                    callee = tryResolveReplFunction(func_key);
                }

                // CRITICAL FIX: Only do variable fallback if we STILL haven't found the function
                if (!callee) {
                    // Fall back to the variable lookup
                    auto var_it = symbol_table.find(func_name);
                    if (var_it != symbol_table.end()) {
                        Value* lambda_ptr = var_it->second;
                        
                        // Check if it's a local variable containing function pointer
                        if (isa<AllocaInst>(lambda_ptr)) {
                            Type* stored_type = dyn_cast<AllocaInst>(lambda_ptr)->getAllocatedType();
                            if (stored_type && stored_type->isIntegerTy(64)) {
                                // Load the function pointer address
                                Value* func_addr = builder->CreateLoad(stored_type, lambda_ptr);
                                
                                // Find the corresponding lambda function by searching function table
                                for (auto& func_pair : function_table) {
                                    if (func_pair.first.find("lambda_") == 0) {
                                        Function* lambda_func = func_pair.second;
                                        
                                        // Check if this lambda matches the expected signature
                                        if (lambda_func->arg_size() == op->call_op.num_vars) {
                                            callee = lambda_func;
                                            eshkol_debug("Resolved lambda function %s for variable %s",
                                                       func_pair.first.c_str(), func_name.c_str());
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if (!callee) {
            // If we can't find the function directly, check if it's a variable containing a function pointer
            // Check local symbols first, then global symbols
            auto var_it = symbol_table.find(func_name);
            if (var_it == symbol_table.end()) {
                var_it = global_symbol_table.find(func_name);
            }
            
            if (var_it != symbol_table.end() || global_symbol_table.find(func_name) != global_symbol_table.end()) {
                if (var_it == symbol_table.end()) {
                    var_it = global_symbol_table.find(func_name);
                }
                eshkol_debug("Found variable %s, attempting dynamic function call", func_name.c_str());
                
                // Try to find associated lambda function
                auto func_it = symbol_table.find(std::string(func_name) + "_func");
                if (func_it == symbol_table.end()) {
                    func_it = global_symbol_table.find(std::string(func_name) + "_func");
                }
                
                if ((func_it != symbol_table.end() || global_symbol_table.find(std::string(func_name) + "_func") != global_symbol_table.end())
                    && func_it->second && isa<Function>(func_it->second)) {
                    // CRITICAL FIX: Check for null before isa<Function>
                    callee = dyn_cast<Function>(func_it->second);
                    eshkol_debug("Resolved closure function for %s", func_name.c_str());
                } else {
                    // Try to find lambda by inspecting function table for matching signatures
                    // CRITICAL FIX: Only match lambdas that actually have captured parameters
                    // (parameter names starting with "captured_"), not just any lambda with the right arg count
                    for (auto& func_pair : function_table) {
                        if (func_pair.first.find("lambda_") == 0) {
                            Function* lambda_func = func_pair.second;
                            // For closures, the lambda has original params + captured params
                            if (lambda_func->arg_size() == op->call_op.num_vars + 1) {
                                // Verify this lambda actually has captured parameters
                                bool has_captures = false;
                                for (auto& arg : lambda_func->args()) {
                                    if (arg.getName().str().find("captured_") == 0) {
                                        has_captures = true;
                                        break;
                                    }
                                }
                                if (has_captures) {
                                    callee = lambda_func;
                                    eshkol_debug("Matched closure lambda %s for %s (args: %zu + 1 captured)",
                                               func_pair.first.c_str(), func_name.c_str(), op->call_op.num_vars);
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (!callee) {
                    eshkol_warn("Could not resolve closure function for: %s", func_name.c_str());
                    return ConstantInt::get(Type::getInt64Ty(*context), 0); // Return 0 as placeholder
                }
            } else {
                eshkol_warn("Unknown function: %s", func_name.c_str());
                return nullptr;
            }
        }

        // Generate arguments with type conversion
        std::vector<Value*> args;
        FunctionType* func_type = callee->getFunctionType();
        
        // Check if this is a closure call (more parameters expected than provided)
        bool is_closure_call = (func_type->getNumParams() > op->call_op.num_vars);
        
        // Add explicit arguments first
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&op->call_op.variables[i]);
            if (arg && i < func_type->getNumParams()) {
                Type* expected_type = func_type->getParamType(i);
                Type* actual_type = arg->getType();

                // If function expects tagged_value, pack the argument
                if (expected_type == tagged_value_type) {
                    if (actual_type == tagged_value_type) {
                        // Already tagged - use as-is
                        // Do nothing, arg is already correct type
                    } else if (actual_type->isIntegerTy(64)) {
                        arg = packInt64ToTaggedValue(arg, true);
                    } else if (actual_type->isDoubleTy()) {
                        arg = packDoubleToTaggedValue(arg);
                    } else if (actual_type->isPointerTy()) {
                        arg = packPtrToTaggedValue(arg, ESHKOL_VALUE_CONS_PTR);
                    } else if (actual_type->isIntegerTy()) {
                        // Convert other integer types to i64 first
                        Value* as_i64 = builder->CreateSExtOrTrunc(arg, Type::getInt64Ty(*context));
                        arg = packInt64ToTaggedValue(as_i64, true);
                    } else {
                        // Fallback: pack as null
                        arg = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
                    }
                }
                // If we have a tagged_value but function expects a C type, unpack it
                else if (actual_type == tagged_value_type && expected_type != tagged_value_type) {
                    // Extract raw data from tagged value and convert to expected type
                    Value* original_tagged = arg;
                    Value* data_i64 = unpackInt64FromTaggedValue(original_tagged);
                    if (expected_type->isPointerTy()) {
                        arg = builder->CreateIntToPtr(data_i64, expected_type);
                    } else if (expected_type->isIntegerTy(64)) {
                        arg = data_i64;
                    } else if (expected_type->isIntegerTy()) {
                        arg = builder->CreateTrunc(data_i64, expected_type);
                    } else if (expected_type->isDoubleTy()) {
                        arg = unpackDoubleFromTaggedValue(original_tagged);
                    } else if (expected_type->isFloatTy()) {
                        Value* as_double = unpackDoubleFromTaggedValue(original_tagged);
                        arg = builder->CreateFPTrunc(as_double, expected_type);
                    }
                }
                // Perform type conversion if necessary
                else if (actual_type != expected_type) {
                    if (actual_type->isIntegerTy() && expected_type->isIntegerTy()) {
                        // Integer to integer conversion
                        if (actual_type->getIntegerBitWidth() > expected_type->getIntegerBitWidth()) {
                            arg = builder->CreateTrunc(arg, expected_type);
                        } else if (actual_type->getIntegerBitWidth() < expected_type->getIntegerBitWidth()) {
                            arg = builder->CreateSExt(arg, expected_type);
                        }
                    } else if (actual_type->isFloatingPointTy() && expected_type->isFloatingPointTy()) {
                        // Float to float conversion
                        if (actual_type->isDoubleTy() && expected_type->isFloatTy()) {
                            arg = builder->CreateFPTrunc(arg, expected_type);
                        } else if (actual_type->isFloatTy() && expected_type->isDoubleTy()) {
                            arg = builder->CreateFPExt(arg, expected_type);
                        }
                    } else if (actual_type->isIntegerTy() && expected_type->isFloatingPointTy()) {
                        // Integer to float conversion
                        arg = builder->CreateSIToFP(arg, expected_type);
                    } else if (actual_type->isFloatingPointTy() && expected_type->isIntegerTy()) {
                        // Float to integer conversion
                        arg = builder->CreateFPToSI(arg, expected_type);
                    } else if (auto* global_value = dyn_cast<GlobalValue>(arg)) {
                        arg = builder->CreateLoad(global_value->getValueType(), global_value);
                    }
                }

                args.push_back(arg);
            } else if (arg && func_type->isVarArg()) {
                // For varargs C functions (like printf), unpack tagged values to native types
                if (arg->getType() == tagged_value_type) {
                    // Get the type from the tagged value
                    Value* type_byte = getTaggedValueType(arg);
                    Value* base_type = builder->CreateAnd(type_byte,
                        ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

                    // Check type and unpack appropriately
                    Value* is_string = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
                    Value* is_double = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

                    // Extract the raw data field
                    Value* data_i64 = unpackInt64FromTaggedValue(arg);

                    // For the first arg position (format string in printf-like calls)
                    // or if it's a string type, convert to pointer
                    if (i == 0) {
                        // First arg is format string - must be pointer
                        arg = builder->CreateIntToPtr(data_i64, PointerType::getUnqual(*context));
                    } else {
                        // For other args, we need to handle based on type
                        // Use select to choose between double and int64
                        Value* as_double = unpackDoubleFromTaggedValue(arg);
                        // For printf, double args are passed as double, int args as int64
                        // We'll let the C varargs mechanism handle this
                        // Push as int64 for ints, double for doubles
                        arg = builder->CreateSelect(is_double,
                            builder->CreateBitCast(as_double, Type::getInt64Ty(*context)),
                            data_i64);
                    }
                }
                args.push_back(arg);
            }
        }
        
        // Add captured arguments for closure calls
        if (is_closure_call) {
            // CRITICAL FIX: Load captured values from CURRENT context, not from storage allocas
            // This avoids cross-function references entirely
            size_t num_captures = func_type->getNumParams() - op->call_op.num_vars;
            
            eshkol_debug("Closure call to %s needs %zu captured arguments",
                        func_name.c_str(), num_captures);
            
            // Get the lambda function to extract capture parameter names
            auto arg_it = callee->arg_begin();
            
            // Skip explicit parameters (those provided by the caller)
            for (size_t i = 0; i < op->call_op.num_vars && arg_it != callee->arg_end(); i++) {
                arg_it++;
            }
            
            // Now load each captured variable from current context
            // CRITICAL FIX: Load captures from STORAGE (not from calling context!)
            // Captures were stored when lambda was created, NOT when it's being called
            std::string lambda_name = callee->getName().str();

            // REPL MODE: Get capture names from registry instead of LLVM parameter names
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t i = 0; i < num_captures; i++) {
                std::string var_name;
                if (i < capture_names.size()) {
                    var_name = capture_names[i];
                } else if (arg_it != callee->arg_end()) {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    std::string param_name = arg_it->getName().str();
                    var_name = param_name;
                    if (param_name.find("captured_") == 0) {
                        var_name = param_name.substr(9);
                    }
                    arg_it++;
                }

                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try local symbol tables
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                capture_key
                            );
                        }
                        Value* captured_val = builder->CreateLoad(tagged_value_type, capture_global);
                        args.push_back(captured_val);
                        continue;
                    }
                }

                if (found && it->second) {
                    Value* storage = it->second;
                    Value* captured_val = builder->CreateLoad(tagged_value_type, storage);
                    args.push_back(captured_val);
                } else {
                    eshkol_error("Missing capture: %s", capture_key.c_str());
                    args.push_back(packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), 0), true));
                }
            }
        }

        // Dereference global variables before passing them
        for (size_t i = 0; i < args.size(); ++i) {
            if (args[i]->getType()->isPointerTy()) {
                Value *pointed_value = args[i];
                if (auto* global_value = dyn_cast<GlobalValue>(pointed_value)) {
                    if (global_value->getLinkage() == GlobalValue::ExternalLinkage ||
                        global_value->getLinkage() == GlobalValue::WeakAnyLinkage) {
                        args[i] = builder->CreateLoad(
                            global_value->getValueType(),
                            global_value
                        );
                    }
                } else if (auto* local_value = dyn_cast<AllocaInst>(pointed_value)) {
                    args[i] = builder->CreateLoad(
                        local_value->getAllocatedType(),
                        local_value
                    );
                }
            }
        }

        return builder->CreateCall(callee, args);
    }
    
    Value* codegenArithmetic(const eshkol_operations_t* op, const std::string& operation) {
        if (op->call_op.num_vars < 2) {
            eshkol_warn("Arithmetic operation requires at least 2 arguments");
            return nullptr;
        }
        
        // Convert all operands to tagged_value
        std::vector<Value*> tagged_operands;
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[i]);
            if (!tv.llvm_value) continue;
            Value* tagged = typedValueToTaggedValue(tv);
            tagged_operands.push_back(tagged);
        }
        
        if (tagged_operands.empty()) return nullptr;
        
        // Apply polymorphic operation to operands (binary reduction for now)
        Value* result = tagged_operands[0];
        for (size_t i = 1; i < tagged_operands.size(); i++) {
            if (operation == "add") {
                result = polymorphicAdd(result, tagged_operands[i]);
            } else if (operation == "sub") {
                result = polymorphicSub(result, tagged_operands[i]);
            } else if (operation == "mul") {
                result = polymorphicMul(result, tagged_operands[i]);
            } else if (operation == "div") {
                result = polymorphicDiv(result, tagged_operands[i]);
            }
        }
        
        // Phase 3B: Keep result as tagged_value to preserve type information!
        // Don't unpack - variables will store tagged_value directly
        return result;
    }

    Value* codegenComparison(const eshkol_operations_t* op, const std::string& operation) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("Comparison operation requires exactly 2 arguments");
            return nullptr;
        }
        
        // Generate operands with type information
        TypedValue left_tv = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue right_tv = codegenTypedAST(&op->call_op.variables[1]);
        
        if (!left_tv.llvm_value || !right_tv.llvm_value) return nullptr;
        
        // Convert to tagged_value for runtime polymorphism
        Value* left_tagged = typedValueToTaggedValue(left_tv);
        Value* right_tagged = typedValueToTaggedValue(right_tv);
        
        // Call polymorphic comparison that handles runtime type detection
        return polymorphicCompare(left_tagged, right_tagged, operation);
    }
    
    Value* codegenDisplay(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("display requires exactly 1 argument");
            return nullptr;
        }

        // OPTION 3: RUNTIME S-expression lookup using module->getNamedGlobal()
        // This works regardless of definition order since globals use ExternalLinkage
        if (op->call_op.variables[0].type == ESHKOL_VAR &&
            op->call_op.variables[0].variable.id) {
            std::string var_name = op->call_op.variables[0].variable.id;

            // SCOPED NAMES FIX: First try scoped name (enclosing_function.var_sexpr)
            // This avoids collisions when multiple functions have same-named let bindings
            GlobalVariable* sexpr_global = nullptr;
            std::string sexpr_key;

            // Try scoped name first (e.g., "test-jacobian-2d.F_sexpr")
            Function* enclosing_func = builder->GetInsertBlock()->getParent();
            if (enclosing_func) {
                std::string scoped_sexpr_key = enclosing_func->getName().str() + "." + var_name + "_sexpr";
                sexpr_global = module->getNamedGlobal(scoped_sexpr_key);
                if (sexpr_global) {
                    sexpr_key = scoped_sexpr_key;
                    eshkol_debug("[DISPLAY] Found scoped S-expression: %s", scoped_sexpr_key.c_str());
                }
            }

            // Fall back to unscoped name (e.g., "F_sexpr") for top-level defines
            if (!sexpr_global) {
                sexpr_key = var_name + "_sexpr";
                sexpr_global = module->getNamedGlobal(sexpr_key);
                if (sexpr_global) {
                    eshkol_debug("[DISPLAY] Found unscoped S-expression: %s", sexpr_key.c_str());
                }
            }

            if (sexpr_global) {
                // S-expression global exists - generate runtime load and display code
                Value* sexpr_list = builder->CreateLoad(Type::getInt64Ty(*context), sexpr_global);

                // Use displaySExprList to render
                Value* depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
                builder->CreateCall(display_sexpr_list_func, {sexpr_list, depth});

                return ConstantInt::get(Type::getInt32Ty(*context), 0);
            }
        }
        
        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;
        
        // For now, use printf to display strings and numbers
        Function* printf_func = function_table["printf"];
        if (!printf_func) return nullptr;
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Check if arg is a tagged value struct
        if (arg->getType() == tagged_value_type) {
            // Extract type field from tagged value
            Value* type_field = getTaggedValueType(arg);
            
            // CRITICAL FIX: Mask out flags to get base type (like car/cdr do)
            Value* base_type = builder->CreateAnd(type_field,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            // CRITICAL FIX: Check for TENSOR_PTR first!
            Value* is_tensor_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
            
            BasicBlock* tensor_ptr_display = BasicBlock::Create(*context, "display_tagged_tensor", current_func);
            BasicBlock* check_other_types = BasicBlock::Create(*context, "display_check_other", current_func);
            
            builder->CreateCondBr(is_tensor_ptr, tensor_ptr_display, check_other_types);
            
            // Display tensor from tagged_value with TENSOR_PTR type
            builder->SetInsertPoint(tensor_ptr_display);
            Value* tensor_ptr_int = unpackInt64FromTaggedValue(arg);
            Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
            
            // Print opening "#("
            builder->CreateCall(printf_func, {codegenString("#(")});
            
            // Get total elements
            Value* total_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
            Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), total_field);
            
            // Get elements array
            Value* elements_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
            Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
            Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
            
            // Loop through elements
            BasicBlock* tensor_tag_loop_cond = BasicBlock::Create(*context, "tensor_tag_loop_cond", current_func);
            BasicBlock* tensor_tag_loop_body = BasicBlock::Create(*context, "tensor_tag_loop_body", current_func);
            BasicBlock* tensor_tag_loop_exit = BasicBlock::Create(*context, "tensor_tag_loop_exit", current_func);
            BasicBlock* tensor_tag_done = BasicBlock::Create(*context, "tensor_tag_done", current_func);
            
            Value* tensor_tag_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "tensor_tag_idx");
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), tensor_tag_idx);
            builder->CreateBr(tensor_tag_loop_cond);
            
            builder->SetInsertPoint(tensor_tag_loop_cond);
            Value* tag_current_idx = builder->CreateLoad(Type::getInt64Ty(*context), tensor_tag_idx);
            Value* tag_idx_less = builder->CreateICmpULT(tag_current_idx, total_elements);
            builder->CreateCondBr(tag_idx_less, tensor_tag_loop_body, tensor_tag_loop_exit);
            
            builder->SetInsertPoint(tensor_tag_loop_body);
            
            // Add space before non-first elements
            Value* tag_is_first = builder->CreateICmpEQ(tag_current_idx, ConstantInt::get(Type::getInt64Ty(*context), 0));
            BasicBlock* tag_skip_space = BasicBlock::Create(*context, "tag_skip_space", current_func);
            BasicBlock* tag_add_space = BasicBlock::Create(*context, "tag_add_space", current_func);
            BasicBlock* tag_print_elem = BasicBlock::Create(*context, "tag_print_elem", current_func);
            
            builder->CreateCondBr(tag_is_first, tag_skip_space, tag_add_space);
            
            builder->SetInsertPoint(tag_add_space);
            builder->CreateCall(printf_func, {codegenString(" ")});
            builder->CreateBr(tag_print_elem);
            
            builder->SetInsertPoint(tag_skip_space);
            builder->CreateBr(tag_print_elem);
            
            builder->SetInsertPoint(tag_print_elem);
            
            // JACOBIAN FIX: Load element and detect type (int, double, or CONS_PTR for nested lists)
            Value* tag_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, tag_current_idx);
            Value* tag_elem_int64 = builder->CreateLoad(Type::getInt64Ty(*context), tag_elem_ptr);
            
            Value* tag_is_small = builder->CreateICmpULT(tag_elem_int64,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            Value* tag_exp_mask = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
            Value* tag_exp_bits = builder->CreateAnd(tag_elem_int64, tag_exp_mask);
            Value* tag_has_exp = builder->CreateICmpNE(tag_exp_bits,
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* tag_likely_double = builder->CreateAnd(tag_has_exp, builder->CreateNot(tag_is_small));
            
            // JACOBIAN FIX: Check if it's a large pointer (CONS_PTR for nested list)
            Value* tag_is_large_ptr = builder->CreateICmpUGT(tag_elem_int64,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            Value* tag_not_double = builder->CreateNot(tag_has_exp);
            Value* tag_is_cons_ptr = builder->CreateAnd(tag_is_large_ptr, tag_not_double);
            
            BasicBlock* tag_elem_double = BasicBlock::Create(*context, "tag_elem_double", current_func);
            BasicBlock* tag_elem_check_ptr = BasicBlock::Create(*context, "tag_elem_check_ptr", current_func);
            BasicBlock* tag_elem_list = BasicBlock::Create(*context, "tag_elem_list", current_func);
            BasicBlock* tag_elem_int = BasicBlock::Create(*context, "tag_elem_int", current_func);
            BasicBlock* tag_elem_done = BasicBlock::Create(*context, "tag_elem_done", current_func);
            
            builder->CreateCondBr(tag_likely_double, tag_elem_double, tag_elem_check_ptr);
            
            builder->SetInsertPoint(tag_elem_double);
            Value* tag_as_double = builder->CreateBitCast(tag_elem_int64, Type::getDoubleTy(*context));
            builder->CreateCall(printf_func, {codegenString("%g"), tag_as_double});
            builder->CreateBr(tag_elem_done);
            
            // JACOBIAN FIX: Check if element is CONS_PTR (nested list from Jacobian)
            builder->SetInsertPoint(tag_elem_check_ptr);
            builder->CreateCondBr(tag_is_cons_ptr, tag_elem_list, tag_elem_int);
            
            // JACOBIAN FIX: Display nested list recursively
            builder->SetInsertPoint(tag_elem_list);
            Value* tag_list_depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
            builder->CreateCall(display_sexpr_list_func, {tag_elem_int64, tag_list_depth});
            builder->CreateBr(tag_elem_done);
            
            builder->SetInsertPoint(tag_elem_int);
            builder->CreateCall(printf_func, {codegenString("%lld"), tag_elem_int64});
            builder->CreateBr(tag_elem_done);
            
            builder->SetInsertPoint(tag_elem_done);
            Value* tag_next_idx = builder->CreateAdd(tag_current_idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
            builder->CreateStore(tag_next_idx, tensor_tag_idx);
            builder->CreateBr(tensor_tag_loop_cond);
            
            builder->SetInsertPoint(tensor_tag_loop_exit);
            builder->CreateCall(printf_func, {codegenString(")")});
            builder->CreateBr(tensor_tag_done);
            
            builder->SetInsertPoint(check_other_types);

            // Branch based on base type (without flags)
            // SYMBOLIC DIFF FIX: Check for CONS_PTR (S-expressions) FIRST!
            Value* is_cons_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            Value* is_int = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            Value* is_string = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
            Value* is_vector = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
            Value* is_lambda_sexpr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_LAMBDA_SEXPR));

            BasicBlock* cons_ptr_display = BasicBlock::Create(*context, "display_cons_ptr", current_func);
            BasicBlock* lambda_sexpr_display = BasicBlock::Create(*context, "display_lambda_sexpr", current_func);
            BasicBlock* int_display = BasicBlock::Create(*context, "display_int", current_func);
            BasicBlock* double_display = BasicBlock::Create(*context, "display_double", current_func);
            BasicBlock* string_display = BasicBlock::Create(*context, "display_string", current_func);
            BasicBlock* vector_display = BasicBlock::Create(*context, "display_vector", current_func);
            BasicBlock* ptr_display = BasicBlock::Create(*context, "display_ptr", current_func);

            BasicBlock* check_lambda = BasicBlock::Create(*context, "check_lambda", current_func);
            BasicBlock* check_int = BasicBlock::Create(*context, "check_int", current_func);
            BasicBlock* check_double = BasicBlock::Create(*context, "check_double", current_func);
            BasicBlock* check_string = BasicBlock::Create(*context, "check_string", current_func);
            BasicBlock* check_vector = BasicBlock::Create(*context, "check_vector", current_func);

            builder->CreateCondBr(is_cons_ptr, cons_ptr_display, check_lambda);

            // HOMOICONIC FIX: Handle LAMBDA_SEXPR type - display the S-expression
            builder->SetInsertPoint(check_lambda);
            builder->CreateCondBr(is_lambda_sexpr, lambda_sexpr_display, check_int);

            builder->SetInsertPoint(lambda_sexpr_display);
            // Lambda S-expression pointer - display using displaySExprList
            Value* lambda_sexpr_ptr = unpackInt64FromTaggedValue(arg);
            Value* lambda_depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
            builder->CreateCall(display_sexpr_list_func, {lambda_sexpr_ptr, lambda_depth});
            builder->CreateBr(tensor_tag_done);  // Use tensor_tag_done as exit point
            
            // Display CONS_PTR as list (S-expressions from symbolic diff!)
            builder->SetInsertPoint(cons_ptr_display);
            Value* list_ptr_int = unpackInt64FromTaggedValue(arg);
            
            // Full S-expression display with proper list traversal
            builder->CreateCall(printf_func, {codegenString("(")});
            
            Value* sexpr_current = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "sexpr_current");
            Value* sexpr_first = builder->CreateAlloca(Type::getInt1Ty(*context), nullptr, "sexpr_first");
            builder->CreateStore(list_ptr_int, sexpr_current);
            builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), sexpr_first);
            
            BasicBlock* sexpr_loop_cond = BasicBlock::Create(*context, "sexpr_loop_cond", current_func);
            BasicBlock* sexpr_loop_body = BasicBlock::Create(*context, "sexpr_loop_body", current_func);
            BasicBlock* sexpr_loop_exit = BasicBlock::Create(*context, "sexpr_loop_exit", current_func);
            
            builder->CreateBr(sexpr_loop_cond);
            
            builder->SetInsertPoint(sexpr_loop_cond);
            Value* sexpr_val = builder->CreateLoad(Type::getInt64Ty(*context), sexpr_current);
            Value* sexpr_not_null = builder->CreateICmpNE(sexpr_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
            builder->CreateCondBr(sexpr_not_null, sexpr_loop_body, sexpr_loop_exit);
            
            builder->SetInsertPoint(sexpr_loop_body);
            
            // Add space before non-first elements
            Value* sexpr_first_flag = builder->CreateLoad(Type::getInt1Ty(*context), sexpr_first);
            BasicBlock* sexpr_skip_space = BasicBlock::Create(*context, "sexpr_skip_space", current_func);
            BasicBlock* sexpr_add_space = BasicBlock::Create(*context, "sexpr_add_space", current_func);
            BasicBlock* sexpr_display_elem = BasicBlock::Create(*context, "sexpr_display_elem", current_func);
            
            builder->CreateCondBr(sexpr_first_flag, sexpr_skip_space, sexpr_add_space);
            
            builder->SetInsertPoint(sexpr_add_space);
            builder->CreateCall(printf_func, {codegenString(" ")});
            builder->CreateBr(sexpr_display_elem);
            
            builder->SetInsertPoint(sexpr_skip_space);
            builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), sexpr_first);
            builder->CreateBr(sexpr_display_elem);
            
            // Display element
            builder->SetInsertPoint(sexpr_display_elem);
            Value* sexpr_car_tagged = extractCarAsTaggedValue(sexpr_val);
            Value* sexpr_car_type = getTaggedValueType(sexpr_car_tagged);
            Value* sexpr_car_base = builder->CreateAnd(sexpr_car_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            Value* sexpr_car_is_ptr = builder->CreateICmpEQ(sexpr_car_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            Value* sexpr_car_is_double = builder->CreateICmpEQ(sexpr_car_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            // HOMOICONIC FIX: Check for STRING_PTR type (symbols like 'x' in (diff (* x x) x))
            Value* sexpr_car_is_string_ptr = builder->CreateICmpEQ(sexpr_car_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));
            // HOMOICONIC FIX: Check for LAMBDA_SEXPR type (lambdas in lists)
            Value* sexpr_car_is_lambda = builder->CreateICmpEQ(sexpr_car_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_LAMBDA_SEXPR));

            // CRITICAL: Declare ALL BasicBlocks BEFORE using them
            BasicBlock* sexpr_check_lambda = BasicBlock::Create(*context, "sexpr_check_lambda", current_func);
            BasicBlock* sexpr_display_lambda = BasicBlock::Create(*context, "sexpr_display_lambda", current_func);
            BasicBlock* sexpr_check_string_ptr = BasicBlock::Create(*context, "sexpr_check_string_ptr", current_func);
            BasicBlock* sexpr_check_string = BasicBlock::Create(*context, "sexpr_check_string", current_func);
            BasicBlock* sexpr_check_double = BasicBlock::Create(*context, "sexpr_check_double", current_func);
            BasicBlock* sexpr_display_symbol = BasicBlock::Create(*context, "sexpr_display_symbol", current_func);
            BasicBlock* sexpr_display_string = BasicBlock::Create(*context, "sexpr_display_string", current_func);
            BasicBlock* sexpr_display_nested = BasicBlock::Create(*context, "sexpr_display_nested", current_func);
            BasicBlock* sexpr_display_double = BasicBlock::Create(*context, "sexpr_display_double", current_func);
            BasicBlock* sexpr_display_int = BasicBlock::Create(*context, "sexpr_display_int", current_func);
            BasicBlock* sexpr_elem_done = BasicBlock::Create(*context, "sexpr_elem_done", current_func);

            // First check for STRING_PTR (symbols), then LAMBDA_SEXPR, then CONS_PTR, then others
            builder->CreateCondBr(sexpr_car_is_string_ptr, sexpr_display_symbol, sexpr_check_lambda);

            // Check for LAMBDA_SEXPR (lambdas stored in lists)
            builder->SetInsertPoint(sexpr_check_lambda);
            builder->CreateCondBr(sexpr_car_is_lambda, sexpr_display_lambda, sexpr_check_string_ptr);

            // Handle LAMBDA_SEXPR: check flags to determine if indirect or direct
            builder->SetInsertPoint(sexpr_display_lambda);
            Value* lambda_flags = getTaggedValueFlags(sexpr_car_tagged);

            // DEBUG: Print flags value
            Function* printf_func2 = module->getFunction("printf");
            if (!printf_func2) {
                FunctionType* printf_type = FunctionType::get(
                    Type::getInt32Ty(*context),
                    {PointerType::getUnqual(*context)},
                    true);
                printf_func2 = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
            }
            Value* fmt_flags = builder->CreateGlobalStringPtr("[DISPLAY-LAMBDA] flags=%d\n");
            Value* flags_ext = builder->CreateZExt(lambda_flags, Type::getInt32Ty(*context));
            builder->CreateCall(printf_func2, {fmt_flags, flags_ext});

            Value* is_indirect = builder->CreateICmpNE(
                builder->CreateAnd(lambda_flags, ConstantInt::get(Type::getInt8Ty(*context), TypedValue::FLAG_INDIRECT)),
                ConstantInt::get(Type::getInt8Ty(*context), 0));

            // DEBUG: Print is_indirect result
            Value* fmt_isindir = builder->CreateGlobalStringPtr("[DISPLAY-LAMBDA] is_indirect=%d\n");
            Value* is_indirect_ext = builder->CreateZExt(is_indirect, Type::getInt32Ty(*context));
            builder->CreateCall(printf_func2, {fmt_isindir, is_indirect_ext});

            BasicBlock* lambda_indirect = BasicBlock::Create(*context, "lambda_indirect", current_func);
            BasicBlock* lambda_direct = BasicBlock::Create(*context, "lambda_direct", current_func);
            builder->CreateCondBr(is_indirect, lambda_indirect, lambda_direct);

            // Indirect case: load S-expression pointer from global address
            builder->SetInsertPoint(lambda_indirect);
            Value* global_addr_int = unpackInt64FromTaggedValue(sexpr_car_tagged);

            // DEBUG: Print global address being loaded from
            Function* printf_func = module->getFunction("printf");
            if (!printf_func) {
                FunctionType* printf_type = FunctionType::get(
                    Type::getInt32Ty(*context),
                    {PointerType::getUnqual(*context)},
                    true);
                printf_func = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
            }
            Value* fmt1 = builder->CreateGlobalStringPtr("[DISPLAY-INDIRECT] Loading from global addr: %lld\n");
            builder->CreateCall(printf_func, {fmt1, global_addr_int});

            Value* global_ptr = builder->CreateIntToPtr(global_addr_int, builder->getPtrTy());
            Value* indirect_sexpr_ptr = builder->CreateLoad(Type::getInt64Ty(*context), global_ptr);

            // DEBUG: Print S-expression pointer that was loaded
            Value* fmt2 = builder->CreateGlobalStringPtr("[DISPLAY-INDIRECT] Loaded sexpr ptr: %lld\n");
            builder->CreateCall(printf_func, {fmt2, indirect_sexpr_ptr});

            Value* indirect_depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
            builder->CreateCall(display_sexpr_list_func, {indirect_sexpr_ptr, indirect_depth});
            builder->CreateBr(sexpr_elem_done);

            // Direct case: use value directly as S-expression pointer
            builder->SetInsertPoint(lambda_direct);
            Value* direct_sexpr_ptr = unpackInt64FromTaggedValue(sexpr_car_tagged);
            Value* direct_depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
            builder->CreateCall(display_sexpr_list_func, {direct_sexpr_ptr, direct_depth});
            builder->CreateBr(sexpr_elem_done);

            // Handle STRING_PTR: display as symbol (e.g., "x")
            builder->SetInsertPoint(sexpr_display_symbol);
            Value* symbol_ptr_int = unpackInt64FromTaggedValue(sexpr_car_tagged);
            Value* symbol_ptr = builder->CreateIntToPtr(symbol_ptr_int, builder->getPtrTy());
            builder->CreateCall(printf_func, {codegenString("%s"), symbol_ptr});
            builder->CreateBr(sexpr_elem_done);

            // Check for CONS_PTR next
            builder->SetInsertPoint(sexpr_check_string_ptr);
            builder->CreateCondBr(sexpr_car_is_ptr, sexpr_check_string, sexpr_check_double);
            
            // Check if CONS_PTR is string or nested list
            builder->SetInsertPoint(sexpr_check_string);
            Value* sexpr_car_ptr_int = unpackInt64FromTaggedValue(sexpr_car_tagged);
            Value* sexpr_car_ptr = builder->CreateIntToPtr(sexpr_car_ptr_int, builder->getPtrTy());
            
            // CRITICAL: String pointers from codegenString() point to GlobalVariable arrays
            // Need to check a reasonable address range AND first byte
            Value* ptr_is_reasonable = builder->CreateICmpUGT(sexpr_car_ptr_int,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            Value* ptr_is_not_huge = builder->CreateICmpULT(sexpr_car_ptr_int,
                ConstantInt::get(Type::getInt64Ty(*context), 0x7FFFFFFFFFFFFFFFULL));
            Value* ptr_in_range = builder->CreateAnd(ptr_is_reasonable, ptr_is_not_huge);
            
            BasicBlock* check_ascii = BasicBlock::Create(*context, "sexpr_check_ascii", current_func);
            
            // If pointer not in reasonable range, treat as nested list
            builder->CreateCondBr(ptr_in_range, check_ascii, sexpr_display_nested);
            
            builder->SetInsertPoint(check_ascii);
            Value* sexpr_first_byte = builder->CreateLoad(Type::getInt8Ty(*context), sexpr_car_ptr);
            Value* sexpr_is_printable = builder->CreateAnd(
                builder->CreateICmpUGE(sexpr_first_byte, ConstantInt::get(Type::getInt8Ty(*context), 32)),
                builder->CreateICmpULE(sexpr_first_byte, ConstantInt::get(Type::getInt8Ty(*context), 126)));
            
            builder->CreateCondBr(sexpr_is_printable, sexpr_display_string, sexpr_display_nested);
            
            builder->SetInsertPoint(sexpr_display_string);
            builder->CreateCall(printf_func, {codegenString("%s"), sexpr_car_ptr});
            builder->CreateBr(sexpr_elem_done);
            
            builder->SetInsertPoint(sexpr_display_nested);
            // Nested list - display using N-depth recursive helper function
            Value* initial_depth = ConstantInt::get(Type::getInt32Ty(*context), 1);
            builder->CreateCall(display_sexpr_list_func, {sexpr_car_ptr_int, initial_depth});
            builder->CreateBr(sexpr_elem_done);
            
            builder->SetInsertPoint(sexpr_check_double);
            builder->CreateCondBr(sexpr_car_is_double, sexpr_display_double, sexpr_display_int);
            
            builder->SetInsertPoint(sexpr_display_double);
            Value* sexpr_car_double = unpackDoubleFromTaggedValue(sexpr_car_tagged);
            builder->CreateCall(printf_func, {codegenString("%g"), sexpr_car_double});
            builder->CreateBr(sexpr_elem_done);
            
            builder->SetInsertPoint(sexpr_display_int);
            Value* sexpr_car_int = unpackInt64FromTaggedValue(sexpr_car_tagged);
            builder->CreateCall(printf_func, {codegenString("%lld"), sexpr_car_int});
            builder->CreateBr(sexpr_elem_done);
            
            // Move to next element
            builder->SetInsertPoint(sexpr_elem_done);
            Value* sexpr_cons_ptr = builder->CreateIntToPtr(sexpr_val, builder->getPtrTy());
            Value* sexpr_is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
            Value* sexpr_cdr_type = builder->CreateCall(arena_tagged_cons_get_type_func, {sexpr_cons_ptr, sexpr_is_cdr});
            Value* sexpr_cdr_base = builder->CreateAnd(sexpr_cdr_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            Value* sexpr_cdr_is_ptr = builder->CreateICmpEQ(sexpr_cdr_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            Value* sexpr_cdr_is_null = builder->CreateICmpEQ(sexpr_cdr_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
            Value* sexpr_cdr_is_double = builder->CreateICmpEQ(sexpr_cdr_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

            BasicBlock* sexpr_cdr_ptr = BasicBlock::Create(*context, "sexpr_cdr_ptr", current_func);
            BasicBlock* sexpr_cdr_check_null = BasicBlock::Create(*context, "sexpr_cdr_check_null", current_func);
            BasicBlock* sexpr_cdr_scalar = BasicBlock::Create(*context, "sexpr_cdr_scalar", current_func);
            BasicBlock* sexpr_cdr_double_val = BasicBlock::Create(*context, "sexpr_cdr_double_val", current_func);
            BasicBlock* sexpr_cdr_int_val = BasicBlock::Create(*context, "sexpr_cdr_int_val", current_func);

            builder->CreateCondBr(sexpr_cdr_is_ptr, sexpr_cdr_ptr, sexpr_cdr_check_null);

            builder->SetInsertPoint(sexpr_cdr_ptr);
            Value* sexpr_next = builder->CreateCall(arena_tagged_cons_get_ptr_func, {sexpr_cons_ptr, sexpr_is_cdr});
            builder->CreateStore(sexpr_next, sexpr_current);
            builder->CreateBr(sexpr_loop_cond);

            builder->SetInsertPoint(sexpr_cdr_check_null);
            builder->CreateCondBr(sexpr_cdr_is_null, sexpr_loop_exit, sexpr_cdr_scalar);

            // Handle dotted pair: cdr is a scalar value (not list, not null)
            builder->SetInsertPoint(sexpr_cdr_scalar);
            builder->CreateCall(printf_func, {codegenString(" . ")});
            builder->CreateCondBr(sexpr_cdr_is_double, sexpr_cdr_double_val, sexpr_cdr_int_val);

            builder->SetInsertPoint(sexpr_cdr_double_val);
            Value* sexpr_cdr_double = builder->CreateCall(arena_tagged_cons_get_double_func, {sexpr_cons_ptr, sexpr_is_cdr});
            builder->CreateCall(printf_func, {codegenString("%g"), sexpr_cdr_double});
            builder->CreateBr(sexpr_loop_exit);

            builder->SetInsertPoint(sexpr_cdr_int_val);
            Value* sexpr_cdr_int = builder->CreateCall(arena_tagged_cons_get_int64_func, {sexpr_cons_ptr, sexpr_is_cdr});
            builder->CreateCall(printf_func, {codegenString("%lld"), sexpr_cdr_int});
            builder->CreateBr(sexpr_loop_exit);

            builder->SetInsertPoint(sexpr_loop_exit);
            builder->CreateCall(printf_func, {codegenString(")")});
            builder->CreateBr(tensor_tag_done);
            
            builder->SetInsertPoint(check_int);
            builder->CreateCondBr(is_int, int_display, check_double);
            
            builder->SetInsertPoint(check_double);
            builder->CreateCondBr(is_double, double_display, check_string);

            builder->SetInsertPoint(check_string);
            builder->CreateCondBr(is_string, string_display, check_vector);

            builder->SetInsertPoint(check_vector);
            builder->CreateCondBr(is_vector, vector_display, ptr_display);

            // Display int64
            builder->SetInsertPoint(int_display);
            Value* int_val = unpackInt64FromTaggedValue(arg);
            builder->CreateCall(printf_func, {codegenString("%lld"), int_val});
            builder->CreateBr(tensor_tag_done);

            // Display double
            builder->SetInsertPoint(double_display);
            Value* double_val = unpackDoubleFromTaggedValue(arg);
            builder->CreateCall(printf_func, {codegenString("%f"), double_val});
            builder->CreateBr(tensor_tag_done);

            // Display string
            builder->SetInsertPoint(string_display);
            Value* str_ptr_int = unpackInt64FromTaggedValue(arg);
            Value* str_ptr = builder->CreateIntToPtr(str_ptr_int, builder->getPtrTy());
            builder->CreateCall(printf_func, {codegenString("%s"), str_ptr});
            builder->CreateBr(tensor_tag_done);

            // Display vector (Scheme vector with tagged elements)
            builder->SetInsertPoint(vector_display);
            {
                Value* vec_ptr_int = unpackInt64FromTaggedValue(arg);
                Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

                // Read vector length (first i64 at vec_ptr)
                Value* vec_len = builder->CreateLoad(Type::getInt64Ty(*context), vec_ptr);

                // Print opening #(
                builder->CreateCall(printf_func, {codegenString("#(")});

                // Loop through elements
                BasicBlock* vec_loop_cond = BasicBlock::Create(*context, "vec_loop_cond", current_func);
                BasicBlock* vec_loop_body = BasicBlock::Create(*context, "vec_loop_body", current_func);
                BasicBlock* vec_loop_exit = BasicBlock::Create(*context, "vec_loop_exit", current_func);

                Value* vec_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "vec_idx");
                builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), vec_idx);
                builder->CreateBr(vec_loop_cond);

                builder->SetInsertPoint(vec_loop_cond);
                Value* vec_i = builder->CreateLoad(Type::getInt64Ty(*context), vec_idx);
                Value* vec_cond = builder->CreateICmpULT(vec_i, vec_len);
                builder->CreateCondBr(vec_cond, vec_loop_body, vec_loop_exit);

                builder->SetInsertPoint(vec_loop_body);
                // Add space between elements (not before first)
                Value* vec_not_first = builder->CreateICmpNE(vec_i, ConstantInt::get(Type::getInt64Ty(*context), 0));
                BasicBlock* vec_add_space = BasicBlock::Create(*context, "vec_add_space", current_func);
                BasicBlock* vec_print_elem = BasicBlock::Create(*context, "vec_print_elem", current_func);
                builder->CreateCondBr(vec_not_first, vec_add_space, vec_print_elem);

                builder->SetInsertPoint(vec_add_space);
                builder->CreateCall(printf_func, {codegenString(" ")});
                builder->CreateBr(vec_print_elem);

                builder->SetInsertPoint(vec_print_elem);
                // Element base is vec_ptr + 8 bytes (skip length)
                Value* elem_base = builder->CreateGEP(Type::getInt8Ty(*context), vec_ptr,
                    ConstantInt::get(Type::getInt64Ty(*context), 8));
                // Each element is sizeof(tagged_value_type)
                Value* elem_offset = builder->CreateMul(vec_i,
                    ConstantInt::get(Type::getInt64Ty(*context), module->getDataLayout().getTypeAllocSize(tagged_value_type)));
                Value* elem_ptr = builder->CreateGEP(Type::getInt8Ty(*context), elem_base, elem_offset);
                Value* elem = builder->CreateLoad(tagged_value_type, elem_ptr);

                // Get element type and print accordingly
                Value* elem_type = getTaggedValueType(elem);
                Value* elem_base_type = builder->CreateAnd(elem_type,
                    ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
                Value* elem_is_double = builder->CreateICmpEQ(elem_base_type,
                    ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

                BasicBlock* print_double = BasicBlock::Create(*context, "vec_print_double", current_func);
                BasicBlock* print_int = BasicBlock::Create(*context, "vec_print_int", current_func);
                BasicBlock* vec_loop_next = BasicBlock::Create(*context, "vec_loop_next", current_func);

                builder->CreateCondBr(elem_is_double, print_double, print_int);

                builder->SetInsertPoint(print_double);
                Value* elem_dbl = unpackDoubleFromTaggedValue(elem);
                builder->CreateCall(printf_func, {codegenString("%g"), elem_dbl});
                builder->CreateBr(vec_loop_next);

                builder->SetInsertPoint(print_int);
                Value* elem_int = unpackInt64FromTaggedValue(elem);
                builder->CreateCall(printf_func, {codegenString("%lld"), elem_int});
                builder->CreateBr(vec_loop_next);

                builder->SetInsertPoint(vec_loop_next);
                Value* vec_next_i = builder->CreateAdd(vec_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
                builder->CreateStore(vec_next_i, vec_idx);
                builder->CreateBr(vec_loop_cond);

                builder->SetInsertPoint(vec_loop_exit);
                builder->CreateCall(printf_func, {codegenString(")")});
            }
            builder->CreateBr(tensor_tag_done);

            // Display pointer (as int64 for now)
            builder->SetInsertPoint(ptr_display);
            Value* ptr_val = unpackPtrFromTaggedValue(arg);
            Value* ptr_as_int = builder->CreatePtrToInt(ptr_val, Type::getInt64Ty(*context));
            builder->CreateCall(printf_func, {codegenString("%lld"), ptr_as_int});
            builder->CreateBr(tensor_tag_done);
            
            builder->SetInsertPoint(tensor_tag_done);
            return ConstantInt::get(Type::getInt32Ty(*context), 0);
        }
        
        // Handle int64 values that might be tensor/list pointers (also handle tagged_value)
        Value* arg_int = safeExtractInt64(arg);
        
        if (arg->getType()->isIntegerTy(64) || arg->getType() == tagged_value_type) {
            // Create all BasicBlocks first
            BasicBlock* check_type = BasicBlock::Create(*context, "display_check_type", current_func);
            BasicBlock* display_tensor = BasicBlock::Create(*context, "display_tensor", current_func);
            BasicBlock* display_list = BasicBlock::Create(*context, "display_list", current_func);
            BasicBlock* display_int = BasicBlock::Create(*context, "display_int_value", current_func);
            BasicBlock* display_done = BasicBlock::Create(*context, "display_complete", current_func);
            
            // CRITICAL FIX: If arg is tagged_value with TENSOR_PTR type, handle specially
            // This prevents calling cons cell functions on tensor pointers (which causes type=32 errors)
            if (arg->getType() == tagged_value_type) {
                Value* arg_type = getTaggedValueType(arg);
                Value* arg_base_type = builder->CreateAnd(arg_type,
                    ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
                
                Value* is_tensor_ptr = builder->CreateICmpEQ(arg_base_type,
                    ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
                
                BasicBlock* tensor_ptr_check = BasicBlock::Create(*context, "display_tensor_ptr_check", current_func);
                BasicBlock* continue_normal = BasicBlock::Create(*context, "display_continue_normal", current_func);
                
                builder->CreateCondBr(is_tensor_ptr, tensor_ptr_check, continue_normal);
                
                // Tensor pointer path: go directly to tensor display
                builder->SetInsertPoint(tensor_ptr_check);
                builder->CreateBr(display_tensor);
                
                // Continue with normal display logic
                builder->SetInsertPoint(continue_normal);
            }
            
            // Check if this is a valid pointer (> 1000)
            Value* is_large_enough = builder->CreateICmpUGT(arg_int,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            
            builder->CreateCondBr(is_large_enough, check_type, display_int);
            
            // SAFE DETECTION: Try as cons cell FIRST using arena functions
            builder->SetInsertPoint(check_type);
            
            // Try to read type tag using arena_tagged_cons_get_type_func
            // This is safe because it uses the actual cons cell access functions
            Value* cons_check_ptr = builder->CreateIntToPtr(arg_int, builder->getPtrTy());
            Value* is_car_check = ConstantInt::get(Type::getInt1Ty(*context), 0);
            Value* car_type_tag = builder->CreateCall(arena_tagged_cons_get_type_func,
                {cons_check_ptr, is_car_check});
            
            // Valid type tags are 0-6 (NULL, INT64, DOUBLE, CONS_PTR, DUAL_NUMBER, AD_NODE_PTR, TENSOR_PTR)
            // Mask to get base type (remove flags)
            Value* type_base = builder->CreateAnd(car_type_tag,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            Value* type_in_range = builder->CreateICmpULE(type_base,
                ConstantInt::get(Type::getInt8Ty(*context), 6));
            
            // If valid cons cell type, display as list
            BasicBlock* try_tensor_check = BasicBlock::Create(*context, "display_try_tensor", current_func);
            builder->CreateCondBr(type_in_range, display_list, try_tensor_check);
            
            // Only try tensor if NOT a valid cons cell
            builder->SetInsertPoint(try_tensor_check);
            
            // Use class member tensor_type (shared by all tensor operations)
            
            // Add safety: check alignment (tensors are 8-byte aligned from malloc)
            Value* is_aligned = builder->CreateICmpEQ(
                builder->CreateAnd(arg_int, ConstantInt::get(Type::getInt64Ty(*context), 7)),
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            
            BasicBlock* check_tensor_dims = BasicBlock::Create(*context, "check_tensor_dims", current_func);
            builder->CreateCondBr(is_aligned, check_tensor_dims, display_int);
            
            // Try reading num_dimensions with validation
            builder->SetInsertPoint(check_tensor_dims);
            Value* potential_tensor_ptr = builder->CreateIntToPtr(arg_int, builder->getPtrTy());
            Value* num_dims_field = builder->CreateStructGEP(tensor_type, potential_tensor_ptr, 1);
            Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), num_dims_field);
            
            // Tensors have reasonable num_dimensions (1-10)
            Value* dims_ge_1 = builder->CreateICmpUGE(num_dims, ConstantInt::get(Type::getInt64Ty(*context), 1));
            Value* dims_le_10 = builder->CreateICmpULE(num_dims, ConstantInt::get(Type::getInt64Ty(*context), 10));
            Value* is_likely_tensor = builder->CreateAnd(dims_ge_1, dims_le_10);
            
            builder->CreateCondBr(is_likely_tensor, display_tensor, display_int);
            
            // Display tensor as #(e1 e2 e3 ...)
            builder->SetInsertPoint(display_tensor);
            
            // Print opening "#("
            builder->CreateCall(printf_func, {codegenString("#(")});
            
            // Get total elements
            Value* total_field = builder->CreateStructGEP(tensor_type, potential_tensor_ptr, 3);
            Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), total_field);
            
            // Get elements array
            Value* elements_field = builder->CreateStructGEP(tensor_type, potential_tensor_ptr, 2);
            Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
            Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
            
            // Loop through elements
            Value* tensor_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "tensor_display_idx");
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), tensor_idx);
            
            BasicBlock* tensor_loop_cond = BasicBlock::Create(*context, "tensor_loop_cond", current_func);
            BasicBlock* tensor_loop_body = BasicBlock::Create(*context, "tensor_loop_body", current_func);
            BasicBlock* tensor_loop_exit = BasicBlock::Create(*context, "tensor_loop_exit", current_func);
            
            builder->CreateBr(tensor_loop_cond);
            
            builder->SetInsertPoint(tensor_loop_cond);
            Value* current_idx = builder->CreateLoad(Type::getInt64Ty(*context), tensor_idx);
            Value* idx_less = builder->CreateICmpULT(current_idx, total_elements);
            builder->CreateCondBr(idx_less, tensor_loop_body, tensor_loop_exit);
            
            builder->SetInsertPoint(tensor_loop_body);
            
            // Add space before non-first elements
            Value* is_first_elem = builder->CreateICmpEQ(current_idx, ConstantInt::get(Type::getInt64Ty(*context), 0));
            BasicBlock* skip_space_tensor = BasicBlock::Create(*context, "skip_space_tensor", current_func);
            BasicBlock* add_space_tensor = BasicBlock::Create(*context, "add_space_tensor", current_func);
            BasicBlock* print_elem = BasicBlock::Create(*context, "print_tensor_elem", current_func);
            
            builder->CreateCondBr(is_first_elem, skip_space_tensor, add_space_tensor);
            
            builder->SetInsertPoint(add_space_tensor);
            builder->CreateCall(printf_func, {codegenString(" ")});
            builder->CreateBr(print_elem);
            
            builder->SetInsertPoint(skip_space_tensor);
            builder->CreateBr(print_elem);
            
            builder->SetInsertPoint(print_elem);
            
            // Load element as int64
            Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, current_idx);
            Value* elem_int64 = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
            
            // JACOBIAN FIX: Detect element type (int, double, or CONS_PTR for nested lists)
            // This allows tensors containing list pointers to display nested structure
            
            // Case 1: Small values (< 1000) are plain integers
            Value* tensor_elem_is_small = builder->CreateICmpULT(elem_int64,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            
            // Case 2: Check IEEE 754 exponent bits for doubles
            Value* tensor_elem_exp_mask = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
            Value* tensor_elem_exp_bits = builder->CreateAnd(elem_int64, tensor_elem_exp_mask);
            Value* tensor_elem_has_exp = builder->CreateICmpNE(tensor_elem_exp_bits,
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            
            // Case 3: Check if it's a large pointer value (potential CONS_PTR)
            Value* tensor_elem_is_large_ptr = builder->CreateICmpUGT(elem_int64,
                ConstantInt::get(Type::getInt64Ty(*context), 1000));
            Value* tensor_elem_not_double = builder->CreateNot(tensor_elem_has_exp);
            Value* tensor_elem_is_cons_ptr = builder->CreateAnd(tensor_elem_is_large_ptr, tensor_elem_not_double);
            
            BasicBlock* tensor_elem_int = BasicBlock::Create(*context, "tensor_elem_int", current_func);
            BasicBlock* tensor_elem_check_double = BasicBlock::Create(*context, "tensor_elem_check_double", current_func);
            BasicBlock* tensor_elem_check_ptr = BasicBlock::Create(*context, "tensor_elem_check_ptr", current_func);
            BasicBlock* tensor_elem_double = BasicBlock::Create(*context, "tensor_elem_double", current_func);
            BasicBlock* tensor_elem_list = BasicBlock::Create(*context, "tensor_elem_list", current_func);
            BasicBlock* tensor_elem_done = BasicBlock::Create(*context, "tensor_elem_done", current_func);
            
            builder->CreateCondBr(tensor_elem_is_small, tensor_elem_int, tensor_elem_check_double);
            
            // Check if large value is double or pointer
            builder->SetInsertPoint(tensor_elem_check_double);
            builder->CreateCondBr(tensor_elem_has_exp, tensor_elem_double, tensor_elem_check_ptr);
            
            // Check if large non-double value is cons ptr
            builder->SetInsertPoint(tensor_elem_check_ptr);
            builder->CreateCondBr(tensor_elem_is_cons_ptr, tensor_elem_list, tensor_elem_int);
            
            // Display as integer
            builder->SetInsertPoint(tensor_elem_int);
            builder->CreateCall(printf_func, {codegenString("%lld"), elem_int64});
            builder->CreateBr(tensor_elem_done);
            
            // Display as double (bitcast from int64)
            builder->SetInsertPoint(tensor_elem_double);
            Value* elem_as_double = builder->CreateBitCast(elem_int64, Type::getDoubleTy(*context));
            builder->CreateCall(printf_func, {codegenString("%g"), elem_as_double});
            builder->CreateBr(tensor_elem_done);
            
            // Display as nested list (recursively display CONS_PTR)
            builder->SetInsertPoint(tensor_elem_list);
            Value* initial_depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
            builder->CreateCall(display_sexpr_list_func, {elem_int64, initial_depth});
            builder->CreateBr(tensor_elem_done);
            
            builder->SetInsertPoint(tensor_elem_done);
            
            // Increment index
            Value* next_idx = builder->CreateAdd(current_idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
            builder->CreateStore(next_idx, tensor_idx);
            builder->CreateBr(tensor_loop_cond);
            
            builder->SetInsertPoint(tensor_loop_exit);
            builder->CreateCall(printf_func, {codegenString(")")});
            builder->CreateBr(display_done);
            
            // Display as list
            builder->SetInsertPoint(display_list);
            builder->CreateCall(printf_func, {codegenString("(")});
            
            // Loop through list
            Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "display_current");
            Value* is_first = builder->CreateAlloca(Type::getInt1Ty(*context), nullptr, "display_is_first");
            builder->CreateStore(arg_int, current_ptr);
            builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), is_first);
            
            BasicBlock* list_loop_cond = BasicBlock::Create(*context, "display_list_cond", current_func);
            BasicBlock* list_loop_body = BasicBlock::Create(*context, "display_list_body", current_func);
            BasicBlock* list_loop_exit = BasicBlock::Create(*context, "display_list_exit", current_func);
            
            builder->CreateBr(list_loop_cond);
            
            // Loop condition: check if current != null
            builder->SetInsertPoint(list_loop_cond);
            Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
            Value* is_not_null = builder->CreateICmpNE(current_val,
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            builder->CreateCondBr(is_not_null, list_loop_body, list_loop_exit);
            
            // Loop body: display element
            builder->SetInsertPoint(list_loop_body);
            
            // Add space separator for non-first elements
            Value* first_flag = builder->CreateLoad(Type::getInt1Ty(*context), is_first);
            BasicBlock* skip_space = BasicBlock::Create(*context, "skip_space", current_func);
            BasicBlock* add_space = BasicBlock::Create(*context, "add_space", current_func);
            BasicBlock* display_element = BasicBlock::Create(*context, "display_elem", current_func);
            
            builder->CreateCondBr(first_flag, skip_space, add_space);
            
            builder->SetInsertPoint(add_space);
            builder->CreateCall(printf_func, {codegenString(" ")});
            builder->CreateBr(display_element);
            
            builder->SetInsertPoint(skip_space);
            builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), is_first);
            builder->CreateBr(display_element);
            
            // Display current element - SYMBOLIC DIFF FIX: Check for string pointers FIRST
            builder->SetInsertPoint(display_element);
            
            // Get car type BEFORE extraction to detect string pointers
            Value* elem_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
            Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
            Value* elem_car_type = builder->CreateCall(arena_tagged_cons_get_type_func,
                {elem_cons_ptr, is_car});
            Value* car_base_type = builder->CreateAnd(elem_car_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            // Check if car is CONS_PTR (could be string symbol OR nested list)
            Value* car_is_cons_ptr = builder->CreateICmpEQ(car_base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            
            BasicBlock* check_if_string = BasicBlock::Create(*context, "check_car_string", current_func);
            BasicBlock* extract_normal = BasicBlock::Create(*context, "extract_car_normal", current_func);
            BasicBlock* element_done = BasicBlock::Create(*context, "element_done", current_func);
            
            builder->CreateCondBr(car_is_cons_ptr, check_if_string, extract_normal);
            
            // CONS_PTR path: Check if it's a string pointer (symbolic operator) or nested list
            builder->SetInsertPoint(check_if_string);
            Value* car_ptr_int = builder->CreateCall(arena_tagged_cons_get_ptr_func,
                {elem_cons_ptr, is_car});
            Value* car_ptr = builder->CreateIntToPtr(car_ptr_int, builder->getPtrTy());
            
            // Load first byte to detect strings (ASCII printable characters)
            Value* first_byte_ptr = builder->CreatePointerCast(car_ptr, builder->getPtrTy());
            Value* first_byte = builder->CreateLoad(Type::getInt8Ty(*context), first_byte_ptr);
            
            // Check if first byte is printable ASCII (32-126) - indicates string symbol
            Value* is_printable_low = builder->CreateICmpUGE(first_byte,
                ConstantInt::get(Type::getInt8Ty(*context), 32));
            Value* is_printable_high = builder->CreateICmpULE(first_byte,
                ConstantInt::get(Type::getInt8Ty(*context), 126));
            Value* is_likely_string = builder->CreateAnd(is_printable_low, is_printable_high);
            
            BasicBlock* display_string_symbol = BasicBlock::Create(*context, "display_string_symbol", current_func);
            BasicBlock* display_nested_list = BasicBlock::Create(*context, "display_nested_list", current_func);
            
            builder->CreateCondBr(is_likely_string, display_string_symbol, display_nested_list);
            
            // Display string symbol (operator names like "+", "*", "sin", etc.)
            builder->SetInsertPoint(display_string_symbol);
            builder->CreateCall(printf_func, {codegenString("%s"), car_ptr});
            builder->CreateBr(element_done);
            
            // Display nested list using N-depth recursive helper function
            builder->SetInsertPoint(display_nested_list);
            Value* initial_depth_2 = ConstantInt::get(Type::getInt32Ty(*context), 1);
            builder->CreateCall(display_sexpr_list_func, {car_ptr_int, initial_depth_2});
            builder->CreateBr(element_done);
            
            // Normal extraction path for int64/double values
            builder->SetInsertPoint(extract_normal);
            Value* car_tagged = extractCarAsTaggedValue(current_val);
            Value* car_type = getTaggedValueType(car_tagged);
            Value* car_extracted_base = builder->CreateAnd(car_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            Value* car_is_double = builder->CreateICmpEQ(car_extracted_base,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            
            BasicBlock* display_car_double = BasicBlock::Create(*context, "display_car_double", current_func);
            BasicBlock* display_car_int = BasicBlock::Create(*context, "display_car_int", current_func);
            
            builder->CreateCondBr(car_is_double, display_car_double, display_car_int);
            
            builder->SetInsertPoint(display_car_double);
            Value* car_double = unpackDoubleFromTaggedValue(car_tagged);
            builder->CreateCall(printf_func, {codegenString("%g"), car_double});
            builder->CreateBr(element_done);
            
            builder->SetInsertPoint(display_car_int);
            Value* car_int = unpackInt64FromTaggedValue(car_tagged);
            builder->CreateCall(printf_func, {codegenString("%lld"), car_int});
            builder->CreateBr(element_done);
            
            // Move to next element
            builder->SetInsertPoint(element_done);
            Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
            Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
            
            // FIX: Check cdr type and handle ptr vs null separately to avoid calling get_ptr on null
            Value* cdr_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_cdr});
            Value* cdr_base_type = builder->CreateAnd(cdr_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            Value* cdr_is_ptr = builder->CreateICmpEQ(cdr_base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
            Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

            // FIX: Branch to separate blocks for ptr vs null vs other (dotted pair)
            BasicBlock* ptr_cdr = BasicBlock::Create(*context, "display_ptr_cdr", current_func);
            BasicBlock* check_null_cdr = BasicBlock::Create(*context, "display_check_null_cdr", current_func);
            BasicBlock* dotted_pair = BasicBlock::Create(*context, "display_dotted_pair", current_func);
            BasicBlock* dotted_double = BasicBlock::Create(*context, "display_dotted_double", current_func);
            BasicBlock* dotted_int = BasicBlock::Create(*context, "display_dotted_int", current_func);

            builder->CreateCondBr(cdr_is_ptr, ptr_cdr, check_null_cdr);

            // Cdr is a pointer - get it and continue
            builder->SetInsertPoint(ptr_cdr);
            Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
            builder->CreateStore(cdr_val, current_ptr);
            builder->CreateBr(list_loop_cond);

            // Check if cdr is null or a scalar value (dotted pair)
            builder->SetInsertPoint(check_null_cdr);
            builder->CreateCondBr(cdr_is_null, list_loop_exit, dotted_pair);

            // Cdr is a scalar value (dotted pair) - print " . <value>"
            builder->SetInsertPoint(dotted_pair);
            builder->CreateCall(printf_func, {codegenString(" . ")});
            builder->CreateCondBr(cdr_is_double, dotted_double, dotted_int);

            builder->SetInsertPoint(dotted_double);
            Value* dotted_cdr_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_cdr});
            builder->CreateCall(printf_func, {codegenString("%g"), dotted_cdr_double});
            builder->CreateBr(list_loop_exit);

            builder->SetInsertPoint(dotted_int);
            Value* dotted_cdr_int = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_cdr});
            builder->CreateCall(printf_func, {codegenString("%lld"), dotted_cdr_int});
            builder->CreateBr(list_loop_exit);

            // List loop exit: close parenthesis
            builder->SetInsertPoint(list_loop_exit);
            builder->CreateCall(printf_func, {codegenString(")")});
            builder->CreateBr(display_done);
            
            // Display as plain integer - but check if it might be a bitcast double
            builder->SetInsertPoint(display_int);
            
            // Heuristic: IEEE 754 doubles have exponent bits in high positions
            // Check if this looks like a double bit pattern (exponent field non-zero)
            Value* exponent_mask = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
            Value* exponent_bits = builder->CreateAnd(arg_int, exponent_mask);
            Value* has_exponent = builder->CreateICmpNE(exponent_bits, ConstantInt::get(Type::getInt64Ty(*context), 0));
            
            // Also check it's not a small integer (< 1000) which definitely isn't a double
            Value* is_small_int = builder->CreateICmpULT(arg_int, ConstantInt::get(Type::getInt64Ty(*context), 1000));
            Value* likely_double = builder->CreateAnd(has_exponent, builder->CreateNot(is_small_int));
            
            BasicBlock* display_as_double = BasicBlock::Create(*context, "display_int_as_double", current_func);
            BasicBlock* display_as_int = BasicBlock::Create(*context, "display_as_plain_int", current_func);
            BasicBlock* int_display_done = BasicBlock::Create(*context, "int_display_done", current_func);
            
            builder->CreateCondBr(likely_double, display_as_double, display_as_int);
            
            // Display as double (bitcast int64 to double)
            builder->SetInsertPoint(display_as_double);
            Value* as_double = builder->CreateBitCast(arg_int, Type::getDoubleTy(*context));
            builder->CreateCall(printf_func, {codegenString("%g"), as_double});
            builder->CreateBr(int_display_done);
            
            // Display as plain integer
            builder->SetInsertPoint(display_as_int);
            builder->CreateCall(printf_func, {codegenString("%lld"), arg_int});
            builder->CreateBr(int_display_done);
            
            builder->SetInsertPoint(int_display_done);
            builder->CreateBr(display_done);
            
            builder->SetInsertPoint(display_done);
            return ConstantInt::get(Type::getInt32Ty(*context), 0);
        }
        
        // Legacy path for non-tagged values

        // Check if arg is a Function* (lambda/closure)
        if (arg->getType()->isPointerTy()) {
            if (isa<Function>(arg)) {
                // HOMOICONIC DISPLAY: Check if lambda has S-expression metadata
                Function* func = dyn_cast<Function>(arg);
                std::string func_name = func->getName().str();

                // Look for lambda S-expression metadata (lambda_N_sexpr)
                std::string sexpr_key = func_name + "_sexpr";

                // REPL MODE: Check for s-expression in REPL registry
                // func_name is now the actual lambda name (e.g., "lambda_0")
                Value* sexpr_list = nullptr;
                if (g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);

                    // Check if we have the captured runtime value for this lambda
                    auto sexpr_val_it = g_repl_sexpr_values.find(sexpr_key);
                    if (sexpr_val_it != g_repl_sexpr_values.end()) {
                        // Inject the s-expression pointer directly as a constant
                        sexpr_list = ConstantInt::get(Type::getInt64Ty(*context), sexpr_val_it->second);
                    }
                }

                // Fall back to checking current module's symbol table
                if (!sexpr_list) {
                    auto sexpr_it = global_symbol_table.find(sexpr_key);
                    if (sexpr_it != global_symbol_table.end()) {
                        Value* sexpr_storage = sexpr_it->second;
                        sexpr_list = builder->CreateLoad(Type::getInt64Ty(*context), sexpr_storage);
                    }
                }

                if (sexpr_list) {
                    // Lambda has S-expression - display it homoiconically!
                    eshkol_debug("Displaying lambda %s as S-expression", func_name.c_str());

                    // Use existing displaySExprList to render lambda structure
                    // Note: displaySExprList expects i64 (treats it as pointer internally)
                    Value* depth = ConstantInt::get(Type::getInt32Ty(*context), 0);
                    builder->CreateCall(display_sexpr_list_func, {sexpr_list, depth});

                    return ConstantInt::get(Type::getInt32Ty(*context), 0);
                } else {
                    // Built-in or external function without S-expression - show <function>
                    eshkol_debug("Displaying %s as <function> (no S-expression metadata)", func_name.c_str());
                    return builder->CreateCall(printf_func, {
                        codegenString("<function>")
                    });
                }
            }
            // String argument - print directly
            return builder->CreateCall(printf_func, {
                codegenString("%s"), arg
            });
        } else if (arg->getType()->isFloatingPointTy()) {
            // Float argument - print with %f format
            return builder->CreateCall(printf_func, {
                codegenString("%f"), arg
            });
        }

        return nullptr;
    }
    
    Value* codegenMathFunction(const eshkol_operations_t* op, const std::string& func_name) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("%s requires exactly 1 argument", func_name.c_str());
            return nullptr;
        }
        
        // Get argument with type information
        TypedValue arg_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!arg_tv.llvm_value) return nullptr;
        
        // Convert to tagged_value for runtime type detection
        Value* arg_tagged = typedValueToTaggedValue(arg_tv);
        
        // Extract type tag
        Value* arg_type = getTaggedValueType(arg_tagged);
        Value* arg_base_type = builder->CreateAnd(arg_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // Check if argument is a dual number
        Value* arg_is_dual = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DUAL_NUMBER));
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* dual_path = BasicBlock::Create(*context, (func_name + "_dual_path").c_str(), current_func);
        BasicBlock* regular_path = BasicBlock::Create(*context, (func_name + "_regular_path").c_str(), current_func);
        BasicBlock* merge = BasicBlock::Create(*context, (func_name + "_merge").c_str(), current_func);
        
        builder->CreateCondBr(arg_is_dual, dual_path, regular_path);
        
        // PHASE 2: Dual number path - use dual math functions
        builder->SetInsertPoint(dual_path);
        Value* arg_dual = unpackDualFromTaggedValue(arg_tagged);
        Value* dual_result = nullptr;
        if (func_name == "sin") {
            dual_result = dualSin(arg_dual);
        } else if (func_name == "cos") {
            dual_result = dualCos(arg_dual);
        } else if (func_name == "exp") {
            dual_result = dualExp(arg_dual);
        } else if (func_name == "log") {
            dual_result = dualLog(arg_dual);
        } else if (func_name == "tan") {
            dual_result = dualTan(arg_dual);
        } else if (func_name == "tanh") {
            dual_result = dualTanh(arg_dual);
        } else if (func_name == "sinh") {
            dual_result = dualSinh(arg_dual);
        } else if (func_name == "cosh") {
            dual_result = dualCosh(arg_dual);
        } else if (func_name == "fabs") {
            dual_result = dualAbs(arg_dual);
        } else if (func_name == "sqrt") {
            dual_result = dualSqrt(arg_dual);
        } else {
            // For functions without dual number support, just call the regular function
            // and set derivative to 0 (treat as constant)
            auto [a, a_prime] = unpackDualNumber(arg_dual);
            Value* value = builder->CreateCall(function_table[func_name], {a});
            dual_result = packDualNumber(value, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        }
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        
        // Regular path: unpack argument and call regular function
        builder->SetInsertPoint(regular_path);
        
        // Check if argument is double or int64
        Value* arg_is_double = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        
        // Convert to double for math functions
        Value* arg_double = builder->CreateSelect(arg_is_double,
            unpackDoubleFromTaggedValue(arg_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(arg_tagged), Type::getDoubleTy(*context)));
        
        // Call the math function
        Value* result_double = builder->CreateCall(function_table[func_name], {arg_double});
        Value* tagged_regular_result = packDoubleToTaggedValue(result_double);
        builder->CreateBr(merge);
        
        // Merge paths
        builder->SetInsertPoint(merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2, (func_name + "_result").c_str());
        result_phi->addIncoming(tagged_dual_result, dual_path);
        result_phi->addIncoming(tagged_regular_result, regular_path);
        
        return result_phi;
    }

    // Binary math function codegen (for atan2, fmod, fmin, fmax, remainder, etc.)
    Value* codegenBinaryMathFunction(const eshkol_operations_t* op, const std::string& func_name) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("%s requires exactly 2 arguments", func_name.c_str());
            return nullptr;
        }

        // Get both arguments
        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // Convert to double
        Value* val1 = extractDoubleFromTagged(arg1);
        Value* val2 = extractDoubleFromTagged(arg2);

        // Call the function
        Value* result = builder->CreateCall(function_table[func_name], {val1, val2});
        return packDoubleToTaggedValue(result);
    }

    // Modulo operation - handles both integer and floating point
    Value* codegenModulo(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("modulo requires exactly 2 arguments");
            return nullptr;
        }

        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // FIXED: Use compile-time LLVM type checking instead of runtime type tags
        // Raw values from literals don't have tagged_value type
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);
        bool arg1_is_double = arg1->getType()->isDoubleTy();
        bool arg2_is_double = arg2->getType()->isDoubleTy();
        bool arg1_is_tagged = arg1->getType() == tagged_value_type;
        bool arg2_is_tagged = arg2->getType() == tagged_value_type;

        // Both raw integers - use direct integer modulo
        if (arg1_is_int64 && arg2_is_int64) {
            Value* result = builder->CreateSRem(arg1, arg2);
            return result;  // Return raw int64
        }

        // Both raw doubles - use fmod
        if (arg1_is_double && arg2_is_double) {
            return builder->CreateCall(function_table["fmod"], {arg1, arg2});
        }

        // Mixed types or tagged values - convert to double and use fmod
        Value* val1 = arg1;
        Value* val2 = arg2;

        if (arg1_is_int64) {
            val1 = builder->CreateSIToFP(arg1, Type::getDoubleTy(*context));
        } else if (arg1_is_tagged) {
            val1 = extractDoubleFromTagged(arg1);
        }

        if (arg2_is_int64) {
            val2 = builder->CreateSIToFP(arg2, Type::getDoubleTy(*context));
        } else if (arg2_is_tagged) {
            val2 = extractDoubleFromTagged(arg2);
        }

        return builder->CreateCall(function_table["fmod"], {val1, val2});
    }

    // Remainder operation - handles both integer and floating point
    // Uses truncated division semantics (sign of result matches dividend)
    Value* codegenRemainder(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("remainder requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = tv1.llvm_value;
        Value* arg2 = tv2.llvm_value;

        // Check LLVM types
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);
        bool arg1_is_double = arg1->getType()->isDoubleTy();
        bool arg2_is_double = arg2->getType()->isDoubleTy();
        bool arg1_is_tagged = arg1->getType() == tagged_value_type;
        bool arg2_is_tagged = arg2->getType() == tagged_value_type;

        // Both raw integers - use direct integer remainder (SRem)
        if (arg1_is_int64 && arg2_is_int64) {
            Value* result = builder->CreateSRem(arg1, arg2);
            return result;  // Return raw int64
        }

        // Both raw doubles - use C's remainder function
        if (arg1_is_double && arg2_is_double) {
            return builder->CreateCall(function_table["remainder"], {arg1, arg2});
        }

        // Mixed types or tagged values - convert to double
        Value* val1 = arg1;
        Value* val2 = arg2;

        if (arg1_is_int64) {
            val1 = builder->CreateSIToFP(arg1, Type::getDoubleTy(*context));
        } else if (arg1_is_tagged) {
            val1 = extractDoubleFromTagged(arg1);
        }

        if (arg2_is_int64) {
            val2 = builder->CreateSIToFP(arg2, Type::getDoubleTy(*context));
        } else if (arg2_is_tagged) {
            val2 = extractDoubleFromTagged(arg2);
        }

        return builder->CreateCall(function_table["remainder"], {val1, val2});
    }

    // Integer quotient (truncated division)
    Value* codegenQuotient(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("quotient requires exactly 2 arguments");
            return nullptr;
        }

        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // FIXED: Handle raw int64/double values correctly
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);

        // Both raw integers - use direct integer division
        if (arg1_is_int64 && arg2_is_int64) {
            return builder->CreateSDiv(arg1, arg2);  // Truncates toward zero
        }

        // Convert to double, divide, truncate
        Value* val1 = arg1;
        Value* val2 = arg2;

        if (arg1_is_int64) {
            val1 = builder->CreateSIToFP(arg1, Type::getDoubleTy(*context));
        } else if (arg1->getType()->isDoubleTy()) {
            // Already double
        } else if (arg1->getType() == tagged_value_type) {
            val1 = extractDoubleFromTagged(arg1);
        }

        if (arg2_is_int64) {
            val2 = builder->CreateSIToFP(arg2, Type::getDoubleTy(*context));
        } else if (arg2->getType()->isDoubleTy()) {
            // Already double
        } else if (arg2->getType() == tagged_value_type) {
            val2 = extractDoubleFromTagged(arg2);
        }

        Value* div_result = builder->CreateFDiv(val1, val2);
        Value* truncated = builder->CreateCall(function_table["trunc"], {div_result});
        return builder->CreateFPToSI(truncated, Type::getInt64Ty(*context));
    }

    // GCD (Greatest Common Divisor) using Euclidean algorithm
    Value* codegenGCD(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("gcd requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        // Convert to int64 for GCD computation
        Value* a = tv1.llvm_value;
        Value* b = tv2.llvm_value;

        if (a->getType()->isDoubleTy()) {
            a = builder->CreateFPToSI(a, Type::getInt64Ty(*context));
        } else if (a->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(a);
            a = builder->CreateFPToSI(extracted, Type::getInt64Ty(*context));
        }

        if (b->getType()->isDoubleTy()) {
            b = builder->CreateFPToSI(b, Type::getInt64Ty(*context));
        } else if (b->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(b);
            b = builder->CreateFPToSI(extracted, Type::getInt64Ty(*context));
        }

        // Take absolute values (gcd is always positive)
        Value* zero = ConstantInt::get(Type::getInt64Ty(*context), 0);
        Value* a_neg = builder->CreateICmpSLT(a, zero);
        a = builder->CreateSelect(a_neg, builder->CreateNeg(a), a);
        Value* b_neg = builder->CreateICmpSLT(b, zero);
        b = builder->CreateSelect(b_neg, builder->CreateNeg(b), b);

        // Euclidean algorithm using loop
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_bb = builder->GetInsertBlock();  // Save entry block
        BasicBlock* loop_bb = BasicBlock::Create(*context, "gcd_loop", current_func);
        BasicBlock* exit_bb = BasicBlock::Create(*context, "gcd_exit", current_func);

        builder->CreateBr(loop_bb);
        builder->SetInsertPoint(loop_bb);

        PHINode* a_phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "a");
        PHINode* b_phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "b");
        a_phi->addIncoming(a, entry_bb);
        b_phi->addIncoming(b, entry_bb);

        Value* b_is_zero = builder->CreateICmpEQ(b_phi, zero);

        // If b is zero, we're done (result is a)
        BasicBlock* continue_bb = BasicBlock::Create(*context, "gcd_continue", current_func);
        builder->CreateCondBr(b_is_zero, exit_bb, continue_bb);

        builder->SetInsertPoint(continue_bb);
        Value* new_a = b_phi;
        Value* new_b = builder->CreateSRem(a_phi, b_phi);
        a_phi->addIncoming(new_a, continue_bb);
        b_phi->addIncoming(new_b, continue_bb);
        builder->CreateBr(loop_bb);

        builder->SetInsertPoint(exit_bb);
        return a_phi;  // Return raw int64
    }

    // LCM (Least Common Multiple) = |a * b| / gcd(a, b)
    Value* codegenLCM(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("lcm requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        // Convert to int64
        Value* a = tv1.llvm_value;
        Value* b = tv2.llvm_value;

        if (a->getType()->isDoubleTy()) {
            a = builder->CreateFPToSI(a, Type::getInt64Ty(*context));
        } else if (a->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(a);
            a = builder->CreateFPToSI(extracted, Type::getInt64Ty(*context));
        }

        if (b->getType()->isDoubleTy()) {
            b = builder->CreateFPToSI(b, Type::getInt64Ty(*context));
        } else if (b->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(b);
            b = builder->CreateFPToSI(extracted, Type::getInt64Ty(*context));
        }

        // lcm(a, b) = |a| * (|b| / gcd(a, b))
        // First compute gcd inline using Euclidean algorithm
        Value* zero = ConstantInt::get(Type::getInt64Ty(*context), 0);

        // Take absolute values
        Value* a_neg = builder->CreateICmpSLT(a, zero);
        Value* abs_a = builder->CreateSelect(a_neg, builder->CreateNeg(a), a);
        Value* b_neg = builder->CreateICmpSLT(b, zero);
        Value* abs_b = builder->CreateSelect(b_neg, builder->CreateNeg(b), b);

        // Special case: if either is 0, lcm is 0
        Value* a_is_zero = builder->CreateICmpEQ(abs_a, zero);
        Value* b_is_zero = builder->CreateICmpEQ(abs_b, zero);
        Value* either_zero = builder->CreateOr(a_is_zero, b_is_zero);

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_bb = builder->GetInsertBlock();  // Save the entry block
        BasicBlock* compute_bb = BasicBlock::Create(*context, "lcm_compute", current_func);
        BasicBlock* done_bb = BasicBlock::Create(*context, "lcm_done", current_func);

        builder->CreateCondBr(either_zero, done_bb, compute_bb);

        builder->SetInsertPoint(compute_bb);

        // Compute gcd using loop
        BasicBlock* gcd_loop = BasicBlock::Create(*context, "lcm_gcd_loop", current_func);
        BasicBlock* gcd_exit = BasicBlock::Create(*context, "lcm_gcd_exit", current_func);

        builder->CreateBr(gcd_loop);
        builder->SetInsertPoint(gcd_loop);

        PHINode* gcd_a = builder->CreatePHI(Type::getInt64Ty(*context), 2, "gcd_a");
        PHINode* gcd_b = builder->CreatePHI(Type::getInt64Ty(*context), 2, "gcd_b");
        gcd_a->addIncoming(abs_a, compute_bb);
        gcd_b->addIncoming(abs_b, compute_bb);

        Value* gcd_b_zero = builder->CreateICmpEQ(gcd_b, zero);

        BasicBlock* gcd_continue = BasicBlock::Create(*context, "lcm_gcd_continue", current_func);
        builder->CreateCondBr(gcd_b_zero, gcd_exit, gcd_continue);

        builder->SetInsertPoint(gcd_continue);
        Value* new_gcd_a = gcd_b;
        Value* new_gcd_b = builder->CreateSRem(gcd_a, gcd_b);
        gcd_a->addIncoming(new_gcd_a, gcd_continue);
        gcd_b->addIncoming(new_gcd_b, gcd_continue);
        builder->CreateBr(gcd_loop);

        builder->SetInsertPoint(gcd_exit);
        Value* gcd_result = gcd_a;

        // lcm = |a| * (|b| / gcd)
        Value* b_div_gcd = builder->CreateSDiv(abs_b, gcd_result);
        Value* lcm_result = builder->CreateMul(abs_a, b_div_gcd);
        builder->CreateBr(done_bb);

        builder->SetInsertPoint(done_bb);
        PHINode* result = builder->CreatePHI(Type::getInt64Ty(*context), 2, "lcm_result");
        result->addIncoming(zero, entry_bb);  // Use saved entry block
        result->addIncoming(lcm_result, gcd_exit);

        return result;  // Return raw int64
    }

    // Helper to convert any value to double
    Value* toDouble(Value* val) {
        if (val->getType()->isDoubleTy()) {
            return val;
        } else if (val->getType()->isIntegerTy(64)) {
            return builder->CreateSIToFP(val, Type::getDoubleTy(*context));
        } else if (val->getType() == tagged_value_type) {
            return extractDoubleFromTagged(val);
        }
        // Default: try to extract as double
        return extractDoubleFromTagged(val);
    }

    // Min/Max - variadic, handles mixed types
    Value* codegenMinMax(const eshkol_operations_t* op, bool is_min) {
        if (op->call_op.num_vars < 1) {
            eshkol_warn("%s requires at least 1 argument", is_min ? "min" : "max");
            return nullptr;
        }

        // Start with first argument
        Value* result = codegenAST(&op->call_op.variables[0]);
        if (!result) return nullptr;
        Value* result_val = toDouble(result);

        // Compare with each subsequent argument
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&op->call_op.variables[i]);
            if (!arg) return nullptr;
            Value* arg_val = toDouble(arg);

            if (is_min) {
                result_val = builder->CreateCall(function_table["fmin"], {result_val, arg_val});
            } else {
                result_val = builder->CreateCall(function_table["fmax"], {result_val, arg_val});
            }
        }

        return result_val;  // Return raw double
    }

    // Power function (for expt alias)
    Value* codegenPow(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("pow/expt requires exactly 2 arguments");
            return nullptr;
        }

        Value* base = codegenAST(&op->call_op.variables[0]);
        Value* exp = codegenAST(&op->call_op.variables[1]);
        if (!base || !exp) return nullptr;

        Value* base_val = toDouble(base);
        Value* exp_val = toDouble(exp);
        return builder->CreateCall(function_table["pow"], {base_val, exp_val});
    }

    // Helper to extract double from tagged value (handles both int and double)
    Value* extractDoubleFromTagged(Value* tagged) {
        if (!tagged) return nullptr;

        // Check if already double
        if (tagged->getType()->isDoubleTy()) return tagged;

        // Get type tag
        Value* type = getTaggedValueType(tagged);
        Value* base_type = builder->CreateAnd(type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* is_double = builder->CreateICmpEQ(base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

        Value* double_val = unpackDoubleFromTaggedValue(tagged);
        Value* int_val = unpackInt64FromTaggedValue(tagged);
        Value* int_as_double = builder->CreateSIToFP(int_val, Type::getDoubleTy(*context));

        return builder->CreateSelect(is_double, double_val, int_as_double);
    }

    // Helper to check if a tagged value is "truthy" (non-false, non-null, non-zero)
    // FIXED: Handle both raw values and tagged values
    Value* isTruthy(Value* val) {
        if (!val) return ConstantInt::getFalse(*context);

        // Handle raw int64 - truthy if non-zero
        if (val->getType()->isIntegerTy(64)) {
            return builder->CreateICmpNE(val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        }

        // Handle raw double - truthy if non-zero
        if (val->getType()->isDoubleTy()) {
            return builder->CreateFCmpONE(val, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
        }

        // Handle tagged_value
        if (val->getType() == tagged_value_type) {
            Value* type = getTaggedValueType(val);
            Value* base_type = builder->CreateAnd(type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

            // Check for false/null (type 0 with value 0)
            Value* is_null_type = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
            Value* data = unpackInt64FromTaggedValue(val);
            Value* is_false_val = builder->CreateICmpEQ(data, ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* is_null_or_false = builder->CreateAnd(is_null_type, is_false_val);

            // Check for zero (int or double)
            Value* is_int = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
            Value* int_is_zero = builder->CreateICmpEQ(data, ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* int_zero = builder->CreateAnd(is_int, int_is_zero);

            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            Value* double_val = unpackDoubleFromTaggedValue(val);
            Value* double_is_zero = builder->CreateFCmpOEQ(double_val, ConstantFP::get(Type::getDoubleTy(*context), 0.0));
            Value* double_zero = builder->CreateAnd(is_double, double_is_zero);

            // Truthy = NOT (null/false OR int-zero OR double-zero)
            Value* is_falsy = builder->CreateOr(is_null_or_false, builder->CreateOr(int_zero, double_zero));
            return builder->CreateNot(is_falsy);
        }

        // Default: assume truthy
        return ConstantInt::getTrue(*context);
    }

    // Create a tagged boolean value (true = 1, false = 0)
    // Uses INT64 type - truthiness is checked by value, not type
    Value* packBoolToTaggedValue(Value* bool_val) {
        Value* int_val = builder->CreateZExt(bool_val, Type::getInt64Ty(*context));
        return packInt64ToTaggedValue(int_val);
    }

    // Short-circuit AND: (and a b ...) - returns last truthy value or first falsy value
    Value* codegenAnd(const eshkol_operations_t* op) {
        // ESHKOL_AND_OP uses sequence_op, ESHKOL_CALL_OP uses call_op
        uint64_t num_args = (op->op == ESHKOL_AND_OP) ?
            op->sequence_op.num_expressions : op->call_op.num_vars;
        const eshkol_ast_t* args = (op->op == ESHKOL_AND_OP) ?
            op->sequence_op.expressions : op->call_op.variables;

        if (num_args == 0) {
            // (and) with no args returns #t
            return packBoolToTaggedValue(ConstantInt::getTrue(*context));
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* merge_block = BasicBlock::Create(*context, "and_merge", current_func);

        // For collecting PHI inputs - only add when we actually branch to merge!
        std::vector<std::pair<Value*, BasicBlock*>> phi_inputs;

        // Evaluate each argument with short-circuit
        for (uint64_t i = 0; i < num_args; i++) {
            // CRITICAL FIX: Use codegenTypedAST + typedValueToTaggedValue to get proper tagged values
            TypedValue tv = codegenTypedAST(&args[i]);
            if (!tv.llvm_value) return nullptr;
            Value* arg = typedValueToTaggedValue(tv);

            BasicBlock* current_block = builder->GetInsertBlock();

            if (i == num_args - 1) {
                // Last argument - always return its value
                phi_inputs.push_back({arg, current_block});
                builder->CreateBr(merge_block);
            } else {
                // Check if truthy
                Value* is_truthy = isTruthy(arg);
                BasicBlock* next_block = BasicBlock::Create(*context, "and_next", current_func);
                BasicBlock* short_circuit_block = BasicBlock::Create(*context, "and_short", current_func);

                // If truthy, continue to next arg; if falsy, short-circuit
                builder->CreateCondBr(is_truthy, next_block, short_circuit_block);

                // Short-circuit: return this falsy value
                builder->SetInsertPoint(short_circuit_block);
                phi_inputs.push_back({arg, short_circuit_block});
                builder->CreateBr(merge_block);

                // Continue evaluation with next arg
                builder->SetInsertPoint(next_block);
            }
        }

        // Merge block with PHI
        builder->SetInsertPoint(merge_block);
        PHINode* result = builder->CreatePHI(tagged_value_type, phi_inputs.size(), "and_result");
        for (auto& [val, block] : phi_inputs) {
            result->addIncoming(val, block);
        }

        return result;
    }

    // Short-circuit OR: (or a b ...) - returns first truthy value or last falsy value
    Value* codegenOr(const eshkol_operations_t* op) {
        // ESHKOL_OR_OP uses sequence_op, ESHKOL_CALL_OP uses call_op
        uint64_t num_args = (op->op == ESHKOL_OR_OP) ?
            op->sequence_op.num_expressions : op->call_op.num_vars;
        const eshkol_ast_t* args = (op->op == ESHKOL_OR_OP) ?
            op->sequence_op.expressions : op->call_op.variables;

        if (num_args == 0) {
            // (or) with no args returns #f
            return packBoolToTaggedValue(ConstantInt::getFalse(*context));
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* merge_block = BasicBlock::Create(*context, "or_merge", current_func);

        std::vector<std::pair<Value*, BasicBlock*>> phi_inputs;

        for (uint64_t i = 0; i < num_args; i++) {
            // CRITICAL FIX: Use codegenTypedAST + typedValueToTaggedValue to get proper tagged values
            TypedValue tv = codegenTypedAST(&args[i]);
            if (!tv.llvm_value) return nullptr;
            Value* arg = typedValueToTaggedValue(tv);

            BasicBlock* current_block = builder->GetInsertBlock();

            if (i == num_args - 1) {
                // Last arg - just branch to merge with this value
                phi_inputs.push_back({arg, current_block});
                builder->CreateBr(merge_block);
            } else {
                Value* is_truthy = isTruthy(arg);
                BasicBlock* next_block = BasicBlock::Create(*context, "or_next", current_func);
                BasicBlock* short_circuit_block = BasicBlock::Create(*context, "or_short", current_func);

                // If truthy, go to short_circuit_block; otherwise continue to next_block
                builder->CreateCondBr(is_truthy, short_circuit_block, next_block);

                // Short circuit block - branch to merge with the truthy value
                builder->SetInsertPoint(short_circuit_block);
                phi_inputs.push_back({arg, short_circuit_block});
                builder->CreateBr(merge_block);

                // Continue evaluation in next_block
                builder->SetInsertPoint(next_block);
            }
        }

        builder->SetInsertPoint(merge_block);
        PHINode* result = builder->CreatePHI(tagged_value_type, phi_inputs.size(), "or_result");
        for (auto& [val, block] : phi_inputs) {
            result->addIncoming(val, block);
        }

        return result;
    }

    // Cond expression: (cond (test1 expr1) (test2 expr2) ... (else exprN))
    Value* codegenCond(const eshkol_operations_t* op) {
        if (op->call_op.num_vars == 0) {
            eshkol_warn("cond requires at least one clause");
            return nullptr;
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* done_block = BasicBlock::Create(*context, "cond_done", current_func);

        std::vector<std::pair<Value*, BasicBlock*>> phi_inputs;

        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            const eshkol_ast_t* clause = &op->call_op.variables[i];

            // Each clause should be a list (test expr...)
            if (clause->type != ESHKOL_OP || clause->operation.op != ESHKOL_CALL_OP) {
                eshkol_warn("cond clause must be a list");
                continue;
            }

            // Check if this is an 'else' clause (just evaluate the expression)
            bool is_else = false;
            if (clause->operation.call_op.func &&
                clause->operation.call_op.func->type == ESHKOL_VAR &&
                clause->operation.call_op.func->variable.id) {
                const char* sym = clause->operation.call_op.func->variable.id;
                is_else = (strcmp(sym, "else") == 0);
            }

            if (is_else) {
                // else clause - evaluate expressions and we're done
                Value* result = nullptr;
                for (uint64_t j = 0; j < clause->operation.call_op.num_vars; j++) {
                    TypedValue tv = codegenTypedAST(&clause->operation.call_op.variables[j]);
                    if (tv.llvm_value) result = typedValueToTaggedValue(tv);
                }
                if (result) {
                    phi_inputs.push_back({result, builder->GetInsertBlock()});
                }
                builder->CreateBr(done_block);
                break;
            } else {
                // Regular clause - evaluate test (func is the test condition)
                TypedValue test_tv = codegenTypedAST(clause->operation.call_op.func);
                if (!test_tv.llvm_value) continue;
                Value* test = typedValueToTaggedValue(test_tv);

                Value* is_true = isTruthy(test);
                BasicBlock* then_block = BasicBlock::Create(*context, "cond_then", current_func);
                BasicBlock* next_block = BasicBlock::Create(*context, "cond_next", current_func);

                builder->CreateCondBr(is_true, then_block, next_block);

                // Then block - evaluate expressions (clause body)
                builder->SetInsertPoint(then_block);
                Value* result = nullptr;
                for (uint64_t j = 0; j < clause->operation.call_op.num_vars; j++) {
                    TypedValue tv = codegenTypedAST(&clause->operation.call_op.variables[j]);
                    if (tv.llvm_value) result = typedValueToTaggedValue(tv);
                }
                if (result) {
                    phi_inputs.push_back({result, builder->GetInsertBlock()});
                }
                builder->CreateBr(done_block);

                // Continue to next clause
                builder->SetInsertPoint(next_block);
            }
        }

        // If no clause matched, return false
        if (phi_inputs.empty() || builder->GetInsertBlock()->getTerminator() == nullptr) {
            phi_inputs.push_back({packBoolToTaggedValue(ConstantInt::getFalse(*context)), builder->GetInsertBlock()});
            builder->CreateBr(done_block);
        }

        builder->SetInsertPoint(done_block);
        if (phi_inputs.size() == 1) {
            return phi_inputs[0].first;
        }
        PHINode* result = builder->CreatePHI(tagged_value_type, phi_inputs.size(), "cond_result");
        for (auto& [val, block] : phi_inputs) {
            result->addIncoming(val, block);
        }

        return result;
    }

    // Helper function to compare two tagged values using eqv? semantics
    // Returns an i1 (boolean) value
    Value* callBuiltinEqv(Value* arg1, Value* arg2) {
        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // For eqv?, we check if types are "numeric compatible"
        Value* is_int1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
        Value* is_int2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
        Value* is_double1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* is_double2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* is_char1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CHAR));
        Value* is_char2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CHAR));

        // Both are numbers?
        Value* is_num1 = builder->CreateOr(is_int1, is_double1);
        Value* is_num2 = builder->CreateOr(is_int2, is_double2);
        Value* both_numbers = builder->CreateAnd(is_num1, is_num2);

        // Both are chars?
        Value* both_chars = builder->CreateAnd(is_char1, is_char2);

        // For same type comparison
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // For integers/chars, compare int values
        Value* data1 = unpackInt64FromTaggedValue(arg1);
        Value* data2 = unpackInt64FromTaggedValue(arg2);
        Value* int_equal = builder->CreateICmpEQ(data1, data2);

        // For doubles, use numeric equality
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double_equal = builder->CreateFCmpOEQ(double1, double2);

        // Same-type number comparison
        Value* both_int = builder->CreateAnd(is_int1, is_int2);
        Value* both_double = builder->CreateAnd(is_double1, is_double2);
        Value* same_type_num_equal = builder->CreateSelect(both_double, double_equal, int_equal);

        // eqv? for numbers: same type and equal value
        Value* num_result = builder->CreateAnd(types_match, same_type_num_equal);

        // eqv? for chars: compare char codes
        Value* char_result = builder->CreateAnd(both_chars, int_equal);

        // For non-numbers, fall back to eq? semantics (type + pointer/value equality)
        Value* non_num_result = builder->CreateAnd(types_match, int_equal);

        // Select based on whether we're comparing numbers or chars
        Value* result = builder->CreateSelect(both_numbers, num_result,
            builder->CreateSelect(both_chars, char_result, non_num_result));

        return result;
    }

    // Case expression: (case key ((datum1 datum2 ...) expr1 ...) ... (else exprN))
    // Parser structure: call_op.func = key, call_op.variables = CONS clauses
    // Each clause is a CONS: car = datums (CALL_OP) or else marker (VAR), cdr = body (CALL_OP)
    Value* codegenCase(const eshkol_operations_t* op) {
        if (!op->call_op.func) {
            eshkol_warn("case requires a key expression");
            return nullptr;
        }

        // Evaluate the key expression once
        TypedValue key_tv = codegenTypedAST(op->call_op.func);
        if (!key_tv.llvm_value) return nullptr;
        Value* key = typedValueToTaggedValue(key_tv);

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* done_block = BasicBlock::Create(*context, "case_done", current_func);

        std::vector<std::pair<Value*, BasicBlock*>> phi_inputs;

        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            const eshkol_ast_t* clause = &op->call_op.variables[i];

            // Each clause is a CONS: car = datums, cdr = body
            if (clause->type != ESHKOL_CONS) {
                eshkol_warn("case clause must be a cons cell");
                continue;
            }

            const eshkol_ast_t* datums_ast = clause->cons_cell.car;
            const eshkol_ast_t* body_ast = clause->cons_cell.cdr;

            // Check if this is an 'else' clause
            bool is_else = false;
            if (datums_ast && datums_ast->type == ESHKOL_VAR && datums_ast->variable.id) {
                is_else = (strcmp(datums_ast->variable.id, "else") == 0);
            }

            if (is_else) {
                // else clause - evaluate body expressions and we're done
                Value* result = nullptr;
                if (body_ast && body_ast->type == ESHKOL_OP &&
                    body_ast->operation.op == ESHKOL_CALL_OP) {
                    for (uint64_t j = 0; j < body_ast->operation.call_op.num_vars; j++) {
                        TypedValue tv = codegenTypedAST(&body_ast->operation.call_op.variables[j]);
                        if (tv.llvm_value) result = typedValueToTaggedValue(tv);
                    }
                }
                if (result) {
                    phi_inputs.push_back({result, builder->GetInsertBlock()});
                }
                builder->CreateBr(done_block);
                break;
            } else {
                // Regular clause - datums_ast is a CALL_OP with variables containing datums
                BasicBlock* then_block = BasicBlock::Create(*context, "case_then", current_func);
                BasicBlock* next_block = BasicBlock::Create(*context, "case_next", current_func);

                Value* any_match = ConstantInt::getFalse(*context);

                if (datums_ast && datums_ast->type == ESHKOL_OP &&
                    datums_ast->operation.op == ESHKOL_CALL_OP) {
                    // Check all datums
                    for (uint64_t d = 0; d < datums_ast->operation.call_op.num_vars; d++) {
                        TypedValue datum_tv = codegenTypedAST(&datums_ast->operation.call_op.variables[d]);
                        if (!datum_tv.llvm_value) continue;
                        Value* datum = typedValueToTaggedValue(datum_tv);
                        Value* is_match = callBuiltinEqv(key, datum);
                        any_match = builder->CreateOr(any_match, is_match);
                    }
                }

                builder->CreateCondBr(any_match, then_block, next_block);

                // Then block - evaluate body expressions
                builder->SetInsertPoint(then_block);
                Value* result = nullptr;
                if (body_ast && body_ast->type == ESHKOL_OP &&
                    body_ast->operation.op == ESHKOL_CALL_OP) {
                    for (uint64_t j = 0; j < body_ast->operation.call_op.num_vars; j++) {
                        TypedValue tv = codegenTypedAST(&body_ast->operation.call_op.variables[j]);
                        if (tv.llvm_value) result = typedValueToTaggedValue(tv);
                    }
                }
                if (result) {
                    phi_inputs.push_back({result, builder->GetInsertBlock()});
                }
                builder->CreateBr(done_block);

                builder->SetInsertPoint(next_block);
            }
        }

        // If no clause matched, return unspecified (false)
        if (phi_inputs.empty() || builder->GetInsertBlock()->getTerminator() == nullptr) {
            phi_inputs.push_back({packBoolToTaggedValue(ConstantInt::getFalse(*context)), builder->GetInsertBlock()});
            builder->CreateBr(done_block);
        }

        builder->SetInsertPoint(done_block);
        if (phi_inputs.size() == 1) {
            return phi_inputs[0].first;
        }
        PHINode* result = builder->CreatePHI(tagged_value_type, phi_inputs.size(), "case_result");
        for (auto& [val, block] : phi_inputs) {
            result->addIncoming(val, block);
        }

        return result;
    }

    // Do loop: (do ((var init step) ...) ((test) result ...) body ...)
    // Parser structure: call_op.func = CONS(bindings-list, test-clause)
    //                   call_op.variables = body expressions
    // Where bindings-list is CALL_OP with CONS bindings (var, CONS(init, step))
    // And test-clause is CONS(test, results-list)
    Value* codegenDo(const eshkol_operations_t* op) {
        if (!op->call_op.func || op->call_op.func->type != ESHKOL_CONS) {
            eshkol_warn("do requires properly formed structure");
            return nullptr;
        }

        const eshkol_ast_t* main_cons = op->call_op.func;
        const eshkol_ast_t* bindings_list = main_cons->cons_cell.car;
        const eshkol_ast_t* test_clause = main_cons->cons_cell.cdr;

        if (!bindings_list || !test_clause || test_clause->type != ESHKOL_CONS) {
            eshkol_warn("do: invalid bindings or test clause");
            return nullptr;
        }

        const eshkol_ast_t* test_ast = test_clause->cons_cell.car;
        const eshkol_ast_t* results_list = test_clause->cons_cell.cdr;

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Create basic blocks
        BasicBlock* init_block = builder->GetInsertBlock();  // We're already in the entry
        BasicBlock* loop_header = BasicBlock::Create(*context, "do_loop_header", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "do_loop_body", current_func);
        BasicBlock* loop_step = BasicBlock::Create(*context, "do_loop_step", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "do_loop_exit", current_func);

        // Collect binding information
        std::vector<std::string> var_names;
        std::vector<Value*> var_allocas;
        std::vector<const eshkol_ast_t*> step_exprs;

        // Initialize loop variables
        if (bindings_list->type == ESHKOL_OP && bindings_list->operation.op == ESHKOL_CALL_OP) {
            for (uint64_t i = 0; i < bindings_list->operation.call_op.num_vars; i++) {
                const eshkol_ast_t* binding = &bindings_list->operation.call_op.variables[i];
                if (binding->type != ESHKOL_CONS) continue;

                const eshkol_ast_t* var_ast = binding->cons_cell.car;
                const eshkol_ast_t* inner_cons = binding->cons_cell.cdr;
                if (!var_ast || !inner_cons || inner_cons->type != ESHKOL_CONS) continue;

                const eshkol_ast_t* init_ast = inner_cons->cons_cell.car;
                const eshkol_ast_t* step_ast = inner_cons->cons_cell.cdr;

                if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) continue;

                std::string var_name = var_ast->variable.id;
                var_names.push_back(var_name);
                step_exprs.push_back(step_ast);

                // Create alloca for loop variable
                Value* alloca = builder->CreateAlloca(tagged_value_type, nullptr, var_name + "_do");
                var_allocas.push_back(alloca);

                // Evaluate init expression and store
                TypedValue init_tv = codegenTypedAST(init_ast);
                if (!init_tv.llvm_value) {
                    eshkol_warn("do: failed to evaluate init expression");
                    continue;
                }
                Value* init_val = typedValueToTaggedValue(init_tv);
                builder->CreateStore(init_val, alloca);

                // Add to symbol table
                symbol_table[var_name] = alloca;
            }
        }

        // Branch to loop header
        builder->CreateBr(loop_header);

        // Loop header - test condition
        builder->SetInsertPoint(loop_header);

        TypedValue test_tv = codegenTypedAST(test_ast);
        if (!test_tv.llvm_value) {
            eshkol_warn("do: failed to evaluate test expression");
            return nullptr;
        }
        Value* test_val = typedValueToTaggedValue(test_tv);
        Value* is_done = isTruthy(test_val);

        builder->CreateCondBr(is_done, loop_exit, loop_body);

        // Loop body
        builder->SetInsertPoint(loop_body);

        // Execute body expressions
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            TypedValue body_tv = codegenTypedAST(&op->call_op.variables[i]);
            // Just evaluate, don't need the result
        }

        builder->CreateBr(loop_step);

        // Loop step - evaluate step expressions and update variables
        builder->SetInsertPoint(loop_step);

        // Evaluate all step expressions FIRST (before updating any variable)
        std::vector<Value*> new_values;
        for (size_t i = 0; i < var_names.size(); i++) {
            TypedValue step_tv = codegenTypedAST(step_exprs[i]);
            if (!step_tv.llvm_value) {
                eshkol_warn("do: failed to evaluate step expression");
                new_values.push_back(nullptr);
                continue;
            }
            Value* step_val = typedValueToTaggedValue(step_tv);
            new_values.push_back(step_val);
        }

        // Now update all variables simultaneously
        for (size_t i = 0; i < var_names.size(); i++) {
            if (new_values[i]) {
                builder->CreateStore(new_values[i], var_allocas[i]);
            }
        }

        builder->CreateBr(loop_header);

        // Loop exit - evaluate result expressions
        builder->SetInsertPoint(loop_exit);

        Value* result = packBoolToTaggedValue(ConstantInt::getFalse(*context));  // Default result

        if (results_list && results_list->type == ESHKOL_OP &&
            results_list->operation.op == ESHKOL_CALL_OP) {
            for (uint64_t i = 0; i < results_list->operation.call_op.num_vars; i++) {
                TypedValue result_tv = codegenTypedAST(&results_list->operation.call_op.variables[i]);
                if (result_tv.llvm_value) {
                    result = typedValueToTaggedValue(result_tv);
                }
            }
        }

        // Remove loop variables from symbol table
        for (const auto& var_name : var_names) {
            symbol_table.erase(var_name);
        }

        return result;
    }

    // Logical NOT: (not x)
    Value* codegenNot(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("not requires exactly 1 argument");
            return nullptr;
        }

        // CRITICAL FIX: Use codegenTypedAST + typedValueToTaggedValue for proper type handling
        TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!tv.llvm_value) return nullptr;
        Value* arg = typedValueToTaggedValue(tv);

        Value* is_truthy_val = isTruthy(arg);
        Value* is_false = builder->CreateNot(is_truthy_val);
        return packBoolToTaggedValue(is_false);
    }

    // when: (when test expr...) - evaluates expressions if test is true, returns last result or void
    Value* codegenWhen(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1) {
            eshkol_warn("when requires at least a test expression");
            return nullptr;
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_block = builder->GetInsertBlock();
        BasicBlock* then_block = BasicBlock::Create(*context, "when_then", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "when_done", current_func);

        // Evaluate test condition
        TypedValue test_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!test_tv.llvm_value) return nullptr;
        Value* test = typedValueToTaggedValue(test_tv);
        Value* is_true = isTruthy(test);

        // Create the false result before branching (in entry block)
        Value* false_result = packBoolToTaggedValue(ConstantInt::getFalse(*context));
        BasicBlock* branch_block = builder->GetInsertBlock();  // Block containing the branch

        builder->CreateCondBr(is_true, then_block, done_block);

        // Then block - evaluate body expressions
        builder->SetInsertPoint(then_block);
        Value* result = nullptr;
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[i]);
            if (tv.llvm_value) result = typedValueToTaggedValue(tv);
        }
        if (!result) result = packBoolToTaggedValue(ConstantInt::getTrue(*context));
        BasicBlock* then_exit = builder->GetInsertBlock();
        builder->CreateBr(done_block);

        // Done block - PHI for result
        builder->SetInsertPoint(done_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "when_result");
        phi->addIncoming(result, then_exit);
        phi->addIncoming(false_result, branch_block);

        return phi;
    }

    // unless: (unless test expr...) - evaluates expressions if test is false
    Value* codegenUnless(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1) {
            eshkol_warn("unless requires at least a test expression");
            return nullptr;
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* else_block = BasicBlock::Create(*context, "unless_else", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "unless_done", current_func);

        // Evaluate test condition
        TypedValue test_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!test_tv.llvm_value) return nullptr;
        Value* test = typedValueToTaggedValue(test_tv);
        Value* is_true = isTruthy(test);

        // Create the false result before branching (in current block)
        Value* false_result = packBoolToTaggedValue(ConstantInt::getFalse(*context));
        BasicBlock* branch_block = builder->GetInsertBlock();

        // Branch to else block if test is FALSE
        builder->CreateCondBr(is_true, done_block, else_block);

        // Else block - evaluate body expressions (when test is false)
        builder->SetInsertPoint(else_block);
        Value* result = nullptr;
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[i]);
            if (tv.llvm_value) result = typedValueToTaggedValue(tv);
        }
        if (!result) result = packBoolToTaggedValue(ConstantInt::getTrue(*context));
        BasicBlock* else_exit = builder->GetInsertBlock();
        builder->CreateBr(done_block);

        // Done block - PHI for result
        builder->SetInsertPoint(done_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "unless_result");
        phi->addIncoming(result, else_exit);
        phi->addIncoming(false_result, branch_block);

        return phi;
    }

    // Type predicates
    Value* codegenTypePredicate(const eshkol_operations_t* op, uint8_t expected_type) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("Type predicate requires exactly 1 argument");
            return nullptr;
        }

        // CRITICAL FIX: Use codegenTypedAST + typedValueToTaggedValue for proper type handling
        TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!tv.llvm_value) return nullptr;
        Value* arg = typedValueToTaggedValue(tv);

        Value* type = getTaggedValueType(arg);
        Value* base_type = builder->CreateAnd(type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* matches = builder->CreateICmpEQ(base_type,
            ConstantInt::get(Type::getInt8Ty(*context), expected_type));

        return packBoolToTaggedValue(matches);
    }

    // ============================================================================
    // STRING FUNCTIONS
    // ============================================================================

    // Helper: Extract string pointer from tagged value
    Value* extractStringPtr(Value* tagged_val) {
        Value* ptr_int = unpackInt64FromTaggedValue(tagged_val);
        return builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
    }

    // string-length: Returns the length of a string
    Value* codegenStringLength(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("string-length requires exactly 1 argument");
            return nullptr;
        }

        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;

        // Get the string pointer
        Value* str_ptr = extractStringPtr(arg);

        // Call strlen
        Function* strlen_func = module->getFunction("strlen");
        if (!strlen_func) {
            FunctionType* strlen_type = FunctionType::get(
                Type::getInt64Ty(*context),
                {builder->getPtrTy()},
                false);
            strlen_func = Function::Create(strlen_type, Function::ExternalLinkage, "strlen", module.get());
        }

        Value* len = builder->CreateCall(strlen_func, {str_ptr});
        return packInt64ToTaggedValue(len, true);
    }

    // string-ref: Returns the character at index (as integer)
    Value* codegenStringRef(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("string-ref requires exactly 2 arguments");
            return nullptr;
        }

        Value* str_arg = codegenAST(&op->call_op.variables[0]);
        if (!str_arg) return nullptr;

        // Use codegenTypedAST for index to get raw integer value
        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        if (!idx_tv.llvm_value) return nullptr;

        Value* str_ptr = extractStringPtr(str_arg);
        // Integer literals are raw i64, use directly
        Value* idx = idx_tv.llvm_value;

        // Get character at index
        Value* char_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_ptr, idx);
        Value* char_val = builder->CreateLoad(Type::getInt8Ty(*context), char_ptr);
        Value* char_int = builder->CreateZExt(char_val, Type::getInt64Ty(*context));

        return packInt64ToTaggedValue(char_int, true);
    }

    // string-append: Concatenates strings
    Value* codegenStringAppend(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1) {
            eshkol_warn("string-append requires at least 1 argument");
            return nullptr;
        }

        // Get strlen and strcpy functions
        Function* strlen_func = module->getFunction("strlen");
        if (!strlen_func) {
            FunctionType* strlen_type = FunctionType::get(
                Type::getInt64Ty(*context), {builder->getPtrTy()}, false);
            strlen_func = Function::Create(strlen_type, Function::ExternalLinkage, "strlen", module.get());
        }

        Function* strcpy_func = module->getFunction("strcpy");
        if (!strcpy_func) {
            FunctionType* strcpy_type = FunctionType::get(
                builder->getPtrTy(), {builder->getPtrTy(), builder->getPtrTy()}, false);
            strcpy_func = Function::Create(strcpy_type, Function::ExternalLinkage, "strcpy", module.get());
        }

        Function* strcat_func = module->getFunction("strcat");
        if (!strcat_func) {
            FunctionType* strcat_type = FunctionType::get(
                builder->getPtrTy(), {builder->getPtrTy(), builder->getPtrTy()}, false);
            strcat_func = Function::Create(strcat_type, Function::ExternalLinkage, "strcat", module.get());
        }

        // Calculate total length needed
        std::vector<Value*> str_ptrs;
        Value* total_len = ConstantInt::get(Type::getInt64Ty(*context), 1); // +1 for null terminator

        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&op->call_op.variables[i]);
            if (!arg) return nullptr;
            Value* str_ptr = extractStringPtr(arg);
            str_ptrs.push_back(str_ptr);
            Value* len = builder->CreateCall(strlen_func, {str_ptr});
            total_len = builder->CreateAdd(total_len, len);
        }

        // Allocate new string using arena_allocate
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* new_str = builder->CreateCall(arena_allocate_func, {arena_ptr, total_len});

        // Copy first string
        builder->CreateCall(strcpy_func, {new_str, str_ptrs[0]});

        // Concatenate remaining strings
        for (size_t i = 1; i < str_ptrs.size(); i++) {
            builder->CreateCall(strcat_func, {new_str, str_ptrs[i]});
        }

        return packPtrToTaggedValue(new_str, ESHKOL_VALUE_STRING_PTR);
    }

    // substring: Extracts a substring
    Value* codegenSubstring(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("substring requires exactly 3 arguments");
            return nullptr;
        }

        Value* str_arg = codegenAST(&op->call_op.variables[0]);
        if (!str_arg) return nullptr;

        // Use codegenTypedAST for indices to get raw integer values
        TypedValue start_tv = codegenTypedAST(&op->call_op.variables[1]);
        TypedValue end_tv = codegenTypedAST(&op->call_op.variables[2]);
        if (!start_tv.llvm_value || !end_tv.llvm_value) return nullptr;

        Value* str_ptr = extractStringPtr(str_arg);
        // Integer literals are raw i64, use directly
        Value* start = start_tv.llvm_value;
        Value* end = end_tv.llvm_value;

        // Calculate length
        Value* len = builder->CreateSub(end, start);
        Value* alloc_len = builder->CreateAdd(len, ConstantInt::get(Type::getInt64Ty(*context), 1));

        // Allocate new string
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* new_str = builder->CreateCall(arena_allocate_func, {arena_ptr, alloc_len});

        // Get memcpy function
        Function* memcpy_func = module->getFunction("memcpy");
        if (!memcpy_func) {
            FunctionType* memcpy_type = FunctionType::get(
                builder->getPtrTy(),
                {builder->getPtrTy(), builder->getPtrTy(), Type::getInt64Ty(*context)},
                false);
            memcpy_func = Function::Create(memcpy_type, Function::ExternalLinkage, "memcpy", module.get());
        }

        // Copy substring
        Value* src_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_ptr, start);
        builder->CreateCall(memcpy_func, {new_str, src_ptr, len});

        // Null terminate
        Value* null_pos = builder->CreateGEP(Type::getInt8Ty(*context), new_str, len);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), null_pos);

        return packPtrToTaggedValue(new_str, ESHKOL_VALUE_STRING_PTR);
    }

    // String comparison functions
    Value* codegenStringCompare(const eshkol_operations_t* op, const std::string& cmp_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("String comparison requires exactly 2 arguments");
            return nullptr;
        }

        Value* str1_arg = codegenAST(&op->call_op.variables[0]);
        Value* str2_arg = codegenAST(&op->call_op.variables[1]);
        if (!str1_arg || !str2_arg) return nullptr;

        Value* str1_ptr = extractStringPtr(str1_arg);
        Value* str2_ptr = extractStringPtr(str2_arg);

        // Get strcmp function
        Function* strcmp_func = module->getFunction("strcmp");
        if (!strcmp_func) {
            FunctionType* strcmp_type = FunctionType::get(
                Type::getInt32Ty(*context),
                {builder->getPtrTy(), builder->getPtrTy()},
                false);
            strcmp_func = Function::Create(strcmp_type, Function::ExternalLinkage, "strcmp", module.get());
        }

        Value* cmp_result = builder->CreateCall(strcmp_func, {str1_ptr, str2_ptr});
        Value* zero = ConstantInt::get(Type::getInt32Ty(*context), 0);
        Value* result;

        if (cmp_type == "eq") {
            result = builder->CreateICmpEQ(cmp_result, zero);
        } else if (cmp_type == "lt") {
            result = builder->CreateICmpSLT(cmp_result, zero);
        } else if (cmp_type == "gt") {
            result = builder->CreateICmpSGT(cmp_result, zero);
        } else if (cmp_type == "le") {
            result = builder->CreateICmpSLE(cmp_result, zero);
        } else if (cmp_type == "ge") {
            result = builder->CreateICmpSGE(cmp_result, zero);
        } else {
            result = ConstantInt::getFalse(*context);
        }

        return packBoolToTaggedValue(result);
    }

    // number->string: Convert number to string
    Value* codegenNumberToString(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("number->string requires exactly 1 argument");
            return nullptr;
        }

        TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!tv.llvm_value) return nullptr;

        // Allocate buffer for string (64 bytes should be enough for any number)
        Value* buf_size = ConstantInt::get(Type::getInt64Ty(*context), 64);
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* buf = builder->CreateCall(arena_allocate_func, {arena_ptr, buf_size});

        // Get snprintf function
        Function* snprintf_func = module->getFunction("snprintf");
        if (!snprintf_func) {
            FunctionType* snprintf_type = FunctionType::get(
                Type::getInt32Ty(*context),
                {builder->getPtrTy(), Type::getInt64Ty(*context), builder->getPtrTy()},
                true); // variadic
            snprintf_func = Function::Create(snprintf_type, Function::ExternalLinkage, "snprintf", module.get());
        }

        // If the value is a tagged_value_type, extract the actual value
        Value* raw_val = tv.llvm_value;
        if (raw_val->getType() == tagged_value_type) {
            // Extract the data field from tagged value
            raw_val = unpackInt64FromTaggedValue(raw_val);
        }

        if (tv.type == ESHKOL_VALUE_DOUBLE || !tv.is_exact) {
            // Format as double
            Value* double_val = raw_val;
            if (raw_val->getType()->isIntegerTy(64)) {
                double_val = builder->CreateBitCast(raw_val, Type::getDoubleTy(*context));
            } else if (!raw_val->getType()->isDoubleTy()) {
                double_val = builder->CreateSIToFP(raw_val, Type::getDoubleTy(*context));
            }
            builder->CreateCall(snprintf_func, {buf, buf_size, codegenString("%g"), double_val});
        } else {
            // Format as integer
            Value* int_val = raw_val;
            if (raw_val->getType()->isDoubleTy()) {
                int_val = builder->CreateFPToSI(raw_val, Type::getInt64Ty(*context));
            } else if (!raw_val->getType()->isIntegerTy(64)) {
                int_val = builder->CreateSExt(raw_val, Type::getInt64Ty(*context));
            }
            builder->CreateCall(snprintf_func, {buf, buf_size, codegenString("%lld"), int_val});
        }

        return packPtrToTaggedValue(buf, ESHKOL_VALUE_STRING_PTR);
    }

    // string->number: Convert string to number
    Value* codegenStringToNumber(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("string->number requires exactly 1 argument");
            return nullptr;
        }

        Value* str_arg = codegenAST(&op->call_op.variables[0]);
        if (!str_arg) return nullptr;

        Value* str_ptr = extractStringPtr(str_arg);

        // Get strtod function (handles both integers and floats)
        Function* strtod_func = module->getFunction("strtod");
        if (!strtod_func) {
            FunctionType* strtod_type = FunctionType::get(
                Type::getDoubleTy(*context),
                {builder->getPtrTy(), builder->getPtrTy()},
                false);
            strtod_func = Function::Create(strtod_type, Function::ExternalLinkage, "strtod", module.get());
        }

        Value* null_ptr = ConstantPointerNull::get(builder->getPtrTy());
        Value* result = builder->CreateCall(strtod_func, {str_ptr, null_ptr});

        return packDoubleToTaggedValue(result);
    }

    // make-string: Create a string of given length, optionally filled with a character
    Value* codegenMakeString(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("make-string requires 1 or 2 arguments");
            return nullptr;
        }

        TypedValue len_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!len_tv.llvm_value) return nullptr;

        // Get the length as i64
        Value* len = len_tv.llvm_value;
        if (!len->getType()->isIntegerTy(64)) {
            len = builder->CreateZExt(len, Type::getInt64Ty(*context));
        }

        // Get the fill character (default to space, ASCII 32)
        Value* fill_char;
        if (op->call_op.num_vars == 2) {
            Value* char_arg = codegenAST(&op->call_op.variables[1]);
            if (!char_arg) return nullptr;
            fill_char = unpackInt64FromTaggedValue(char_arg);
            fill_char = builder->CreateTrunc(fill_char, Type::getInt8Ty(*context));
        } else {
            fill_char = ConstantInt::get(Type::getInt8Ty(*context), ' ');
        }

        // Allocate buffer: len + 1 for null terminator
        Value* buf_size = builder->CreateAdd(len, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Function* malloc_func = module->getFunction("malloc");
        Value* buf = builder->CreateCall(malloc_func, {buf_size});

        // Fill with the character using memset
        Function* memset_func = module->getFunction("memset");
        if (!memset_func) {
            std::vector<Type*> memset_args = {
                PointerType::get(*context, 0),
                Type::getInt32Ty(*context),
                Type::getInt64Ty(*context)
            };
            FunctionType* memset_type = FunctionType::get(
                PointerType::get(*context, 0), memset_args, false);
            memset_func = Function::Create(memset_type, Function::ExternalLinkage, "memset", module.get());
        }
        Value* fill_char_i32 = builder->CreateZExt(fill_char, Type::getInt32Ty(*context));
        builder->CreateCall(memset_func, {buf, fill_char_i32, len});

        // Add null terminator
        Value* term_ptr = builder->CreateGEP(Type::getInt8Ty(*context), buf, len);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), term_ptr);

        return packPtrToTaggedValue(buf, ESHKOL_VALUE_STRING_PTR);
    }

    // string-set!: Set character at index in string
    Value* codegenStringSet(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("string-set! requires exactly 3 arguments");
            return nullptr;
        }

        Value* str_arg = codegenAST(&op->call_op.variables[0]);
        if (!str_arg) return nullptr;

        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        if (!idx_tv.llvm_value) return nullptr;

        Value* char_arg = codegenAST(&op->call_op.variables[2]);
        if (!char_arg) return nullptr;

        // Extract string pointer
        Value* str_ptr = extractStringPtr(str_arg);

        // Get index
        Value* idx = idx_tv.llvm_value;
        if (!idx->getType()->isIntegerTy(64)) {
            idx = builder->CreateZExt(idx, Type::getInt64Ty(*context));
        }

        // Get character value
        Value* char_val = unpackInt64FromTaggedValue(char_arg);
        char_val = builder->CreateTrunc(char_val, Type::getInt8Ty(*context));

        // Store character at index
        Value* char_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_ptr, idx);
        builder->CreateStore(char_val, char_ptr);

        // Return void (unspecified in Scheme, return the string)
        return str_arg;
    }

    // string->list: Convert string to list of characters
    Value* codegenStringToList(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("string->list requires exactly 1 argument");
            return nullptr;
        }

        Value* str_arg = codegenAST(&op->call_op.variables[0]);
        if (!str_arg) return nullptr;

        Value* str_ptr = extractStringPtr(str_arg);

        // Get string length using strlen
        Function* strlen_func = module->getFunction("strlen");
        Value* len = builder->CreateCall(strlen_func, {str_ptr});

        // We'll build the list backwards then reverse, or use a helper
        // For simplicity, build from end to beginning

        Function* parent_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_cond = BasicBlock::Create(*context, "strtolist_cond", parent_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "strtolist_body", parent_func);
        BasicBlock* loop_end = BasicBlock::Create(*context, "strtolist_end", parent_func);

        // Create alloca for index and result list at function entry
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        BasicBlock& entry = parent_func->getEntryBlock();
        builder->SetInsertPoint(&entry, entry.begin());
        Value* idx_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "stl_idx");
        Value* list_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "stl_list");
        builder->restoreIP(saved_ip);

        // Start from the end of string: idx = len - 1
        Value* start_idx = builder->CreateSub(len, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(start_idx, idx_ptr);

        // Start with empty list (null)
        Value* nil_val = packNullToTaggedValue();
        builder->CreateStore(nil_val, list_ptr);

        builder->CreateBr(loop_cond);

        // Loop condition: idx >= 0
        builder->SetInsertPoint(loop_cond);
        Value* current_idx = builder->CreateLoad(Type::getInt64Ty(*context), idx_ptr);
        Value* cond = builder->CreateICmpSGE(current_idx, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(cond, loop_body, loop_end);

        // Loop body: cons char at idx with current list
        builder->SetInsertPoint(loop_body);
        Value* body_idx = builder->CreateLoad(Type::getInt64Ty(*context), idx_ptr);
        Value* char_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_ptr, body_idx);
        Value* char_byte = builder->CreateLoad(Type::getInt8Ty(*context), char_ptr);
        Value* char_i64 = builder->CreateZExt(char_byte, Type::getInt64Ty(*context));
        Value* char_tagged = packCharToTaggedValue(char_i64);

        // Cons this character with current list
        Value* current_list = builder->CreateLoad(tagged_value_type, list_ptr);
        Value* cons_ptr_int = codegenTaggedArenaConsCellFromTaggedValue(char_tagged, current_list);
        // Pack cons cell pointer as tagged value with CONS_PTR type
        Value* new_list = packPtrToTaggedValue(
            builder->CreateIntToPtr(cons_ptr_int, PointerType::get(*context, 0)),
            ESHKOL_VALUE_CONS_PTR);
        builder->CreateStore(new_list, list_ptr);

        // Decrement index
        Value* next_idx = builder->CreateSub(body_idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_idx, idx_ptr);
        builder->CreateBr(loop_cond);

        // Loop end
        builder->SetInsertPoint(loop_end);
        return builder->CreateLoad(tagged_value_type, list_ptr);
    }

    // list->string: Convert list of characters to string
    Value* codegenListToString(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("list->string requires exactly 1 argument");
            return nullptr;
        }

        Value* list_arg = codegenAST(&op->call_op.variables[0]);
        if (!list_arg) return nullptr;

        // Ensure list_arg is a tagged value (codegenList returns i64 cons pointer)
        if (list_arg->getType() != tagged_value_type) {
            // It's an i64 cons pointer, pack it as tagged value
            list_arg = packPtrToTaggedValue(
                builder->CreateIntToPtr(list_arg, PointerType::get(*context, 0)),
                ESHKOL_VALUE_CONS_PTR);
        }

        Function* parent_func = builder->GetInsertBlock()->getParent();

        // First, count the length of the list
        BasicBlock* count_cond = BasicBlock::Create(*context, "lts_count_cond", parent_func);
        BasicBlock* count_body = BasicBlock::Create(*context, "lts_count_body", parent_func);
        BasicBlock* count_end = BasicBlock::Create(*context, "lts_count_end", parent_func);
        BasicBlock* fill_cond = BasicBlock::Create(*context, "lts_fill_cond", parent_func);
        BasicBlock* fill_body = BasicBlock::Create(*context, "lts_fill_body", parent_func);
        BasicBlock* fill_end = BasicBlock::Create(*context, "lts_fill_end", parent_func);

        // Create allocas at function entry
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        BasicBlock& entry = parent_func->getEntryBlock();
        builder->SetInsertPoint(&entry, entry.begin());
        Value* count_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "lts_count");
        Value* list_iter_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "lts_iter");
        Value* idx_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "lts_idx");
        builder->restoreIP(saved_ip);

        // Initialize count = 0, list_iter = list_arg
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), count_ptr);
        builder->CreateStore(list_arg, list_iter_ptr);
        builder->CreateBr(count_cond);

        // Count loop condition: while list is not nil
        builder->SetInsertPoint(count_cond);
        Value* iter_val = builder->CreateLoad(tagged_value_type, list_iter_ptr);
        Value* type_ptr = builder->CreateExtractValue(iter_val, {0});
        Value* is_nil = builder->CreateICmpEQ(type_ptr, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        builder->CreateCondBr(is_nil, count_end, count_body);

        // Count loop body: increment count, move to cdr
        builder->SetInsertPoint(count_body);
        Value* curr_count = builder->CreateLoad(Type::getInt64Ty(*context), count_ptr);
        Value* new_count = builder->CreateAdd(curr_count, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, count_ptr);

        // Get cdr of current cons cell
        Value* curr_iter = builder->CreateLoad(tagged_value_type, list_iter_ptr);
        Value* cons_ptr = builder->CreateExtractValue(curr_iter, {3});
        cons_ptr = builder->CreateIntToPtr(cons_ptr, PointerType::get(*context, 0));
        // cdr is at offset 16 (second tagged value in cons cell)
        Value* cdr_ptr = builder->CreateGEP(Type::getInt8Ty(*context), cons_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 16));
        cdr_ptr = builder->CreateBitCast(cdr_ptr, PointerType::get(tagged_value_type, 0));
        Value* cdr_val = builder->CreateLoad(tagged_value_type, cdr_ptr);
        builder->CreateStore(cdr_val, list_iter_ptr);
        builder->CreateBr(count_cond);

        // Count end: allocate string buffer
        builder->SetInsertPoint(count_end);
        Value* final_count = builder->CreateLoad(Type::getInt64Ty(*context), count_ptr);
        Value* buf_size = builder->CreateAdd(final_count, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Function* malloc_func = module->getFunction("malloc");
        Value* str_buf = builder->CreateCall(malloc_func, {buf_size});

        // Reset iterator and index for filling
        builder->CreateStore(list_arg, list_iter_ptr);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), idx_ptr);
        builder->CreateBr(fill_cond);

        // Fill loop condition
        builder->SetInsertPoint(fill_cond);
        Value* fill_iter = builder->CreateLoad(tagged_value_type, list_iter_ptr);
        Value* fill_type = builder->CreateExtractValue(fill_iter, {0});
        Value* fill_is_nil = builder->CreateICmpEQ(fill_type, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        builder->CreateCondBr(fill_is_nil, fill_end, fill_body);

        // Fill loop body: get car (character), store in buffer
        builder->SetInsertPoint(fill_body);
        Value* fill_curr = builder->CreateLoad(tagged_value_type, list_iter_ptr);
        Value* fill_cons_ptr = builder->CreateExtractValue(fill_curr, {3});
        fill_cons_ptr = builder->CreateIntToPtr(fill_cons_ptr, PointerType::get(*context, 0));

        // car is at offset 0
        Value* car_ptr = builder->CreateBitCast(fill_cons_ptr, PointerType::get(tagged_value_type, 0));
        Value* car_val = builder->CreateLoad(tagged_value_type, car_ptr);
        Value* char_data = builder->CreateExtractValue(car_val, {3});
        Value* char_byte = builder->CreateTrunc(char_data, Type::getInt8Ty(*context));

        // Store in buffer at current index
        Value* curr_idx = builder->CreateLoad(Type::getInt64Ty(*context), idx_ptr);
        Value* dest_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_buf, curr_idx);
        builder->CreateStore(char_byte, dest_ptr);

        // Increment index
        Value* next_idx = builder->CreateAdd(curr_idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_idx, idx_ptr);

        // Move to cdr
        Value* fill_cdr_ptr = builder->CreateGEP(Type::getInt8Ty(*context), fill_cons_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 16));
        fill_cdr_ptr = builder->CreateBitCast(fill_cdr_ptr, PointerType::get(tagged_value_type, 0));
        Value* fill_cdr = builder->CreateLoad(tagged_value_type, fill_cdr_ptr);
        builder->CreateStore(fill_cdr, list_iter_ptr);
        builder->CreateBr(fill_cond);

        // Fill end: add null terminator and return
        builder->SetInsertPoint(fill_end);
        Value* term_idx = builder->CreateLoad(Type::getInt64Ty(*context), idx_ptr);
        Value* term_ptr = builder->CreateGEP(Type::getInt8Ty(*context), str_buf, term_idx);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), term_ptr);

        return packPtrToTaggedValue(str_buf, ESHKOL_VALUE_STRING_PTR);
    }

    // ============================================================================
    // CHARACTER FUNCTIONS
    // ============================================================================

    // Helper: Pack a character (as integer codepoint) into tagged value
    Value* packCharToTaggedValue(Value* char_val) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();

        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }

        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "char_tagged");

        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);

        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CHAR), type_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), flags_ptr);
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(Type::getInt16Ty(*context), 0), reserved_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 3);

        // Ensure char_val is i64
        Value* char_as_i64;
        if (char_val->getType()->isIntegerTy(64)) {
            char_as_i64 = char_val;
        } else {
            char_as_i64 = builder->CreateZExt(char_val, Type::getInt64Ty(*context));
        }
        builder->CreateStore(char_as_i64, data_ptr);
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }

    // char->integer: Convert character to its Unicode codepoint
    Value* codegenCharToInteger(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("char->integer requires exactly 1 argument");
            return nullptr;
        }

        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;

        // Extract the integer value from the char's data field
        Value* char_val = unpackInt64FromTaggedValue(arg);
        return packInt64ToTaggedValue(char_val, true);
    }

    // integer->char: Convert integer to character
    Value* codegenIntegerToChar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("integer->char requires exactly 1 argument");
            return nullptr;
        }

        TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!tv.llvm_value) return nullptr;

        // Use the integer value directly
        return packCharToTaggedValue(tv.llvm_value);
    }

    // Character comparison
    Value* codegenCharCompare(const eshkol_operations_t* op, const std::string& cmp_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("Character comparison requires exactly 2 arguments");
            return nullptr;
        }

        Value* char1_arg = codegenAST(&op->call_op.variables[0]);
        Value* char2_arg = codegenAST(&op->call_op.variables[1]);
        if (!char1_arg || !char2_arg) return nullptr;

        Value* char1_val = unpackInt64FromTaggedValue(char1_arg);
        Value* char2_val = unpackInt64FromTaggedValue(char2_arg);

        Value* result;
        if (cmp_type == "eq") {
            result = builder->CreateICmpEQ(char1_val, char2_val);
        } else if (cmp_type == "lt") {
            result = builder->CreateICmpSLT(char1_val, char2_val);
        } else if (cmp_type == "gt") {
            result = builder->CreateICmpSGT(char1_val, char2_val);
        } else if (cmp_type == "le") {
            result = builder->CreateICmpSLE(char1_val, char2_val);
        } else if (cmp_type == "ge") {
            result = builder->CreateICmpSGE(char1_val, char2_val);
        } else {
            result = ConstantInt::get(Type::getInt1Ty(*context), 0);
        }

        return packBoolToTaggedValue(result);
    }

    // ============================================================================
    // SCHEME VECTOR FUNCTIONS (heterogeneous arrays)
    // ============================================================================

    // Vector structure: [i64 length][tagged_value_t elements...]
    // Each element is 16 bytes (tagged value struct)

    // make-vector: Create a vector of given size, optionally filled with a value
    Value* codegenMakeVector(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("make-vector requires 1 or 2 arguments");
            return nullptr;
        }

        TypedValue len_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!len_tv.llvm_value) return nullptr;

        Value* length = len_tv.llvm_value;

        // Calculate allocation size: 8 (length) + 16 * length (elements)
        Value* elem_size = ConstantInt::get(Type::getInt64Ty(*context), 16);
        Value* data_size = builder->CreateMul(length, elem_size);
        Value* total_size = builder->CreateAdd(data_size, ConstantInt::get(Type::getInt64Ty(*context), 8));

        // Allocate from arena
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* vec_ptr = builder->CreateCall(arena_allocate_func, {arena_ptr, total_size});

        // Store length at beginning
        Value* len_ptr = builder->CreateBitCast(vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        builder->CreateStore(length, len_ptr);

        // Get fill value (default to #f/0 if not provided)
        Value* fill_val;
        if (op->call_op.num_vars == 2) {
            fill_val = codegenAST(&op->call_op.variables[1]);
        } else {
            fill_val = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }

        // Fill loop - store fill_val at each element position
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_header = BasicBlock::Create(*context, "vec_fill_header", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "vec_fill_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "vec_fill_exit", current_func);

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(Type::getInt8Ty(*context), vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(tagged_value_type));

        builder->CreateBr(loop_header);

        builder->SetInsertPoint(loop_header);
        PHINode* i = builder->CreatePHI(Type::getInt64Ty(*context), 2, "fill_i");
        i->addIncoming(ConstantInt::get(Type::getInt64Ty(*context), 0),
            loop_header->getSinglePredecessor());
        Value* done = builder->CreateICmpUGE(i, length);
        builder->CreateCondBr(done, loop_exit, loop_body);

        builder->SetInsertPoint(loop_body);
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, i);
        builder->CreateStore(fill_val, elem_ptr);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        i->addIncoming(next_i, loop_body);
        builder->CreateBr(loop_header);

        builder->SetInsertPoint(loop_exit);
        return packPtrToTaggedValue(vec_ptr, ESHKOL_VALUE_VECTOR_PTR);
    }

    // vector: Create a vector from given elements
    Value* codegenVector(const eshkol_operations_t* op) {
        uint64_t num_elems = op->call_op.num_vars;

        // Calculate allocation size: 8 (length) + 16 * num_elems (elements)
        uint64_t total_size = 8 + 16 * num_elems;

        // Allocate from arena
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* vec_ptr = builder->CreateCall(arena_allocate_func,
            {arena_ptr, ConstantInt::get(Type::getInt64Ty(*context), total_size)});

        // Store length at beginning
        Value* len_ptr = builder->CreateBitCast(vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), num_elems), len_ptr);

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(Type::getInt8Ty(*context), vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(tagged_value_type));

        // Store each element - use codegenTypedAST to properly handle all types
        for (uint64_t i = 0; i < num_elems; i++) {
            TypedValue elem_tv = codegenTypedAST(&op->call_op.variables[i]);
            if (!elem_tv.llvm_value) return nullptr;

            // Convert TypedValue to tagged value for storage
            Value* tagged_elem = typedValueToTaggedValue(elem_tv);

            Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed,
                ConstantInt::get(Type::getInt64Ty(*context), i));
            builder->CreateStore(tagged_elem, elem_ptr);
        }

        return packPtrToTaggedValue(vec_ptr, ESHKOL_VALUE_VECTOR_PTR);
    }

    // vector-ref: Get element at index
    Value* codegenSchemeVectorRef(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("vector-ref requires exactly 2 arguments");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        if (!vec_arg || !idx_tv.llvm_value) return nullptr;

        // Extract vector pointer
        Value* vec_ptr_int = unpackInt64FromTaggedValue(vec_arg);
        Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(Type::getInt8Ty(*context), vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(tagged_value_type));

        // Get element at index
        Value* idx = idx_tv.llvm_value;
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, idx);
        return builder->CreateLoad(tagged_value_type, elem_ptr);
    }

    // vector-set!: Set element at index
    Value* codegenSchemeVectorSet(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("vector-set! requires exactly 3 arguments");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        TypedValue val_tv = codegenTypedAST(&op->call_op.variables[2]);
        if (!vec_arg || !idx_tv.llvm_value || !val_tv.llvm_value) return nullptr;

        // Extract vector pointer
        Value* vec_ptr_int = unpackInt64FromTaggedValue(vec_arg);
        Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(Type::getInt8Ty(*context), vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(tagged_value_type));

        // Convert value to tagged value for storage
        Value* tagged_val = typedValueToTaggedValue(val_tv);

        // Set element at index
        Value* idx = idx_tv.llvm_value;
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, idx);
        builder->CreateStore(tagged_val, elem_ptr);

        // Return unspecified (void) - return the vector
        return vec_arg;
    }

    // vector-length: Get length of vector
    Value* codegenVectorLength(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("vector-length requires exactly 1 argument");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        if (!vec_arg) return nullptr;

        // Extract vector pointer
        Value* vec_ptr_int = unpackInt64FromTaggedValue(vec_arg);
        Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

        // Load length from beginning
        Value* len_ptr = builder->CreateBitCast(vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* length = builder->CreateLoad(Type::getInt64Ty(*context), len_ptr);

        return packInt64ToTaggedValue(length, true);
    }

    // Numeric predicates
    Value* codegenNumericPredicate(const eshkol_operations_t* op, const std::string& pred) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("%s requires exactly 1 argument", pred.c_str());
            return nullptr;
        }

        // CRITICAL FIX: Use toDouble helper which handles raw int64/double/tagged_value
        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;

        Value* val = toDouble(arg);
        Value* zero = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        Value* result;

        if (pred == "positive?") {
            result = builder->CreateFCmpOGT(val, zero);
        } else if (pred == "negative?") {
            result = builder->CreateFCmpOLT(val, zero);
        } else if (pred == "zero?") {
            result = builder->CreateFCmpOEQ(val, zero);
        } else if (pred == "even?") {
            Value* int_val = builder->CreateFPToSI(val, Type::getInt64Ty(*context));
            Value* mod2 = builder->CreateSRem(int_val, ConstantInt::get(Type::getInt64Ty(*context), 2));
            result = builder->CreateICmpEQ(mod2, ConstantInt::get(Type::getInt64Ty(*context), 0));
        } else if (pred == "odd?") {
            Value* int_val = builder->CreateFPToSI(val, Type::getInt64Ty(*context));
            Value* mod2 = builder->CreateSRem(int_val, ConstantInt::get(Type::getInt64Ty(*context), 2));
            result = builder->CreateICmpNE(mod2, ConstantInt::get(Type::getInt64Ty(*context), 0));
        } else {
            result = ConstantInt::getFalse(*context);
        }

        return packBoolToTaggedValue(result);
    }

    // eq? - Identity comparison (pointer equality for lists, value equality for primitives)
    Value* codegenEq(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("eq? requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Types must be equal for eq?
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // Extract data fields (int64 representation)
        Value* data1 = unpackInt64FromTaggedValue(arg1);
        Value* data2 = unpackInt64FromTaggedValue(arg2);

        // For integers, cons pointers, null - compare data directly
        Value* data_equal = builder->CreateICmpEQ(data1, data2);

        // For doubles, use bitwise comparison (exact equality, not numeric)
        Value* is_double = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double1_bits = builder->CreateBitCast(double1, Type::getInt64Ty(*context));
        Value* double2_bits = builder->CreateBitCast(double2, Type::getInt64Ty(*context));
        Value* double_bits_equal = builder->CreateICmpEQ(double1_bits, double2_bits);

        // Select appropriate comparison based on type
        Value* value_equal = builder->CreateSelect(is_double, double_bits_equal, data_equal);

        // Both types and values must match
        Value* result = builder->CreateAnd(types_match, value_equal);

        return packBoolToTaggedValue(result);
    }

    // eqv? - Same as eq? in our implementation since we don't have characters
    // In Scheme, eqv? differs from eq? mainly for characters and some number cases
    Value* codegenEqv(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("eqv? requires exactly 2 arguments");
            return nullptr;
        }

        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // For eqv?, we check if types are "numeric compatible"
        // Both must be numbers for numeric comparison, otherwise types must match exactly
        Value* is_int1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
        Value* is_int2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
        Value* is_double1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* is_double2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

        // Both are numbers?
        Value* is_num1 = builder->CreateOr(is_int1, is_double1);
        Value* is_num2 = builder->CreateOr(is_int2, is_double2);
        Value* both_numbers = builder->CreateAnd(is_num1, is_num2);

        // For numbers with same type, compare values
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // For integers, compare int values
        Value* data1 = unpackInt64FromTaggedValue(arg1);
        Value* data2 = unpackInt64FromTaggedValue(arg2);
        Value* int_equal = builder->CreateICmpEQ(data1, data2);

        // For doubles, use numeric equality
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double_equal = builder->CreateFCmpOEQ(double1, double2);

        // Same-type number comparison
        Value* both_int = builder->CreateAnd(is_int1, is_int2);
        Value* both_double = builder->CreateAnd(is_double1, is_double2);
        Value* same_type_num_equal = builder->CreateSelect(both_double, double_equal, int_equal);

        // eqv? for numbers: same type and equal value
        Value* num_result = builder->CreateAnd(types_match, same_type_num_equal);

        // For non-numbers, fall back to eq? semantics (type + pointer/value equality)
        Value* non_num_result = builder->CreateAnd(types_match, int_equal);

        // Select based on whether we're comparing numbers
        Value* result = builder->CreateSelect(both_numbers, num_result, non_num_result);

        return packBoolToTaggedValue(result);
    }

    // equal? - Deep structural equality (iterative for lists)
    Value* codegenEqual(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("equal? requires exactly 2 arguments");
            return nullptr;
        }

        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Allocate storage for current positions (for list iteration)
        Value* current1_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "equal_cur1");
        Value* current2_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "equal_cur2");
        builder->CreateStore(arg1, current1_ptr);
        builder->CreateStore(arg2, current2_ptr);

        // Create ALL blocks upfront to avoid issues with dynamic block creation
        BasicBlock* loop_start = BasicBlock::Create(*context, "equal_loop", current_func);
        BasicBlock* check_one_null = BasicBlock::Create(*context, "equal_check_one_null", current_func);
        BasicBlock* check_cons = BasicBlock::Create(*context, "equal_check_cons", current_func);
        BasicBlock* both_null_block = BasicBlock::Create(*context, "equal_both_null", current_func);
        BasicBlock* both_cons_block = BasicBlock::Create(*context, "equal_both_cons", current_func);
        BasicBlock* cars_equal_block = BasicBlock::Create(*context, "equal_cars_equal", current_func);
        BasicBlock* primitive_block = BasicBlock::Create(*context, "equal_primitive", current_func);
        BasicBlock* not_equal_block = BasicBlock::Create(*context, "equal_not_equal", current_func);
        BasicBlock* equal_block = BasicBlock::Create(*context, "equal_true", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "equal_merge", current_func);

        builder->CreateBr(loop_start);

        // Loop start: load current values and check types
        builder->SetInsertPoint(loop_start);
        Value* cur1 = builder->CreateLoad(tagged_value_type, current1_ptr);
        Value* cur2 = builder->CreateLoad(tagged_value_type, current2_ptr);

        // Get types
        Value* type1 = getTaggedValueType(cur1);
        Value* type2 = getTaggedValueType(cur2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check for null
        Value* is_null1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        Value* is_null2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        Value* both_null = builder->CreateAnd(is_null1, is_null2);

        // If both are null -> equal
        builder->CreateCondBr(both_null, both_null_block, check_one_null);

        // Check if exactly one is null
        builder->SetInsertPoint(check_one_null);
        Value* one_null_only = builder->CreateXor(is_null1, is_null2);
        builder->CreateCondBr(one_null_only, not_equal_block, check_cons);

        // Check if both are cons cells
        builder->SetInsertPoint(check_cons);
        Value* is_cons1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* is_cons2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* both_cons = builder->CreateAnd(is_cons1, is_cons2);
        builder->CreateCondBr(both_cons, both_cons_block, primitive_block);

        // Both null: return true
        builder->SetInsertPoint(both_null_block);
        builder->CreateBr(equal_block);

        // Both cons: compare cars and continue with cdrs
        builder->SetInsertPoint(both_cons_block);
        Value* data1 = unpackInt64FromTaggedValue(cur1);
        Value* data2 = unpackInt64FromTaggedValue(cur2);

        Value* car1 = extractCarAsTaggedValue(data1);
        Value* car2 = extractCarAsTaggedValue(data2);

        // Compare cars using polymorphicCompare
        Value* car_cmp = polymorphicCompare(car1, car2, "eq");
        Value* car_equal_int = unpackInt64FromTaggedValue(car_cmp);
        Value* car_equal = builder->CreateICmpNE(car_equal_int,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(car_equal, cars_equal_block, not_equal_block);

        // Cars are equal, get cdrs and loop
        builder->SetInsertPoint(cars_equal_block);
        Value* cdr1 = extractCdrAsTaggedValue(data1);
        Value* cdr2 = extractCdrAsTaggedValue(data2);
        builder->CreateStore(cdr1, current1_ptr);
        builder->CreateStore(cdr2, current2_ptr);
        builder->CreateBr(loop_start);

        // Primitive comparison (neither null nor cons)
        builder->SetInsertPoint(primitive_block);
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // Check for double type
        Value* is_double = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

        Value* prim_data1 = unpackInt64FromTaggedValue(cur1);
        Value* prim_data2 = unpackInt64FromTaggedValue(cur2);
        Value* int_equal = builder->CreateICmpEQ(prim_data1, prim_data2);

        Value* double1 = unpackDoubleFromTaggedValue(cur1);
        Value* double2 = unpackDoubleFromTaggedValue(cur2);
        Value* double_equal = builder->CreateFCmpOEQ(double1, double2);

        Value* value_equal = builder->CreateSelect(is_double, double_equal, int_equal);
        Value* prim_result = builder->CreateAnd(types_match, value_equal);
        builder->CreateCondBr(prim_result, equal_block, not_equal_block);

        // Equal block
        builder->SetInsertPoint(equal_block);
        builder->CreateBr(merge_block);

        // Not equal block
        builder->SetInsertPoint(not_equal_block);
        builder->CreateBr(merge_block);

        // Merge block
        builder->SetInsertPoint(merge_block);
        PHINode* result_phi = builder->CreatePHI(Type::getInt1Ty(*context), 2);
        result_phi->addIncoming(ConstantInt::getTrue(*context), equal_block);
        result_phi->addIncoming(ConstantInt::getFalse(*context), not_equal_block);

        return packBoolToTaggedValue(result_phi);
    }

    Value* codegenNewline(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 0) {
            eshkol_warn("newline takes no arguments");
            return nullptr;
        }
        
        // Use printf to print a newline
        Function* printf_func = function_table["printf"];
        if (!printf_func) return nullptr;
        
        return builder->CreateCall(printf_func, {
            codegenString("\n")
        });
    }

    Value* codegenError(const eshkol_operations_t* op) {
        Function* printf_func = function_table["printf"];
        Function* exit_func = function_table["exit"];
        if (!printf_func || !exit_func) return nullptr;

        // Print "Error: " prefix
        builder->CreateCall(printf_func, {
            codegenString("Error: ")
        });

        // Display all arguments (message and irritants)
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            TypedValue arg = codegenTypedAST(&op->call_op.variables[i]);
            if (!arg.llvm_value) continue;

            Value* tagged_arg = typedValueToTaggedValue(arg);
            if (!tagged_arg) continue;

            // Extract type and data from tagged value
            Value* type_byte = builder->CreateExtractValue(tagged_arg, {0});
            Value* data_i64 = builder->CreateExtractValue(tagged_arg, {3});

            // Check if it's a string (type == ESHKOL_VALUE_STRING_PTR)
            Value* is_string = builder->CreateICmpEQ(type_byte,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR));

            Function* current_func = builder->GetInsertBlock()->getParent();
            // Check if it's a double (type == ESHKOL_VALUE_DOUBLE)
            Value* is_double = builder->CreateICmpEQ(type_byte,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));

            BasicBlock* string_block = BasicBlock::Create(*context, "error_string", current_func);
            BasicBlock* check_double_block = BasicBlock::Create(*context, "error_check_double", current_func);
            BasicBlock* double_block = BasicBlock::Create(*context, "error_double", current_func);
            BasicBlock* int_block = BasicBlock::Create(*context, "error_int", current_func);
            BasicBlock* done_block = BasicBlock::Create(*context, "error_done", current_func);

            builder->CreateCondBr(is_string, string_block, check_double_block);

            // String case: print as %s
            builder->SetInsertPoint(string_block);
            Value* str_ptr = builder->CreateIntToPtr(data_i64, PointerType::get(*context, 0));
            builder->CreateCall(printf_func, {codegenString("%s"), str_ptr});
            builder->CreateBr(done_block);

            // Check if double
            builder->SetInsertPoint(check_double_block);
            builder->CreateCondBr(is_double, double_block, int_block);

            // Double case: print as %g
            builder->SetInsertPoint(double_block);
            Value* as_double = builder->CreateBitCast(data_i64, Type::getDoubleTy(*context));
            builder->CreateCall(printf_func, {codegenString("%g"), as_double});
            builder->CreateBr(done_block);

            // Integer case: print as %lld
            builder->SetInsertPoint(int_block);
            builder->CreateCall(printf_func, {codegenString("%lld"), data_i64});
            builder->CreateBr(done_block);

            builder->SetInsertPoint(done_block);

            // Add space between arguments
            if (i < op->call_op.num_vars - 1) {
                builder->CreateCall(printf_func, {codegenString(" ")});
            }
        }

        // Print newline
        builder->CreateCall(printf_func, {codegenString("\n")});

        // Call exit(1) to terminate the program
        builder->CreateCall(exit_func, {
            ConstantInt::get(Type::getInt32Ty(*context), 1)
        });

        // Mark as unreachable since exit never returns
        builder->CreateUnreachable();

        // Create a new unreachable block for any subsequent code
        // This allows error to be used in branches without breaking the IR
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* dead_block = BasicBlock::Create(*context, "error_dead", current_func);
        builder->SetInsertPoint(dead_block);

        // Return a void value (though we'll never reach this)
        return ConstantPointerNull::get(PointerType::get(*context, 0));
    }

    // ========================================================================
    // FILE I/O OPERATIONS
    // ========================================================================

    // Port type: we use a tagged value with type ESHKOL_VALUE_CONS_PTR to store FILE*
    // The data field holds the FILE* pointer as an i64

    Value* codegenOpenInputFile(const eshkol_operations_t* op) {
        // (open-input-file filename) -> port
        if (op->call_op.num_vars != 1) {
            eshkol_warn("open-input-file requires exactly 1 argument");
            return nullptr;
        }

        Function* fopen_func = function_table["fopen"];
        if (!fopen_func) return nullptr;

        // Get filename argument (should be a string)
        TypedValue filename_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!filename_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(filename_tv);
        Value* filename_ptr = builder->CreateIntToPtr(
            builder->CreateExtractValue(tagged, {3}),
            PointerType::get(*context, 0));

        // Call fopen with "r" mode
        Value* mode = codegenString("r");
        Value* file_ptr = builder->CreateCall(fopen_func, {filename_ptr, mode});

        // Convert FILE* to i64 for storage in tagged value
        Value* file_ptr_int = builder->CreatePtrToInt(file_ptr, Type::getInt64Ty(*context));

        // Pack as a tagged value with a special "port" type
        // We'll use ESHKOL_VALUE_CONS_PTR + 0x10 flag to indicate it's a port
        Value* result = UndefValue::get(tagged_value_type);
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR | 0x10), {0}); // type = port
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt8Ty(*context), 0), {1}); // flags
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt16Ty(*context), 0), {2}); // reserved
        result = builder->CreateInsertValue(result, file_ptr_int, {3}); // data = FILE*

        return result;
    }

    Value* codegenReadLine(const eshkol_operations_t* op) {
        // (read-line port) -> string or eof-object
        if (op->call_op.num_vars != 1) {
            eshkol_warn("read-line requires exactly 1 argument");
            return nullptr;
        }

        Function* fgets_func = function_table["fgets"];
        Function* strlen_func = function_table["strlen"];
        Function* malloc_func = function_table["malloc"];
        if (!fgets_func || !strlen_func || !malloc_func) return nullptr;

        // Get port argument
        TypedValue port_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!port_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(port_tv);
        Value* file_ptr_int = builder->CreateExtractValue(tagged, {3});
        Value* file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));

        // Allocate a buffer for reading (1024 bytes)
        Value* buffer_size = ConstantInt::get(Type::getInt64Ty(*context), 1024);
        Value* buffer = builder->CreateCall(malloc_func, {buffer_size});

        // Call fgets
        Value* result_ptr = builder->CreateCall(fgets_func, {
            buffer,
            ConstantInt::get(Type::getInt32Ty(*context), 1024),
            file_ptr
        });

        // Check if fgets returned NULL (EOF or error)
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* eof_block = BasicBlock::Create(*context, "read_eof", current_func);
        BasicBlock* success_block = BasicBlock::Create(*context, "read_success", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "read_done", current_func);

        Value* is_null = builder->CreateICmpEQ(result_ptr,
            ConstantPointerNull::get(PointerType::get(*context, 0)));
        builder->CreateCondBr(is_null, eof_block, success_block);

        // EOF case: return eof-object (tagged value with type 0xFF)
        builder->SetInsertPoint(eof_block);
        Value* eof_result = UndefValue::get(tagged_value_type);
        eof_result = builder->CreateInsertValue(eof_result,
            ConstantInt::get(Type::getInt8Ty(*context), 0xFF), {0}); // type = eof-object
        eof_result = builder->CreateInsertValue(eof_result,
            ConstantInt::get(Type::getInt8Ty(*context), 0), {1});
        eof_result = builder->CreateInsertValue(eof_result,
            ConstantInt::get(Type::getInt16Ty(*context), 0), {2});
        eof_result = builder->CreateInsertValue(eof_result,
            ConstantInt::get(Type::getInt64Ty(*context), 0), {3});
        builder->CreateBr(done_block);

        // Success case: strip newline and return string
        builder->SetInsertPoint(success_block);

        // Get string length
        Value* len = builder->CreateCall(strlen_func, {buffer});

        // Strip trailing newline if present
        Value* last_idx = builder->CreateSub(len, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* last_char_ptr = builder->CreateGEP(Type::getInt8Ty(*context), buffer, last_idx);
        Value* last_char = builder->CreateLoad(Type::getInt8Ty(*context), last_char_ptr);
        Value* is_newline = builder->CreateICmpEQ(last_char, ConstantInt::get(Type::getInt8Ty(*context), '\n'));

        BasicBlock* strip_block = BasicBlock::Create(*context, "strip_newline", current_func);
        BasicBlock* no_strip_block = BasicBlock::Create(*context, "no_strip", current_func);
        builder->CreateCondBr(is_newline, strip_block, no_strip_block);

        builder->SetInsertPoint(strip_block);
        builder->CreateStore(ConstantInt::get(Type::getInt8Ty(*context), 0), last_char_ptr);
        builder->CreateBr(no_strip_block);

        builder->SetInsertPoint(no_strip_block);

        // Pack string as tagged value
        Value* buffer_int = builder->CreatePtrToInt(buffer, Type::getInt64Ty(*context));
        Value* str_result = UndefValue::get(tagged_value_type);
        str_result = builder->CreateInsertValue(str_result,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_STRING_PTR), {0});
        str_result = builder->CreateInsertValue(str_result,
            ConstantInt::get(Type::getInt8Ty(*context), 0), {1});
        str_result = builder->CreateInsertValue(str_result,
            ConstantInt::get(Type::getInt16Ty(*context), 0), {2});
        str_result = builder->CreateInsertValue(str_result, buffer_int, {3});
        builder->CreateBr(done_block);

        // Done block with PHI
        builder->SetInsertPoint(done_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "read_result");
        phi->addIncoming(eof_result, eof_block);
        phi->addIncoming(str_result, no_strip_block);

        return phi;
    }

    Value* codegenClosePort(const eshkol_operations_t* op) {
        // (close-port port) -> void
        if (op->call_op.num_vars != 1) {
            eshkol_warn("close-port requires exactly 1 argument");
            return nullptr;
        }

        Function* fclose_func = function_table["fclose"];
        if (!fclose_func) return nullptr;

        // Get port argument
        TypedValue port_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!port_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(port_tv);
        Value* file_ptr_int = builder->CreateExtractValue(tagged, {3});
        Value* file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));

        // Call fclose
        builder->CreateCall(fclose_func, {file_ptr});

        // Return void as tagged value (0)
        return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }

    Value* codegenEofObject(const eshkol_operations_t* op) {
        // (eof-object? obj) -> boolean
        if (op->call_op.num_vars != 1) {
            eshkol_warn("eof-object? requires exactly 1 argument");
            return nullptr;
        }

        // Get argument
        TypedValue arg_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!arg_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(arg_tv);
        Value* type_byte = builder->CreateExtractValue(tagged, {0});

        // Check if type is 0xFF (eof-object)
        Value* is_eof = builder->CreateICmpEQ(type_byte,
            ConstantInt::get(Type::getInt8Ty(*context), 0xFF));

        // Return 1 for true, 0 for false as tagged value
        Value* result_int = builder->CreateSelect(is_eof,
            ConstantInt::get(Type::getInt64Ty(*context), 1),
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        return packInt64ToTaggedValue(result_int, true);
    }

    // ========================================================================
    // FILE OUTPUT OPERATIONS
    // ========================================================================

    Value* codegenOpenOutputFile(const eshkol_operations_t* op) {
        // (open-output-file filename) -> port
        if (op->call_op.num_vars != 1) {
            eshkol_warn("open-output-file requires exactly 1 argument");
            return nullptr;
        }

        Function* fopen_func = function_table["fopen"];
        if (!fopen_func) return nullptr;

        // Get filename argument (should be a string)
        TypedValue filename_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!filename_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(filename_tv);
        Value* filename_ptr = builder->CreateIntToPtr(
            builder->CreateExtractValue(tagged, {3}),
            PointerType::get(*context, 0));

        // Call fopen with "w" mode for writing
        Value* mode = codegenString("w");
        Value* file_ptr = builder->CreateCall(fopen_func, {filename_ptr, mode});

        // Convert FILE* to i64 for storage in tagged value
        Value* file_ptr_int = builder->CreatePtrToInt(file_ptr, Type::getInt64Ty(*context));

        // Pack as a tagged value with port type (CONS_PTR | 0x10)
        // Use 0x20 flag to indicate output port (vs 0x10 for input port)
        Value* result = UndefValue::get(tagged_value_type);
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR | 0x20), {0}); // type = output port
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt8Ty(*context), 0), {1}); // flags
        result = builder->CreateInsertValue(result,
            ConstantInt::get(Type::getInt16Ty(*context), 0), {2}); // reserved
        result = builder->CreateInsertValue(result, file_ptr_int, {3}); // data = FILE*

        return result;
    }

    Value* codegenWriteString(const eshkol_operations_t* op) {
        // (write-string str port) -> unspecified
        // Also supports (write-string str) which writes to stdout
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("write-string requires 1 or 2 arguments");
            return nullptr;
        }

        Function* fputs_func = function_table["fputs"];
        if (!fputs_func) return nullptr;

        // Get string argument
        TypedValue str_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!str_tv.llvm_value) return nullptr;

        Value* tagged_str = typedValueToTaggedValue(str_tv);
        Value* str_ptr = builder->CreateIntToPtr(
            builder->CreateExtractValue(tagged_str, {3}),
            PointerType::get(*context, 0));

        Value* file_ptr;
        if (op->call_op.num_vars == 2) {
            // Get port argument
            TypedValue port_tv = codegenTypedAST(&op->call_op.variables[1]);
            if (!port_tv.llvm_value) return nullptr;

            Value* tagged_port = typedValueToTaggedValue(port_tv);
            Value* file_ptr_int = builder->CreateExtractValue(tagged_port, {3});
            file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));
        } else {
            // Write to stdout
            Function* main_func = module->getFunction("main");
            GlobalVariable* stdout_var = module->getGlobalVariable("stdout");
            if (!stdout_var) {
                // Declare extern FILE* stdout
                stdout_var = new GlobalVariable(
                    *module, PointerType::get(*context, 0), false,
                    GlobalVariable::ExternalLinkage, nullptr, "stdout");
            }
            file_ptr = builder->CreateLoad(PointerType::get(*context, 0), stdout_var);
        }

        // Call fputs
        builder->CreateCall(fputs_func, {str_ptr, file_ptr});

        // Return void as tagged value (0)
        return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }

    Value* codegenWriteLine(const eshkol_operations_t* op) {
        // (write-line str port) -> unspecified
        // Writes string followed by newline
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("write-line requires 1 or 2 arguments");
            return nullptr;
        }

        Function* fputs_func = function_table["fputs"];
        Function* fputc_func = function_table["fputc"];
        if (!fputs_func || !fputc_func) return nullptr;

        // Get string argument
        TypedValue str_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!str_tv.llvm_value) return nullptr;

        Value* tagged_str = typedValueToTaggedValue(str_tv);
        Value* str_ptr = builder->CreateIntToPtr(
            builder->CreateExtractValue(tagged_str, {3}),
            PointerType::get(*context, 0));

        Value* file_ptr;
        if (op->call_op.num_vars == 2) {
            // Get port argument
            TypedValue port_tv = codegenTypedAST(&op->call_op.variables[1]);
            if (!port_tv.llvm_value) return nullptr;

            Value* tagged_port = typedValueToTaggedValue(port_tv);
            Value* file_ptr_int = builder->CreateExtractValue(tagged_port, {3});
            file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));
        } else {
            // Write to stdout
            GlobalVariable* stdout_var = module->getGlobalVariable("stdout");
            if (!stdout_var) {
                stdout_var = new GlobalVariable(
                    *module, PointerType::get(*context, 0), false,
                    GlobalVariable::ExternalLinkage, nullptr, "stdout");
            }
            file_ptr = builder->CreateLoad(PointerType::get(*context, 0), stdout_var);
        }

        // Call fputs for string, then fputc for newline
        builder->CreateCall(fputs_func, {str_ptr, file_ptr});
        builder->CreateCall(fputc_func, {
            ConstantInt::get(Type::getInt32Ty(*context), '\n'),
            file_ptr
        });

        // Return void as tagged value (0)
        return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }

    Value* codegenWriteChar(const eshkol_operations_t* op) {
        // (write-char char port) -> unspecified
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("write-char requires 1 or 2 arguments");
            return nullptr;
        }

        Function* fputc_func = function_table["fputc"];
        if (!fputc_func) return nullptr;

        // Get char argument
        TypedValue char_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!char_tv.llvm_value) return nullptr;

        Value* char_val;
        if (char_tv.llvm_value->getType()->isIntegerTy(64)) {
            char_val = builder->CreateTrunc(char_tv.llvm_value, Type::getInt32Ty(*context));
        } else if (char_tv.llvm_value->getType()->isIntegerTy(32)) {
            char_val = char_tv.llvm_value;
        } else {
            // Handle tagged value
            Value* tagged = typedValueToTaggedValue(char_tv);
            Value* data = builder->CreateExtractValue(tagged, {3});
            char_val = builder->CreateTrunc(data, Type::getInt32Ty(*context));
        }

        Value* file_ptr;
        if (op->call_op.num_vars == 2) {
            // Get port argument
            TypedValue port_tv = codegenTypedAST(&op->call_op.variables[1]);
            if (!port_tv.llvm_value) return nullptr;

            Value* tagged_port = typedValueToTaggedValue(port_tv);
            Value* file_ptr_int = builder->CreateExtractValue(tagged_port, {3});
            file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));
        } else {
            // Write to stdout
            GlobalVariable* stdout_var = module->getGlobalVariable("stdout");
            if (!stdout_var) {
                stdout_var = new GlobalVariable(
                    *module, PointerType::get(*context, 0), false,
                    GlobalVariable::ExternalLinkage, nullptr, "stdout");
            }
            file_ptr = builder->CreateLoad(PointerType::get(*context, 0), stdout_var);
        }

        // Call fputc
        builder->CreateCall(fputc_func, {char_val, file_ptr});

        // Return void as tagged value (0)
        return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }

    Value* codegenFlushOutputPort(const eshkol_operations_t* op) {
        // (flush-output-port port) -> unspecified
        if (op->call_op.num_vars != 1) {
            eshkol_warn("flush-output-port requires exactly 1 argument");
            return nullptr;
        }

        // Declare fflush if not already declared
        Function* fflush_func = function_table["fflush"];
        if (!fflush_func) {
            std::vector<Type*> fflush_args;
            fflush_args.push_back(PointerType::get(*context, 0));
            FunctionType* fflush_type = FunctionType::get(
                Type::getInt32Ty(*context), fflush_args, false);
            fflush_func = Function::Create(
                fflush_type, Function::ExternalLinkage, "fflush", module.get());
            function_table["fflush"] = fflush_func;
        }

        // Get port argument
        TypedValue port_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!port_tv.llvm_value) return nullptr;

        Value* tagged = typedValueToTaggedValue(port_tv);
        Value* file_ptr_int = builder->CreateExtractValue(tagged, {3});
        Value* file_ptr = builder->CreateIntToPtr(file_ptr_int, PointerType::get(*context, 0));

        // Call fflush
        builder->CreateCall(fflush_func, {file_ptr});

        // Return void as tagged value (0)
        return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }

    Value* codegenSequence(const eshkol_operations_t* op) {
        Value* last_value = nullptr;
        
        for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
            last_value = codegenAST(&op->sequence_op.expressions[i]);
        }
        
        return last_value;
    }

    Value* codegenExternVar(const eshkol_operations_t* op) {
        const char* var_name = op->extern_var_op.name;

        // Check if the variable is already in the symbol table
        auto it = symbol_table.find(var_name);
        if (it != symbol_table.end()) {
            return it->second;
        }

        // Map type strings to LLVM types
        auto mapStringToType = [this](const char* type_str) -> Type* {
            if (strcmp(type_str, "int") == 0) return Type::getInt32Ty(*context);
            if (strcmp(type_str, "long") == 0) return Type::getInt64Ty(*context);
            if (strcmp(type_str, "float") == 0) return Type::getFloatTy(*context);
            if (strcmp(type_str, "double") == 0) return Type::getDoubleTy(*context);
            if (strcmp(type_str, "char*") == 0 || strcmp(type_str, "string") == 0) {
                return PointerType::getUnqual(*context); // char*
            }
            // Default to int32 for unknown types
            eshkol_warn("Unknown type '%s', defaulting to int32", type_str);
            return Type::getInt32Ty(*context);
        };

        // Get the LLVM type based on the operation's type string
        Type* var_type = mapStringToType(op->extern_var_op.type);

        // Create a global variable with external linkage
        GlobalVariable* externVar = new GlobalVariable(
            *module,
            var_type,
            false, // isConstant
            GlobalValue::ExternalLinkage,
            nullptr,
            var_name
        );

        // Add to symbol table so it can be used later
        symbol_table[var_name] = externVar;                                                                 
                                                                                                        
        eshkol_debug("Declared external variable: %s with type %s", var_name, op->extern_var_op.type);

        return externVar;
    }                        
    
    Value* codegenExtern(const eshkol_operations_t* op) {
        const char* return_type_str = op->extern_op.return_type;
        const char* func_name = op->extern_op.name;
        const char* real_func_name = op->extern_op.real_name ? op->extern_op.real_name : func_name;
        uint64_t num_params = op->extern_op.num_params;

        bool is_vaarg = false;
        
        eshkol_debug("Creating external function declaration: %s (real: %s)", func_name, real_func_name);
        
        // Map type strings to LLVM types
        auto mapStringToType = [this](const char* type_str) -> Type* {
            if (strcmp(type_str, "void") == 0) return Type::getVoidTy(*context);
            if (strcmp(type_str, "int") == 0) return Type::getInt32Ty(*context);
            if (strcmp(type_str, "long") == 0) return Type::getInt64Ty(*context);
            if (strcmp(type_str, "float") == 0) return Type::getFloatTy(*context);
            if (strcmp(type_str, "double") == 0) return Type::getDoubleTy(*context);
            if (strcmp(type_str, "char*") == 0 || strcmp(type_str, "string") == 0) {
                return PointerType::getUnqual(*context);
            }
            if (strcmp(type_str, "...") == 0) return nullptr;
            // Default to int64 for unknown types
            eshkol_warn("Unknown type '%s', defaulting to int64", type_str);
            return Type::getInt64Ty(*context);
        };
        
        // Get return type
        Type* return_type = mapStringToType(return_type_str);
        
        // Get parameter types
        std::vector<Type*> param_types;
        for (uint64_t i = 0; i < num_params; i++) {
            if (op->extern_op.parameters[i].type == ESHKOL_STRING) {
                Type* param_type = mapStringToType(op->extern_op.parameters[i].str_val.ptr);
                if (param_type != nullptr)
                    param_types.push_back(param_type);
                else
                    is_vaarg = true;
            } else {
                eshkol_warn("Parameter type must be a string, defaulting to int64");
                param_types.push_back(Type::getInt64Ty(*context));
            }
        }
        
        // Create function type
        FunctionType* func_type = FunctionType::get(
            return_type, param_types, is_vaarg
        );
        
        // Create function declaration using the real function name
        Function* extern_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            real_func_name,
            module.get()
        );
        
        // Add to function table using the given name so it can be called by that name
        function_table[func_name] = extern_func;
        
        eshkol_info("Declared external function: %s (real: %s) with %llu parameters", 
                   func_name, real_func_name, (unsigned long long)num_params);
        
        // extern declarations don't return a value at runtime, just nullptr
        return nullptr;
    }
    
    Value* codegenIfCall(const eshkol_operations_t* op) {
        // Handle if as a function call: (if condition then-expr else-expr)
        if (op->call_op.num_vars != 3) {
            eshkol_warn("if requires exactly 3 arguments: condition, then-expr, else-expr");
            return nullptr;
        }
        
        // Generate condition
        Value* condition = codegenAST(&op->call_op.variables[0]);
        if (!condition) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* condition_int = safeExtractInt64(condition);
        
        // Convert condition to boolean (non-zero is true)
        Value* cond_bool = builder->CreateICmpNE(condition_int,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        // Get current function for creating basic blocks
        Function* function = builder->GetInsertBlock()->getParent();
        
        // Create basic blocks for then, else, and merge
        BasicBlock* then_block = BasicBlock::Create(*context, "then", function);
        BasicBlock* else_block = BasicBlock::Create(*context, "else", function);
        BasicBlock* merge_block = BasicBlock::Create(*context, "ifcont", function);
        
        // Create conditional branch
        builder->CreateCondBr(cond_bool, then_block, else_block);
        
        // Generate then block
        builder->SetInsertPoint(then_block);
        Value* then_value = codegenAST(&op->call_op.variables[1]);
        if (!then_value) {
            then_value = ConstantInt::get(Type::getInt64Ty(*context), 0);
        }

        builder->CreateBr(merge_block);
        then_block = builder->GetInsertBlock(); // Update in case of nested blocks

        // Generate else block
        builder->SetInsertPoint(else_block);
        Value* else_value = codegenAST(&op->call_op.variables[2]);
        if (!else_value) {
            else_value = ConstantInt::get(Type::getInt64Ty(*context), 0);
        }

        builder->CreateBr(merge_block);
        else_block = builder->GetInsertBlock(); // Update in case of nested blocks

        // Determine result type - prefer tagged_value_type to preserve type info
        Type* result_type;
        if (then_value->getType() == tagged_value_type || else_value->getType() == tagged_value_type) {
            result_type = tagged_value_type;
        } else {
            result_type = Type::getInt64Ty(*context);
        }

        // Convert values to result_type if needed
        auto convertToResultType = [&](Value* val, BasicBlock* block) -> Value* {
            if (val->getType() == result_type) return val;

            // Need to insert conversion at the end of the original block (before the branch)
            BasicBlock* current_block = builder->GetInsertBlock();
            builder->SetInsertPoint(block->getTerminator());

            Value* converted;
            if (result_type == tagged_value_type) {
                // Convert to tagged_value
                if (val->getType()->isIntegerTy(64)) {
                    converted = packInt64ToTaggedValue(val, true);
                } else if (val->getType()->isDoubleTy()) {
                    converted = packDoubleToTaggedValue(val);
                } else if (val->getType()->isIntegerTy()) {
                    Value* extended = builder->CreateSExt(val, Type::getInt64Ty(*context));
                    converted = packInt64ToTaggedValue(extended, true);
                } else {
                    converted = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
                }
            } else {
                // Convert to i64
                if (val->getType() == tagged_value_type) {
                    converted = safeExtractInt64(val);
                } else if (val->getType()->isIntegerTy()) {
                    if (val->getType()->getIntegerBitWidth() < 64) {
                        converted = builder->CreateSExt(val, result_type);
                    } else {
                        converted = builder->CreateTrunc(val, result_type);
                    }
                } else {
                    converted = ConstantInt::get(result_type, 0);
                }
            }

            builder->SetInsertPoint(current_block);
            return converted;
        };

        then_value = convertToResultType(then_value, then_block);
        else_value = convertToResultType(else_value, else_block);

        // Generate merge block with PHI node
        builder->SetInsertPoint(merge_block);
        PHINode* phi = builder->CreatePHI(result_type, 2, "iftmp");
        phi->addIncoming(then_value, then_block);
        phi->addIncoming(else_value, else_block);

        return phi;
    }
    
    Value* codegenBegin(const eshkol_operations_t* op) {
        // Handle begin sequence: (begin expr1 expr2 ... exprN)
        // Execute all expressions and return the value of the last one
        if (op->call_op.num_vars == 0) {
            eshkol_warn("begin requires at least 1 expression");
            return ConstantInt::get(Type::getInt64Ty(*context), 0);
        }
        
        Value* last_value = nullptr;
        
        // Execute all expressions in sequence
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            last_value = codegenAST(&op->call_op.variables[i]);
        }
        
        // Return the value of the last expression
        return last_value ? last_value : ConstantInt::get(Type::getInt64Ty(*context), 0);
    }
    
    Value* codegenCons(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("cons requires exactly 2 arguments");
            return nullptr;
        }
        
        // Generate car and cdr with type information
        TypedValue car_typed = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue cdr_typed = codegenTypedAST(&op->call_op.variables[1]);
        
        if (!car_typed.llvm_value || !cdr_typed.llvm_value) return nullptr;
        
        // Use tagged arena-based allocation for cons cell with type preservation
        return codegenTaggedArenaConsCell(car_typed, cdr_typed);
    }
    
    Value* codegenCar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("car requires exactly 1 argument");
            return nullptr;
        }
        
        Value* pair_int = codegenAST(&op->call_op.variables[0]);
        if (!pair_int) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* pair_int_safe = safeExtractInt64(pair_int);
        
        // SAFETY CHECK: Ensure pair_int is not null (0) before dereferencing
        Value* is_null = builder->CreateICmpEQ(pair_int_safe, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* null_block = BasicBlock::Create(*context, "car_null", current_func);
        BasicBlock* valid_block = BasicBlock::Create(*context, "car_valid", current_func);
        BasicBlock* continue_block = BasicBlock::Create(*context, "car_continue", current_func);
        
        builder->CreateCondBr(is_null, null_block, valid_block);
        
        // Null block: return 0 (null) for safety - pack as tagged value
        builder->SetInsertPoint(null_block);
        Value* null_result = ConstantInt::get(Type::getInt64Ty(*context), 0);
        Value* null_tagged = packInt64ToTaggedValue(null_result, true);
        builder->CreateBr(continue_block);
        
        // Valid block: use TAGGED cons cell to extract car with proper type
        builder->SetInsertPoint(valid_block);
        
        // Convert pair_int to pointer
        Value* cons_ptr = builder->CreateIntToPtr(pair_int_safe, builder->getPtrTy());
        
        // Get car type using arena_tagged_cons_get_type(cell, false)
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 0); // false = car
        Value* car_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_cdr});
        
        // Mask out flags to get base type (type & 0x0F), matching C macro ESHKOL_GET_BASE_TYPE
        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // FIX: Check for all three types: DOUBLE, CONS_PTR, INT64
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* car_is_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        
        BasicBlock* double_car = BasicBlock::Create(*context, "car_extract_double", current_func);
        BasicBlock* check_ptr_car = BasicBlock::Create(*context, "car_check_ptr", current_func);
        BasicBlock* ptr_car = BasicBlock::Create(*context, "car_extract_ptr", current_func);
        BasicBlock* int_car = BasicBlock::Create(*context, "car_extract_int", current_func);
        BasicBlock* merge_car = BasicBlock::Create(*context, "car_merge", current_func);
        
        builder->CreateCondBr(car_is_double, double_car, check_ptr_car);
        
        // Extract double car and pack into tagged value
        builder->SetInsertPoint(double_car);
        Value* car_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_cdr});
        Value* tagged_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(merge_car);
        BasicBlock* double_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_ptr_car);
        builder->CreateCondBr(car_is_ptr, ptr_car, int_car);
        
        builder->SetInsertPoint(ptr_car);
        Value* car_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        // CRITICAL FIX: Use packPtrToTaggedValue with CONS_PTR type, not packInt64ToTaggedValue!
        // This preserves the list type so display knows to recursively print the list contents
        Value* tagged_ptr = packPtrToTaggedValue(builder->CreateIntToPtr(car_ptr, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* ptr_exit = builder->GetInsertBlock();
        
        // Extract int64 car and pack into tagged value
        builder->SetInsertPoint(int_car);
        Value* car_int64 = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_cdr});
        Value* tagged_int64 = packInt64ToTaggedValue(car_int64, true);
        builder->CreateBr(merge_car);
        BasicBlock* int_exit = builder->GetInsertBlock();
        
        // Merge: return tagged value struct (can merge because all are same struct type!)
        builder->SetInsertPoint(merge_car);
        PHINode* car_tagged_phi = builder->CreatePHI(tagged_value_type, 3);
        car_tagged_phi->addIncoming(tagged_double, double_exit);
        car_tagged_phi->addIncoming(tagged_ptr, ptr_exit);
        car_tagged_phi->addIncoming(tagged_int64, int_exit);
        
        Value* car_result = car_tagged_phi;
        builder->CreateBr(continue_block);
        
        // Continue block: use PHI to select result (tagged value or null tagged value)
        builder->SetInsertPoint(continue_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2);
        phi->addIncoming(null_tagged, null_block);
        phi->addIncoming(car_result, merge_car);
        
        return phi;
    }
    
    Value* codegenCdr(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("cdr requires exactly 1 argument");
            return nullptr;
        }
        
        Value* pair_int = codegenAST(&op->call_op.variables[0]);
        if (!pair_int) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* pair_int_safe = safeExtractInt64(pair_int);
        
        // SAFETY CHECK: Ensure pair_int is not null (0) before dereferencing
        Value* is_null = builder->CreateICmpEQ(pair_int_safe, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* null_block = BasicBlock::Create(*context, "cdr_null", current_func);
        BasicBlock* valid_block = BasicBlock::Create(*context, "cdr_valid", current_func);
        BasicBlock* continue_block = BasicBlock::Create(*context, "cdr_continue", current_func);
        
        builder->CreateCondBr(is_null, null_block, valid_block);
        
        // Null block: return 0 (null) for safety - pack as tagged value
        builder->SetInsertPoint(null_block);
        Value* null_tagged_cdr = packNullToTaggedValue();
        builder->CreateBr(continue_block);
        
        // Valid block: use TAGGED cons cell to extract cdr with proper type
        builder->SetInsertPoint(valid_block);
        
        // Convert pair_int to pointer
        Value* cons_ptr = builder->CreateIntToPtr(pair_int_safe, builder->getPtrTy());
        
        // Get cdr type using arena_tagged_cons_get_type(cell, true)
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1); // true = cdr
        Value* cdr_type = builder->CreateCall(arena_tagged_cons_get_type_func, {cons_ptr, is_cdr});
        
        // Mask out flags to get base type (type & 0x0F), matching C macro ESHKOL_GET_BASE_TYPE
        Value* cdr_base_type = builder->CreateAnd(cdr_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // FIX: Check for all three types: DOUBLE, CONS_PTR, INT64
        Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* cdr_is_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_NULL));
        
        BasicBlock* double_cdr = BasicBlock::Create(*context, "cdr_extract_double", current_func);
        BasicBlock* check_ptr_cdr = BasicBlock::Create(*context, "cdr_check_ptr", current_func);
        BasicBlock* ptr_cdr = BasicBlock::Create(*context, "cdr_extract_ptr", current_func);
        BasicBlock* check_null_cdr = BasicBlock::Create(*context, "cdr_check_null", current_func);
        BasicBlock* null_cdr = BasicBlock::Create(*context, "cdr_extract_null", current_func);
        BasicBlock* int_cdr = BasicBlock::Create(*context, "cdr_extract_int", current_func);
        BasicBlock* merge_cdr = BasicBlock::Create(*context, "cdr_merge", current_func);
        
        builder->CreateCondBr(cdr_is_double, double_cdr, check_ptr_cdr);
        
        // Extract double cdr and pack into tagged value
        builder->SetInsertPoint(double_cdr);
        Value* cdr_double = builder->CreateCall(arena_tagged_cons_get_double_func, {cons_ptr, is_cdr});
        Value* tagged_double_cdr = packDoubleToTaggedValue(cdr_double);
        builder->CreateBr(merge_cdr);
        BasicBlock* double_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_ptr_cdr);
        builder->CreateCondBr(cdr_is_ptr, ptr_cdr, check_null_cdr);
        
        builder->SetInsertPoint(ptr_cdr);
        Value* cdr_ptr = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        Value* tagged_ptr_cdr = packPtrToTaggedValue(cdr_ptr, ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* ptr_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(check_null_cdr);
        builder->CreateCondBr(cdr_is_null, null_cdr, int_cdr);
        
        builder->SetInsertPoint(null_cdr);
        Value* tagged_null_cdr = packNullToTaggedValue();
        builder->CreateBr(merge_cdr);
        BasicBlock* null_exit = builder->GetInsertBlock();
        
        // Extract int64 cdr and pack into tagged value
        builder->SetInsertPoint(int_cdr);
        Value* cdr_int64 = builder->CreateCall(arena_tagged_cons_get_int64_func, {cons_ptr, is_cdr});
        Value* tagged_int64_cdr = packInt64ToTaggedValue(cdr_int64, true);
        builder->CreateBr(merge_cdr);
        BasicBlock* int_exit = builder->GetInsertBlock();
        
        // Merge: return tagged value struct (can merge because all are same struct type!)
        builder->SetInsertPoint(merge_cdr);
        PHINode* cdr_tagged_phi = builder->CreatePHI(tagged_value_type, 4);
        cdr_tagged_phi->addIncoming(tagged_double_cdr, double_exit);
        cdr_tagged_phi->addIncoming(tagged_ptr_cdr, ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_null_cdr, null_exit);
        cdr_tagged_phi->addIncoming(tagged_int64_cdr, int_exit);
        
        Value* cdr_result = cdr_tagged_phi;
        builder->CreateBr(continue_block);
        
        // Continue block: use PHI to select result (tagged value or null tagged value)
        builder->SetInsertPoint(continue_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2);
        phi->addIncoming(null_tagged_cdr, null_block);
        phi->addIncoming(cdr_result, merge_cdr);
        
        return phi;
    }
    
    Value* codegenList(const eshkol_operations_t* op) {
        if (op->call_op.num_vars == 0) {
            // Empty list
            return ConstantInt::get(Type::getInt64Ty(*context), 0);
        }

        // Production implementation: build proper cons chain from right to left with type preservation
        TypedValue result(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL); // Start with empty list (null)

        // Build list from last element to first (right-associative)
        for (int64_t i = op->call_op.num_vars - 1; i >= 0; i--) {
            TypedValue element = codegenTypedAST(&op->call_op.variables[i]);

            // HOMOICONIC FIX: Capture lambda name immediately after generation
            // This must happen before the next element is processed (which might overwrite last_generated_lambda_name)
            std::string this_lambda_name;
            bool is_lambda_sexpr = (element.type == ESHKOL_VALUE_LAMBDA_SEXPR);
            bool is_op_node = (op->call_op.variables[i].type == ESHKOL_OP);
            bool is_lambda_op = is_op_node && (op->call_op.variables[i].operation.op == ESHKOL_LAMBDA_OP);

            fprintf(stderr, "[ESHKOL DEBUG] List element %lld: is_lambda_sexpr=%d, is_op_node=%d, is_lambda_op=%d\n",
                    (long long)i, is_lambda_sexpr, is_op_node, is_lambda_op);

            if (is_lambda_sexpr && is_lambda_op) {
                // This is an inline lambda that was just generated
                this_lambda_name = last_generated_lambda_name;
                fprintf(stderr, "[ESHKOL DEBUG] Captured inline lambda name: %s\n", this_lambda_name.c_str());
            }

            if (element.llvm_value) {
                // HOMOICONIC FIX: For lambdas in lists, store the ADDRESS of the sexpr global
                // At display time, we load from this address to get the S-expression pointer
                // This avoids the timing issue where S-expression globals aren't populated at list creation time
                if (element.type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                    GlobalVariable* sexpr_global = nullptr;

                    if (op->call_op.variables[i].type == ESHKOL_VAR &&
                        op->call_op.variables[i].variable.id) {
                        // Named lambda variable: use var_name_sexpr
                        std::string var_name = op->call_op.variables[i].variable.id;
                        std::string var_sexpr_key = var_name + "_sexpr";
                        sexpr_global = module->getNamedGlobal(var_sexpr_key);
                    } else if (!this_lambda_name.empty()) {
                        // Inline lambda: use the lambda name we captured immediately after generation
                        std::string lambda_sexpr_key = this_lambda_name + "_sexpr";
                        sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                        fprintf(stderr, "[ESHKOL DEBUG] Looking up S-expression global: %s, found: %s\n",
                                lambda_sexpr_key.c_str(), sexpr_global ? "YES" : "NO");
                    }

                    if (sexpr_global) {
                        // Store the ADDRESS of the global, not its value
                        // At runtime display, we'll load from this address
                        // Set FLAG_INDIRECT to indicate this is an indirect reference
                        Value* global_addr = builder->CreatePtrToInt(sexpr_global, Type::getInt64Ty(*context));

                        // DEBUG: Emit runtime printf to show global address being stored
                        Function* printf_func = module->getFunction("printf");
                        if (!printf_func) {
                            FunctionType* printf_type = FunctionType::get(
                                Type::getInt32Ty(*context),
                                {PointerType::getUnqual(*context)},
                                true);
                            printf_func = Function::Create(printf_type, Function::ExternalLinkage, "printf", module.get());
                        }
                        Value* fmt = builder->CreateGlobalStringPtr(("[LIST-CREATE] Storing global addr for " + this_lambda_name + ": %lld\n").c_str());
                        builder->CreateCall(printf_func, {fmt, global_addr});

                        element = TypedValue(global_addr, ESHKOL_VALUE_LAMBDA_SEXPR, true, TypedValue::FLAG_INDIRECT);
                        fprintf(stderr, "[ESHKOL DEBUG] Set lambda element to indirect reference with FLAG_INDIRECT\n");
                    } else {
                        fprintf(stderr, "[ESHKOL DEBUG] FAILED to find S-expression global for lambda in list!\n");
                    }
                }
                // Create tagged cons cell: (element . rest) with type preservation
                Value* cons_result = codegenTaggedArenaConsCell(element, result);
                // Update result to be a cons pointer (represented as int64)
                result = TypedValue(cons_result, ESHKOL_VALUE_CONS_PTR, true);
            }
        }

        return result.llvm_value;
    }
    
    Value* codegenNullCheck(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("null? requires exactly 1 argument");
            return nullptr;
        }
        
        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* arg_int = safeExtractInt64(arg);
        
        // Check if the value is 0 (our representation of null/empty list)
        Value* result = builder->CreateICmpEQ(arg_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        return builder->CreateZExt(result, Type::getInt64Ty(*context));
    }
    
    Value* codegenPairCheck(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("pair? requires exactly 1 argument");
            return nullptr;
        }
        
        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* arg_int = safeExtractInt64(arg);
        
        // Proper pair check: must be non-null AND a valid pointer range
        // For arena-allocated cons cells, check if it's in a reasonable address range
        // Simple heuristic: pair pointers should be > 1000 (distinguishes from small integers)
        Value* is_not_null = builder->CreateICmpNE(arg_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* is_large_enough = builder->CreateICmpUGT(arg_int, ConstantInt::get(Type::getInt64Ty(*context), 1000));
        Value* result = builder->CreateAnd(is_not_null, is_large_enough);
        return builder->CreateZExt(result, Type::getInt64Ty(*context));
    }
    
    Value* codegenConsCell(const eshkol_ast_t* ast) {
        // Generate code for a cons cell AST node using arena allocation
        if (!ast->cons_cell.car || !ast->cons_cell.cdr) {
            eshkol_error("Invalid cons cell structure");
            return nullptr;
        }
        
        // Production implementation: use arena allocation for cons cells
        Value* car_val = codegenAST(ast->cons_cell.car);
        Value* cdr_val = codegenAST(ast->cons_cell.cdr);
        
        if (!car_val || !cdr_val) return nullptr;
        
        // Use arena-based allocation for proper cons cell creation
        return codegenArenaConsCell(car_val, cdr_val);
    }

    // Helper function to find free variables in a lambda body
    void findFreeVariables(const eshkol_ast_t* ast, 
                          const std::map<std::string, Value*>& current_scope,
                          const eshkol_ast_t* parameters, uint64_t num_params,
                          std::vector<std::string>& free_vars) {
        if (!ast) return;
        
        switch (ast->type) {
            case ESHKOL_VAR: {
                std::string var_name = ast->variable.id;
                
                // Check if this variable is a parameter
                bool is_parameter = false;
                if (parameters) {
                    for (uint64_t i = 0; i < num_params; i++) {
                        if (parameters[i].type == ESHKOL_VAR &&
                            parameters[i].variable.id &&
                            var_name == parameters[i].variable.id) {
                            is_parameter = true;
                            break;
                        }
                    }
                }
                
                // If not a parameter and exists in current scope or REPL registry, it's a free variable
                if (!is_parameter) {
                    bool is_free_var = false;

                    // Check local symbol table first
                    if (current_scope.find(var_name) != current_scope.end()) {
                        Value* val = current_scope.at(var_name);
                        // Skip if it's a Function (built-ins, user-defined functions, etc.)
                        if (!isa<Function>(val)) {
                            is_free_var = true;
                        }
                    }
                    // REPL MODE: Also check REPL registry for cross-module variables
                    else if (g_repl_mode_enabled) {
                        std::lock_guard<std::mutex> lock(g_repl_mutex);
                        // Check if it's a variable in REPL registry
                        if (g_repl_symbol_addresses.find(var_name) != g_repl_symbol_addresses.end()) {
                            is_free_var = true;
                        }
                        // Also check if it's a lambda function that needs to be captured
                        else if (g_repl_function_addresses.find(var_name) != g_repl_function_addresses.end() ||
                                 g_repl_function_addresses.find(var_name + "_func") != g_repl_function_addresses.end()) {
                            is_free_var = true;
                        }
                    }

                    if (is_free_var) {
                        // Check if already in free_vars to avoid duplicates
                        if (std::find(free_vars.begin(), free_vars.end(), var_name) == free_vars.end()) {
                            free_vars.push_back(var_name);
                        }
                    }
                }
                break;
            }
            case ESHKOL_OP: {
                const eshkol_operations_t* op = &ast->operation;
                switch (op->op) {
                    case ESHKOL_CALL_OP:
                        // CRITICAL: Also check the function expression - it could be a captured lambda!
                        if (op->call_op.func) {
                            findFreeVariables(op->call_op.func, current_scope, parameters, num_params, free_vars);
                        }
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            findFreeVariables(&op->call_op.variables[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_SEQUENCE_OP:
                        for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
                            findFreeVariables(&op->sequence_op.expressions[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_LET_OP: {
                        // CRITICAL: Handle let expressions to find free variables in bindings and body
                        // First, collect let-bound variable names (they shadow outer scope)
                        std::vector<std::string> let_bound_names;
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.car) {
                                const eshkol_ast_t* var_ast = binding->cons_cell.car;
                                if (var_ast->type == ESHKOL_VAR && var_ast->variable.id) {
                                    let_bound_names.push_back(var_ast->variable.id);
                                }
                            }
                        }

                        // Search binding VALUE expressions (they can reference outer scope)
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                                findFreeVariables(binding->cons_cell.cdr, current_scope, parameters, num_params, free_vars);
                            }
                        }

                        // Search let body - but let-bound variables should be treated as parameters
                        // Create extended parameter list including let-bound names
                        if (op->let_op.body) {
                            // We need to pass let-bound names as "virtual parameters" so they're not captured
                            // For simplicity, just search the body and filter out let-bound names after
                            findFreeVariables(op->let_op.body, current_scope, parameters, num_params, free_vars);

                            // Remove any let-bound names that were incorrectly added as free vars
                            for (const std::string& let_var : let_bound_names) {
                                free_vars.erase(std::remove(free_vars.begin(), free_vars.end(), let_var), free_vars.end());
                            }
                        }
                        break;
                    }
                    case ESHKOL_LAMBDA_OP:
                        // Nested lambda - search its body too (but its parameters are bound)
                        if (op->lambda_op.body) {
                            findFreeVariables(op->lambda_op.body, current_scope,
                                             op->lambda_op.parameters, op->lambda_op.num_params, free_vars);
                        }
                        break;
                    // Note: 'if' conditionals are handled as CALL_OP with func_name "if"
                    // The ESHKOL_CALL_OP case above correctly handles them via call_op.variables
                    default:
                        break;
                }
                break;
            }
            case ESHKOL_CONS:
                if (ast->cons_cell.car) {
                    findFreeVariables(ast->cons_cell.car, current_scope, parameters, num_params, free_vars);
                }
                if (ast->cons_cell.cdr) {
                    findFreeVariables(ast->cons_cell.cdr, current_scope, parameters, num_params, free_vars);
                }
                break;
            default:
                break;
        }
    }

    Value* codegenLambda(const eshkol_operations_t* op) {
        // Generate anonymous function for lambda expression
        static int lambda_counter = 0;
        std::string lambda_name = "lambda_" + std::to_string(lambda_counter++);
        
        // Find free variables in the lambda body
        std::vector<std::string> free_vars;
        findFreeVariables(op->lambda_op.body, symbol_table, op->lambda_op.parameters, op->lambda_op.num_params, free_vars);
        
        eshkol_debug("Lambda %s found %zu free variables", lambda_name.c_str(), free_vars.size());
        for (const std::string& var : free_vars) {
            eshkol_debug("  Free variable: %s", var.c_str());
        }
        
        // ===== PHASE 1: STORE CAPTURED VALUES IN GLOBAL VARIABLES =====
        // ARCHITECTURE: Captures are stored in GlobalVariable at lambda creation time.
        // This allows closures to persist values across function boundaries and avoids
        // cross-function Value* references which cause LLVM verification errors.
        
        // REPL MODE: Store capture names for gradient lookup
        if (g_repl_mode_enabled && !free_vars.empty()) {
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            g_repl_lambda_captures[lambda_name] = free_vars;
        }

        for (const std::string& var_name : free_vars) {
            Value* var_value = nullptr;
            Value* captured_val = nullptr;

            // Try local symbol table first
            auto var_it = symbol_table.find(var_name);
            if (var_it != symbol_table.end() && var_it->second) {
                var_value = var_it->second;

                // Load actual value from storage location
                captured_val = var_value;
                if (isa<AllocaInst>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<AllocaInst>(var_value)->getAllocatedType(), var_value);
                } else if (isa<GlobalVariable>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<GlobalVariable>(var_value)->getValueType(), var_value);
                }
            }
            // REPL MODE: Check REPL registry for cross-module captures
            else if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);

                // First check if it's a lambda function
                auto func_it = g_repl_function_addresses.find(var_name);
                if (func_it == g_repl_function_addresses.end()) {
                    func_it = g_repl_function_addresses.find(var_name + "_func");
                }

                if (func_it != g_repl_function_addresses.end()) {
                    // Capture is a lambda function - store function pointer as tagged value
                    uint64_t func_addr = func_it->second;
                    captured_val = packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), func_addr), true);
                } else {
                    // Check if it's a regular variable
                    auto sym_it = g_repl_symbol_addresses.find(var_name);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for the global
                        GlobalVariable* global_var = module->getGlobalVariable(var_name);
                        if (!global_var) {
                            global_var = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,  // external - no initializer
                                var_name
                            );
                        }
                        // Load the captured value
                        captured_val = builder->CreateLoad(tagged_value_type, global_var);
                    }
                }
            }

            if (!captured_val) {
                continue;  // Skip this capture
            }

            // Ensure value is tagged_value
            if (captured_val->getType() != tagged_value_type) {
                if (captured_val->getType()->isIntegerTy(64)) {
                    captured_val = packInt64ToTaggedValue(captured_val, true);
                } else if (captured_val->getType()->isDoubleTy()) {
                    captured_val = packDoubleToTaggedValue(captured_val);
                } else if (isa<Function>(captured_val)) {
                    Value* func_addr = builder->CreatePtrToInt(captured_val, Type::getInt64Ty(*context));
                    captured_val = packInt64ToTaggedValue(func_addr, true);
                } else {
                    TypedValue tv = detectValueType(captured_val);
                    captured_val = typedValueToTaggedValue(tv);
                }
            }

            // Create GlobalVariable for persistent storage (accessible from any function)
            std::string capture_key = lambda_name + "_capture_" + var_name;
            // REPL MODE: Use ExternalLinkage for cross-module access
            GlobalValue::LinkageTypes linkage = g_repl_mode_enabled ?
                GlobalValue::ExternalLinkage : GlobalValue::InternalLinkage;
            GlobalVariable* storage = new GlobalVariable(
                *module,
                tagged_value_type,
                false, // not constant
                linkage,
                UndefValue::get(tagged_value_type), // Initial value
                capture_key
            );

            // Store captured value in global variable
            builder->CreateStore(captured_val, storage);

            // Register in both symbol tables for cross-scope access
            symbol_table[capture_key] = storage;
            global_symbol_table[capture_key] = storage;

            eshkol_debug("Stored capture: %s -> %s", var_name.c_str(), capture_key.c_str());
        }
        
        // ===== END PHASE 1 =====
        
        // Create polymorphic function type - all parameters and return type are tagged_value
        std::vector<Type*> param_types;
        for (uint64_t i = 0; i < op->lambda_op.num_params; i++) {
            param_types.push_back(tagged_value_type);
        }
        for (size_t i = 0; i < free_vars.size(); i++) {
            param_types.push_back(tagged_value_type);
        }
        
        FunctionType* func_type = FunctionType::get(
            tagged_value_type, // return tagged_value
            param_types,
            false // not varargs
        );
        
        Function* lambda_func = Function::Create(
            func_type,
            Function::ExternalLinkage, // Use external linkage so it can be called
            lambda_name,
            module.get()
        );
        
        // Set parameter names
        auto arg_it = lambda_func->arg_begin();
        
        // Set names for original parameters
        if (op->lambda_op.parameters) {
            for (uint64_t i = 0; i < op->lambda_op.num_params && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
                if (op->lambda_op.parameters[i].type == ESHKOL_VAR &&
                    op->lambda_op.parameters[i].variable.id) {
                    arg_it->setName(op->lambda_op.parameters[i].variable.id);
                }
            }
        }
        
        // Set names for captured parameters
        for (size_t i = 0; i < free_vars.size() && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
            arg_it->setName("captured_" + free_vars[i]);
        }
        
        // Create basic block for lambda body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", lambda_func);
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        builder->SetInsertPoint(entry);
        
        // Set current function and save previous state
        Function* prev_function = current_function;
        current_function = lambda_func;
        std::map<std::string, Value*> prev_symbols = symbol_table;
        
        // GLOBAL ARENA FIX: No per-lambda arena initialization needed
        // All lambdas share the global arena initialized in main
        
        // Add parameters to symbol table
        arg_it = lambda_func->arg_begin();
        if (op->lambda_op.parameters) {
            for (uint64_t i = 0; i < op->lambda_op.num_params && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
                if (op->lambda_op.parameters[i].type == ESHKOL_VAR &&
                    op->lambda_op.parameters[i].variable.id) {
                    symbol_table[op->lambda_op.parameters[i].variable.id] = &(*arg_it);
                }
            }
        }
        
        // Add captured variables to symbol table
        for (size_t i = 0; i < free_vars.size() && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
            symbol_table[free_vars[i]] = &(*arg_it);
            eshkol_debug("Lambda captures variable: %s", free_vars[i].c_str());
        }
        
        // Generate lambda body
        Value* body_result = nullptr;
        if (op->lambda_op.body) {
            body_result = codegenAST(op->lambda_op.body);
        }

        // Pack return value to tagged_value (lambdas now return tagged_value)
        if (body_result) {
            // If body_result is already a tagged_value, return it directly
            if (body_result->getType() == tagged_value_type) {
                builder->CreateRet(body_result);
            }
            // Otherwise, detect type and pack to tagged_value
            else {
                TypedValue typed = detectValueType(body_result);
                Value* tagged = typedValueToTaggedValue(typed);
                builder->CreateRet(tagged);
            }
        } else {
            // Return null tagged value as default
            Value* null_tagged = packInt64ToTaggedValue(
                ConstantInt::get(Type::getInt64Ty(*context), 0), true);
            builder->CreateRet(null_tagged);
        }
        
        // Restore previous state
        symbol_table = prev_symbols;
        current_function = prev_function;
        
        // Add lambda function to function table so it can be called
        registerContextFunction(lambda_name, lambda_func);
        
        // CRITICAL FIX: Also add to global_symbol_table immediately for gradient/jacobian resolution
        // This allows autodiff operators to find lambdas WITHOUT changing evaluation order
        global_symbol_table[lambda_name] = lambda_func;
        eshkol_debug("Added lambda %s to global_symbol_table for autodiff resolution", lambda_name.c_str());
        
        // OPTION 3: Store lambda metadata for deferred S-expression generation
        // S-expressions will be generated in createMainWrapper() after all lambdas are compiled
        // This prevents basic block corruption from generating IR during lambda compilation
        pending_lambda_sexprs.push_back({op, lambda_name});
        fprintf(stderr, "[LAMBDA GEN] Added %s to pending_lambda_sexprs (now %zu total)\n",
                lambda_name.c_str(), pending_lambda_sexprs.size());

        // Track last generated lambda name for codegenList to use
        last_generated_lambda_name = lambda_name;

        // HOMOICONIC FIX: Map lambda function to its S-expression global name
        // This allows codegenList to find the correct S-expression for inline lambdas
        lambda_sexpr_map[lambda_func] = lambda_name;

        // HOMOICONIC FIX: Create S-expression global variable IMMEDIATELY so detectValueType can find it
        // The actual S-expression will be stored into this global at runtime in createMainWrapper()
        std::string sexpr_key = lambda_name + "_sexpr";
        GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
        if (!sexpr_global) {
            sexpr_global = new GlobalVariable(
                *module, Type::getInt64Ty(*context), false,
                GlobalValue::ExternalLinkage,
                ConstantInt::get(Type::getInt64Ty(*context), 0),
                sexpr_key
            );
            global_symbol_table[sexpr_key] = sexpr_global;
            eshkol_debug("Pre-created S-expression global %s for lambda", sexpr_key.c_str());
        }

        eshkol_debug("Generated lambda function: %s with %llu parameters + %zu captured",
                    lambda_name.c_str(), (unsigned long long)op->lambda_op.num_params, free_vars.size());
        eshkol_debug("Stored lambda metadata for deferred S-expression generation");
        
        builder->restoreIP(old_point);
        eshkol_debug("Lambda function %s created, restored insertion point", lambda_name.c_str());
        
        // Return the lambda function itself
        return lambda_func;
    }
    
    Value* codegenLet(const eshkol_operations_t* op) {
        if (!op || !op->let_op.body) {
            eshkol_error("Invalid let expression - missing body");
            return nullptr;
        }
        
        eshkol_debug("Processing let expression with %llu bindings",
                    (unsigned long long)op->let_op.num_bindings);
        
        // Save current symbol table state
        std::map<std::string, Value*> prev_symbols = symbol_table;
        
        // Process all bindings: evaluate values and add to symbol table
        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];
            
            // Binding is a cons cell: (variable . value)
            if (binding->type != ESHKOL_CONS || !binding->cons_cell.car || !binding->cons_cell.cdr) {
                eshkol_error("Invalid let binding structure at index %llu", (unsigned long long)i);
                continue;
            }
            
            // Extract variable name from car
            const eshkol_ast_t* var_ast = binding->cons_cell.car;
            if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) {
                eshkol_error("Let binding must have variable name");
                continue;
            }
            
            std::string var_name = var_ast->variable.id;
            
            // Evaluate value expression from cdr
            const eshkol_ast_t* val_ast = binding->cons_cell.cdr;
            Value* val = codegenAST(val_ast);
            if (!val) {
                eshkol_warn("Failed to evaluate let binding value for %s", var_name.c_str());
                continue;
            }
            
            // Determine storage type based on value type
            Type* storage_type = val->getType();
            
            // Check if value is a function and store appropriately
            if (val && isa<Function>(val)) {
                Function* func = dyn_cast<Function>(val);
                storage_type = Type::getInt64Ty(*context);

                // SCOPED NAMES FIX: Use enclosing function name to avoid collisions
                // e.g., "test-jacobian-2d.F_func" instead of just "F_func"
                std::string scope_prefix = "";
                if (current_function) {
                    scope_prefix = current_function->getName().str() + ".";
                }
                std::string scoped_func_key = scope_prefix + var_name + "_func";
                std::string scoped_sexpr_key = scope_prefix + var_name + "_sexpr";

                // Store direct function reference for lambda resolution in BOTH tables
                symbol_table[var_name + "_func"] = func;
                symbol_table[scoped_func_key] = func;
                global_symbol_table[var_name + "_func"] = func;
                global_symbol_table[scoped_func_key] = func;
                eshkol_debug("Let binding: stored lambda function reference %s -> %s",
                           scoped_func_key.c_str(), func->getName().str().c_str());

                // HOMOICONICITY FIX: Create S-expression GlobalVariable with scoped name
                // This allows (display F) to find the correct S-expression at compile time
                std::string lambda_name = func->getName().str();

                // Create the GlobalVariable immediately so display can find it at compile time
                GlobalVariable* var_sexpr_global = module->getNamedGlobal(scoped_sexpr_key);
                if (!var_sexpr_global) {
                    var_sexpr_global = new GlobalVariable(
                        *module, Type::getInt64Ty(*context), false,
                        GlobalVariable::ExternalLinkage,
                        ConstantInt::get(Type::getInt64Ty(*context), 0),
                        scoped_sexpr_key
                    );
                    global_symbol_table[scoped_sexpr_key] = var_sexpr_global;
                    eshkol_debug("Let binding: created S-expression global %s for lambda %s",
                               scoped_sexpr_key.c_str(), lambda_name.c_str());
                }

                val = builder->CreatePtrToInt(func, storage_type);
            }
            // CRITICAL FIX: Handle returned lambdas (tagged_value containing function pointer)
            else if (val && val->getType() == tagged_value_type) {
                // Extract type to check if it's a function pointer
                Value* val_type = getTaggedValueType(val);
                Value* val_base_type = builder->CreateAnd(val_type,
                    ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
                
                // Check if it's a CONS_PTR (function pointers are stored as CONS_PTR)
                Value* is_func_ptr = builder->CreateICmpEQ(val_base_type,
                    ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
                
                // Extract the function pointer value
                Value* func_addr = unpackInt64FromTaggedValue(val);
                
                // Try to find matching lambda by searching function_table
                // Use the most recently created lambda (highest lambda_N number)
                Function* matching_lambda = nullptr;
                int highest_lambda_num = -1;
                
                for (auto& func_entry : function_table) {
                    if (func_entry.first.find("lambda_") == 0) {
                        // Extract lambda number from name
                        std::string num_str = func_entry.first.substr(7);  // Skip "lambda_"
                        try {
                            int lambda_num = std::stoi(num_str);
                            if (lambda_num > highest_lambda_num) {
                                highest_lambda_num = lambda_num;
                                matching_lambda = func_entry.second;
                            }
                        } catch (...) {
                            // Skip if number parsing fails
                        }
                    }
                }
                
                if (matching_lambda) {
                    symbol_table[var_name + "_func"] = matching_lambda;
                    global_symbol_table[var_name + "_func"] = matching_lambda;
                    eshkol_debug("Let binding: stored returned lambda reference %s_func -> %s (latest lambda match)",
                               var_name.c_str(), matching_lambda->getName().str().c_str());
                    // Note: S-expression not created for returned lambdas as we can't reliably
                    // match the lambda at compile time. The "highest lambda" heuristic is unreliable.
                }
            }
            
            // Create alloca for the variable in current function scope
            if (current_function) {
                AllocaInst* var_alloca = builder->CreateAlloca(
                    storage_type,
                    nullptr,
                    var_name.c_str()
                );
                
                // Set proper alignment for i64 types
                if (storage_type->isIntegerTy(64)) {
                    var_alloca->setAlignment(Align(8));
                }
                
                builder->CreateStore(val, var_alloca);
                symbol_table[var_name] = var_alloca;
                
                eshkol_debug("Let binding: %s = <value>", var_name.c_str());
            } else {
                eshkol_warn("Let expression outside function context - creating temporary binding");
                symbol_table[var_name] = val;
            }
        }
        
        // Evaluate body in the new scope with bindings
        Value* body_result = codegenAST(op->let_op.body);
        
        // CRITICAL FIX (Bug #2): Preserve _func entries before restoring symbol table
        // Local functions defined in let bindings must be accessible for autodiff
        std::map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            // Preserve all entries ending with "_func" (function references for autodiff)
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {
                func_refs_to_preserve[entry.first] = entry.second;
                // Also ensure in global for gradient/derivative operators
                global_symbol_table[entry.first] = entry.second;
                eshkol_debug("Let: preserving function reference: %s", entry.first.c_str());
            }
        }
        
        // Restore previous symbol table state
        symbol_table = prev_symbols;
        
        // Re-add preserved function references to local symbol table
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
        }
        
        eshkol_debug("Let expression completed, scope restored (preserved %zu function refs)",
                    func_refs_to_preserve.size());

        return body_result ? body_result : ConstantInt::get(Type::getInt64Ty(*context), 0);
    }

    // letrec - Recursive bindings (all bindings visible to all values)
    // Used for mutually recursive function definitions
    Value* codegenLetrec(const eshkol_operations_t* op) {
        if (!op || !op->let_op.body) {
            eshkol_error("Invalid letrec expression - missing body");
            return nullptr;
        }

        eshkol_debug("Processing letrec expression with %llu bindings",
                    (unsigned long long)op->let_op.num_bindings);

        // Save current symbol table state
        std::map<std::string, Value*> prev_symbols = symbol_table;

        // Collect binding info
        std::vector<std::string> var_names;
        std::vector<AllocaInst*> var_allocas;
        std::vector<const eshkol_ast_t*> val_asts;
        std::vector<bool> is_lambda;

        // PHASE 1: Analyze bindings and create forward declarations for lambdas
        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];

            // Binding is a cons cell: (variable . value)
            if (binding->type != ESHKOL_CONS || !binding->cons_cell.car || !binding->cons_cell.cdr) {
                eshkol_error("Invalid letrec binding structure at index %llu", (unsigned long long)i);
                continue;
            }

            // Extract variable name from car
            const eshkol_ast_t* var_ast = binding->cons_cell.car;
            if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) {
                eshkol_error("Letrec binding must have variable name");
                continue;
            }

            std::string var_name = var_ast->variable.id;
            const eshkol_ast_t* val_ast = binding->cons_cell.cdr;

            var_names.push_back(var_name);
            val_asts.push_back(val_ast);

            // Check if this binding is a lambda
            bool binding_is_lambda = (val_ast->type == ESHKOL_OP &&
                                      val_ast->operation.op == ESHKOL_LAMBDA_OP);
            is_lambda.push_back(binding_is_lambda);

            if (binding_is_lambda) {
                // Create a forward declaration for the lambda function
                // This allows recursive calls to resolve before the body is generated
                static int letrec_lambda_counter = 0;
                std::string lambda_name = "letrec_lambda_" + std::to_string(letrec_lambda_counter++);

                const eshkol_operations_t* lambda_op = &val_ast->operation;

                // Create function type with tagged_value parameters and return
                std::vector<Type*> param_types;
                for (uint64_t j = 0; j < lambda_op->lambda_op.num_params; j++) {
                    param_types.push_back(tagged_value_type);
                }

                FunctionType* func_type = FunctionType::get(
                    tagged_value_type,
                    param_types,
                    false
                );

                Function* forward_decl = Function::Create(
                    func_type,
                    Function::ExternalLinkage,
                    lambda_name,
                    module.get()
                );

                // Register the forward declaration so recursive calls can find it
                symbol_table[var_name + "_func"] = forward_decl;
                global_symbol_table[var_name + "_func"] = forward_decl;
                function_table[lambda_name] = forward_decl;

                eshkol_debug("Letrec phase 1: created forward declaration for %s -> %s",
                           var_name.c_str(), lambda_name.c_str());
            }

            // Create alloca for the variable
            if (current_function) {
                AllocaInst* var_alloca = builder->CreateAlloca(
                    tagged_value_type,
                    nullptr,
                    var_name.c_str()
                );
                var_alloca->setAlignment(Align(8));
                var_allocas.push_back(var_alloca);

                // Initialize with null
                Value* null_val = packNullToTaggedValue();
                builder->CreateStore(null_val, var_alloca);

                // Add to symbol table
                symbol_table[var_name] = var_alloca;

                eshkol_debug("Letrec phase 1: allocated slot for %s", var_name.c_str());
            } else {
                var_allocas.push_back(nullptr);
            }
        }

        // PHASE 2: Generate lambda bodies and evaluate other expressions
        for (uint64_t i = 0; i < var_names.size(); i++) {
            const eshkol_ast_t* val_ast = val_asts[i];
            std::string& var_name = var_names[i];

            Value* val = nullptr;

            if (is_lambda[i]) {
                // Get the forward declaration we created
                Value* forward_decl = symbol_table[var_name + "_func"];
                Function* forward_func = dyn_cast<Function>(forward_decl);

                if (forward_func) {
                    // Generate the lambda body inside the forward declaration
                    const eshkol_operations_t* lambda_op = &val_ast->operation;

                    // Create entry block for the function
                    BasicBlock* entry = BasicBlock::Create(*context, "entry", forward_func);
                    IRBuilderBase::InsertPoint old_point = builder->saveIP();
                    builder->SetInsertPoint(entry);

                    // Save current function context
                    Function* prev_function = current_function;
                    current_function = forward_func;
                    std::map<std::string, Value*> lambda_scope = symbol_table;

                    // Add parameters to symbol table
                    auto arg_it = forward_func->arg_begin();
                    if (lambda_op->lambda_op.parameters) {
                        for (uint64_t j = 0; j < lambda_op->lambda_op.num_params && arg_it != forward_func->arg_end(); ++j, ++arg_it) {
                            if (lambda_op->lambda_op.parameters[j].type == ESHKOL_VAR &&
                                lambda_op->lambda_op.parameters[j].variable.id) {
                                std::string param_name = lambda_op->lambda_op.parameters[j].variable.id;
                                arg_it->setName(param_name);
                                symbol_table[param_name] = &(*arg_it);
                            }
                        }
                    }

                    // Generate lambda body
                    Value* body_result = codegenAST(lambda_op->lambda_op.body);

                    // Create return
                    if (body_result) {
                        if (body_result->getType() != tagged_value_type) {
                            if (body_result->getType()->isDoubleTy()) {
                                body_result = packDoubleToTaggedValue(body_result);
                            } else if (body_result->getType()->isIntegerTy(64)) {
                                body_result = packInt64ToTaggedValue(body_result, ESHKOL_VALUE_INT64);
                            } else if (body_result->getType()->isIntegerTy(1)) {
                                body_result = packInt64ToTaggedValue(
                                    builder->CreateZExt(body_result, Type::getInt64Ty(*context)),
                                    ESHKOL_VALUE_INT64);
                            }
                        }
                        builder->CreateRet(body_result);
                    } else {
                        builder->CreateRet(packNullToTaggedValue());
                    }

                    // Restore context
                    symbol_table = lambda_scope;
                    current_function = prev_function;
                    builder->restoreIP(old_point);

                    val = forward_func;
                    eshkol_debug("Letrec phase 2: generated body for %s", var_name.c_str());
                }
            } else {
                // Non-lambda binding - evaluate normally
                val = codegenAST(val_ast);
            }

            if (!val) {
                eshkol_warn("Failed to evaluate letrec binding value for %s", var_name.c_str());
                continue;
            }

            // Handle function bindings specially
            if (val && isa<Function>(val)) {
                Function* func = dyn_cast<Function>(val);

                // Store direct function reference
                symbol_table[var_name + "_func"] = func;
                global_symbol_table[var_name + "_func"] = func;

                // Convert function pointer to tagged value for storage
                val = packInt64ToTaggedValue(
                    builder->CreatePtrToInt(func, Type::getInt64Ty(*context)),
                    ESHKOL_VALUE_CONS_PTR
                );
            }
            // Ensure value is tagged_value_type for storage
            else if (val->getType() != tagged_value_type) {
                if (val->getType()->isDoubleTy()) {
                    val = packDoubleToTaggedValue(val);
                } else if (val->getType()->isIntegerTy(64)) {
                    val = packInt64ToTaggedValue(val, ESHKOL_VALUE_INT64);
                } else if (val->getType()->isIntegerTy(1)) {
                    val = packInt64ToTaggedValue(
                        builder->CreateZExt(val, Type::getInt64Ty(*context)),
                        ESHKOL_VALUE_INT64
                    );
                }
            }

            // Store value in pre-allocated slot
            if (i < var_allocas.size() && var_allocas[i]) {
                builder->CreateStore(val, var_allocas[i]);
                eshkol_debug("Letrec phase 2: stored value for %s", var_name.c_str());
            }
        }

        // PHASE 3: Evaluate body in the new scope with bindings
        Value* body_result = codegenAST(op->let_op.body);

        // Preserve _func entries before restoring symbol table
        std::map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {
                func_refs_to_preserve[entry.first] = entry.second;
                global_symbol_table[entry.first] = entry.second;
                eshkol_debug("Letrec: preserving function reference: %s", entry.first.c_str());
            }
        }

        // Restore previous symbol table state
        symbol_table = prev_symbols;

        // Re-add preserved function references
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
        }

        eshkol_debug("Letrec expression completed, scope restored (preserved %zu function refs)",
                    func_refs_to_preserve.size());

        return body_result ? body_result : ConstantInt::get(Type::getInt64Ty(*context), 0);
    }

    Value* codegenTensor(const eshkol_ast_t* ast) {
        if (!ast || ast->type != ESHKOL_TENSOR) return nullptr;
        
        // Use class member tensor_type (shared by all tensor operations)
        
        // Allocate memory for tensor structure
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());
        
        // Allocate and populate dimensions array
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                          ast->tensor_val.num_dimensions * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < ast->tensor_val.num_dimensions; i++) {
            Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                              ConstantInt::get(Type::getInt64Ty(*context), i));
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), ast->tensor_val.dimensions[i]), dim_ptr);
        }
        
        // Allocate and populate elements array
        Value* elements_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                             ast->tensor_val.total_elements * sizeof(int64_t));
        Value* elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < ast->tensor_val.total_elements; i++) {
            Value* element_val = codegenAST(&ast->tensor_val.elements[i]);
            if (element_val) {
                // CRITICAL FIX: Store elements as int64, but preserve double bit patterns
                if (element_val->getType() != Type::getInt64Ty(*context)) {
                    if (element_val->getType()->isIntegerTy()) {
                        element_val = builder->CreateSExtOrTrunc(element_val, Type::getInt64Ty(*context));
                    } else if (element_val->getType()->isFloatingPointTy()) {
                        // Use BitCast for doubles, NOT FPToSI (which truncates to integer!)
                        element_val = builder->CreateBitCast(element_val, Type::getInt64Ty(*context));
                    } else {
                        element_val = ConstantInt::get(Type::getInt64Ty(*context), 0);
                    }
                }
                
                Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr,
                                                   ConstantInt::get(Type::getInt64Ty(*context), i));
                builder->CreateStore(element_val, elem_ptr);
            }
        }
        
        // Store fields in tensor structure
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);
        
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), ast->tensor_val.num_dimensions), num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2);
        builder->CreateStore(typed_elements_ptr, elements_field_ptr);
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), ast->tensor_val.total_elements), total_elements_field_ptr);
        
        // Return pointer to tensor as int64
        return builder->CreatePtrToInt(typed_tensor_ptr, Type::getInt64Ty(*context));
    }
    
    Value* codegenTensorOperation(const eshkol_operations_t* op) {
        if (!op || op->op != ESHKOL_TENSOR_OP) return nullptr;

        // Use class member tensor_type (shared by all tensor operations)


        // Allocate memory for tensor structure
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }

        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
                                            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});

        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());
        
        // Allocate and populate dimensions array
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                          op->tensor_op.num_dimensions * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < op->tensor_op.num_dimensions; i++) {
            Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                              ConstantInt::get(Type::getInt64Ty(*context), i));
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), op->tensor_op.dimensions[i]), dim_ptr);
        }
        
        // Allocate and populate elements array
        Value* elements_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                             op->tensor_op.total_elements * sizeof(int64_t));
        Value* elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < op->tensor_op.total_elements; i++) {
            Value* element_val = codegenAST(&op->tensor_op.elements[i]);
            if (element_val) {
                // CRITICAL FIX: Extract i64 from tagged_value (preserves AD node pointers!)
                if (element_val->getType() == tagged_value_type) {
                    element_val = safeExtractInt64(element_val);
                }
                
                // CRITICAL FIX: Store elements as int64, but preserve double bit patterns
                if (element_val->getType() != Type::getInt64Ty(*context)) {
                    if (element_val->getType()->isIntegerTy()) {
                        element_val = builder->CreateSExtOrTrunc(element_val, Type::getInt64Ty(*context));
                    } else if (element_val->getType()->isFloatingPointTy()) {
                        // Use BitCast for doubles, NOT FPToSI (which truncates to integer!)
                        element_val = builder->CreateBitCast(element_val, Type::getInt64Ty(*context));
                    } else {
                        element_val = ConstantInt::get(Type::getInt64Ty(*context), 0);
                    }
                }
                
                Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr,
                                                   ConstantInt::get(Type::getInt64Ty(*context), i));
                builder->CreateStore(element_val, elem_ptr);
            }
        }
        
        // Store fields in tensor structure
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), op->tensor_op.num_dimensions), num_dims_field_ptr);

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2);
        builder->CreateStore(typed_elements_ptr, elements_field_ptr);

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), op->tensor_op.total_elements), total_elements_field_ptr);

        // Return pointer to tensor as tagged value with TENSOR_PTR type tag
        Value* tensor_int = builder->CreatePtrToInt(typed_tensor_ptr, Type::getInt64Ty(*context));
        // packPtrToTaggedValue handles i64 directly - no need to convert back to ptr
        return packPtrToTaggedValue(tensor_int, ESHKOL_VALUE_TENSOR_PTR);
    }
    
    Value* codegenTensorGet(const eshkol_operations_t* op) {
        // tensor-get: (tensor-get tensor index1 index2 ...)
        if (op->call_op.num_vars < 2) {
            eshkol_error("tensor-get requires at least tensor and one index");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        if (!tensor_var_ptr) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Calculate linear index from multi-dimensional indices
        Value* linear_index = ConstantInt::get(Type::getInt64Ty(*context), 0);
        
        // Load dimensions and elements
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Calculate linear index using row-major order
        Value* stride = ConstantInt::get(Type::getInt64Ty(*context), 1);
        for (int64_t i = op->call_op.num_vars - 2; i >= 0; i--) {
            Value* index = codegenAST(&op->call_op.variables[i + 1]);
            if (index) {
                Value* contribution = builder->CreateMul(index, stride);
                linear_index = builder->CreateAdd(linear_index, contribution);
                
                // Update stride for next dimension
                if (i > 0) {
                    Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                                      ConstantInt::get(Type::getInt64Ty(*context), i));
                    Value* dim = builder->CreateLoad(Type::getInt64Ty(*context), dim_ptr);
                    stride = builder->CreateMul(stride, dim);
                }
            }
        }
        
        // Load element at linear index
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, linear_index);
        return builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
    }
    
    Value* codegenTensorVectorRef(const eshkol_operations_t* op) {
        // vref: (vref tensor index) - shorthand for (tensor-get tensor index)
        // Simplified 1D tensor access for numerical arrays
        // PHASE 3/4 FIX: Now AD-aware - detects and preserves AD node pointers
        if (op->call_op.num_vars != 2) {
            eshkol_error("vref requires exactly 2 arguments: tensor and index");
            return nullptr;
        }
        
        Value* vector_val = codegenAST(&op->call_op.variables[0]);
        Value* index = codegenAST(&op->call_op.variables[1]);
        if (!vector_val || !index) return nullptr;
        
        // CRITICAL FIX: Detect if input is AD_NODE_PTR (scalar gradient case) vs TENSOR_PTR
        // Gradient with scalar functions passes single AD node, not tensor!
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Check if vector_val is tagged_value with AD_NODE_PTR, VECTOR_PTR, or TENSOR_PTR type
        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        Value* is_ad_node_ptr = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* is_vector_ptr = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* ad_node_input = BasicBlock::Create(*context, "vref_ad_node_input", current_func);
        BasicBlock* scheme_vector_input = BasicBlock::Create(*context, "vref_scheme_vector_input", current_func);
        BasicBlock* tensor_input = BasicBlock::Create(*context, "vref_tensor_input", current_func);
        BasicBlock* vref_final = BasicBlock::Create(*context, "vref_final", current_func);

        BasicBlock* check_vector = BasicBlock::Create(*context, "vref_check_vector", current_func);
        builder->CreateCondBr(is_ad_node_ptr, ad_node_input, check_vector);

        builder->SetInsertPoint(check_vector);
        builder->CreateCondBr(is_vector_ptr, scheme_vector_input, tensor_input);
        
        // AD NODE INPUT: Extract value directly from AD node structure (NOT tensor!)
        builder->SetInsertPoint(ad_node_input);
        
        // Unpack AD node pointer from tagged_value
        Value* ad_node_ptr = unpackPtrFromTaggedValue(vector_val);
        
        // AD node struct: {type, value, gradient, input1, input2, id}
        // We want field 1 (value)
        Value* value_field_ptr = builder->CreateStructGEP(ad_node_type, ad_node_ptr, 1);
        Value* ad_value = builder->CreateLoad(Type::getDoubleTy(*context), value_field_ptr);
        
        // Return value as tagged_value (gradient expects this)
        Value* ad_result = packPtrToTaggedValue(ad_node_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_final);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // SCHEME VECTOR INPUT: Handle Scheme vectors (from (vector ...))
        // Scheme vector layout: [length (8 bytes)] + [tagged_value elements (16 bytes each)]
        builder->SetInsertPoint(scheme_vector_input);

        Value* scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* scheme_vec_ptr = builder->CreateIntToPtr(scheme_vec_ptr_int, builder->getPtrTy());

        // Get index as int64
        Value* scheme_index_int = safeExtractInt64(index);

        // Get pointer to elements (after length field - 8 bytes offset)
        Value* scheme_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), scheme_vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* scheme_elem_base_typed = builder->CreateBitCast(scheme_elem_base, PointerType::getUnqual(tagged_value_type));

        // Get element at index
        Value* scheme_elem_ptr = builder->CreateGEP(tagged_value_type, scheme_elem_base_typed, scheme_index_int);
        Value* scheme_result = builder->CreateLoad(tagged_value_type, scheme_elem_ptr);
        builder->CreateBr(vref_final);
        BasicBlock* scheme_vector_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Normal tensor access path (existing logic)
        builder->SetInsertPoint(tensor_input);
        
        // Unpack if tagged_value (lambda parameters are tagged_value)
        Value* vector_ptr_int = safeExtractInt64(vector_val);
        Value* index_int = safeExtractInt64(index);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* vector_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        // Get elements array
        Value* elements_field = builder->CreateStructGEP(tensor_type, vector_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Load element as int64 (could be double bitcasted OR AD node pointer)
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, index_int);
        Value* elem_as_int64 = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
        
        // PHASE 1 FIX: Runtime AD mode detection using global flag
        // Handle 3 cases: small integers, doubles (bitcast), AD node pointers
        
        // PHASE 1 FIX: Check global __ad_mode_active flag at RUNTIME
        Value* in_ad_mode = builder->CreateLoad(Type::getInt1Ty(*context), ad_mode_active);

        BasicBlock* ad_mode_check = BasicBlock::Create(*context, "vref_ad_mode_check", current_func);
        BasicBlock* normal_mode_check = BasicBlock::Create(*context, "vref_normal_mode_check", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "vref_int", current_func);
        BasicBlock* check_large = BasicBlock::Create(*context, "vref_check_large", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "vref_double", current_func);
        BasicBlock* tensor_ad_node_path = BasicBlock::Create(*context, "vref_tensor_ad_node", current_func);
        BasicBlock* vref_merge = BasicBlock::Create(*context, "vref_merge", current_func);
        
        builder->CreateCondBr(in_ad_mode, ad_mode_check, normal_mode_check);

        // AD mode path: MUST STILL distinguish AD nodes from regular doubles!
        // Captured tensors like 'x' contain regular doubles even when ad_mode_active=true
        builder->SetInsertPoint(ad_mode_check);
        Value* is_small_in_ad = builder->CreateICmpULT(elem_as_int64,
            ConstantInt::get(Type::getInt64Ty(*context), 1000));
        BasicBlock* ad_mode_small = BasicBlock::Create(*context, "vref_ad_small", current_func);
        BasicBlock* ad_mode_large = BasicBlock::Create(*context, "vref_ad_large", current_func);
        builder->CreateCondBr(is_small_in_ad, ad_mode_small, ad_mode_large);

        // AD mode, small value: integer
        builder->SetInsertPoint(ad_mode_small);
        Value* ad_int_tagged = packInt64ToTaggedValue(elem_as_int64, true);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_small_exit = builder->GetInsertBlock();

        // AD mode, large value: CRITICAL FIX - use IEEE754 exponent check like normal mode
        // AD node pointers are memory addresses (no exponent bits in high position)
        // Doubles have exponent bits set (0x7FF0000000000000 mask)
        builder->SetInsertPoint(ad_mode_large);
        Value* ad_exponent_mask = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
        Value* ad_exponent_bits = builder->CreateAnd(elem_as_int64, ad_exponent_mask);
        Value* ad_has_exponent = builder->CreateICmpNE(ad_exponent_bits,
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        BasicBlock* ad_large_is_double = BasicBlock::Create(*context, "vref_ad_large_double", current_func);
        BasicBlock* ad_large_is_ptr = BasicBlock::Create(*context, "vref_ad_large_ptr", current_func);
        builder->CreateCondBr(ad_has_exponent, ad_large_is_double, ad_large_is_ptr);

        // AD mode, large value with exponent: it's a double (e.g., captured constant tensor)
        builder->SetInsertPoint(ad_large_is_double);
        Value* ad_elem_double = builder->CreateBitCast(elem_as_int64, Type::getDoubleTy(*context));
        Value* ad_double_tagged = packDoubleToTaggedValue(ad_elem_double);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_double_exit = builder->GetInsertBlock();

        // AD mode, large value without exponent: AD node pointer
        builder->SetInsertPoint(ad_large_is_ptr);
        Value* ad_ptr = builder->CreateIntToPtr(elem_as_int64, PointerType::getUnqual(*context));
        Value* ad_tagged = packPtrToTaggedValue(ad_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_large_exit = builder->GetInsertBlock();
        
        // Normal mode path: use existing IEEE754 heuristic
        builder->SetInsertPoint(normal_mode_check);
        Value* is_small_int = builder->CreateICmpULT(elem_as_int64,
            ConstantInt::get(Type::getInt64Ty(*context), 1000));
        builder->CreateCondBr(is_small_int, int_path, check_large);
        
        // Small integer path: Pack as int64
        builder->SetInsertPoint(int_path);
        Value* int_tagged = packInt64ToTaggedValue(elem_as_int64, true);
        builder->CreateBr(vref_merge);
        BasicBlock* int_exit = builder->GetInsertBlock();
        
        // Check if large value is double (has exponent) or pointer (no exponent)
        builder->SetInsertPoint(check_large);
        Value* exponent_mask = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
        Value* exponent_bits = builder->CreateAnd(elem_as_int64, exponent_mask);
        Value* has_exponent = builder->CreateICmpNE(exponent_bits,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(has_exponent, double_path, tensor_ad_node_path);
        
        // Double path: Bitcast int64 to double and pack
        builder->SetInsertPoint(double_path);
        Value* elem_double = builder->CreateBitCast(elem_as_int64, Type::getDoubleTy(*context));
        Value* double_tagged = packDoubleToTaggedValue(elem_double);
        builder->CreateBr(vref_merge);
        BasicBlock* double_exit = builder->GetInsertBlock();
        
        // AD node path: Treat as AD node pointer (fallback for normal mode)
        builder->SetInsertPoint(tensor_ad_node_path);
        Value* tensor_ad_node_ptr = builder->CreateIntToPtr(elem_as_int64, PointerType::getUnqual(*context));
        Value* tensor_ad_node_tagged = packPtrToTaggedValue(tensor_ad_node_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_exit = builder->GetInsertBlock();
        
        // Merge: Return tagged_value (int, double, or AD node from tensor)
        builder->SetInsertPoint(vref_merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 6, "vref_result");
        result_phi->addIncoming(ad_int_tagged, ad_small_exit);
        result_phi->addIncoming(ad_double_tagged, ad_double_exit);  // AD mode double (captured tensors)
        result_phi->addIncoming(ad_tagged, ad_large_exit);          // AD mode AD node pointer
        result_phi->addIncoming(int_tagged, int_exit);
        result_phi->addIncoming(double_tagged, double_exit);
        result_phi->addIncoming(tensor_ad_node_tagged, ad_exit);
        builder->CreateBr(vref_final);
        
        // Final merge: Return tensor element, Scheme vector element, or AD node
        builder->SetInsertPoint(vref_final);
        PHINode* final_result = builder->CreatePHI(tagged_value_type, 3, "vref_final_result");
        final_result->addIncoming(ad_result, ad_node_exit);
        final_result->addIncoming(scheme_result, scheme_vector_exit);
        final_result->addIncoming(result_phi, vref_merge);

        return final_result;
    }
    
    Value* codegenTensorSet(const eshkol_operations_t* op) {
        // tensor-set: (tensor-set tensor value index1 index2 ...)
        if (op->call_op.num_vars < 3) {
            eshkol_error("tensor-set requires at least tensor, value, and one index");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        Value* new_value = codegenAST(&op->call_op.variables[1]);
        if (!tensor_var_ptr || !new_value) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Calculate linear index from multi-dimensional indices (similar to tensor-get)
        Value* linear_index = ConstantInt::get(Type::getInt64Ty(*context), 0);
        
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Calculate linear index
        Value* stride = ConstantInt::get(Type::getInt64Ty(*context), 1);
        for (int64_t i = op->call_op.num_vars - 3; i >= 0; i--) {
            Value* index = codegenAST(&op->call_op.variables[i + 2]);
            if (index) {
                Value* contribution = builder->CreateMul(index, stride);
                linear_index = builder->CreateAdd(linear_index, contribution);
                
                if (i > 0) {
                    Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                                      ConstantInt::get(Type::getInt64Ty(*context), i));
                    Value* dim = builder->CreateLoad(Type::getInt64Ty(*context), dim_ptr);
                    stride = builder->CreateMul(stride, dim);
                }
            }
        }
        
        // Store new value at linear index
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, linear_index);
        builder->CreateStore(new_value, elem_ptr);
        
        return tensor_ptr_int; // Return the tensor
    }

    // Helper for scheme vector arithmetic (used by tensor-add etc. when given scheme vectors)
    Value* codegenSchemeVectorArithmetic(Value* vec1_tagged, Value* vec2_tagged, const std::string& operation) {
        // Scheme vector layout: [length:i64][elem0:tagged_value][elem1:tagged_value]...

        // Extract pointers from tagged values
        Value* ptr1_int = vec1_tagged;
        Value* ptr2_int = vec2_tagged;
        if (vec1_tagged->getType() == tagged_value_type) {
            ptr1_int = unpackInt64FromTaggedValue(vec1_tagged);
        }
        if (vec2_tagged->getType() == tagged_value_type) {
            ptr2_int = unpackInt64FromTaggedValue(vec2_tagged);
        }

        Value* ptr1 = builder->CreateIntToPtr(ptr1_int, builder->getPtrTy());
        Value* ptr2 = builder->CreateIntToPtr(ptr2_int, builder->getPtrTy());

        // Get length from first vector
        Value* len_ptr = builder->CreateBitCast(ptr1, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* length = builder->CreateLoad(Type::getInt64Ty(*context), len_ptr);

        // Allocate result vector from arena
        uint64_t elem_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);
        Value* result_size = builder->CreateAdd(
            ConstantInt::get(Type::getInt64Ty(*context), 8),  // length field
            builder->CreateMul(length, ConstantInt::get(Type::getInt64Ty(*context), elem_size)));

        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* result_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, result_size});

        // Store length in result
        Value* result_len_ptr = builder->CreateBitCast(result_vec, PointerType::getUnqual(Type::getInt64Ty(*context)));
        builder->CreateStore(length, result_len_ptr);

        // Get element bases (after 8-byte length field)
        Value* elems1_base = builder->CreateGEP(Type::getInt8Ty(*context), ptr1,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* elems2_base = builder->CreateGEP(Type::getInt8Ty(*context), ptr2,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* result_elems_base = builder->CreateGEP(Type::getInt8Ty(*context), result_vec,
            ConstantInt::get(Type::getInt64Ty(*context), 8));

        Value* elems1_typed = builder->CreateBitCast(elems1_base, PointerType::getUnqual(tagged_value_type));
        Value* elems2_typed = builder->CreateBitCast(elems2_base, PointerType::getUnqual(tagged_value_type));
        Value* result_elems_typed = builder->CreateBitCast(result_elems_base, PointerType::getUnqual(tagged_value_type));

        // Create loop
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_cond = BasicBlock::Create(*context, "vec_arith_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "vec_arith_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "vec_arith_exit", current_func);

        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "vec_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateBr(loop_cond);

        // Loop condition
        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* cond = builder->CreateICmpULT(i, length);
        builder->CreateCondBr(cond, loop_body, loop_exit);

        // Loop body
        builder->SetInsertPoint(loop_body);

        // Load tagged values at index i
        Value* elem1_ptr = builder->CreateGEP(tagged_value_type, elems1_typed, i);
        Value* elem2_ptr = builder->CreateGEP(tagged_value_type, elems2_typed, i);
        Value* result_elem_ptr = builder->CreateGEP(tagged_value_type, result_elems_typed, i);

        Value* elem1_tagged = builder->CreateLoad(tagged_value_type, elem1_ptr);
        Value* elem2_tagged = builder->CreateLoad(tagged_value_type, elem2_ptr);

        // Extract doubles from tagged values
        Value* elem1_double = unpackDoubleFromTaggedValue(elem1_tagged);
        Value* elem2_double = unpackDoubleFromTaggedValue(elem2_tagged);

        // Perform operation
        Value* result_double = nullptr;
        if (operation == "add") {
            result_double = builder->CreateFAdd(elem1_double, elem2_double);
        } else if (operation == "sub") {
            result_double = builder->CreateFSub(elem1_double, elem2_double);
        } else if (operation == "mul") {
            result_double = builder->CreateFMul(elem1_double, elem2_double);
        } else if (operation == "div") {
            result_double = builder->CreateFDiv(elem1_double, elem2_double);
        }

        // Pack result and store
        Value* result_tagged = packDoubleToTaggedValue(result_double);
        builder->CreateStore(result_tagged, result_elem_ptr);

        // Increment counter
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, counter);
        builder->CreateBr(loop_cond);

        // Loop exit - return result as tagged value
        builder->SetInsertPoint(loop_exit);
        return packPtrToTaggedValue(result_vec, ESHKOL_VALUE_VECTOR_PTR);
    }

    // Internal helper for tensor/vector arithmetic that accepts tagged values directly
    // Used by both codegenTensorArithmetic and polymorphicAdd/Sub/Mul/Div
    Value* codegenTensorArithmeticInternal(Value* arg1, Value* arg2, const std::string& operation) {
        if (!arg1 || !arg2) return packNullToTaggedValue();

        // Ensure they're tagged values so we can check type at runtime
        if (arg1->getType() != tagged_value_type) {
            arg1 = packInt64ToTaggedValue(arg1, true);
        }
        if (arg2->getType() != tagged_value_type) {
            arg2 = packInt64ToTaggedValue(arg2, true);
        }

        // Extract type tag from first argument at RUNTIME
        Value* type_tag = getTaggedValueType(arg1);
        Value* is_vector = builder->CreateICmpEQ(type_tag,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        // Branch based on type
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* vector_path = BasicBlock::Create(*context, "int_arith_vec_path", current_func);
        BasicBlock* tensor_path = BasicBlock::Create(*context, "int_arith_tensor_path", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "int_arith_merge", current_func);

        // Store result in alloca for merge (more reliable than phi nodes for complex control flow)
        Value* result_alloca = builder->CreateAlloca(tagged_value_type, nullptr, "int_arith_result");

        builder->CreateCondBr(is_vector, vector_path, tensor_path);

        // === VECTOR PATH ===
        builder->SetInsertPoint(vector_path);
        Value* vec_result = codegenSchemeVectorArithmetic(arg1, arg2, operation);
        builder->CreateStore(vec_result, result_alloca);
        builder->CreateBr(merge_block);

        // === TENSOR PATH ===
        builder->SetInsertPoint(tensor_path);

        // Get raw int64 values (tensor pointers)
        Value* tensor1_int = unpackInt64FromTaggedValue(arg1);
        Value* tensor2_int = unpackInt64FromTaggedValue(arg2);

        Value* tensor1_ptr = builder->CreateIntToPtr(tensor1_int, builder->getPtrTy());
        Value* tensor2_ptr = builder->CreateIntToPtr(tensor2_int, builder->getPtrTy());

        // Create result tensor (copy structure of tensor1)
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            builder->CreateStore(packNullToTaggedValue(), result_alloca);
            builder->CreateBr(merge_block);
            builder->SetInsertPoint(merge_block);
            return builder->CreateLoad(tagged_value_type, result_alloca);
        }

        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
                                                   module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor_ptr = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());

        // Copy dimensions from tensor1 to result
        Value* tensor1_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor1_ptr, 0);
        Value* tensor1_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), tensor1_dims_field_ptr);

        Value* result_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 0);
        builder->CreateStore(tensor1_dims_ptr, result_dims_field_ptr);

        // Copy num_dimensions
        Value* tensor1_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor1_ptr, 1);
        Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), tensor1_num_dims_field_ptr);

        Value* result_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 1);
        builder->CreateStore(num_dims, result_num_dims_field_ptr);

        // Get total elements
        Value* tensor1_total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor1_ptr, 3);
        Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), tensor1_total_elements_field_ptr);

        Value* result_total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 3);
        builder->CreateStore(total_elements, result_total_elements_field_ptr);

        // Allocate result elements array
        Value* elements_size = builder->CreateMul(total_elements,
                                                ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* result_elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());

        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 2);
        builder->CreateStore(typed_result_elements_ptr, result_elements_field_ptr);

        // Get elements arrays
        Value* tensor1_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor1_ptr, 2);
        Value* tensor1_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), tensor1_elements_field_ptr);
        Value* typed_tensor1_elements_ptr = builder->CreatePointerCast(tensor1_elements_ptr, builder->getPtrTy());

        Value* tensor2_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor2_ptr, 2);
        Value* tensor2_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), tensor2_elements_field_ptr);
        Value* typed_tensor2_elements_ptr = builder->CreatePointerCast(tensor2_elements_ptr, builder->getPtrTy());

        // Create loop to iterate over all elements
        BasicBlock* loop_cond = BasicBlock::Create(*context, "int_tensor_arith_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "int_tensor_arith_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "int_tensor_arith_exit", current_func);

        // Initialize loop counter
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "int_tensor_arith_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateBr(loop_cond);

        // Loop condition: i < total_elements
        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* cond = builder->CreateICmpULT(i, total_elements);
        builder->CreateCondBr(cond, loop_body, loop_exit);

        // Loop body: perform operation on element i
        builder->SetInsertPoint(loop_body);

        // Get pointers to elements at index i
        Value* elem1_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_tensor1_elements_ptr, i);
        Value* elem2_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_tensor2_elements_ptr, i);
        Value* result_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_result_elements_ptr, i);

        // Load elements as doubles (tensors store doubles)
        Value* elem1 = builder->CreateLoad(Type::getDoubleTy(*context), elem1_ptr);
        Value* elem2 = builder->CreateLoad(Type::getDoubleTy(*context), elem2_ptr);

        // Perform operation
        Value* result_elem = nullptr;
        if (operation == "add") {
            result_elem = builder->CreateFAdd(elem1, elem2);
        } else if (operation == "sub") {
            result_elem = builder->CreateFSub(elem1, elem2);
        } else if (operation == "mul") {
            result_elem = builder->CreateFMul(elem1, elem2);
        } else if (operation == "div") {
            result_elem = builder->CreateFDiv(elem1, elem2);
        }

        // Store result
        if (result_elem) {
            builder->CreateStore(result_elem, result_elem_ptr);
        }

        // Increment counter
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, counter);
        builder->CreateBr(loop_cond);

        // Loop exit - pack tensor result and store
        builder->SetInsertPoint(loop_exit);
        Value* tensor_result = packPtrToTaggedValue(
            builder->CreatePtrToInt(typed_result_tensor_ptr, Type::getInt64Ty(*context)),
            ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateStore(tensor_result, result_alloca);
        builder->CreateBr(merge_block);

        // === MERGE BLOCK ===
        builder->SetInsertPoint(merge_block);
        return builder->CreateLoad(tagged_value_type, result_alloca);
    }

    Value* codegenTensorArithmetic(const eshkol_operations_t* op, const std::string& operation) {
        // tensor-add/sub/mul/div: (tensor-op arg1 arg2)
        // Supports both scheme vectors (VECTOR_PTR) and tensors (TENSOR_PTR)
        if (op->call_op.num_vars != 2) {
            eshkol_error("tensor arithmetic requires exactly 2 arguments");
            return nullptr;
        }

        // Get values - they will be tagged values containing type info at runtime
        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // Delegate to internal helper
        return codegenTensorArithmeticInternal(arg1, arg2, operation);
    }
    
    Value* codegenTensorDot(const eshkol_operations_t* op) {
        // tensor-dot: (tensor-dot A B) - Dot product for 1D vectors, matrix multiplication for 2D
        if (op->call_op.num_vars != 2) {
            eshkol_error("tensor-dot requires exactly 2 arguments: tensor A and tensor B");
            return nullptr;
        }

        // Use codegenTypedAST to get typed values
        TypedValue tensor_a_tv = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tensor_b_tv = codegenTypedAST(&op->call_op.variables[1]);
        if (!tensor_a_tv.llvm_value || !tensor_b_tv.llvm_value) return nullptr;

        // Get raw int64 values (tensor pointers)
        Value* tensor_a_ptr_int = tensor_a_tv.llvm_value;
        Value* tensor_b_ptr_int = tensor_b_tv.llvm_value;

        // Handle tagged_value if returned
        if (tensor_a_ptr_int->getType() == tagged_value_type) {
            tensor_a_ptr_int = unpackInt64FromTaggedValue(tensor_a_ptr_int);
        }
        if (tensor_b_ptr_int->getType() == tagged_value_type) {
            tensor_b_ptr_int = unpackInt64FromTaggedValue(tensor_b_ptr_int);
        }

        // Use class member tensor_type (shared by all tensor operations)

        Value* tensor_a_ptr = builder->CreateIntToPtr(tensor_a_ptr_int, builder->getPtrTy());
        Value* tensor_b_ptr = builder->CreateIntToPtr(tensor_b_ptr_int, builder->getPtrTy());

        // Get tensor A properties
        Value* a_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_a_ptr, 1);
        Value* a_num_dims = builder->CreateLoad(Type::getInt64Ty(*context), a_num_dims_field_ptr);

        Value* a_total_field_ptr = builder->CreateStructGEP(tensor_type, tensor_a_ptr, 3);
        Value* a_total = builder->CreateLoad(Type::getInt64Ty(*context), a_total_field_ptr);

        Value* a_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_a_ptr, 2);
        Value* a_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), a_elements_field_ptr);
        Value* typed_a_elements_ptr = builder->CreatePointerCast(a_elements_ptr, builder->getPtrTy());

        // Get tensor B properties
        Value* b_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_b_ptr, 2);
        Value* b_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), b_elements_field_ptr);
        Value* typed_b_elements_ptr = builder->CreatePointerCast(b_elements_ptr, builder->getPtrTy());

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if 1D vectors - use simple dot product
        Value* is_1d = builder->CreateICmpEQ(a_num_dims, ConstantInt::get(Type::getInt64Ty(*context), 1));

        BasicBlock* dot_1d_block = BasicBlock::Create(*context, "dot_1d", current_func);
        BasicBlock* dot_2d_block = BasicBlock::Create(*context, "dot_2d", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "dot_merge", current_func);

        builder->CreateCondBr(is_1d, dot_1d_block, dot_2d_block);

        // 1D Vector Dot Product: sum(a[i] * b[i])
        builder->SetInsertPoint(dot_1d_block);

        // Initialize accumulator
        Value* sum_alloca = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "dot_sum");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), sum_alloca);

        // Create loop
        BasicBlock* loop_cond_1d = BasicBlock::Create(*context, "dot1d_cond", current_func);
        BasicBlock* loop_body_1d = BasicBlock::Create(*context, "dot1d_body", current_func);
        BasicBlock* loop_exit_1d = BasicBlock::Create(*context, "dot1d_exit", current_func);

        Value* counter_1d = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "dot1d_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter_1d);
        builder->CreateBr(loop_cond_1d);

        builder->SetInsertPoint(loop_cond_1d);
        Value* i_1d = builder->CreateLoad(Type::getInt64Ty(*context), counter_1d);
        Value* cond_1d = builder->CreateICmpULT(i_1d, a_total);
        builder->CreateCondBr(cond_1d, loop_body_1d, loop_exit_1d);

        builder->SetInsertPoint(loop_body_1d);
        Value* a_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_a_elements_ptr, i_1d);
        Value* b_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_b_elements_ptr, i_1d);
        Value* a_elem = builder->CreateLoad(Type::getDoubleTy(*context), a_elem_ptr);
        Value* b_elem = builder->CreateLoad(Type::getDoubleTy(*context), b_elem_ptr);
        Value* product = builder->CreateFMul(a_elem, b_elem);
        Value* old_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum_alloca);
        Value* new_sum = builder->CreateFAdd(old_sum, product);
        builder->CreateStore(new_sum, sum_alloca);

        Value* next_i_1d = builder->CreateAdd(i_1d, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i_1d, counter_1d);
        builder->CreateBr(loop_cond_1d);

        builder->SetInsertPoint(loop_exit_1d);
        Value* dot_result_1d = builder->CreateLoad(Type::getDoubleTy(*context), sum_alloca);
        builder->CreateBr(merge_block);

        // 2D Matrix Multiplication (simplified - just return 0 for now)
        builder->SetInsertPoint(dot_2d_block);
        Value* dot_result_2d = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        // TODO: Implement proper matrix multiplication
        builder->CreateBr(merge_block);

        // Merge and return result as double
        builder->SetInsertPoint(merge_block);
        PHINode* result_phi = builder->CreatePHI(Type::getDoubleTy(*context), 2, "dot_result");
        result_phi->addIncoming(dot_result_1d, loop_exit_1d);
        result_phi->addIncoming(dot_result_2d, dot_2d_block);

        // Return as double (not a tensor)
        return result_phi;
    }

    Value* codegenTensorShape(const eshkol_operations_t* op) {
        // tensor-shape: (tensor-shape tensor) -> returns dimensions as vector
        if (op->call_op.num_vars != 1) {
            eshkol_error("tensor-shape requires exactly 1 tensor argument");
            return nullptr;
        }
        
        Value* tensor_ptr_int = codegenAST(&op->call_op.variables[0]);
        if (!tensor_ptr_int) return nullptr;
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Load num_dimensions
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), num_dims_field_ptr);
        
        // For simplicity, return the num_dimensions as int64
        // A full implementation would return the actual dimensions array as a vector
        eshkol_warn("tensor-shape implementation simplified - returning number of dimensions only");
        return num_dims;
    }
    
    Value* codegenTensorApply(const eshkol_operations_t* op) {
        // tensor-apply: (tensor-apply tensor function)
        // Applies a function to each element of a tensor, returning a new tensor
        if (op->call_op.num_vars != 2) {
            eshkol_error("tensor-apply requires exactly 2 arguments: tensor and function");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        if (!tensor_var_ptr) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Get function to apply - for now we'll support simple arithmetic functions
        // In a full implementation, this would handle lambda expressions and function references
        eshkol_ast_t* func_ast = &op->call_op.variables[1];
        if (func_ast->type != ESHKOL_VAR) {
            eshkol_error("tensor-apply currently only supports simple function names");
            return nullptr;
        }
        
        std::string func_name = func_ast->variable.id;
        
        // Convert int64 back to tensor pointer
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Create result tensor with same dimensions
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                                   module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor_ptr = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Copy tensor structure (dimensions, num_dimensions, total_elements)
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* result_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 0);
        builder->CreateStore(dims_ptr, result_dims_field_ptr);
        
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), num_dims_field_ptr);
        Value* result_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 1);
        builder->CreateStore(num_dims, result_num_dims_field_ptr);
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), total_elements_field_ptr);
        Value* result_total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 3);
        builder->CreateStore(total_elements, result_total_elements_field_ptr);
        
        // Allocate result elements array
        Value* elements_size = builder->CreateMul(total_elements, 
                                                ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* result_elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());
        
        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 2);
        builder->CreateStore(typed_result_elements_ptr, result_elements_field_ptr);
        
        // Get source elements
        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* typed_src_elements_ptr = builder->CreatePointerCast(src_elements_ptr, builder->getPtrTy());
        
        // Apply function to each element (FULL implementation with loops)
        
        // Create basic blocks for loop
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "apply_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "apply_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "apply_loop_exit", current_func);
        
        // Initialize loop counter
        Value* loop_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "loop_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), loop_counter);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < total_elements
        builder->SetInsertPoint(loop_condition);
        Value* current_index = builder->CreateLoad(Type::getInt64Ty(*context), loop_counter);
        Value* loop_cmp = builder->CreateICmpULT(current_index, total_elements);
        builder->CreateCondBr(loop_cmp, loop_body, loop_exit);
        
        // Loop body: apply function to current element
        builder->SetInsertPoint(loop_body);
        
        // Load source element at current index
        Value* src_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_elements_ptr, current_index);
        Value* src_elem = builder->CreateLoad(Type::getInt64Ty(*context), src_elem_ptr);
        
        // Apply function based on function name
        Value* result_elem = nullptr;
        if (func_name == "double") {
            result_elem = builder->CreateMul(src_elem, ConstantInt::get(Type::getInt64Ty(*context), 2));
        } else if (func_name == "square") {
            result_elem = builder->CreateMul(src_elem, src_elem);
        } else if (func_name == "increment") {
            result_elem = builder->CreateAdd(src_elem, ConstantInt::get(Type::getInt64Ty(*context), 1));
        } else if (func_name == "negate") {
            result_elem = builder->CreateNeg(src_elem);
        } else if (func_name == "abs") {
            // abs(x) = x < 0 ? -x : x
            Value* is_negative = builder->CreateICmpSLT(src_elem, ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* negated = builder->CreateNeg(src_elem);
            result_elem = builder->CreateSelect(is_negative, negated, src_elem);
        } else if (func_name == "identity") {
            result_elem = src_elem;
        } else {
            eshkol_warn("Unknown function in tensor-apply: %s, using identity", func_name.c_str());
            result_elem = src_elem;
        }
        
        // Store result element at current index
        Value* result_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_result_elements_ptr, current_index);
        builder->CreateStore(result_elem, result_elem_ptr);
        
        // Increment loop counter
        Value* next_index = builder->CreateAdd(current_index, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_index, loop_counter);
        
        // Jump back to condition check
        builder->CreateBr(loop_condition);
        
        // Loop exit: continue with rest of function
        builder->SetInsertPoint(loop_exit);
        
        return builder->CreatePtrToInt(typed_result_tensor_ptr, Type::getInt64Ty(*context));
    }
    
    Value* codegenTensorReduceAll(const eshkol_operations_t* op) {
        // tensor-reduce-all: (tensor-reduce-all tensor function initial-value)
        // Reduces entire tensor to a single value by applying a binary function
        if (op->call_op.num_vars != 3) {
            eshkol_error("tensor-reduce requires exactly 3 arguments: tensor, function, and initial value");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        Value* initial_value = codegenAST(&op->call_op.variables[2]);
        if (!tensor_var_ptr || !initial_value) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Get function to apply
        eshkol_ast_t* func_ast = &op->call_op.variables[1];
        if (func_ast->type != ESHKOL_VAR) {
            eshkol_error("tensor-reduce currently only supports simple function names");
            return nullptr;
        }
        
        std::string func_name = func_ast->variable.id;
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get tensor elements
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), total_elements_field_ptr);
        
        // FULL implementation: reduce all elements with loop
        
        // Create accumulator variable initialized with initial_value
        Value* accumulator = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "accumulator");
        builder->CreateStore(initial_value, accumulator);
        
        // Create basic blocks for loop
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "reduce_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "reduce_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "reduce_loop_exit", current_func);
        
        // Initialize loop counter
        Value* loop_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "loop_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), loop_counter);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < total_elements
        builder->SetInsertPoint(loop_condition);
        Value* current_index = builder->CreateLoad(Type::getInt64Ty(*context), loop_counter);
        Value* loop_cmp = builder->CreateICmpULT(current_index, total_elements);
        builder->CreateCondBr(loop_cmp, loop_body, loop_exit);
        
        // Loop body: apply reduction function to current element
        builder->SetInsertPoint(loop_body);
        
        // Load current element
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, current_index);
        Value* current_elem = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
        
        // Load current accumulator value
        Value* current_acc = builder->CreateLoad(Type::getInt64Ty(*context), accumulator);
        
        // Apply reduction function
        Value* new_acc = nullptr;
        if (func_name == "+") {
            new_acc = builder->CreateAdd(current_acc, current_elem);
        } else if (func_name == "*") {
            new_acc = builder->CreateMul(current_acc, current_elem);
        } else if (func_name == "max") {
            Value* cmp = builder->CreateICmpSGT(current_acc, current_elem);
            new_acc = builder->CreateSelect(cmp, current_acc, current_elem);
        } else if (func_name == "min") {
            Value* cmp = builder->CreateICmpSLT(current_acc, current_elem);
            new_acc = builder->CreateSelect(cmp, current_acc, current_elem);
        } else if (func_name == "and") {
            new_acc = builder->CreateAnd(current_acc, current_elem);
        } else if (func_name == "or") {
            new_acc = builder->CreateOr(current_acc, current_elem);
        } else if (func_name == "xor") {
            new_acc = builder->CreateXor(current_acc, current_elem);
        } else {
            eshkol_warn("Unknown reduction function: %s, using addition", func_name.c_str());
            new_acc = builder->CreateAdd(current_acc, current_elem);
        }
        
        // Store updated accumulator
        builder->CreateStore(new_acc, accumulator);
        
        // Increment loop counter
        Value* next_index = builder->CreateAdd(current_index, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_index, loop_counter);
        
        // Jump back to condition check
        builder->CreateBr(loop_condition);
        
        // Loop exit: return final accumulator value
        builder->SetInsertPoint(loop_exit);
        Value* result = builder->CreateLoad(Type::getInt64Ty(*context), accumulator);
        
        return result;
    }
    
    Value* codegenTensorReduceWithDim(const eshkol_operations_t* op) {
        // tensor-reduce: (tensor-reduce tensor function initial-value dimension)
        // Reduces tensor along specified dimension, returning tensor with reduced dimensionality
        if (op->call_op.num_vars != 4) {
            eshkol_error("tensor-reduce requires exactly 4 arguments: tensor, function, initial-value, dimension");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        Value* initial_value = codegenAST(&op->call_op.variables[2]);
        Value* dimension_value = codegenAST(&op->call_op.variables[3]);
        if (!tensor_var_ptr || !initial_value || !dimension_value) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Get function to apply
        eshkol_ast_t* func_ast = &op->call_op.variables[1];
        if (func_ast->type != ESHKOL_VAR) {
            eshkol_error("tensor-reduce currently only supports simple function names");
            return nullptr;
        }
        
        std::string func_name = func_ast->variable.id;
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get source tensor properties
        Value* src_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* src_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_dims_field_ptr);
        Value* typed_src_dims_ptr = builder->CreatePointerCast(src_dims_ptr, builder->getPtrTy());

        Value* src_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* src_num_dims = builder->CreateLoad(Type::getInt64Ty(*context), src_num_dims_field_ptr);
        
        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* typed_src_elements_ptr = builder->CreatePointerCast(src_elements_ptr, builder->getPtrTy());
        
        // Create result tensor with one less dimension
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context), 
                                                   module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor_ptr = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Calculate result dimensions (all dimensions except the reduced one)
        // For simplicity, let's assume we're reducing dimension 0 and create a 1D result
        Value* result_num_dims = builder->CreateSub(src_num_dims, ConstantInt::get(Type::getInt64Ty(*context), 1));
        
        // Handle special case where result becomes scalar (0 dimensions)
        Value* is_scalar = builder->CreateICmpEQ(result_num_dims, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* final_num_dims = builder->CreateSelect(is_scalar, ConstantInt::get(Type::getInt64Ty(*context), 1), result_num_dims);
        
        // Allocate result dimensions array
        Value* result_dims_size = builder->CreateMul(final_num_dims, 
                                                   ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims_ptr = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        
        // For simplified implementation: create result with single dimension of size 1 (scalar result)
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), typed_result_dims_ptr);
        
        // Set result tensor properties
        Value* result_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 0);
        builder->CreateStore(typed_result_dims_ptr, result_dims_field_ptr);
        
        Value* result_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 1);
        builder->CreateStore(final_num_dims, result_num_dims_field_ptr);
        
        Value* result_total_elements = ConstantInt::get(Type::getInt64Ty(*context), 1); // Single result element
        Value* result_total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 3);
        builder->CreateStore(result_total_elements, result_total_elements_field_ptr);
        
        // Allocate result elements array (single element for simplified version)
        Value* result_elements_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t));
        Value* result_elements_ptr = builder->CreateCall(malloc_func, {result_elements_size});
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());
        
        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 2);
        builder->CreateStore(typed_result_elements_ptr, result_elements_field_ptr);
        
        // IMPROVED implementation: Handle common dimensional reductions
        
        // For now, implement a basic version that works for vectors (1D) and matrices (2D)
        // This reduces along the specified dimension with proper element iteration
        
        // Create accumulator for result
        Value* accumulator = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "dim_accumulator");
        builder->CreateStore(initial_value, accumulator);
        
        // Get total elements for the reduction
        Value* src_total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* src_total_elements = builder->CreateLoad(Type::getInt64Ty(*context), src_total_elements_field_ptr);
        
        // For simplified implementation, handle dimension 0 reduction properly
        // This will reduce over the first dimension of any tensor
        
        // Calculate stride for dimension 0 (how many elements to skip)
        Value* dim0_size = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_dims_ptr, 
                                            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* first_dim = builder->CreateLoad(Type::getInt64Ty(*context), dim0_size);
        
        // Get total elements divided by first dimension = elements to reduce over
        Value* elements_to_reduce = builder->CreateUDiv(src_total_elements, first_dim);
        
        // PROPER DIMENSIONAL REDUCTION IMPLEMENTATION
        // For a 2D matrix [rows x cols], dimension 0 reduces over rows, dimension 1 reduces over columns
        
        // Check which dimension we're reducing
        Value* dim_is_zero = builder->CreateICmpEQ(dimension_value, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        // Get matrix dimensions (assuming 2D for now)
        Value* dim0_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_dims_ptr, 
                                            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* rows = builder->CreateLoad(Type::getInt64Ty(*context), dim0_ptr);
        
        Value* dim1_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_dims_ptr, 
                                            ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* cols = builder->CreateLoad(Type::getInt64Ty(*context), dim1_ptr);
        
        // Calculate result dimensions and size
        // If reducing dim 0: result is [1 x cols]  
        // If reducing dim 1: result is [rows x 1]
        Value* result_rows = builder->CreateSelect(dim_is_zero, ConstantInt::get(Type::getInt64Ty(*context), 1), rows);
        Value* result_cols = builder->CreateSelect(dim_is_zero, cols, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* result_elements = builder->CreateMul(result_rows, result_cols);
        
        // Update result tensor dimensions
        builder->CreateStore(result_rows, typed_result_dims_ptr);
        Value* result_dim1_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_result_dims_ptr, 
                                                    ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(result_cols, result_dim1_ptr);
        
        // Update result tensor total elements
        builder->CreateStore(result_elements, result_total_elements_field_ptr);
        
        // Allocate result elements array  
        Value* result_elem_size = builder->CreateMul(result_elements, ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* new_result_elements_ptr = builder->CreateCall(malloc_func, {result_elem_size});
        Value* typed_new_result_elements_ptr = builder->CreatePointerCast(new_result_elements_ptr, builder->getPtrTy());
        builder->CreateStore(typed_new_result_elements_ptr, result_elements_field_ptr);
        
        // Create loops based on dimension
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* outer_loop_cond = BasicBlock::Create(*context, "dim_outer_cond", current_func);
        BasicBlock* outer_loop_body = BasicBlock::Create(*context, "dim_outer_body", current_func);
        BasicBlock* inner_loop_cond = BasicBlock::Create(*context, "dim_inner_cond", current_func);
        BasicBlock* inner_loop_body = BasicBlock::Create(*context, "dim_inner_body", current_func);
        BasicBlock* inner_loop_exit = BasicBlock::Create(*context, "dim_inner_exit", current_func);
        BasicBlock* outer_loop_exit = BasicBlock::Create(*context, "dim_outer_exit", current_func);
        
        // Initialize result index counter
        Value* result_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "result_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_idx);
        
        // Initialize outer loop counter
        Value* outer_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "outer_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), outer_counter);
        
        // Jump to outer loop
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop condition
        builder->SetInsertPoint(outer_loop_cond);
        Value* current_outer = builder->CreateLoad(Type::getInt64Ty(*context), outer_counter);
        Value* outer_limit = builder->CreateSelect(dim_is_zero, cols, rows);  // dim0: iterate cols, dim1: iterate rows
        Value* outer_cmp = builder->CreateICmpULT(current_outer, outer_limit);
        builder->CreateCondBr(outer_cmp, outer_loop_body, outer_loop_exit);
        
        // Outer loop body: initialize accumulator for this dimension
        builder->SetInsertPoint(outer_loop_body);
        Value* dim_accumulator = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "dim_acc");
        builder->CreateStore(initial_value, dim_accumulator);
        
        // Initialize inner loop counter  
        Value* inner_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "inner_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), inner_counter);
        
        // Jump to inner loop
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop condition
        builder->SetInsertPoint(inner_loop_cond);
        Value* current_inner = builder->CreateLoad(Type::getInt64Ty(*context), inner_counter);
        Value* inner_limit = builder->CreateSelect(dim_is_zero, rows, cols);  // dim0: iterate rows, dim1: iterate cols
        Value* inner_cmp = builder->CreateICmpULT(current_inner, inner_limit);
        builder->CreateCondBr(inner_cmp, inner_loop_body, inner_loop_exit);
        
        // Inner loop body: calculate element index and apply reduction
        builder->SetInsertPoint(inner_loop_body);
        
        // Calculate source element index: row * cols + col
        Value* src_row = builder->CreateSelect(dim_is_zero, current_inner, current_outer);
        Value* src_col = builder->CreateSelect(dim_is_zero, current_outer, current_inner);
        Value* src_linear_idx = builder->CreateMul(src_row, cols);
        src_linear_idx = builder->CreateAdd(src_linear_idx, src_col);
        
        // Load source element
        Value* src_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_elements_ptr, src_linear_idx);
        Value* src_elem = builder->CreateLoad(Type::getInt64Ty(*context), src_elem_ptr);
        
        // Load current accumulator
        Value* current_acc = builder->CreateLoad(Type::getInt64Ty(*context), dim_accumulator);
        
        // Apply reduction function
        Value* new_acc = nullptr;
        if (func_name == "+") {
            new_acc = builder->CreateAdd(current_acc, src_elem);
        } else if (func_name == "*") {
            new_acc = builder->CreateMul(current_acc, src_elem);
        } else if (func_name == "max") {
            Value* cmp = builder->CreateICmpSGT(current_acc, src_elem);
            new_acc = builder->CreateSelect(cmp, current_acc, src_elem);
        } else if (func_name == "min") {
            Value* cmp = builder->CreateICmpSLT(current_acc, src_elem);
            new_acc = builder->CreateSelect(cmp, current_acc, src_elem);
        } else if (func_name == "mean") {
            new_acc = builder->CreateAdd(current_acc, src_elem);
        } else {
            eshkol_warn("Unknown reduction function: %s, using addition", func_name.c_str());
            new_acc = builder->CreateAdd(current_acc, src_elem);
        }
        
        // Store updated accumulator
        builder->CreateStore(new_acc, dim_accumulator);
        
        // Increment inner counter
        Value* next_inner = builder->CreateAdd(current_inner, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_inner, inner_counter);
        
        // Jump back to inner condition
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop exit: store result and move to next outer iteration
        builder->SetInsertPoint(inner_loop_exit);
        Value* final_acc = builder->CreateLoad(Type::getInt64Ty(*context), dim_accumulator);
        
        // For mean, divide by the dimension size
        if (func_name == "mean") {
            final_acc = builder->CreateSDiv(final_acc, inner_limit);
        }
        
        // Store result in result array
        Value* current_result_idx = builder->CreateLoad(Type::getInt64Ty(*context), result_idx);
        Value* result_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_new_result_elements_ptr, current_result_idx);
        builder->CreateStore(final_acc, result_elem_ptr);
        
        // Increment result index and outer counter
        Value* next_result_idx = builder->CreateAdd(current_result_idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_result_idx, result_idx);
        
        Value* next_outer = builder->CreateAdd(current_outer, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_outer, outer_counter);
        
        // Jump back to outer condition
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop exit
        builder->SetInsertPoint(outer_loop_exit);
        
        return builder->CreatePtrToInt(typed_result_tensor_ptr, Type::getInt64Ty(*context));
    }

    // ===== PHASE 1: ML TENSOR OPERATIONS =====

    // Helper: Create a tensor with given dimensions, returns pointer to tensor struct
    Value* createTensorWithDims(const std::vector<Value*>& dims, Value* fill_value = nullptr, bool use_memset_zero = false) {
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }

        // Calculate total elements
        Value* total_elements = dims[0];
        for (size_t i = 1; i < dims.size(); i++) {
            total_elements = builder->CreateMul(total_elements, dims[i]);
        }

        // Allocate tensor structure
        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
                                             module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());

        // Allocate dimensions array
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), dims.size() * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());

        // Store dimensions
        for (size_t i = 0; i < dims.size(); i++) {
            Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
                                               ConstantInt::get(Type::getInt64Ty(*context), i));
            builder->CreateStore(dims[i], dim_ptr);
        }

        // Allocate elements array
        Value* elements_size = builder->CreateMul(total_elements,
                                                  ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Fill elements if requested
        if (use_memset_zero) {
            // Use memset for efficient zero-fill
            Function* memset_func = module->getFunction("memset");
            if (!memset_func) {
                std::vector<Type*> memset_args = {
                    PointerType::get(*context, 0),
                    Type::getInt32Ty(*context),
                    Type::getInt64Ty(*context)
                };
                FunctionType* memset_type = FunctionType::get(
                    PointerType::get(*context, 0), memset_args, false);
                memset_func = Function::Create(memset_type, Function::ExternalLinkage, "memset", module.get());
            }
            builder->CreateCall(memset_func, {typed_elements_ptr,
                                              ConstantInt::get(Type::getInt32Ty(*context), 0),
                                              elements_size});
        } else if (fill_value) {
            // Fill with specified value using loop
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* loop_cond = BasicBlock::Create(*context, "fill_cond", current_func);
            BasicBlock* loop_body = BasicBlock::Create(*context, "fill_body", current_func);
            BasicBlock* loop_exit = BasicBlock::Create(*context, "fill_exit", current_func);

            Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "fill_i");
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_cond);
            Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
            Value* cmp = builder->CreateICmpULT(i, total_elements);
            builder->CreateCondBr(cmp, loop_body, loop_exit);

            builder->SetInsertPoint(loop_body);
            Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, i);
            builder->CreateStore(fill_value, elem_ptr);
            Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
            builder->CreateStore(next_i, counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_exit);
        }

        // Store tensor fields
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), dims.size()), num_dims_field_ptr);

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2);
        builder->CreateStore(typed_elements_ptr, elements_field_ptr);

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3);
        builder->CreateStore(total_elements, total_elements_field_ptr);

        return typed_tensor_ptr;
    }

    // zeros: (zeros dim1 dim2 ...) - Create tensor filled with zeros
    Value* codegenZeros(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1) {
            eshkol_error("zeros requires at least 1 dimension argument");
            return nullptr;
        }

        std::vector<Value*> dims;
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            Value* dim = codegenAST(&op->call_op.variables[i]);
            if (!dim) return nullptr;
            // Extract int64 from tagged value if needed
            if (dim->getType() == tagged_value_type) {
                dim = unpackInt64FromTaggedValue(dim);
            }
            dims.push_back(dim);
        }

        Value* tensor_ptr = createTensorWithDims(dims, nullptr, true);  // use_memset_zero = true
        if (!tensor_ptr) return nullptr;

        return packPtrToTaggedValue(tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // ones: (ones dim1 dim2 ...) - Create tensor filled with ones (as doubles)
    Value* codegenOnes(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1) {
            eshkol_error("ones requires at least 1 dimension argument");
            return nullptr;
        }

        std::vector<Value*> dims;
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            Value* dim = codegenAST(&op->call_op.variables[i]);
            if (!dim) return nullptr;
            if (dim->getType() == tagged_value_type) {
                dim = unpackInt64FromTaggedValue(dim);
            }
            dims.push_back(dim);
        }

        // Create fill value: 1.0 as double, stored as int64 bit pattern
        Value* one_double = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
        Value* one_bits = builder->CreateBitCast(one_double, Type::getInt64Ty(*context));

        Value* tensor_ptr = createTensorWithDims(dims, one_bits, false);
        if (!tensor_ptr) return nullptr;

        return packPtrToTaggedValue(tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // eye: (eye n) or (eye rows cols) - Create identity matrix
    Value* codegenEye(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_error("eye requires 1 or 2 arguments");
            return nullptr;
        }

        Value* rows = codegenAST(&op->call_op.variables[0]);
        if (!rows) return nullptr;
        if (rows->getType() == tagged_value_type) {
            rows = unpackInt64FromTaggedValue(rows);
        }

        Value* cols = rows;  // Default: square matrix
        if (op->call_op.num_vars == 2) {
            cols = codegenAST(&op->call_op.variables[1]);
            if (!cols) return nullptr;
            if (cols->getType() == tagged_value_type) {
                cols = unpackInt64FromTaggedValue(cols);
            }
        }

        // Create zero-filled tensor first
        std::vector<Value*> dims = {rows, cols};
        Value* tensor_ptr = createTensorWithDims(dims, nullptr, true);  // Zero fill
        if (!tensor_ptr) return nullptr;

        // Get elements pointer
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Set diagonal to 1.0
        Value* one_double = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
        Value* one_bits = builder->CreateBitCast(one_double, Type::getInt64Ty(*context));

        // Loop to set diagonal
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_cond = BasicBlock::Create(*context, "eye_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "eye_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "eye_exit", current_func);

        Value* min_dim = builder->CreateSelect(builder->CreateICmpULT(rows, cols), rows, cols);
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "eye_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* cmp = builder->CreateICmpULT(i, min_dim);
        builder->CreateCondBr(cmp, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        // Diagonal index: i * cols + i
        Value* diag_idx = builder->CreateMul(i, cols);
        diag_idx = builder->CreateAdd(diag_idx, i);
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, diag_idx);
        builder->CreateStore(one_bits, elem_ptr);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, counter);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);

        return packPtrToTaggedValue(tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // arange: (arange n) or (arange start end) or (arange start end step)
    Value* codegenArange(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 3) {
            eshkol_error("arange requires 1-3 arguments");
            return nullptr;
        }

        Value* start = ConstantInt::get(Type::getInt64Ty(*context), 0);
        Value* end;
        Value* step = ConstantInt::get(Type::getInt64Ty(*context), 1);

        if (op->call_op.num_vars == 1) {
            // (arange n) -> 0 to n-1
            end = codegenAST(&op->call_op.variables[0]);
            if (!end) return nullptr;
            if (end->getType() == tagged_value_type) {
                end = unpackInt64FromTaggedValue(end);
            }
        } else {
            // (arange start end) or (arange start end step)
            start = codegenAST(&op->call_op.variables[0]);
            end = codegenAST(&op->call_op.variables[1]);
            if (!start || !end) return nullptr;
            if (start->getType() == tagged_value_type) {
                start = unpackInt64FromTaggedValue(start);
            }
            if (end->getType() == tagged_value_type) {
                end = unpackInt64FromTaggedValue(end);
            }
            if (op->call_op.num_vars == 3) {
                step = codegenAST(&op->call_op.variables[2]);
                if (!step) return nullptr;
                if (step->getType() == tagged_value_type) {
                    step = unpackInt64FromTaggedValue(step);
                }
            }
        }

        // Calculate number of elements: (end - start) / step
        Value* range = builder->CreateSub(end, start);
        Value* num_elements = builder->CreateSDiv(range, step);

        // Create tensor
        std::vector<Value*> dims = {num_elements};
        Value* tensor_ptr = createTensorWithDims(dims, nullptr, false);
        if (!tensor_ptr) return nullptr;

        // Get elements pointer
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Fill with range values
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_cond = BasicBlock::Create(*context, "arange_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "arange_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "arange_exit", current_func);

        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "arange_i");
        Value* current_val = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "arange_val");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateStore(start, current_val);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* cmp = builder->CreateICmpULT(i, num_elements);
        builder->CreateCondBr(cmp, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        Value* val = builder->CreateLoad(Type::getInt64Ty(*context), current_val);
        // Store as double bit pattern for consistency
        Value* val_double = builder->CreateSIToFP(val, Type::getDoubleTy(*context));
        Value* val_bits = builder->CreateBitCast(val_double, Type::getInt64Ty(*context));
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, i);
        builder->CreateStore(val_bits, elem_ptr);

        Value* next_val = builder->CreateAdd(val, step);
        builder->CreateStore(next_val, current_val);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, counter);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);

        return packPtrToTaggedValue(tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // linspace: (linspace start end num) - num evenly spaced values from start to end
    Value* codegenLinspace(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_error("linspace requires exactly 3 arguments: start, end, num");
            return nullptr;
        }

        Value* start = codegenAST(&op->call_op.variables[0]);
        Value* end = codegenAST(&op->call_op.variables[1]);
        Value* num = codegenAST(&op->call_op.variables[2]);
        if (!start || !end || !num) return nullptr;

        // Extract values - convert to double for computation
        if (start->getType() == tagged_value_type) {
            start = unpackDoubleFromTaggedValue(start);
        } else if (start->getType()->isIntegerTy(64)) {
            start = builder->CreateSIToFP(start, Type::getDoubleTy(*context));
        }
        if (end->getType() == tagged_value_type) {
            end = unpackDoubleFromTaggedValue(end);
        } else if (end->getType()->isIntegerTy(64)) {
            end = builder->CreateSIToFP(end, Type::getDoubleTy(*context));
        }
        if (num->getType() == tagged_value_type) {
            num = unpackInt64FromTaggedValue(num);
        }

        // Create tensor
        std::vector<Value*> dims = {num};
        Value* tensor_ptr = createTensorWithDims(dims, nullptr, false);
        if (!tensor_ptr) return nullptr;

        // Get elements pointer
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Calculate step: (end - start) / (num - 1)
        Value* range = builder->CreateFSub(end, start);
        Value* num_minus_1 = builder->CreateSub(num, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* num_minus_1_fp = builder->CreateSIToFP(num_minus_1, Type::getDoubleTy(*context));
        Value* step = builder->CreateFDiv(range, num_minus_1_fp);

        // Fill with linspace values
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_cond = BasicBlock::Create(*context, "linspace_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "linspace_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "linspace_exit", current_func);

        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "ls_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* cmp = builder->CreateICmpULT(i, num);
        builder->CreateCondBr(cmp, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        // val = start + i * step
        Value* i_fp = builder->CreateSIToFP(i, Type::getDoubleTy(*context));
        Value* offset = builder->CreateFMul(i_fp, step);
        Value* val = builder->CreateFAdd(start, offset);
        Value* val_bits = builder->CreateBitCast(val, Type::getInt64Ty(*context));
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, i);
        builder->CreateStore(val_bits, elem_ptr);

        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, counter);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);

        return packPtrToTaggedValue(tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // reshape: (reshape tensor dim1 dim2 ...) - Change tensor shape (must preserve total elements)
    Value* codegenReshape(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 2) {
            eshkol_error("reshape requires tensor and at least 1 dimension");
            return nullptr;
        }

        // Get source tensor
        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        // Extract tensor pointer
        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        // Get new dimensions
        std::vector<Value*> new_dims;
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            Value* dim = codegenAST(&op->call_op.variables[i]);
            if (!dim) return nullptr;
            if (dim->getType() == tagged_value_type) {
                dim = unpackInt64FromTaggedValue(dim);
            }
            new_dims.push_back(dim);
        }

        // Get source tensor properties
        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(Type::getInt64Ty(*context), src_total_field_ptr);

        // Create new tensor structure (reuse elements - no copy needed for reshape)
        Function* malloc_func = function_table["malloc"];
        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
                                             module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* new_tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_new_tensor_ptr = builder->CreatePointerCast(new_tensor_ptr, builder->getPtrTy());

        // Allocate new dimensions array
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), new_dims.size() * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());

        // Store new dimensions and compute new total
        Value* new_total = new_dims[0];
        for (size_t i = 0; i < new_dims.size(); i++) {
            Value* dim_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
                                               ConstantInt::get(Type::getInt64Ty(*context), i));
            builder->CreateStore(new_dims[i], dim_ptr);
            if (i > 0) {
                new_total = builder->CreateMul(new_total, new_dims[i]);
            }
        }

        // Store tensor fields (reuse source elements pointer - zero-copy reshape)
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), new_dims.size()), num_dims_field_ptr);

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 2);
        builder->CreateStore(src_elements_ptr, elements_field_ptr);  // Reuse source elements!

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 3);
        builder->CreateStore(new_total, total_elements_field_ptr);

        return packPtrToTaggedValue(typed_new_tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // transpose: (transpose tensor) - Transpose 2D matrix (swap rows and cols)
    Value* codegenTranspose(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("transpose requires exactly 1 argument");
            return nullptr;
        }

        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        // Get source tensor properties
        Value* src_dims_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 0);
        Value* src_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_dims_field_ptr);
        Value* typed_src_dims_ptr = builder->CreatePointerCast(src_dims_ptr, builder->getPtrTy());

        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* typed_src_elements_ptr = builder->CreatePointerCast(src_elements_ptr, builder->getPtrTy());

        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(Type::getInt64Ty(*context), src_total_field_ptr);

        // Get rows and cols
        Value* rows = builder->CreateLoad(Type::getInt64Ty(*context), typed_src_dims_ptr);
        Value* dim1_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_dims_ptr,
                                            ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* cols = builder->CreateLoad(Type::getInt64Ty(*context), dim1_ptr);

        // Create result tensor with swapped dimensions [cols, rows]
        std::vector<Value*> new_dims = {cols, rows};
        Value* result_ptr = createTensorWithDims(new_dims, nullptr, false);
        if (!result_ptr) return nullptr;

        // Get result elements pointer
        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, result_ptr, 2);
        Value* result_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), result_elements_field_ptr);
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());

        // Transpose: result[j][i] = src[i][j]
        // Optimized loop: iterate linearly over source, compute destination index
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* row_cond = BasicBlock::Create(*context, "trans_row_cond", current_func);
        BasicBlock* row_body = BasicBlock::Create(*context, "trans_row_body", current_func);
        BasicBlock* col_cond = BasicBlock::Create(*context, "trans_col_cond", current_func);
        BasicBlock* col_body = BasicBlock::Create(*context, "trans_col_body", current_func);
        BasicBlock* col_exit = BasicBlock::Create(*context, "trans_col_exit", current_func);
        BasicBlock* row_exit = BasicBlock::Create(*context, "trans_row_exit", current_func);

        Value* row_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "trans_i");
        Value* col_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "trans_j");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), row_counter);
        builder->CreateBr(row_cond);

        builder->SetInsertPoint(row_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), row_counter);
        Value* row_cmp = builder->CreateICmpULT(i, rows);
        builder->CreateCondBr(row_cmp, row_body, row_exit);

        builder->SetInsertPoint(row_body);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), col_counter);
        builder->CreateBr(col_cond);

        builder->SetInsertPoint(col_cond);
        Value* j = builder->CreateLoad(Type::getInt64Ty(*context), col_counter);
        Value* col_cmp = builder->CreateICmpULT(j, cols);
        builder->CreateCondBr(col_cmp, col_body, col_exit);

        builder->SetInsertPoint(col_body);
        // src_idx = i * cols + j
        Value* src_idx = builder->CreateMul(i, cols);
        src_idx = builder->CreateAdd(src_idx, j);
        // dst_idx = j * rows + i
        Value* dst_idx = builder->CreateMul(j, rows);
        dst_idx = builder->CreateAdd(dst_idx, i);

        Value* src_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_elements_ptr, src_idx);
        Value* elem = builder->CreateLoad(Type::getInt64Ty(*context), src_elem_ptr);
        Value* dst_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_result_elements_ptr, dst_idx);
        builder->CreateStore(elem, dst_elem_ptr);

        Value* next_j = builder->CreateAdd(j, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_j, col_counter);
        builder->CreateBr(col_cond);

        builder->SetInsertPoint(col_exit);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, row_counter);
        builder->CreateBr(row_cond);

        builder->SetInsertPoint(row_exit);

        return packPtrToTaggedValue(result_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // flatten: (flatten tensor) - Return 1D view of tensor
    Value* codegenFlatten(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("flatten requires exactly 1 argument");
            return nullptr;
        }

        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        // Get source total elements
        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(Type::getInt64Ty(*context), src_total_field_ptr);

        // Get source elements pointer
        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);

        // Create new 1D tensor (zero-copy - reuse elements)
        Function* malloc_func = function_table["malloc"];
        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
                                             module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* new_tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_new_tensor_ptr = builder->CreatePointerCast(new_tensor_ptr, builder->getPtrTy());

        // Allocate single dimension
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        builder->CreateStore(src_total, typed_dims_ptr);

        // Store tensor fields
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), num_dims_field_ptr);

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 2);
        builder->CreateStore(src_elements_ptr, elements_field_ptr);  // Zero-copy!

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 3);
        builder->CreateStore(src_total, total_elements_field_ptr);

        return packPtrToTaggedValue(typed_new_tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // matmul: (matmul A B) - Matrix multiplication [M x K] @ [K x N] -> [M x N]
    Value* codegenMatmul(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_error("matmul requires exactly 2 arguments");
            return nullptr;
        }

        Value* tensor_a = codegenAST(&op->call_op.variables[0]);
        Value* tensor_b = codegenAST(&op->call_op.variables[1]);
        if (!tensor_a || !tensor_b) return nullptr;

        // Extract tensor pointers
        Value* ptr_a;
        if (tensor_a->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(tensor_a);
            ptr_a = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            ptr_a = builder->CreateIntToPtr(tensor_a, builder->getPtrTy());
        }

        Value* ptr_b;
        if (tensor_b->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(tensor_b);
            ptr_b = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            ptr_b = builder->CreateIntToPtr(tensor_b, builder->getPtrTy());
        }

        // Get A dimensions [M x K]
        Value* a_dims_field_ptr = builder->CreateStructGEP(tensor_type, ptr_a, 0);
        Value* a_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), a_dims_field_ptr);
        Value* typed_a_dims_ptr = builder->CreatePointerCast(a_dims_ptr, builder->getPtrTy());
        Value* M = builder->CreateLoad(Type::getInt64Ty(*context), typed_a_dims_ptr);
        Value* a_dim1_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_a_dims_ptr,
                                              ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* K = builder->CreateLoad(Type::getInt64Ty(*context), a_dim1_ptr);

        // Get B dimensions [K x N]
        Value* b_dims_field_ptr = builder->CreateStructGEP(tensor_type, ptr_b, 0);
        Value* b_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), b_dims_field_ptr);
        Value* typed_b_dims_ptr = builder->CreatePointerCast(b_dims_ptr, builder->getPtrTy());
        Value* b_dim1_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_b_dims_ptr,
                                              ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* N = builder->CreateLoad(Type::getInt64Ty(*context), b_dim1_ptr);

        // Get elements pointers
        Value* a_elements_field_ptr = builder->CreateStructGEP(tensor_type, ptr_a, 2);
        Value* a_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), a_elements_field_ptr);
        Value* typed_a_elements = builder->CreatePointerCast(a_elements_ptr, builder->getPtrTy());

        Value* b_elements_field_ptr = builder->CreateStructGEP(tensor_type, ptr_b, 2);
        Value* b_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), b_elements_field_ptr);
        Value* typed_b_elements = builder->CreatePointerCast(b_elements_ptr, builder->getPtrTy());

        // Create result tensor [M x N]
        std::vector<Value*> result_dims = {M, N};
        Value* result_ptr = createTensorWithDims(result_dims, nullptr, true);  // Zero-fill
        if (!result_ptr) return nullptr;

        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, result_ptr, 2);
        Value* result_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), result_elements_field_ptr);
        Value* typed_result_elements = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());

        // Triple nested loop for matrix multiplication
        // C[i][j] = sum_k(A[i][k] * B[k][j])
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* i_cond = BasicBlock::Create(*context, "mm_i_cond", current_func);
        BasicBlock* i_body = BasicBlock::Create(*context, "mm_i_body", current_func);
        BasicBlock* j_cond = BasicBlock::Create(*context, "mm_j_cond", current_func);
        BasicBlock* j_body = BasicBlock::Create(*context, "mm_j_body", current_func);
        BasicBlock* k_cond = BasicBlock::Create(*context, "mm_k_cond", current_func);
        BasicBlock* k_body = BasicBlock::Create(*context, "mm_k_body", current_func);
        BasicBlock* k_exit = BasicBlock::Create(*context, "mm_k_exit", current_func);
        BasicBlock* j_exit = BasicBlock::Create(*context, "mm_j_exit", current_func);
        BasicBlock* i_exit = BasicBlock::Create(*context, "mm_i_exit", current_func);

        Value* i_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "mm_i");
        Value* j_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "mm_j");
        Value* k_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "mm_k");
        Value* sum_acc = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "mm_sum");

        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), i_counter);
        builder->CreateBr(i_cond);

        // i loop
        builder->SetInsertPoint(i_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), i_counter);
        Value* i_cmp = builder->CreateICmpULT(i, M);
        builder->CreateCondBr(i_cmp, i_body, i_exit);

        builder->SetInsertPoint(i_body);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), j_counter);
        builder->CreateBr(j_cond);

        // j loop
        builder->SetInsertPoint(j_cond);
        Value* j = builder->CreateLoad(Type::getInt64Ty(*context), j_counter);
        Value* j_cmp = builder->CreateICmpULT(j, N);
        builder->CreateCondBr(j_cmp, j_body, j_exit);

        builder->SetInsertPoint(j_body);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), sum_acc);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), k_counter);
        builder->CreateBr(k_cond);

        // k loop (inner accumulation)
        builder->SetInsertPoint(k_cond);
        Value* k = builder->CreateLoad(Type::getInt64Ty(*context), k_counter);
        Value* k_cmp = builder->CreateICmpULT(k, K);
        builder->CreateCondBr(k_cmp, k_body, k_exit);

        builder->SetInsertPoint(k_body);
        // A[i][k] = A[i * K + k]
        Value* a_idx = builder->CreateMul(i, K);
        a_idx = builder->CreateAdd(a_idx, k);
        Value* a_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_a_elements, a_idx);
        Value* a_bits = builder->CreateLoad(Type::getInt64Ty(*context), a_elem_ptr);
        Value* a_val = builder->CreateBitCast(a_bits, Type::getDoubleTy(*context));

        // B[k][j] = B[k * N + j]
        Value* b_idx = builder->CreateMul(k, N);
        b_idx = builder->CreateAdd(b_idx, j);
        Value* b_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_b_elements, b_idx);
        Value* b_bits = builder->CreateLoad(Type::getInt64Ty(*context), b_elem_ptr);
        Value* b_val = builder->CreateBitCast(b_bits, Type::getDoubleTy(*context));

        // sum += A[i][k] * B[k][j]
        Value* product = builder->CreateFMul(a_val, b_val);
        Value* current_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum_acc);
        Value* new_sum = builder->CreateFAdd(current_sum, product);
        builder->CreateStore(new_sum, sum_acc);

        Value* next_k = builder->CreateAdd(k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_k, k_counter);
        builder->CreateBr(k_cond);

        // k exit - store result
        builder->SetInsertPoint(k_exit);
        Value* final_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum_acc);
        Value* result_bits = builder->CreateBitCast(final_sum, Type::getInt64Ty(*context));
        // C[i][j] = C[i * N + j]
        Value* c_idx = builder->CreateMul(i, N);
        c_idx = builder->CreateAdd(c_idx, j);
        Value* c_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_result_elements, c_idx);
        builder->CreateStore(result_bits, c_elem_ptr);

        Value* next_j = builder->CreateAdd(j, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_j, j_counter);
        builder->CreateBr(j_cond);

        // j exit
        builder->SetInsertPoint(j_exit);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, i_counter);
        builder->CreateBr(i_cond);

        // i exit
        builder->SetInsertPoint(i_exit);

        return packPtrToTaggedValue(result_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // tensor-sum: (tensor-sum tensor) or (tensor-sum tensor axis) - Sum elements
    Value* codegenTensorSum(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_error("tensor-sum requires 1 or 2 arguments");
            return nullptr;
        }

        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* typed_src_elements = builder->CreatePointerCast(src_elements_ptr, builder->getPtrTy());

        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(Type::getInt64Ty(*context), src_total_field_ptr);

        // If no axis, sum all elements
        if (op->call_op.num_vars == 1) {
            // Sum all elements
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* loop_cond = BasicBlock::Create(*context, "sum_cond", current_func);
            BasicBlock* loop_body = BasicBlock::Create(*context, "sum_body", current_func);
            BasicBlock* loop_exit = BasicBlock::Create(*context, "sum_exit", current_func);

            Value* sum = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "sum_acc");
            Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "sum_i");
            builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), sum);
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_cond);
            Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
            Value* cmp = builder->CreateICmpULT(i, src_total);
            builder->CreateCondBr(cmp, loop_body, loop_exit);

            builder->SetInsertPoint(loop_body);
            Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_elements, i);
            Value* elem_bits = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
            Value* elem_val = builder->CreateBitCast(elem_bits, Type::getDoubleTy(*context));
            Value* current_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum);
            Value* new_sum = builder->CreateFAdd(current_sum, elem_val);
            builder->CreateStore(new_sum, sum);

            Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
            builder->CreateStore(next_i, counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_exit);
            Value* result = builder->CreateLoad(Type::getDoubleTy(*context), sum);
            return packDoubleToTaggedValue(result);
        }

        // TODO: Axis-specific sum (returns tensor)
        eshkol_warn("tensor-sum with axis not yet implemented, returning total sum");
        return packDoubleToTaggedValue(ConstantFP::get(Type::getDoubleTy(*context), 0.0));
    }

    // tensor-mean: (tensor-mean tensor) or (tensor-mean tensor axis) - Mean of elements
    Value* codegenTensorMean(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_error("tensor-mean requires 1 or 2 arguments");
            return nullptr;
        }

        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);
        Value* typed_src_elements = builder->CreatePointerCast(src_elements_ptr, builder->getPtrTy());

        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(Type::getInt64Ty(*context), src_total_field_ptr);

        // If no axis, mean all elements
        if (op->call_op.num_vars == 1) {
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* loop_cond = BasicBlock::Create(*context, "mean_cond", current_func);
            BasicBlock* loop_body = BasicBlock::Create(*context, "mean_body", current_func);
            BasicBlock* loop_exit = BasicBlock::Create(*context, "mean_exit", current_func);

            Value* sum = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "mean_acc");
            Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "mean_i");
            builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), sum);
            builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_cond);
            Value* i = builder->CreateLoad(Type::getInt64Ty(*context), counter);
            Value* cmp = builder->CreateICmpULT(i, src_total);
            builder->CreateCondBr(cmp, loop_body, loop_exit);

            builder->SetInsertPoint(loop_body);
            Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_src_elements, i);
            Value* elem_bits = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
            Value* elem_val = builder->CreateBitCast(elem_bits, Type::getDoubleTy(*context));
            Value* current_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum);
            Value* new_sum = builder->CreateFAdd(current_sum, elem_val);
            builder->CreateStore(new_sum, sum);

            Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
            builder->CreateStore(next_i, counter);
            builder->CreateBr(loop_cond);

            builder->SetInsertPoint(loop_exit);
            Value* total_sum = builder->CreateLoad(Type::getDoubleTy(*context), sum);
            Value* count_fp = builder->CreateSIToFP(src_total, Type::getDoubleTy(*context));
            Value* result = builder->CreateFDiv(total_sum, count_fp);
            return packDoubleToTaggedValue(result);
        }

        // TODO: Axis-specific mean (returns tensor)
        eshkol_warn("tensor-mean with axis not yet implemented, returning total mean");
        return packDoubleToTaggedValue(ConstantFP::get(Type::getDoubleTy(*context), 0.0));
    }

    // Symbolic differentiation function
    // Returns S-expression (list) representing symbolic derivative formula
    Value* codegenDiff(const eshkol_operations_t* op) {
        if (!op->diff_op.expression || !op->diff_op.variable) {
            eshkol_error("Invalid diff operation");
            return nullptr;
        }
        
        const char* var = op->diff_op.variable;
        eshkol_info("Building symbolic derivative S-expression for %s", var);
        
        // STEP 1: Build symbolic derivative as AST (compile-time)
        eshkol_ast_t* symbolic_deriv = buildSymbolicDerivative(
            op->diff_op.expression,
            var
        );
        
        if (!symbolic_deriv) {
            eshkol_error("Failed to build symbolic derivative");
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }
        
        // STEP 2: Generate runtime code that constructs the S-expression
        // For simple constants, return them directly (not as lists)
        if (symbolic_deriv->type == ESHKOL_INT64 || symbolic_deriv->type == ESHKOL_DOUBLE) {
            Value* result = codegenQuotedAST(symbolic_deriv);
            
            // Clean up temporary AST
            eshkol_ast_clean(symbolic_deriv);
            free(symbolic_deriv);
            
            eshkol_info("Generated constant symbolic derivative");
            return result;
        }
        
        // For complex expressions, convert to S-expression list
        Value* result = codegenQuotedAST(symbolic_deriv);
        
        // Clean up temporary AST
        eshkol_ast_clean(symbolic_deriv);
        free(symbolic_deriv);
        
        eshkol_info("Generated symbolic derivative S-expression");
        
        return result;
    }
    
    // ===== PHASE 0: AUTODIFF TYPE-AWARE HELPERS =====
    
    // Helper: Detect if an expression evaluates to double type
    bool isDoubleExpression(const eshkol_ast_t* expr) {
        if (!expr) return false;
        
        switch (expr->type) {
            case ESHKOL_DOUBLE:
                return true;
                
            case ESHKOL_INT64:
            case ESHKOL_VAR:
                return false;
                
            case ESHKOL_OP:
                // Check operation type
                if (expr->operation.op == ESHKOL_CALL_OP &&
                    expr->operation.call_op.func &&
                    expr->operation.call_op.func->type == ESHKOL_VAR) {
                    std::string func_name = expr->operation.call_op.func->variable.id;
                    
                    // Division always returns double
                    if (func_name == "/") return true;
                    
                    // Trig functions return double
                    if (func_name == "sin" || func_name == "cos" ||
                        func_name == "exp" || func_name == "log" ||
                        func_name == "sqrt" || func_name == "pow") {
                        return true;
                    }
                    
                    // For arithmetic ops, check if any operand is double
                    if (func_name == "+" || func_name == "-" || func_name == "*") {
                        for (uint64_t i = 0; i < expr->operation.call_op.num_vars; i++) {
                            if (isDoubleExpression(&expr->operation.call_op.variables[i])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
                
            default:
                return false;
        }
    }
    
    // Helper: Create type-appropriate constant (int64 or double)
    Value* createTypedConstant(double value, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            return ConstantFP::get(Type::getDoubleTy(*context), value);
        } else {
            return ConstantInt::get(Type::getInt64Ty(*context), static_cast<int64_t>(value));
        }
    }
    
    // Helper: Type-aware multiplication for derivatives
    Value* createTypedMul(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, Type::getDoubleTy(*context));
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, Type::getDoubleTy(*context));
            }
            return builder->CreateFMul(a, b);
        } else {
            // Integer multiplication
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, Type::getInt64Ty(*context));
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, Type::getInt64Ty(*context));
            }
            return builder->CreateMul(a, b);
        }
    }
    
    // Helper: Type-aware addition for derivatives
    Value* createTypedAdd(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, Type::getDoubleTy(*context));
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, Type::getDoubleTy(*context));
            }
            return builder->CreateFAdd(a, b);
        } else {
            // Integer addition
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, Type::getInt64Ty(*context));
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, Type::getInt64Ty(*context));
            }
            return builder->CreateAdd(a, b);
        }
    }
    
    // Helper: Type-aware subtraction for derivatives
    Value* createTypedSub(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, Type::getDoubleTy(*context));
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, Type::getDoubleTy(*context));
            }
            return builder->CreateFSub(a, b);
        } else {
            // Integer subtraction
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, Type::getInt64Ty(*context));
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, Type::getInt64Ty(*context));
            }
            return builder->CreateSub(a, b);
        }
    }
    
    // Helper: Type-aware division for derivatives
    Value* createTypedDiv(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        // Division always returns double
        if (a->getType()->isIntegerTy()) {
            a = builder->CreateSIToFP(a, Type::getDoubleTy(*context));
        }
        if (b->getType()->isIntegerTy()) {
            b = builder->CreateSIToFP(b, Type::getDoubleTy(*context));
        }
        return builder->CreateFDiv(a, b);
    }
    // ===== SYMBOLIC DIFFERENTIATION HELPER FUNCTIONS =====
    // AST-based symbolic derivative builder (compile-time transformation)
    
    // Helper: Check if AST is a constant (number)
    bool isConstant(const eshkol_ast_t* ast) {
        return ast && (ast->type == ESHKOL_INT64 || ast->type == ESHKOL_DOUBLE);
    }
    
    // Helper: Check if AST is specific variable
    bool isVariable(const eshkol_ast_t* ast, const char* var_name) {
        return ast && ast->type == ESHKOL_VAR &&
               ast->variable.id && strcmp(ast->variable.id, var_name) == 0;
    }
    
    // Helper: Check if constant equals specific value
    bool isConstantValue(const eshkol_ast_t* ast, double value) {
        if (ast->type == ESHKOL_INT64) return (double)ast->int64_val == value;
        if (ast->type == ESHKOL_DOUBLE) return ast->double_val == value;
        return false;
    }
    
    // Helper: Check if constant equals 0
    bool isConstantZero(const eshkol_ast_t* ast) {
        return isConstantValue(ast, 0.0);
    }
    
    // Helper: Check if constant equals 1
    bool isConstantOne(const eshkol_ast_t* ast) {
        return isConstantValue(ast, 1.0);
    }
    
    // Core symbolic differentiation function (AST → AST transformation)
    eshkol_ast_t* buildSymbolicDerivative(const eshkol_ast_t* expr, const char* var) {
        if (!expr || !var) return eshkol_make_int_ast(0);
        
        switch (expr->type) {
            case ESHKOL_INT64:
            case ESHKOL_DOUBLE:
                // d/dx(c) = 0
                return eshkol_make_int_ast(0);
                
            case ESHKOL_VAR:
                // d/dx(x) = 1, d/dx(y) = 0
                if (expr->variable.id && strcmp(expr->variable.id, var) == 0)
                    return eshkol_make_int_ast(1);
                else
                    return eshkol_make_int_ast(0);
                    
            case ESHKOL_OP:
                return differentiateOperationSymbolic(&expr->operation, var);
                
            default:
                return eshkol_make_int_ast(0);
        }
    }
    
    // Differentiate operations (symbolic, AST-based)
    eshkol_ast_t* differentiateOperationSymbolic(const eshkol_operations_t* op, const char* var) {
        if (!op || op->op != ESHKOL_CALL_OP) {
            return eshkol_make_int_ast(0);
        }
        
        if (!op->call_op.func || op->call_op.func->type != ESHKOL_VAR ||
            !op->call_op.func->variable.id) {
            return eshkol_make_int_ast(0);
        }
        
        const char* func_name = op->call_op.func->variable.id;
        
        // ADDITION RULE: d/dx(f + g) = f' + g'
        if (strcmp(func_name, "+") == 0 && op->call_op.num_vars >= 2) {
            eshkol_ast_t* result = buildSymbolicDerivative(&op->call_op.variables[0], var);
            
            for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
                eshkol_ast_t* term = buildSymbolicDerivative(&op->call_op.variables[i], var);
                
                // Simplification: skip adding 0
                if (isConstantZero(term)) {
                    continue;
                } else if (isConstantZero(result)) {
                    result = term;
                } else {
                    result = eshkol_make_binary_op_ast("+", result, term);
                }
            }
            return result;
        }
        
        // SUBTRACTION RULE: d/dx(f - g) = f' - g'
        if (strcmp(func_name, "-") == 0 && op->call_op.num_vars == 2) {
            eshkol_ast_t* f_prime = buildSymbolicDerivative(&op->call_op.variables[0], var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(&op->call_op.variables[1], var);
            
            // Simplification: f' - 0 = f'
            if (isConstantZero(g_prime)) return f_prime;
            // Simplification: 0 - g' = -g' (would need negation)
            if (isConstantZero(f_prime)) {
                return eshkol_make_unary_call_ast("-", g_prime);
            }
            
            return eshkol_make_binary_op_ast("-", f_prime, g_prime);
        }
        
        // PRODUCT RULE: d/dx(f * g) = f'*g + f*g'
        if (strcmp(func_name, "*") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* g = &op->call_op.variables[1];
            
            // SPECIAL CASE: d/dx(c * x) = c (constant * variable)
            if (isConstant(f) && isVariable(g, var)) {
                return eshkol_copy_ast(f);
            }
            if (isVariable(f, var) && isConstant(g)) {
                return eshkol_copy_ast(g);
            }
            
            // SPECIAL CASE: d/dx(x * x) = 2*x (simplified)
            if (isVariable(f, var) && isVariable(g, var)) {
                // Return '(* 2 x) as S-expression
                return eshkol_make_binary_op_ast("*",
                    eshkol_make_int_ast(2),
                    eshkol_make_var_ast(var));
            }
            
            // GENERAL CASE: f'*g + f*g'
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(g, var);
            
            // Simplification: 0*g + f*0 = 0
            if (isConstantZero(f_prime) && isConstantZero(g_prime)) {
                return eshkol_make_int_ast(0);
            }
            // Simplification: 0*g + f*g' = f*g'
            if (isConstantZero(f_prime)) {
                return eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            }
            // Simplification: f'*g + f*0 = f'*g
            if (isConstantZero(g_prime)) {
                return eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            }
            
            eshkol_ast_t* term1 = eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            eshkol_ast_t* term2 = eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            return eshkol_make_binary_op_ast("+", term1, term2);
        }
        
        // QUOTIENT RULE: d/dx(f / g) = (f'*g - f*g') / g²
        if (strcmp(func_name, "/") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* g = &op->call_op.variables[1];
            
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(g, var);
            
            // Build: (f'*g - f*g') / g²
            eshkol_ast_t* f_prime_g = eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            eshkol_ast_t* f_g_prime = eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            eshkol_ast_t* numerator = eshkol_make_binary_op_ast("-", f_prime_g, f_g_prime);
            eshkol_ast_t* g_squared = eshkol_make_binary_op_ast("*", eshkol_copy_ast(g), eshkol_copy_ast(g));
            
            return eshkol_make_binary_op_ast("/", numerator, g_squared);
        }
        
        // CHAIN RULE: d/dx(sin(f)) = cos(f) * f'
        if (strcmp(func_name, "sin") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* cos_f = eshkol_make_unary_call_ast("cos", eshkol_copy_ast(f));
            
            // Special case: d/dx(sin(x)) = cos(x) (not cos(x)*1)
            if (isConstantOne(f_prime)) {
                return cos_f;
            }
            
            return eshkol_make_binary_op_ast("*", cos_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(cos(f)) = -sin(f) * f'
        if (strcmp(func_name, "cos") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* sin_f = eshkol_make_unary_call_ast("sin", eshkol_copy_ast(f));
            eshkol_ast_t* neg_sin_f = eshkol_make_unary_call_ast("-", sin_f);
            
            // Special case: d/dx(cos(x)) = -sin(x) (not -sin(x)*1)
            if (isConstantOne(f_prime)) {
                return neg_sin_f;
            }
            
            return eshkol_make_binary_op_ast("*", neg_sin_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(exp(f)) = exp(f) * f'
        if (strcmp(func_name, "exp") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* exp_f = eshkol_make_unary_call_ast("exp", eshkol_copy_ast(f));
            
            // Special case: d/dx(exp(x)) = exp(x)
            if (isConstantOne(f_prime)) {
                return exp_f;
            }
            
            return eshkol_make_binary_op_ast("*", exp_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(log(f)) = f' / f
        if (strcmp(func_name, "log") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            
            // Special case: d/dx(log(x)) = 1/x
            if (isConstantOne(f_prime)) {
                return eshkol_make_binary_op_ast("/", eshkol_make_int_ast(1), eshkol_copy_ast(f));
            }
            
            return eshkol_make_binary_op_ast("/", f_prime, eshkol_copy_ast(f));
        }
        
        // POWER RULE: d/dx(f^n) = n * f^(n-1) * f' (constant exponent)
        if (strcmp(func_name, "pow") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* n = &op->call_op.variables[1];
            
            // Only handle constant exponents
            if (isConstant(n)) {
                eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
                
                // Build: n * f^(n-1) * f'
                eshkol_ast_t* n_minus_1 = nullptr;
                if (n->type == ESHKOL_INT64) {
                    n_minus_1 = eshkol_make_int_ast(n->int64_val - 1);
                } else {
                    n_minus_1 = eshkol_make_double_ast(n->double_val - 1.0);
                }
                
                eshkol_ast_t* f_power = eshkol_make_binary_op_ast("pow", eshkol_copy_ast(f), n_minus_1);
                eshkol_ast_t* n_times_power = eshkol_make_binary_op_ast("*", eshkol_copy_ast(n), f_power);
                
                // Special case: f'=1, simplify to n * f^(n-1)
                if (isConstantOne(f_prime)) {
                    return n_times_power;
                }
                
                return eshkol_make_binary_op_ast("*", n_times_power, f_prime);
            }
        }
        
        // SQRT RULE: d/dx(sqrt(f)) = f' / (2*sqrt(f))
        if (strcmp(func_name, "sqrt") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            
            // Build: f' / (2*sqrt(f))
            eshkol_ast_t* sqrt_f = eshkol_make_unary_call_ast("sqrt", eshkol_copy_ast(f));
            eshkol_ast_t* two_sqrt_f = eshkol_make_binary_op_ast("*", eshkol_make_int_ast(2), sqrt_f);
            
            // Special case: f'=1, simplify to 1 / (2*sqrt(f))
            if (isConstantOne(f_prime)) {
                return eshkol_make_binary_op_ast("/", eshkol_make_int_ast(1), two_sqrt_f);
            }
            
            return eshkol_make_binary_op_ast("/", f_prime, two_sqrt_f);
        }
        
        // Unknown operation - return 0
        return eshkol_make_int_ast(0);
    }
    
    // Convert AST to runtime S-expression (quoted list)
    Value* codegenQuotedAST(const eshkol_ast_t* ast) {
        if (!ast) return packInt64ToTaggedValue(
            ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        
        switch (ast->type) {
            case ESHKOL_INT64:
                // Return integer directly (not as list)
                return packInt64ToTaggedValue(
                    ConstantInt::get(Type::getInt64Ty(*context), ast->int64_val),
                    true);
                
            case ESHKOL_DOUBLE:
                // Return double directly (not as list)
                return packDoubleToTaggedValue(
                    ConstantFP::get(Type::getDoubleTy(*context), ast->double_val));
                
            case ESHKOL_VAR:
                // Return symbol as string - use STRING_PTR type for symbols
                return packPtrToTaggedValue(
                    codegenString(ast->variable.id),
                    ESHKOL_VALUE_STRING_PTR);
                
            case ESHKOL_OP:
                if (ast->operation.op == ESHKOL_CALL_OP) {
                    // Build list: (op arg1 arg2 ...) and wrap as tagged_value
                    Value* list_ptr = codegenQuotedList(&ast->operation);
                    // SYMBOLIC DIFF FIX: Wrap list pointer in tagged_value for nested S-expressions
                    if (list_ptr == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                        return packNullToTaggedValue();
                    }
                    return packPtrToTaggedValue(
                        builder->CreateIntToPtr(list_ptr, builder->getPtrTy()),
                        ESHKOL_VALUE_CONS_PTR);
                }
                // HOMOICONIC FIX: Handle nested lambdas in S-expression generation
                else if (ast->operation.op == ESHKOL_LAMBDA_OP) {
                    Value* nested_sexpr = codegenLambdaToSExpr(&ast->operation);
                    if (nested_sexpr == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                        return packNullToTaggedValue();
                    }
                    return packPtrToTaggedValue(
                        builder->CreateIntToPtr(nested_sexpr, builder->getPtrTy()),
                        ESHKOL_VALUE_CONS_PTR);
                }
                break;
                
            default:
                return packInt64ToTaggedValue(
                    ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }
        
        return packInt64ToTaggedValue(
            ConstantInt::get(Type::getInt64Ty(*context), 0), true);
    }
    
    // Build runtime S-expression list from call operation
    Value* codegenQuotedList(const eshkol_operations_t* op) {
        if (!op || op->op != ESHKOL_CALL_OP) {
            return packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        }
        
        // Build list from right to left: (op arg1 arg2 ...)
        // Start with empty list (null)
        Value* result_int = ConstantInt::get(Type::getInt64Ty(*context), 0);
        
        // Add arguments in reverse
        for (int64_t i = op->call_op.num_vars - 1; i >= 0; i--) {
            Value* elem_tagged = codegenQuotedAST(&op->call_op.variables[i]);
            
            // Convert result_int to tagged value
            Value* result_tagged;
            if (result_int == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                result_tagged = packNullToTaggedValue();
            } else {
                result_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result_int, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }
            
            // Create cons cell from two tagged values
            Value* cons_cell = codegenTaggedArenaConsCellFromTaggedValue(elem_tagged, result_tagged);
            result_int = cons_cell;
        }
        
        // Add operator symbol at front
        // CRITICAL: Must check func->type is ESHKOL_VAR before accessing variable.id
        // func could be any AST type (lambda call, nested call, etc.)
        // EXCEPTION: Skip adding "list" operator for quoted data lists - they should just be (1 2 3), not (list 1 2 3)
        if (op->call_op.func && op->call_op.func->type == ESHKOL_VAR && op->call_op.func->variable.id) {
            std::string func_name = op->call_op.func->variable.id;

            // For "list" function (used to represent quoted data), just return the list without the operator
            if (func_name == "list") {
                // Return result_int as a tagged value
                if (result_int == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                    return ConstantInt::get(Type::getInt64Ty(*context), 0);
                }
                return result_int;
            }

            Value* op_string = codegenString(op->call_op.func->variable.id);
            TypedValue op_symbol(op_string, ESHKOL_VALUE_STRING_PTR, true);
            Value* op_tagged = typedValueToTaggedValue(op_symbol);

            Value* result_tagged;
            if (result_int == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                result_tagged = packNullToTaggedValue();
            } else {
                result_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result_int, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }

            Value* final_list = codegenTaggedArenaConsCellFromTaggedValue(op_tagged, result_tagged);
            // SYMBOLIC DIFF FIX: Return int64 pointer, not tagged (for consistency with codegenQuotedAST caller)
            return final_list;
        }
        
        // SYMBOLIC DIFF FIX: Return int64 pointer, not tagged (for consistency with codegenQuotedAST caller)
        return result_int;
    }
        
    // ===== LAMBDA S-EXPRESSION HOMOICONIC DISPLAY =====
    // Convert lambda AST to runtime S-expression for code-as-data display
    
    // Helper: Build parameter list as cons chain: (param1 param2 ...)
    Value* buildParameterList(const eshkol_ast_t* params, uint64_t num_params) {
        if (num_params == 0) {
            return ConstantInt::get(Type::getInt64Ty(*context), 0); // Empty list
        }
        
        Value* result = ConstantInt::get(Type::getInt64Ty(*context), 0); // Start with null
        
        // Build list backwards for proper cons chain
        for (int64_t i = num_params - 1; i >= 0; i--) {
            if (params[i].type != ESHKOL_VAR || !params[i].variable.id) continue;
            
            // Create parameter symbol string
            Value* param_name = codegenString(params[i].variable.id);
            Value* param_tagged = packPtrToTaggedValue(param_name, ESHKOL_VALUE_STRING_PTR);
            
            // Get rest of list as tagged value
            Value* rest_tagged;
            if (result == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
                rest_tagged = packNullToTaggedValue();
            } else {
                rest_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }
            
            // Cons parameter onto rest
            result = codegenTaggedArenaConsCellFromTaggedValue(param_tagged, rest_tagged);
        }
        
        return result;
    }
    
    // Convert lambda AST to runtime S-expression for homoiconic display
    // Returns cons list pointer (int64): (lambda (param1 param2 ...) body)
    Value* codegenLambdaToSExpr(const eshkol_operations_t* lambda_op) {
        if (!lambda_op || lambda_op->op != ESHKOL_LAMBDA_OP) {
            eshkol_error("codegenLambdaToSExpr: not a lambda operation");
            return ConstantInt::get(Type::getInt64Ty(*context), 0);
        }
        
        // Step 1: Build parameter list - (param1 param2 ...)
        Value* param_list = buildParameterList(
            lambda_op->lambda_op.parameters,
            lambda_op->lambda_op.num_params);
        
        // Step 2: Convert body AST to quoted S-expression
        Value* body_sexpr = ConstantInt::get(Type::getInt64Ty(*context), 0);
        if (lambda_op->lambda_op.body) {
            body_sexpr = codegenQuotedAST(lambda_op->lambda_op.body);
            // codegenQuotedAST returns tagged_value, extract int64 pointer
            if (body_sexpr && body_sexpr->getType() == tagged_value_type) {
                body_sexpr = unpackInt64FromTaggedValue(body_sexpr);
            }
        }
        
        // Step 3: Build complete structure: (lambda (params) body)
        
        // 3a: Create "lambda" symbol string
        Value* lambda_symbol = codegenString("lambda");
        Value* lambda_tagged = packPtrToTaggedValue(lambda_symbol, ESHKOL_VALUE_STRING_PTR);
        
        // 3b: Pack param_list as tagged value
        Value* param_list_tagged;
        if (param_list == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
            param_list_tagged = packNullToTaggedValue();
        } else {
            param_list_tagged = packPtrToTaggedValue(
                builder->CreateIntToPtr(param_list, builder->getPtrTy()),
                ESHKOL_VALUE_CONS_PTR);
        }
        
        // 3c: Pack body_sexpr as tagged value
        Value* body_tagged;
        if (body_sexpr == ConstantInt::get(Type::getInt64Ty(*context), 0)) {
            body_tagged = packNullToTaggedValue();
        } else {
            body_tagged = packPtrToTaggedValue(
                builder->CreateIntToPtr(body_sexpr, builder->getPtrTy()),
                ESHKOL_VALUE_CONS_PTR);
        }
        
        // 3d: Build ((params) . (body . null))
        Value* body_null_tagged = packNullToTaggedValue();
        Value* body_cons = codegenTaggedArenaConsCellFromTaggedValue(body_tagged, body_null_tagged);
        Value* body_cons_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(body_cons, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* params_body = codegenTaggedArenaConsCellFromTaggedValue(
            param_list_tagged, body_cons_tagged);
        
        // 3e: Build (lambda . (params body))
        Value* params_body_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(params_body, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* result = codegenTaggedArenaConsCellFromTaggedValue(
            lambda_tagged, params_body_tagged);
        
        eshkol_debug("Generated lambda S-expression with %llu parameters",
                    (unsigned long long)lambda_op->lambda_op.num_params);
        
        return result;
    }

    // ===== END LAMBDA S-EXPRESSION HOMOICONIC DISPLAY =====
    
    // ===== DUAL NUMBER LLVM IR HELPER FUNCTIONS =====
    
    // Pack value and derivative into dual number struct
    Value* packDualNumber(Value* value, Value* derivative) {
        if (!value || !derivative) return nullptr;
        
        // Create alloca for dual number at function entry
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        Value* dual_ptr = builder->CreateAlloca(dual_number_type, nullptr, "dual");
        
        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);
        
        // Store value in field 0
        Value* value_ptr = builder->CreateStructGEP(dual_number_type, dual_ptr, 0);
        builder->CreateStore(value, value_ptr);
        
        // Store derivative in field 1
        Value* deriv_ptr = builder->CreateStructGEP(dual_number_type, dual_ptr, 1);
        builder->CreateStore(derivative, deriv_ptr);
        
        // Load and return the dual number struct
        return builder->CreateLoad(dual_number_type, dual_ptr);
    }
    
    // Unpack dual number into value and derivative components
    std::pair<Value*, Value*> unpackDualNumber(Value* dual) {
        if (!dual) return {nullptr, nullptr};
        
        // Store dual to temporary alloca
        Value* dual_ptr = builder->CreateAlloca(dual_number_type, nullptr, "temp_dual");
        builder->CreateStore(dual, dual_ptr);
        
        // Extract value (field 0)
        Value* value_ptr = builder->CreateStructGEP(dual_number_type, dual_ptr, 0);
        Value* value = builder->CreateLoad(Type::getDoubleTy(*context), value_ptr);
        
        // Extract derivative (field 1)
        Value* deriv_ptr = builder->CreateStructGEP(dual_number_type, dual_ptr, 1);
        Value* deriv = builder->CreateLoad(Type::getDoubleTy(*context), deriv_ptr);
        
        return {value, deriv};
    }
    
    // Pack dual number into tagged value for storage
    Value* packDualToTaggedValue(Value* dual) {
        if (!dual) return nullptr;
        
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        
        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        // Allocate space for dual number
        Value* dual_ptr = builder->CreateAlloca(dual_number_type, nullptr, "dual_temp");
        
        // Restore insertion point
        builder->restoreIP(saved_ip);
        
        // Store dual number
        builder->CreateStore(dual, dual_ptr);
        
        // Cast pointer to uint64 for storage in tagged value
        Value* dual_as_int = builder->CreatePtrToInt(dual_ptr, Type::getInt64Ty(*context));
        
        // Pack as pointer type tagged value with DUAL_NUMBER type
        return packPtrToTaggedValue(
            builder->CreateIntToPtr(dual_as_int, builder->getPtrTy()),
            ESHKOL_VALUE_DUAL_NUMBER
        );
    }
    
    // Unpack dual number from tagged value
    Value* unpackDualFromTaggedValue(Value* tagged) {
        if (!tagged) return nullptr;
        
        // Verify type is dual number
        Value* type = getTaggedValueType(tagged);
        Value* base_type = builder->CreateAnd(type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        // Extract pointer
        Value* ptr_val = unpackPtrFromTaggedValue(tagged);
        Value* dual_ptr = builder->CreateBitCast(ptr_val,
            PointerType::get(dual_number_type, 0));
        
        // Load and return dual number
        return builder->CreateLoad(dual_number_type, dual_ptr);
    }
    
    // ===== END DUAL NUMBER HELPERS =====
    
    // ===== PHASE 2: DUAL NUMBER ARITHMETIC OPERATIONS =====
    // Forward-mode automatic differentiation via dual numbers
    // Each operation propagates derivatives using automatic differentiation rules
    
    // Addition: (a, a') + (b, b') = (a+b, a'+b')
    Value* dualAdd(Value* dual_a, Value* dual_b) {
        if (!dual_a || !dual_b) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        auto [b, b_prime] = unpackDualNumber(dual_b);
        
        // Value: a + b
        Value* value = builder->CreateFAdd(a, b);
        
        // Derivative: a' + b'
        Value* deriv = builder->CreateFAdd(a_prime, b_prime);
        
        return packDualNumber(value, deriv);
    }
    
    // Subtraction: (a, a') - (b, b') = (a-b, a'-b')
    Value* dualSub(Value* dual_a, Value* dual_b) {
        if (!dual_a || !dual_b) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        auto [b, b_prime] = unpackDualNumber(dual_b);
        
        // Value: a - b
        Value* value = builder->CreateFSub(a, b);
        
        // Derivative: a' - b'
        Value* deriv = builder->CreateFSub(a_prime, b_prime);
        
        return packDualNumber(value, deriv);
    }
    
    // Multiplication: (a, a') * (b, b') = (a*b, a'*b + a*b')
    // This is the product rule for automatic differentiation
    Value* dualMul(Value* dual_a, Value* dual_b) {
        if (!dual_a || !dual_b) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        auto [b, b_prime] = unpackDualNumber(dual_b);
        
        // Value: a * b
        Value* value = builder->CreateFMul(a, b);
        
        // Derivative: a' * b + a * b' (product rule)
        Value* term1 = builder->CreateFMul(a_prime, b);
        Value* term2 = builder->CreateFMul(a, b_prime);
        Value* deriv = builder->CreateFAdd(term1, term2);
        
        return packDualNumber(value, deriv);
    }
    
    // Division: (a, a') / (b, b') = (a/b, (a'*b - a*b')/b²)
    // This is the quotient rule for automatic differentiation
    Value* dualDiv(Value* dual_a, Value* dual_b) {
        if (!dual_a || !dual_b) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        auto [b, b_prime] = unpackDualNumber(dual_b);
        
        // Value: a / b
        Value* value = builder->CreateFDiv(a, b);
        
        // Derivative: (a' * b - a * b') / b²
        Value* numerator_term1 = builder->CreateFMul(a_prime, b);
        Value* numerator_term2 = builder->CreateFMul(a, b_prime);
        Value* numerator = builder->CreateFSub(numerator_term1, numerator_term2);
        Value* denominator = builder->CreateFMul(b, b);
        Value* deriv = builder->CreateFDiv(numerator, denominator);
        
        return packDualNumber(value, deriv);
    }
    
    // Sine: sin(a, a') = (sin(a), a' * cos(a))
    // Chain rule: d/dx[sin(f(x))] = cos(f(x)) * f'(x)
    Value* dualSin(Value* dual_a) {
        if (!dual_a) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        
        // Value: sin(a)
        Value* value = builder->CreateCall(function_table["sin"], {a});
        
        // Derivative: a' * cos(a)
        Value* cos_a = builder->CreateCall(function_table["cos"], {a});
        Value* deriv = builder->CreateFMul(a_prime, cos_a);
        
        return packDualNumber(value, deriv);
    }
    
    // Cosine: cos(a, a') = (cos(a), -a' * sin(a))
    // Chain rule: d/dx[cos(f(x))] = -sin(f(x)) * f'(x)
    Value* dualCos(Value* dual_a) {
        if (!dual_a) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        
        // Value: cos(a)
        Value* value = builder->CreateCall(function_table["cos"], {a});
        
        // Derivative: -a' * sin(a)
        Value* sin_a = builder->CreateCall(function_table["sin"], {a});
        Value* neg_sin_a = builder->CreateFNeg(sin_a);
        Value* deriv = builder->CreateFMul(a_prime, neg_sin_a);
        
        return packDualNumber(value, deriv);
    }
    
    // Exponential: exp(a, a') = (exp(a), a' * exp(a))
    // Chain rule: d/dx[exp(f(x))] = exp(f(x)) * f'(x)
    Value* dualExp(Value* dual_a) {
        if (!dual_a) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        
        // Declare exp function if not already declared
        if (function_table.find("exp") == function_table.end()) {
            std::vector<Type*> exp_args = {Type::getDoubleTy(*context)};
            FunctionType* exp_type = FunctionType::get(
                Type::getDoubleTy(*context), exp_args, false);
            Function* exp_func = Function::Create(
                exp_type, Function::ExternalLinkage, "exp", module.get());
            function_table["exp"] = exp_func;
        }
        
        // Value: exp(a)
        Value* exp_a = builder->CreateCall(function_table["exp"], {a});
        
        // Derivative: a' * exp(a)
        Value* deriv = builder->CreateFMul(a_prime, exp_a);
        
        return packDualNumber(exp_a, deriv);
    }
    
    // Logarithm: log(a, a') = (log(a), a'/a)
    // Chain rule: d/dx[log(f(x))] = f'(x)/f(x)
    Value* dualLog(Value* dual_a) {
        if (!dual_a) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        
        // Declare log function if not already declared
        if (function_table.find("log") == function_table.end()) {
            std::vector<Type*> log_args = {Type::getDoubleTy(*context)};
            FunctionType* log_type = FunctionType::get(
                Type::getDoubleTy(*context), log_args, false);
            Function* log_func = Function::Create(
                log_type, Function::ExternalLinkage, "log", module.get());
            function_table["log"] = log_func;
        }
        
        // Value: log(a)
        Value* value = builder->CreateCall(function_table["log"], {a});

        // Derivative: a' / a
        Value* deriv = builder->CreateFDiv(a_prime, a);

        return packDualNumber(value, deriv);
    }

    // Tangent: tan(a, a') = (tan(a), a' * sec²(a)) = (tan(a), a' * (1 + tan²(a)))
    // Chain rule: d/dx[tan(f(x))] = sec²(f(x)) * f'(x)
    Value* dualTan(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        // Value: tan(a)
        Value* tan_a = builder->CreateCall(function_table["tan"], {a});

        // Derivative: a' * (1 + tan²(a)) = a' * sec²(a)
        Value* tan_sq = builder->CreateFMul(tan_a, tan_a);
        Value* one = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
        Value* sec_sq = builder->CreateFAdd(one, tan_sq);
        Value* deriv = builder->CreateFMul(a_prime, sec_sq);

        return packDualNumber(tan_a, deriv);
    }

    // Hyperbolic sine: sinh(a, a') = (sinh(a), a' * cosh(a))
    // Chain rule: d/dx[sinh(f(x))] = cosh(f(x)) * f'(x)
    Value* dualSinh(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        Value* sinh_a = builder->CreateCall(function_table["sinh"], {a});
        Value* cosh_a = builder->CreateCall(function_table["cosh"], {a});
        Value* deriv = builder->CreateFMul(a_prime, cosh_a);

        return packDualNumber(sinh_a, deriv);
    }

    // Hyperbolic cosine: cosh(a, a') = (cosh(a), a' * sinh(a))
    // Chain rule: d/dx[cosh(f(x))] = sinh(f(x)) * f'(x)
    Value* dualCosh(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        Value* cosh_a = builder->CreateCall(function_table["cosh"], {a});
        Value* sinh_a = builder->CreateCall(function_table["sinh"], {a});
        Value* deriv = builder->CreateFMul(a_prime, sinh_a);

        return packDualNumber(cosh_a, deriv);
    }

    // Hyperbolic tangent: tanh(a, a') = (tanh(a), a' * (1 - tanh²(a))) = (tanh(a), a' * sech²(a))
    // Chain rule: d/dx[tanh(f(x))] = sech²(f(x)) * f'(x)
    Value* dualTanh(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        // Value: tanh(a)
        Value* tanh_a = builder->CreateCall(function_table["tanh"], {a});

        // Derivative: a' * (1 - tanh²(a))
        Value* tanh_sq = builder->CreateFMul(tanh_a, tanh_a);
        Value* one = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
        Value* sech_sq = builder->CreateFSub(one, tanh_sq);
        Value* deriv = builder->CreateFMul(a_prime, sech_sq);

        return packDualNumber(tanh_a, deriv);
    }

    // Absolute value: abs(a, a') = (|a|, a' * sign(a))
    // Note: derivative is undefined at 0, we use 0 there
    Value* dualAbs(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        // Value: |a|
        Value* abs_a = builder->CreateCall(function_table["fabs"], {a});

        // Sign: sign(a) = a / |a| (handles a=0 by returning 0)
        Value* zero = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        Value* is_zero = builder->CreateFCmpOEQ(a, zero);
        Value* sign = builder->CreateSelect(is_zero, zero, builder->CreateFDiv(a, abs_a));

        Value* deriv = builder->CreateFMul(a_prime, sign);

        return packDualNumber(abs_a, deriv);
    }

    // Square root: sqrt(a, a') = (sqrt(a), a' / (2 * sqrt(a)))
    // Chain rule: d/dx[sqrt(f(x))] = f'(x) / (2 * sqrt(f(x)))
    Value* dualSqrt(Value* dual_a) {
        if (!dual_a) return nullptr;

        auto [a, a_prime] = unpackDualNumber(dual_a);

        // Value: sqrt(a)
        Value* sqrt_a = builder->CreateCall(function_table["sqrt"], {a});

        // Derivative: a' / (2 * sqrt(a))
        Value* two = ConstantFP::get(Type::getDoubleTy(*context), 2.0);
        Value* two_sqrt_a = builder->CreateFMul(two, sqrt_a);
        Value* deriv = builder->CreateFDiv(a_prime, two_sqrt_a);

        return packDualNumber(sqrt_a, deriv);
    }

    // Power: (a, a')^(b, b') = (a^b, a^b * (b' * log(a) + b * a'/a))
    // General power rule for both base and exponent being functions
    Value* dualPow(Value* dual_a, Value* dual_b) {
        if (!dual_a || !dual_b) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        auto [b, b_prime] = unpackDualNumber(dual_b);
        
        // Declare log function if not already declared
        if (function_table.find("log") == function_table.end()) {
            std::vector<Type*> log_args = {Type::getDoubleTy(*context)};
            FunctionType* log_type = FunctionType::get(
                Type::getDoubleTy(*context), log_args, false);
            Function* log_func = Function::Create(
                log_type, Function::ExternalLinkage, "log", module.get());
            function_table["log"] = log_func;
        }
        
        // Value: a^b
        Value* value = builder->CreateCall(function_table["pow"], {a, b});
        
        // Derivative: a^b * (b' * log(a) + b * a'/a)
        Value* log_a = builder->CreateCall(function_table["log"], {a});
        Value* term1 = builder->CreateFMul(b_prime, log_a);
        Value* term2 = builder->CreateFMul(b, builder->CreateFDiv(a_prime, a));
        Value* sum = builder->CreateFAdd(term1, term2);
        Value* deriv = builder->CreateFMul(value, sum);
        
        return packDualNumber(value, deriv);
    }
    
    // Negation: -(a, a') = (-a, -a')
    Value* dualNeg(Value* dual_a) {
        if (!dual_a) return nullptr;
        
        auto [a, a_prime] = unpackDualNumber(dual_a);
        
        // Value: -a
        Value* value = builder->CreateFNeg(a);
        
        // Derivative: -a'
        Value* deriv = builder->CreateFNeg(a_prime);
        
        return packDualNumber(value, deriv);
    }
    
    // ===== END DUAL NUMBER ARITHMETIC =====

    // ===== NESTED GRADIENT SUPPORT: TAPE STACK OPERATIONS =====
    // These functions enable arbitrary-depth nested gradient computations
    // by saving/restoring the tape context on a stack.

    // Push current tape context onto stack and activate new tape
    // Returns the saved depth (for verification on pop)
    void pushTapeContext(Value* new_tape) {
        // Load current depth
        Value* depth = builder->CreateLoad(Type::getInt64Ty(*context), ad_tape_depth);

        // Check for stack overflow (depth < MAX_TAPE_DEPTH)
        // Note: In practice we just proceed; 32 levels is generous
        // A more robust implementation could add runtime checks

        // Save current tape to stack[depth]
        Value* current_tape = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);
        ArrayType* stack_type = ArrayType::get(PointerType::getUnqual(*context), MAX_TAPE_DEPTH);
        Value* slot_ptr = builder->CreateGEP(stack_type, ad_tape_stack,
            {ConstantInt::get(Type::getInt64Ty(*context), 0), depth});
        builder->CreateStore(current_tape, slot_ptr);

        // Increment depth
        Value* new_depth = builder->CreateAdd(depth, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_depth, ad_tape_depth);

        // Set new tape as current
        builder->CreateStore(new_tape, current_ad_tape);

        // Set AD mode active
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), ad_mode_active);
    }

    // Pop tape context from stack, restoring previous tape
    void popTapeContext() {
        // Load current depth
        Value* depth = builder->CreateLoad(Type::getInt64Ty(*context), ad_tape_depth);

        // Decrement depth
        Value* new_depth = builder->CreateSub(depth, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_depth, ad_tape_depth);

        // Restore tape from stack[new_depth]
        ArrayType* stack_type = ArrayType::get(PointerType::getUnqual(*context), MAX_TAPE_DEPTH);
        Value* slot_ptr = builder->CreateGEP(stack_type, ad_tape_stack,
            {ConstantInt::get(Type::getInt64Ty(*context), 0), new_depth});
        Value* saved_tape = builder->CreateLoad(PointerType::getUnqual(*context), slot_ptr);

        // Set restored tape as current
        builder->CreateStore(saved_tape, current_ad_tape);

        // Set AD mode based on whether we still have active tapes
        // If new_depth == 0, we're exiting the outermost gradient
        Value* still_active = builder->CreateICmpNE(new_depth,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateStore(still_active, ad_mode_active);
    }

    // ===== DOUBLE BACKWARD HELPER FUNCTIONS =====
    // These functions enable the backward pass to be AD-aware when nested,
    // recording operations on the outer tape for computing higher-order derivatives.

    // Get the outer tape (from stack[depth-1])
    // Returns nullptr if not nested (depth == 0)
    Value* getOuterTape() {
        Value* depth = builder->CreateLoad(Type::getInt64Ty(*context), ad_tape_depth);

        // Check if nested (depth > 0)
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* nested_bb = BasicBlock::Create(*context, "outer_tape_nested", current_func);
        BasicBlock* not_nested_bb = BasicBlock::Create(*context, "outer_tape_not_nested", current_func);
        BasicBlock* merge_bb = BasicBlock::Create(*context, "outer_tape_merge", current_func);

        Value* is_nested = builder->CreateICmpUGT(depth, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_nested, nested_bb, not_nested_bb);

        // Nested: get tape from stack[depth-1]
        builder->SetInsertPoint(nested_bb);
        Value* outer_idx = builder->CreateSub(depth, ConstantInt::get(Type::getInt64Ty(*context), 1));
        ArrayType* stack_type = ArrayType::get(PointerType::getUnqual(*context), MAX_TAPE_DEPTH);
        Value* outer_slot = builder->CreateGEP(stack_type, ad_tape_stack,
            {ConstantInt::get(Type::getInt64Ty(*context), 0), outer_idx});
        Value* outer_tape = builder->CreateLoad(PointerType::getUnqual(*context), outer_slot);
        builder->CreateBr(merge_bb);
        BasicBlock* nested_exit = builder->GetInsertBlock();

        // Not nested: return null
        builder->SetInsertPoint(not_nested_bb);
        Value* null_tape = ConstantPointerNull::get(PointerType::getUnqual(*context));
        builder->CreateBr(merge_bb);
        BasicBlock* not_nested_exit = builder->GetInsertBlock();

        // Merge
        builder->SetInsertPoint(merge_bb);
        PHINode* result = builder->CreatePHI(PointerType::getUnqual(*context), 2, "outer_tape_result");
        result->addIncoming(outer_tape, nested_exit);
        result->addIncoming(null_tape, not_nested_exit);

        return result;
    }

    // Check if currently nested (tape_depth > 0)
    Value* isNested() {
        Value* depth = builder->CreateLoad(Type::getInt64Ty(*context), ad_tape_depth);
        return builder->CreateICmpUGT(depth, ConstantInt::get(Type::getInt64Ty(*context), 0));
    }

    // Create AD constant node on a specific tape
    Value* createADConstantOnTape(Value* tape_ptr, Value* value) {
        if (!tape_ptr || !value) return nullptr;

        // Convert value to double if needed
        if (value->getType()->isIntegerTy()) {
            value = builder->CreateSIToFP(value, Type::getDoubleTy(*context));
        }

        // Allocate AD node
        Value* arena_ptr = getArenaPtr();
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});

        // Set type = AD_NODE_CONSTANT (0)
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt32Ty(*context), 0), type_ptr);

        // Set value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(value, value_ptr);

        // Initialize gradient = 0.0
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);

        // Set input pointers to null (constant has no inputs)
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), input1_ptr);
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), input2_ptr);

        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), next_node_id++), id_ptr);

        // Add to specified tape
        builder->CreateCall(arena_tape_add_node_func, {tape_ptr, node_ptr});

        return node_ptr;
    }

    // Record binary operation on a specific tape
    // Used for double backward - records operations on outer tape
    Value* recordADNodeBinaryOnTape(Value* tape_ptr, uint32_t op_type, Value* left_node, Value* right_node) {
        if (!tape_ptr || !left_node || !right_node) return nullptr;

        // Load values from input nodes
        Value* left_value = loadNodeValue(left_node);
        Value* right_value = loadNodeValue(right_node);

        // Compute result value based on operation
        Value* result_value = nullptr;
        switch (op_type) {
            case 2: // AD_NODE_ADD
                result_value = builder->CreateFAdd(left_value, right_value);
                break;
            case 3: // AD_NODE_SUB
                result_value = builder->CreateFSub(left_value, right_value);
                break;
            case 4: // AD_NODE_MUL
                result_value = builder->CreateFMul(left_value, right_value);
                break;
            case 5: // AD_NODE_DIV
                result_value = builder->CreateFDiv(left_value, right_value);
                break;
            default:
                return nullptr;
        }

        // Allocate new AD node
        Value* arena_ptr = getArenaPtr();
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});

        // Set operation type
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt32Ty(*context), op_type), type_ptr);

        // Set computed value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(result_value, value_ptr);

        // Initialize gradient = 0.0
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);

        // Set input pointers
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(left_node, input1_ptr);
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(right_node, input2_ptr);

        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), next_node_id++), id_ptr);

        // Add to specified tape
        builder->CreateCall(arena_tape_add_node_func, {tape_ptr, node_ptr});

        return node_ptr;
    }

    // ===== PHASE 3: AD NODE HELPER FUNCTIONS =====
    // Computational graph construction for reverse-mode automatic differentiation
    
    // Create AD node for a constant value (gradient = 0)
    Value* createADConstant(Value* value) {
        if (!value) return nullptr;
        
        // Convert value to double if needed
        if (value->getType()->isIntegerTy()) {
            value = builder->CreateSIToFP(value, Type::getDoubleTy(*context));
        }
        
        // Allocate AD node
        Value* arena_ptr = getArenaPtr();
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});

        // Set type = AD_NODE_CONSTANT (0)
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(
            ConstantInt::get(Type::getInt32Ty(*context), 0), // AD_NODE_CONSTANT
            type_ptr
        );
        
        // Set value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(value, value_ptr);
        
        // Initialize gradient = 0.0
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);
        
        // Set input pointers to null
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(
            ConstantPointerNull::get(PointerType::getUnqual(*context)),
            input1_ptr
        );
        
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(
            ConstantPointerNull::get(PointerType::getUnqual(*context)),
            input2_ptr
        );
        
        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(
            ConstantInt::get(Type::getInt64Ty(*context), next_node_id++),
            id_ptr
        );
        
        // Add node to tape - PHASE 1 FIX: Use global runtime tape pointer
        Value* tape_ptr_runtime = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);
        builder->CreateCall(arena_tape_add_node_func, {tape_ptr_runtime, node_ptr});
        
        return node_ptr;
    }
    
    // Create AD node for an input variable (this is where gradients flow back to)
    Value* createADVariable(Value* value, size_t var_index) {
        if (!value) return nullptr;
        
        // Convert value to double if needed
        if (value->getType()->isIntegerTy()) {
            value = builder->CreateSIToFP(value, Type::getDoubleTy(*context));
        }
        
        // Allocate AD node
        Value* arena_ptr = getArenaPtr();
        
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});
        
        // Set type = AD_NODE_VARIABLE (1)
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(
            ConstantInt::get(Type::getInt32Ty(*context), 1), // AD_NODE_VARIABLE
            type_ptr
        );
        
        // Set value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(value, value_ptr);
        
        // Initialize gradient = 0.0 (will be set during backward pass)
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);
        
        // Set input pointers to null (variables have no inputs)
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(
            ConstantPointerNull::get(PointerType::getUnqual(*context)),
            input1_ptr
        );
        
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(
            ConstantPointerNull::get(PointerType::getUnqual(*context)),
            input2_ptr
        );
        
        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(
            ConstantInt::get(Type::getInt64Ty(*context), next_node_id++),
            id_ptr
        );
        
        // Variables are NOT added to tape (they're stored separately)
        
        return node_ptr;
    }
    
    // Record binary operation node (add, sub, mul, div) in computational graph
    Value* recordADNodeBinary(uint32_t op_type, Value* left_node, Value* right_node) {
        if (!left_node || !right_node) return nullptr;

        // Load values from input nodes
        Value* left_value_ptr = builder->CreateStructGEP(ad_node_type, left_node, 1);
        Value* left_value = builder->CreateLoad(Type::getDoubleTy(*context), left_value_ptr);
        
        Value* right_value_ptr = builder->CreateStructGEP(ad_node_type, right_node, 1);
        Value* right_value = builder->CreateLoad(Type::getDoubleTy(*context), right_value_ptr);
        
        // Compute result value based on operation
        Value* result_value = nullptr;
        switch (op_type) {
            case 2: // AD_NODE_ADD
                result_value = builder->CreateFAdd(left_value, right_value);
                break;
            case 3: // AD_NODE_SUB
                result_value = builder->CreateFSub(left_value, right_value);
                break;
            case 4: // AD_NODE_MUL
                result_value = builder->CreateFMul(left_value, right_value);
                break;
            case 5: // AD_NODE_DIV
                result_value = builder->CreateFDiv(left_value, right_value);
                break;
            case 10: // AD_NODE_POW
                result_value = builder->CreateCall(function_table["pow"], {left_value, right_value});
                break;
            default:
                eshkol_error("Unknown binary AD operation type: %u", op_type);
                return nullptr;
        }
        
        // Allocate new AD node
        Value* arena_ptr = getArenaPtr();
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});
        
        // Set operation type
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt32Ty(*context), op_type), type_ptr);
        
        // Set computed value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(result_value, value_ptr);
        
        // Initialize gradient = 0.0
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);
        
        // Set input pointers
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(left_node, input1_ptr);
        
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(right_node, input2_ptr);
        
        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(
            ConstantInt::get(Type::getInt64Ty(*context), next_node_id++),
            id_ptr
        );
        
        // Add to tape - PHASE 1 FIX: Use global runtime tape pointer
        Value* tape_ptr_runtime_binary = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);
        builder->CreateCall(arena_tape_add_node_func, {tape_ptr_runtime_binary, node_ptr});
        
        return node_ptr;
    }
    
    // Record unary operation node (sin, cos, exp, log, neg) in computational graph
    Value* recordADNodeUnary(uint32_t op_type, Value* input_node) {
        if (!input_node) return nullptr;
        
        // Load value from input node
        Value* input_value_ptr = builder->CreateStructGEP(ad_node_type, input_node, 1);
        Value* input_value = builder->CreateLoad(Type::getDoubleTy(*context), input_value_ptr);
        
        // Compute result value based on operation
        Value* result_value = nullptr;
        switch (op_type) {
            case 6: // AD_NODE_SIN
                result_value = builder->CreateCall(function_table["sin"], {input_value});
                break;
            case 7: // AD_NODE_COS
                result_value = builder->CreateCall(function_table["cos"], {input_value});
                break;
            case 8: // AD_NODE_EXP
                if (function_table.find("exp") == function_table.end()) {
                    std::vector<Type*> exp_args = {Type::getDoubleTy(*context)};
                    FunctionType* exp_type = FunctionType::get(Type::getDoubleTy(*context), exp_args, false);
                    Function* exp_func = Function::Create(exp_type, Function::ExternalLinkage, "exp", module.get());
                    function_table["exp"] = exp_func;
                }
                result_value = builder->CreateCall(function_table["exp"], {input_value});
                break;
            case 9: // AD_NODE_LOG
                if (function_table.find("log") == function_table.end()) {
                    std::vector<Type*> log_args = {Type::getDoubleTy(*context)};
                    FunctionType* log_type = FunctionType::get(Type::getDoubleTy(*context), log_args, false);
                    Function* log_func = Function::Create(log_type, Function::ExternalLinkage, "log", module.get());
                    function_table["log"] = log_func;
                }
                result_value = builder->CreateCall(function_table["log"], {input_value});
                break;
            case 11: // AD_NODE_NEG
                result_value = builder->CreateFNeg(input_value);
                break;
            default:
                eshkol_error("Unknown unary AD operation type: %u", op_type);
                return nullptr;
        }
        
        // Allocate new AD node
        Value* arena_ptr = getArenaPtr();
        Value* node_ptr = builder->CreateCall(arena_allocate_ad_node_func, {arena_ptr});
        
        // Set operation type
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        builder->CreateStore(ConstantInt::get(Type::getInt32Ty(*context), op_type), type_ptr);
        
        // Set computed value
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        builder->CreateStore(result_value, value_ptr);
        
        // Initialize gradient = 0.0
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), grad_ptr);
        
        // Set input1 pointer (for unary operations)
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        builder->CreateStore(input_node, input1_ptr);
        
        // Set input2 to null (unary operation has only one input)
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        builder->CreateStore(
            ConstantPointerNull::get(PointerType::getUnqual(*context)),
            input2_ptr
        );
        
        // Set node ID
        Value* id_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 5);
        builder->CreateStore(
            ConstantInt::get(Type::getInt64Ty(*context), next_node_id++),
            id_ptr
        );
        
        // Add to tape - PHASE 1 FIX: Use global runtime tape pointer
        Value* tape_ptr_runtime_unary = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);
        Value* tape_not_null_unary = builder->CreateICmpNE(
            builder->CreatePtrToInt(tape_ptr_runtime_unary, Type::getInt64Ty(*context)),
            ConstantInt::get(Type::getInt64Ty(*context), 0)
        );
        
        BasicBlock* add_unary_to_tape = BasicBlock::Create(*context, "add_unary_to_tape", builder->GetInsertBlock()->getParent());
        BasicBlock* skip_unary_tape = BasicBlock::Create(*context, "skip_unary_tape", builder->GetInsertBlock()->getParent());
        
        builder->CreateCondBr(tape_not_null_unary, add_unary_to_tape, skip_unary_tape);
        
        builder->SetInsertPoint(add_unary_to_tape);
        builder->CreateCall(arena_tape_add_node_func, {tape_ptr_runtime_unary, node_ptr});
        builder->CreateBr(skip_unary_tape);
        
        builder->SetInsertPoint(skip_unary_tape);
        
        return node_ptr;
    }
    
    // Helper: Load node value
    Value* loadNodeValue(Value* node_ptr) {
        if (!node_ptr) return nullptr;
        Value* value_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 1);
        return builder->CreateLoad(Type::getDoubleTy(*context), value_ptr);
    }
    
    // Helper: Load node gradient
    Value* loadNodeGradient(Value* node_ptr) {
        if (!node_ptr) return nullptr;
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        return builder->CreateLoad(Type::getDoubleTy(*context), grad_ptr);
    }
    
    // Helper: Store node gradient
    void storeNodeGradient(Value* node_ptr, Value* gradient) {
        if (!node_ptr || !gradient) return;
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        builder->CreateStore(gradient, grad_ptr);
    }
    
    // Helper: Accumulate gradient (add to existing gradient)
    // CRITICAL FIX: Add RUNTIME null check for node_ptr, not just compile-time check
    void accumulateGradient(Value* node_ptr, Value* gradient_to_add) {
        if (!node_ptr || !gradient_to_add) return;  // Compile-time check (keep for safety)

        // RUNTIME NULL CHECK: Generate LLVM IR to check if node_ptr is null at runtime
        // This is critical because AD constant/variable nodes have null input pointers
        Function* current_func = builder->GetInsertBlock()->getParent();

        BasicBlock* accumulate_block = BasicBlock::Create(*context, "accumulate_grad", current_func);
        BasicBlock* skip_accumulate = BasicBlock::Create(*context, "skip_accumulate", current_func);
        BasicBlock* merge_accumulate = BasicBlock::Create(*context, "merge_accumulate", current_func);

        // Check if node_ptr is null at runtime
        Value* is_null = builder->CreateICmpEQ(node_ptr,
            ConstantPointerNull::get(PointerType::getUnqual(*context)));
        builder->CreateCondBr(is_null, skip_accumulate, accumulate_block);

        // Non-null path: perform gradient accumulation
        builder->SetInsertPoint(accumulate_block);
        Value* grad_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 2);
        Value* current_grad = builder->CreateLoad(Type::getDoubleTy(*context), grad_ptr);
        Value* new_grad = builder->CreateFAdd(current_grad, gradient_to_add);
        builder->CreateStore(new_grad, grad_ptr);
        builder->CreateBr(merge_accumulate);

        // Null path: skip accumulation
        builder->SetInsertPoint(skip_accumulate);
        builder->CreateBr(merge_accumulate);

        // Merge point: continue from here
        builder->SetInsertPoint(merge_accumulate);
    }
    
    // Helper: Load input node pointers
    Value* loadNodeInput1(Value* node_ptr) {
        if (!node_ptr) return nullptr;
        Value* input1_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 3);
        return builder->CreateLoad(PointerType::getUnqual(*context), input1_ptr);
    }
    
    Value* loadNodeInput2(Value* node_ptr) {
        if (!node_ptr) return nullptr;
        Value* input2_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 4);
        return builder->CreateLoad(PointerType::getUnqual(*context), input2_ptr);
    }
    
    // ===== END AD NODE HELPERS =====
    // ===== PHASE 3: BACKWARD PASS IMPLEMENTATION =====
    // Backpropagation through computational graph
    
    // Main backward pass function - propagates gradients from output to inputs
    void codegenBackward(Value* output_node_ptr, Value* tape_ptr) {
        // CRITICAL: Add runtime null checks for placeholder functions
        Function* current_func = builder->GetInsertBlock()->getParent();
        if (!current_func) {
            eshkol_error("Backward pass requires active function context");
            return;
        }
        
        // Create safety check blocks
        BasicBlock* check_validity = BasicBlock::Create(*context, "backward_check_valid", current_func);
        BasicBlock* backward_valid = BasicBlock::Create(*context, "backward_valid", current_func);
        BasicBlock* backward_skip = BasicBlock::Create(*context, "backward_skip", current_func);
        
        builder->CreateBr(check_validity);
        
        // Check if output node and tape are valid (not null)
        builder->SetInsertPoint(check_validity);
        Value* output_int = builder->CreatePtrToInt(output_node_ptr, Type::getInt64Ty(*context));
        Value* tape_int = builder->CreatePtrToInt(tape_ptr, Type::getInt64Ty(*context));
        
        Value* output_valid = builder->CreateICmpNE(output_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* tape_valid = builder->CreateICmpNE(tape_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* both_valid = builder->CreateAnd(output_valid, tape_valid);
        
        builder->CreateCondBr(both_valid, backward_valid, backward_skip);
        
        builder->SetInsertPoint(backward_valid);
        
        // Initialize output gradient = 1.0 (seed for backpropagation)
        storeNodeGradient(output_node_ptr, ConstantFP::get(Type::getDoubleTy(*context), 1.0));
        
        // Get number of nodes in tape (runtime value, not compile-time constant)
        Value* num_nodes = builder->CreateCall(arena_tape_get_node_count_func, {tape_ptr});
        
        // Allocate loop counter for backward traversal (MUST iterate in reverse order)
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "backward_counter");
        if (!counter) {
            eshkol_error("Failed to allocate backward pass counter");
            return;
        }
        
        // Initialize counter = num_nodes (start at end, decrement to 0)
        builder->CreateStore(num_nodes, counter);
        
        // Create loop basic blocks (REQUIRED for LLVM IR structure)
        BasicBlock* loop_cond = BasicBlock::Create(*context, "backward_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "backward_loop_body", current_func);
        BasicBlock* check_node = BasicBlock::Create(*context, "backward_check_node", current_func);
        BasicBlock* propagate_block = BasicBlock::Create(*context, "backward_propagate", current_func);
        BasicBlock* skip_node = BasicBlock::Create(*context, "backward_skip_node", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "backward_loop_exit", current_func);
        
        // Jump to loop condition
        builder->CreateBr(loop_cond);
        
        // Loop condition: while (counter > 0)
        builder->SetInsertPoint(loop_cond);
        Value* counter_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* counter_gt_zero = builder->CreateICmpUGT(counter_val,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(counter_gt_zero, loop_body, loop_exit);
        
        // Loop body: Process node at index (counter - 1)
        builder->SetInsertPoint(loop_body);
        
        // Decrement counter FIRST to get 0-based index
        Value* counter_minus_1 = builder->CreateSub(counter_val,
            ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(counter_minus_1, counter);
        
        // Get node at index using arena_tape_get_node (may return nullptr)
        Value* node_ptr = builder->CreateCall(arena_tape_get_node_func,
            {tape_ptr, counter_minus_1});
        
        // Null check before propagation (defensive programming)
        builder->CreateBr(check_node);
        
        builder->SetInsertPoint(check_node);
        Value* node_is_null = builder->CreateICmpEQ(node_ptr,
            ConstantPointerNull::get(PointerType::getUnqual(*context)));
        builder->CreateCondBr(node_is_null, skip_node, propagate_block);
        
        // Propagate gradient for this node using existing propagateGradient()
        builder->SetInsertPoint(propagate_block);
        propagateGradient(node_ptr);
        builder->CreateBr(skip_node);
        
        // Skip or continue to next iteration
        builder->SetInsertPoint(skip_node);
        builder->CreateBr(loop_cond);
        
        // Loop exit: backward pass complete
        builder->SetInsertPoint(loop_exit);
        builder->CreateBr(backward_skip);
        
        // Skip block: exit point for null/invalid inputs
        builder->SetInsertPoint(backward_skip);
        
        eshkol_debug("Completed backward pass through computational graph");
    }
    
    // Propagate gradient from a node to its inputs based on operation type
    void propagateGradient(Value* node_ptr) {
        if (!node_ptr) return;
        
        // Load node type
        Value* type_ptr = builder->CreateStructGEP(ad_node_type, node_ptr, 0);
        Value* node_type = builder->CreateLoad(Type::getInt32Ty(*context), type_ptr);
        
        // Load node gradient
        Value* node_grad = loadNodeGradient(node_ptr);
        
        // Load input pointers
        Value* input1 = loadNodeInput1(node_ptr);
        Value* input2 = loadNodeInput2(node_ptr);
        
        // Branch on operation type to apply correct gradient rules
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Create blocks for each operation type
        BasicBlock* add_block = BasicBlock::Create(*context, "grad_add", current_func);
        BasicBlock* sub_block = BasicBlock::Create(*context, "grad_sub", current_func);
        BasicBlock* mul_block = BasicBlock::Create(*context, "grad_mul", current_func);
        BasicBlock* div_block = BasicBlock::Create(*context, "grad_div", current_func);
        BasicBlock* sin_block = BasicBlock::Create(*context, "grad_sin", current_func);
        BasicBlock* cos_block = BasicBlock::Create(*context, "grad_cos", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "grad_done", current_func);
        
        // Switch on node type
        // For ADD (type=2): gradient flows equally to both inputs
        Value* is_add = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 2));
        
        BasicBlock* check_sub = BasicBlock::Create(*context, "check_sub", current_func);
        builder->CreateCondBr(is_add, add_block, check_sub);
        
        // ADD: dL/dx = dL/dz * 1, dL/dy = dL/dz * 1
        builder->SetInsertPoint(add_block);
        if (input1) accumulateGradient(input1, node_grad);
        if (input2) accumulateGradient(input2, node_grad);
        builder->CreateBr(done_block);
        
        // Check for SUB
        builder->SetInsertPoint(check_sub);
        Value* is_sub = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 3));
        BasicBlock* check_mul = BasicBlock::Create(*context, "check_mul", current_func);
        builder->CreateCondBr(is_sub, sub_block, check_mul);
        
        // SUB: dL/dx = dL/dz * 1, dL/dy = dL/dz * (-1)
        builder->SetInsertPoint(sub_block);
        if (input1) accumulateGradient(input1, node_grad);
        if (input2) {
            Value* neg_grad = builder->CreateFNeg(node_grad);
            accumulateGradient(input2, neg_grad);
        }
        builder->CreateBr(done_block);
        
        // Check for MUL
        builder->SetInsertPoint(check_mul);
        Value* is_mul = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 4));
        BasicBlock* check_div = BasicBlock::Create(*context, "check_div", current_func);
        builder->CreateCondBr(is_mul, mul_block, check_div);
        
        // MUL: dL/dx = dL/dz * y, dL/dy = dL/dz * x
        builder->SetInsertPoint(mul_block);
        if (input1 && input2) {
            Value* input1_val = loadNodeValue(input1);
            Value* input2_val = loadNodeValue(input2);

            Value* grad_input1 = builder->CreateFMul(node_grad, input2_val);
            Value* grad_input2 = builder->CreateFMul(node_grad, input1_val);

            // DOUBLE BACKWARD: Track degree when multiplying by variable value
            // Load stored variable node and its value for comparison
            Value* stored_var_node = builder->CreateLoad(PointerType::getUnqual(*context), inner_var_node_ptr);
            Value* stored_var_is_valid = builder->CreateICmpNE(stored_var_node,
                ConstantPointerNull::get(PointerType::getUnqual(*context)));

            // Only track degree if we have a stored variable node
            BasicBlock* track_degree_bb = BasicBlock::Create(*context, "track_degree", current_func);
            BasicBlock* skip_degree_bb = BasicBlock::Create(*context, "skip_degree", current_func);
            BasicBlock* after_degree_bb = BasicBlock::Create(*context, "after_degree", current_func);

            builder->CreateCondBr(stored_var_is_valid, track_degree_bb, skip_degree_bb);

            builder->SetInsertPoint(track_degree_bb);
            Value* var_val = loadNodeValue(stored_var_node);

            // FIX: Check node TYPE as well as value to avoid false positives
            // A constant with the same value as the variable should NOT count as a variable
            // AD_NODE_CONSTANT = 0, AD_NODE_PTR (variable) = 1
            Value* input1_type_ptr = builder->CreateStructGEP(ad_node_type, input1, 0);
            Value* input1_type = builder->CreateLoad(Type::getInt32Ty(*context), input1_type_ptr);
            Value* input1_is_var_type = builder->CreateICmpEQ(input1_type, ConstantInt::get(Type::getInt32Ty(*context), 1));

            Value* input2_type_ptr = builder->CreateStructGEP(ad_node_type, input2, 0);
            Value* input2_type = builder->CreateLoad(Type::getInt32Ty(*context), input2_type_ptr);
            Value* input2_is_var_type = builder->CreateICmpEQ(input2_type, ConstantInt::get(Type::getInt32Ty(*context), 1));

            // Check if input2 is the variable (by value comparison with tolerance AND type check)
            Value* diff2 = builder->CreateFSub(input2_val, var_val);
            Function* fabs_intrinsic = Intrinsic::getDeclaration(module.get(), Intrinsic::fabs, {Type::getDoubleTy(*context)});
            Value* abs_diff2 = builder->CreateCall(fabs_intrinsic, {diff2});
            Value* val_matches_2 = builder->CreateFCmpOLT(abs_diff2, ConstantFP::get(Type::getDoubleTy(*context), 1e-10));
            Value* is_var2 = builder->CreateAnd(val_matches_2, input2_is_var_type);

            // Check if input1 is the variable (by value comparison AND type check)
            Value* diff1 = builder->CreateFSub(input1_val, var_val);
            Value* abs_diff1 = builder->CreateCall(fabs_intrinsic, {diff1});
            Value* val_matches_1 = builder->CreateFCmpOLT(abs_diff1, ConstantFP::get(Type::getDoubleTy(*context), 1e-10));
            Value* is_var1 = builder->CreateAnd(val_matches_1, input1_is_var_type);

            // Count how many times we multiply by variable value
            // This tracks the polynomial degree of the gradient
            Value* current_degree = builder->CreateLoad(Type::getInt64Ty(*context), gradient_x_degree);
            Value* inc2 = builder->CreateSelect(is_var2,
                ConstantInt::get(Type::getInt64Ty(*context), 1),
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* inc1 = builder->CreateSelect(is_var1,
                ConstantInt::get(Type::getInt64Ty(*context), 1),
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            Value* total_inc = builder->CreateAdd(inc1, inc2);
            Value* new_degree = builder->CreateAdd(current_degree, total_inc);
            builder->CreateStore(new_degree, gradient_x_degree);
            builder->CreateBr(after_degree_bb);

            builder->SetInsertPoint(skip_degree_bb);
            builder->CreateBr(after_degree_bb);

            builder->SetInsertPoint(after_degree_bb);

            accumulateGradient(input1, grad_input1);
            accumulateGradient(input2, grad_input2);
        }
        builder->CreateBr(done_block);
        
        // Check for DIV
        builder->SetInsertPoint(check_div);
        Value* is_div = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 5));
        BasicBlock* check_sin = BasicBlock::Create(*context, "check_sin", current_func);
        builder->CreateCondBr(is_div, div_block, check_sin);
        
        // DIV: dL/dx = dL/dz / y, dL/dy = dL/dz * (-x/y²)
        builder->SetInsertPoint(div_block);
        if (input1 && input2) {
            Value* input1_val = loadNodeValue(input1);
            Value* input2_val = loadNodeValue(input2);
            
            Value* grad_input1 = builder->CreateFDiv(node_grad, input2_val);
            
            Value* y_squared = builder->CreateFMul(input2_val, input2_val);
            Value* neg_x_over_y2 = builder->CreateFDiv(builder->CreateFNeg(input1_val), y_squared);
            Value* grad_input2 = builder->CreateFMul(node_grad, neg_x_over_y2);
            
            accumulateGradient(input1, grad_input1);
            accumulateGradient(input2, grad_input2);
        }
        builder->CreateBr(done_block);
        
        // Check for SIN
        builder->SetInsertPoint(check_sin);
        Value* is_sin = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 6));
        BasicBlock* check_cos = BasicBlock::Create(*context, "check_cos", current_func);
        builder->CreateCondBr(is_sin, sin_block, check_cos);
        
        // SIN: dL/dx = dL/dz * cos(x)
        builder->SetInsertPoint(sin_block);
        if (input1) {
            Value* input_val = loadNodeValue(input1);
            Value* cos_val = builder->CreateCall(function_table["cos"], {input_val});
            Value* grad_input = builder->CreateFMul(node_grad, cos_val);
            accumulateGradient(input1, grad_input);
        }
        builder->CreateBr(done_block);
        
        // Check for COS
        builder->SetInsertPoint(check_cos);
        Value* is_cos = builder->CreateICmpEQ(node_type, ConstantInt::get(Type::getInt32Ty(*context), 7));
        builder->CreateCondBr(is_cos, cos_block, done_block); // Default to done if unknown
        
        // COS: dL/dx = dL/dz * (-sin(x))
        builder->SetInsertPoint(cos_block);
        if (input1) {
            Value* input_val = loadNodeValue(input1);
            Value* sin_val = builder->CreateCall(function_table["sin"], {input_val});
            Value* neg_sin = builder->CreateFNeg(sin_val);
            Value* grad_input = builder->CreateFMul(node_grad, neg_sin);
            accumulateGradient(input1, grad_input);
        }
        builder->CreateBr(done_block);
        
        // Done
        builder->SetInsertPoint(done_block);
    }
    
    // ===== END BACKWARD PASS =====
    
    
    // ===== PHASE 2: DERIVATIVE OPERATOR IMPLEMENTATION =====
    // Runtime derivative computation using dual numbers
    
    Value* codegenDerivative(const eshkol_operations_t* op) {
        if (!op->derivative_op.function || !op->derivative_op.point) {
            eshkol_error("Invalid derivative operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing derivative using forward-mode AD (dual numbers)");
        
        // Get the function to differentiate
        Value* func = resolveLambdaFunction(op->derivative_op.function);
        if (!func) {
            eshkol_error("Failed to resolve function for derivative");
            return nullptr;
        }
        
        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("derivative operator requires a function");
            return nullptr;
        }
        
        // Get evaluation point - must be a scalar double
        Value* x = codegenAST(op->derivative_op.point);
        if (!x) {
            eshkol_error("Failed to evaluate derivative point");
            return nullptr;
        }
        
        // Convert x to double if it's an integer or tagged_value
        if (x->getType()->isIntegerTy()) {
            x = builder->CreateSIToFP(x, Type::getDoubleTy(*context));
        } else if (x->getType() == tagged_value_type) {
            // Handle computed values that return tagged_value_t
            // Extract the double from the data field
            x = unpackDoubleFromTaggedValue(x);
        } else if (!x->getType()->isDoubleTy()) {
            eshkol_error("derivative point must be numeric (int64 or double)");
            return nullptr;
        }
        
        // Create dual number with seed derivative = 1.0
        // This means: "we're computing the derivative with respect to this input"
        Value* one = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
        Value* x_dual = packDualNumber(x, one);
        
        // Pack dual number into tagged_value for function call
        Value* x_dual_tagged = packDualToTaggedValue(x_dual);
        
        // Build arguments for derivative lambda call
        std::vector<Value*> deriv_call_args = {x_dual_tagged};
        
        // CLOSURE FIX: Load captures from STORAGE
        FunctionType* deriv_func_type = func_ptr->getFunctionType();
        if (deriv_func_type->getNumParams() > 1) {
            size_t num_captures = deriv_func_type->getNumParams() - 1;
            std::string lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            // (LLVM external declarations may have empty parameter names)
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t i = 0; i < num_captures; i++) {
                std::string var_name;
                if (i < capture_names.size()) {
                    var_name = capture_names[i];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto arg_it = func_ptr->arg_begin();
                    std::advance(arg_it, i + 1);  // Skip first parameter
                    if (arg_it != func_ptr->arg_end()) {
                        var_name = arg_it->getName().str();
                        if (var_name.find("captured_") == 0) {
                            var_name = var_name.substr(9);
                        }
                    }
                }

                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try local symbol tables
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                capture_key
                            );
                        }
                        Value* captured_val = builder->CreateLoad(tagged_value_type, capture_global);
                        deriv_call_args.push_back(captured_val);
                        continue;
                    }
                }

                if (found && it->second) {
                    Value* storage = it->second;
                    Value* captured_val = builder->CreateLoad(tagged_value_type, storage);
                    deriv_call_args.push_back(captured_val);
                } else {
                    deriv_call_args.push_back(packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), 0), true));
                    eshkol_warn("Derivative: capture '%s' not found, using 0", var_name.c_str());
                }
            }
        }
        
        // Call function with dual number input and captures
        // The function will automatically use dual arithmetic, propagating derivatives
        Value* result_tagged = builder->CreateCall(func_ptr, deriv_call_args);
        
        // Unpack result from tagged_value
        Value* result_dual = unpackDualFromTaggedValue(result_tagged);
        
        // Extract derivative component from result
        auto [value, derivative] = unpackDualNumber(result_dual);
        
        eshkol_debug("Derivative operator: extracted derivative component");
        
        // Return just the derivative (as a double)
        return derivative;
    }
    
    // ===== END DERIVATIVE OPERATOR =====
    // ===== PHASE 3: GRADIENT OPERATOR IMPLEMENTATION =====
    // Reverse-mode automatic differentiation for vector gradients
    
    Value* codegenGradient(const eshkol_operations_t* op) {
        if (!op->gradient_op.function || !op->gradient_op.point) {
            eshkol_error("Invalid gradient operation - missing function or point");
            return nullptr;
        }

        // Resolve function (lambda or function reference)
        Value* func = resolveLambdaFunction(op->gradient_op.function);

        if (!func) {
            eshkol_error("Failed to resolve function for gradient computation");
            return nullptr;
        }

        Function* func_ptr = dyn_cast<Function>(func);

        if (!func_ptr) {
            eshkol_error("Gradient operator requires actual function, got non-function value");
            return nullptr;
        }
        
        // Evaluate point to get input vector
        Value* vector_val_raw = codegenAST(op->gradient_op.point);
        if (!vector_val_raw) {
            eshkol_error("Failed to evaluate gradient evaluation point");
            return nullptr;
        }
        
        // CRITICAL FIX: Ensure input is tagged_value (codegenAST can return raw types for literals)
        Value* vector_val;
        if (vector_val_raw->getType() == tagged_value_type) {
            vector_val = vector_val_raw; // Already tagged
        } else if (vector_val_raw->getType()->isIntegerTy(64)) {
            vector_val = packInt64ToTaggedValue(vector_val_raw, true); // Pack int64
        } else if (vector_val_raw->getType()->isDoubleTy()) {
            vector_val = packDoubleToTaggedValue(vector_val_raw); // Pack double
        } else {
            TypedValue tv = detectValueType(vector_val_raw);
            vector_val = typedValueToTaggedValue(tv); // Pack other types
        }
        
        // SCALAR→VECTOR AUTO-PROMOTION: Detect input type BEFORE tensor structure access
        // This prevents segfault when users pass scalars like 3.0 instead of vectors like #(3.0)

        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Extract type from input (may be DOUBLE, INT64, TENSOR_PTR, or AD_NODE_PTR for nested gradients)
        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // DOUBLE BACKWARD: Check if input is an AD node (from outer gradient)
        // This happens in nested gradients like (gradient (lambda (y) (gradient f y)) x)
        Value* is_ad_node_input = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));

        // Check if input is scalar (INT64 or DOUBLE)
        Value* is_int64 = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_INT64));
        Value* is_double = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        Value* is_scalar = builder->CreateOr(is_int64, is_double);

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        // Branch: AD node input (nested), scalar input (promotion), scheme vector (convert), or tensor input (normal)
        BasicBlock* ad_node_input = BasicBlock::Create(*context, "grad_ad_node_input", current_func);
        BasicBlock* scalar_input = BasicBlock::Create(*context, "grad_scalar_input", current_func);
        BasicBlock* scheme_vector_input = BasicBlock::Create(*context, "grad_scheme_vector_input", current_func);
        BasicBlock* vector_input = BasicBlock::Create(*context, "grad_vector_input", current_func);
        BasicBlock* grad_merge_input = BasicBlock::Create(*context, "grad_merge_input", current_func);

        // First check if AD node (nested gradient)
        BasicBlock* check_scalar = BasicBlock::Create(*context, "grad_check_scalar", current_func);
        builder->CreateCondBr(is_ad_node_input, ad_node_input, check_scalar);

        // NESTED GRADIENT (AD_NODE_PTR input): Extract value and wrap in tensor for uniform handling
        builder->SetInsertPoint(ad_node_input);
        eshkol_debug("Gradient: detected AD_NODE_PTR input (nested gradient)");

        // Extract the AD node pointer
        Value* outer_ad_node = unpackPtrFromTaggedValue(vector_val);

        // DOUBLE BACKWARD: Store outer AD node in global for later use
        // This allows the backward pass to connect to outer computation graph
        builder->CreateStore(outer_ad_node, outer_ad_node_storage);

        // Extract the VALUE from the AD node (field 1)
        Value* ad_value_ptr = builder->CreateStructGEP(ad_node_type, outer_ad_node, 1);
        Value* ad_value = builder->CreateLoad(Type::getDoubleTy(*context), ad_value_ptr);

        // Create a 1D tensor containing this value (so rest of gradient code works uniformly)
        Function* malloc_func_nested = function_table["malloc"];
        Value* nested_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* nested_tensor_ptr = builder->CreateCall(malloc_func_nested, {nested_tensor_size});
        Value* typed_ad_tensor = builder->CreatePointerCast(nested_tensor_ptr, builder->getPtrTy());

        // Set up 1D tensor structure
        Value* nested_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* nested_dims_ptr = builder->CreateCall(malloc_func_nested, {nested_dims_size});
        Value* typed_ad_dims = builder->CreatePointerCast(nested_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), typed_ad_dims);

        builder->CreateStore(typed_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 1));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 3));

        Value* nested_elems_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t));
        Value* nested_elems_ptr = builder->CreateCall(malloc_func_nested, {nested_elems_size});
        Value* typed_nested_elems = builder->CreatePointerCast(nested_elems_ptr, builder->getPtrTy());
        Value* nested_value_as_int64 = builder->CreateBitCast(ad_value, Type::getInt64Ty(*context));
        builder->CreateStore(nested_value_as_int64, typed_nested_elems);
        builder->CreateStore(typed_nested_elems,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 2));

        Value* nested_tensor_int = builder->CreatePtrToInt(typed_ad_tensor, Type::getInt64Ty(*context));
        Value* ad_promoted_tagged = packPtrToTaggedValue(nested_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_merge_input);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // Check for scalar
        builder->SetInsertPoint(check_scalar);

        // DOUBLE BACKWARD: Clear outer AD node storage for non-nested case
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)),
            outer_ad_node_storage);

        // Check: scalar → scalar_input, scheme_vector → scheme_vector_input, else → vector_input (tensor)
        BasicBlock* check_scheme_vector = BasicBlock::Create(*context, "grad_check_scheme_vec", current_func);
        builder->CreateCondBr(is_scalar, scalar_input, check_scheme_vector);

        builder->SetInsertPoint(check_scheme_vector);
        builder->CreateCondBr(is_scheme_vector, scheme_vector_input, vector_input);

        // SCALAR INPUT: Auto-promote scalar to 1D tensor #(scalar_value)
        builder->SetInsertPoint(scalar_input);
        eshkol_debug("Gradient: auto-promoting scalar input to 1D vector");
        
        // Extract scalar value (INT64 or DOUBLE)
        Value* scalar_val_int = unpackInt64FromTaggedValue(vector_val);
        
        // Convert to double if needed
        Value* scalar_double = builder->CreateSelect(is_double,
            builder->CreateBitCast(scalar_val_int, Type::getDoubleTy(*context)),
            builder->CreateSIToFP(scalar_val_int, Type::getDoubleTy(*context)));
        
        // Get malloc for tensor creation
        Function* malloc_func_scalar = function_table["malloc"];
        
        // Allocate 1D tensor structure for promoted scalar
        Value* promoted_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* promoted_tensor_ptr = builder->CreateCall(malloc_func_scalar, {promoted_tensor_size});
        Value* typed_promoted_tensor = builder->CreatePointerCast(promoted_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions: [1] (1D tensor with single element)
        Value* promoted_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* promoted_dims_ptr = builder->CreateCall(malloc_func_scalar, {promoted_dims_size});
        Value* typed_promoted_dims = builder->CreatePointerCast(promoted_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), typed_promoted_dims);
        
        // Set tensor metadata
        builder->CreateStore(typed_promoted_dims,
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 0));  // dimensions = [1]
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 1));  // num_dimensions = 1
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 3));  // total_elements = 1
        
        // Allocate and set elements: [scalar_value]
        Value* promoted_elems_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t));
        Value* promoted_elems_ptr = builder->CreateCall(malloc_func_scalar, {promoted_elems_size});
        Value* typed_promoted_elems = builder->CreatePointerCast(promoted_elems_ptr, builder->getPtrTy());
        
        // Store scalar as bitcast int64 (preserves IEEE754 bits for doubles)
        Value* scalar_as_int64 = builder->CreateBitCast(scalar_double, Type::getInt64Ty(*context));
        builder->CreateStore(scalar_as_int64, typed_promoted_elems);
        
        builder->CreateStore(typed_promoted_elems,
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 2));  // elements
        
        // Pack promoted tensor as tagged_value with TENSOR_PTR type
        Value* promoted_tensor_int = builder->CreatePtrToInt(typed_promoted_tensor, Type::getInt64Ty(*context));
        Value* promoted_vector_tagged = packPtrToTaggedValue(promoted_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        builder->CreateBr(grad_merge_input);
        BasicBlock* scalar_input_exit = builder->GetInsertBlock();
        
        // SCHEME VECTOR INPUT: Convert Scheme vector to tensor format
        // Scheme vector layout: [length (8 bytes)] + [tagged_value elements (16 bytes each)]
        builder->SetInsertPoint(scheme_vector_input);
        eshkol_debug("Gradient: converting Scheme vector to tensor format");

        // Get Scheme vector pointer
        Value* scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* scheme_vec_ptr = builder->CreateIntToPtr(scheme_vec_ptr_int, builder->getPtrTy());

        // Read length from first 8 bytes
        Value* scheme_len_ptr = builder->CreateBitCast(scheme_vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* scheme_len = builder->CreateLoad(Type::getInt64Ty(*context), scheme_len_ptr);

        // Allocate tensor structure
        Function* malloc_func_scheme = function_table["malloc"];
        Value* scheme_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* scheme_tensor_ptr = builder->CreateCall(malloc_func_scheme, {scheme_tensor_size});
        Value* typed_scheme_tensor = builder->CreatePointerCast(scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions: [length] (1D tensor)
        Value* scheme_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* scheme_dims_ptr = builder->CreateCall(malloc_func_scheme, {scheme_dims_size});
        Value* typed_scheme_dims = builder->CreatePointerCast(scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(scheme_len, typed_scheme_dims);

        // Set tensor metadata
        builder->CreateStore(typed_scheme_dims,
            builder->CreateStructGEP(tensor_type, typed_scheme_tensor, 0));  // dimensions
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_scheme_tensor, 1));  // num_dimensions = 1
        builder->CreateStore(scheme_len,
            builder->CreateStructGEP(tensor_type, typed_scheme_tensor, 3));  // total_elements

        // Allocate elements array
        Value* scheme_elems_size = builder->CreateMul(scheme_len,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* scheme_elems_ptr = builder->CreateCall(malloc_func_scheme, {scheme_elems_size});
        Value* typed_scheme_elems = builder->CreatePointerCast(scheme_elems_ptr, builder->getPtrTy());

        builder->CreateStore(typed_scheme_elems,
            builder->CreateStructGEP(tensor_type, typed_scheme_tensor, 2));  // elements

        // Copy elements from Scheme vector (tagged_value) to tensor (double as int64)
        // Scheme elements start at offset 8, each is 16 bytes (tagged_value)
        Value* scheme_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), scheme_vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* scheme_elem_base_typed = builder->CreateBitCast(scheme_elem_base, PointerType::getUnqual(tagged_value_type));

        // Loop to copy elements
        BasicBlock* scheme_copy_cond = BasicBlock::Create(*context, "scheme_copy_cond", current_func);
        BasicBlock* scheme_copy_body = BasicBlock::Create(*context, "scheme_copy_body", current_func);
        BasicBlock* scheme_copy_done = BasicBlock::Create(*context, "scheme_copy_done", current_func);

        Value* scheme_copy_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "scheme_copy_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), scheme_copy_i);
        builder->CreateBr(scheme_copy_cond);

        builder->SetInsertPoint(scheme_copy_cond);
        Value* scheme_i = builder->CreateLoad(Type::getInt64Ty(*context), scheme_copy_i);
        Value* scheme_cond = builder->CreateICmpULT(scheme_i, scheme_len);
        builder->CreateCondBr(scheme_cond, scheme_copy_body, scheme_copy_done);

        builder->SetInsertPoint(scheme_copy_body);
        // Load tagged_value from Scheme vector
        Value* scheme_src_ptr = builder->CreateGEP(tagged_value_type, scheme_elem_base_typed, scheme_i);
        Value* scheme_tagged_elem = builder->CreateLoad(tagged_value_type, scheme_src_ptr);
        // Extract the double value and store as int64 bitcast
        Value* scheme_double_val = unpackDoubleFromTaggedValue(scheme_tagged_elem);
        Value* scheme_as_int64 = builder->CreateBitCast(scheme_double_val, Type::getInt64Ty(*context));
        Value* scheme_dst_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_scheme_elems, scheme_i);
        builder->CreateStore(scheme_as_int64, scheme_dst_ptr);
        // Increment
        Value* scheme_next_i = builder->CreateAdd(scheme_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(scheme_next_i, scheme_copy_i);
        builder->CreateBr(scheme_copy_cond);

        builder->SetInsertPoint(scheme_copy_done);
        // Pack converted tensor as tagged_value with TENSOR_PTR type
        Value* scheme_tensor_int = builder->CreatePtrToInt(typed_scheme_tensor, Type::getInt64Ty(*context));
        Value* scheme_vector_tagged = packPtrToTaggedValue(scheme_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_merge_input);
        BasicBlock* scheme_vector_exit = builder->GetInsertBlock();

        // VECTOR INPUT: Use original vector as-is (existing behavior - tensor format)
        builder->SetInsertPoint(vector_input);
        builder->CreateBr(grad_merge_input);
        BasicBlock* vector_input_exit = builder->GetInsertBlock();

        // MERGE: PHI node selects AD node promoted, scalar promoted, scheme vector converted, or original tensor
        builder->SetInsertPoint(grad_merge_input);
        PHINode* actual_input = builder->CreatePHI(tagged_value_type, 4, "gradient_input");
        actual_input->addIncoming(ad_promoted_tagged, ad_node_exit);  // Nested gradient path
        actual_input->addIncoming(promoted_vector_tagged, scalar_input_exit);
        actual_input->addIncoming(scheme_vector_tagged, scheme_vector_exit);  // Scheme vector converted
        actual_input->addIncoming(vector_val, vector_input_exit);
        
        // Continue with gradient computation using merged input (guaranteed to be tensor!)
        Value* vector_ptr_int = safeExtractInt64(actual_input);

        // Get malloc for tensor allocations
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found for gradient computation");
            return nullptr;
        }
        // Use class member tensor_type (shared by all tensor operations)


        // Convert int64 pointer to typed tensor pointer
        Value* vector_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());

        // Extract ALL tensor properties (MUST access all fields correctly)
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, vector_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, vector_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Load dimension n from tensor (RUNTIME value, NOT hardcoded)
        Value* dim0_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), dim0_ptr);
        
        // VALIDATION: Check dimension > 0 (scalars already promoted to tensors, so type check not needed)
        Value* n_is_positive = builder->CreateICmpUGT(n, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* dim_valid = BasicBlock::Create(*context, "grad_dim_valid", current_func);
        BasicBlock* dim_invalid = BasicBlock::Create(*context, "grad_dim_invalid", current_func);
        BasicBlock* grad_done = BasicBlock::Create(*context, "grad_done", current_func);
        
        // CRITICAL FIX: Create empty tensor BEFORE branching (for PHI node dominance)
        // This ensures null_tagged_grad is available in all paths
        Value* empty_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* empty_tensor_ptr = builder->CreateCall(malloc_func, {empty_tensor_size});
        Value* typed_empty_tensor = builder->CreatePointerCast(empty_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions array (size 1, value 0)
        Value* empty_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* empty_dims_ptr = builder->CreateCall(malloc_func, {empty_dims_size});
        Value* typed_empty_dims = builder->CreatePointerCast(empty_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), typed_empty_dims);
        
        builder->CreateStore(typed_empty_dims,
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 1));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0),
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 3));
        
        // Empty elements array
        Value* empty_elems_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(double));
        Value* empty_elems_ptr = builder->CreateCall(malloc_func, {empty_elems_size});
        Value* typed_empty_elems = builder->CreatePointerCast(empty_elems_ptr, builder->getPtrTy());
        builder->CreateStore(typed_empty_elems,
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 2));
        
        // Pack as tagged_value (TENSOR_PTR type) - available in all paths
        Value* empty_tensor_int = builder->CreatePtrToInt(typed_empty_tensor, Type::getInt64Ty(*context));
        Value* null_tagged_grad = packPtrToTaggedValue(empty_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        builder->CreateCondBr(n_is_positive, dim_valid, dim_invalid);
        
        // Invalid input: return empty tensor
        builder->SetInsertPoint(dim_invalid);
        eshkol_debug("Gradient: invalid input tensor (dimension must be > 0)");
        builder->CreateBr(grad_done);
        
        // Valid dimension: compute gradient
        builder->SetInsertPoint(dim_valid);
        
        // Allocate result gradient vector (SAME structure as input vector)
        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor_ptr = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Set result tensor dimension (1D vector of size n)
        Value* result_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims_ptr = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_result_dims_ptr);
        
        // Store dimension in result tensor
        Value* result_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 0);
        builder->CreateStore(typed_result_dims_ptr, result_dims_field_ptr);
        
        // Store num_dimensions = 1
        Value* result_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), result_num_dims_field_ptr);
        
        // Store total_elements = n
        Value* result_total_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 3);
        builder->CreateStore(n, result_total_field_ptr);
        
        // Allocate result elements array (n doubles for partial derivatives)
        Value* result_elements_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* result_elements_ptr = builder->CreateCall(malloc_func, {result_elements_size});
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());
        
        // Store elements pointer in result tensor
        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 2);
        builder->CreateStore(typed_result_elements_ptr, result_elements_field_ptr);
        
        // ===== MAIN GRADIENT COMPUTATION LOOP =====
        // For each component i from 0 to n-1, compute ∂f/∂xᵢ
        
        BasicBlock* grad_loop_cond = BasicBlock::Create(*context, "grad_loop_cond", current_func);
        BasicBlock* grad_loop_body = BasicBlock::Create(*context, "grad_loop_body", current_func);
        BasicBlock* grad_loop_exit = BasicBlock::Create(*context, "grad_loop_exit", current_func);
        
        // Allocate loop counter
        Value* component_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "component_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), component_idx);
        
        builder->CreateBr(grad_loop_cond);
        
        // Loop condition: i < n
        builder->SetInsertPoint(grad_loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), component_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, grad_loop_body, grad_loop_exit);
        
        // Loop body: Compute ∂f/∂xᵢ using reverse-mode AD
        builder->SetInsertPoint(grad_loop_body);
        
        // Step 1: Create tape for this partial derivative
        Value* arena_ptr = getArenaPtr();
        Value* tape_capacity = ConstantInt::get(Type::getInt64Ty(*context), 1024);
        Value* partial_tape = builder->CreateCall(arena_allocate_tape_func,
            {arena_ptr, tape_capacity});
        
        // Store tape as current (required by recordADNode* functions)
        Value* saved_tape = current_tape_ptr;
        current_tape_ptr = partial_tape;
        
        // Step 2: Create n AD variable nodes (one per vector component)
        // Allocate array to hold variable node pointers
        Value* var_nodes_array_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(void*)));
        Value* var_nodes_array = builder->CreateCall(malloc_func, {var_nodes_array_size});
        Value* typed_var_nodes = builder->CreatePointerCast(var_nodes_array, builder->getPtrTy());
        
        // Loop to create and initialize variable nodes
        BasicBlock* init_vars_cond = BasicBlock::Create(*context, "init_vars_cond", current_func);
        BasicBlock* init_vars_body = BasicBlock::Create(*context, "init_vars_body", current_func);
        BasicBlock* init_vars_exit = BasicBlock::Create(*context, "init_vars_exit", current_func);
        
        Value* init_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "init_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), init_idx);
        builder->CreateBr(init_vars_cond);
        
        builder->SetInsertPoint(init_vars_cond);
        Value* j = builder->CreateLoad(Type::getInt64Ty(*context), init_idx);
        Value* j_less_n = builder->CreateICmpULT(j, n);
        builder->CreateCondBr(j_less_n, init_vars_body, init_vars_exit);
        
        builder->SetInsertPoint(init_vars_body);

        // CRITICAL FIX: Tensor elements are stored as int64, load as int64 then convert to double
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_elements_ptr, j);
        Value* elem_val_int64 = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);

        // NESTED GRADIENT FIX: Check if element might be an AD node pointer (from outer gradient)
        // Don't check tape depth - the element itself tells us if it's an AD node
        // When a gradient's input contains an AD node, we detect it and set up double backward
        BasicBlock* check_ad_ptr = BasicBlock::Create(*context, "check_ad_ptr", current_func);
        BasicBlock* is_regular_double = BasicBlock::Create(*context, "is_regular_double", current_func);
        BasicBlock* merge_elem = BasicBlock::Create(*context, "merge_elem", current_func);

        // Check if the value could be a pointer (in valid heap address range)
        // On 64-bit systems:
        // - Heap pointers are typically 0x100000000 to 0x00007FFFFFFFFFFF (small as int64)
        // - Normal doubles like 2.0 = 0x4000000000000000, 12.0 = 0x4028... (LARGE as int64)
        // So a potential pointer is: non-zero AND less than typical double values
        // Use threshold 0x0001000000000000 (~281 trillion) - catches all user space addresses
        // but excludes normal positive doubles (which are >= 0x3FF0000000000000 for >= 1.0)
        Value* not_zero = builder->CreateICmpNE(elem_val_int64,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* in_ptr_range = builder->CreateICmpULT(elem_val_int64,
            ConstantInt::get(Type::getInt64Ty(*context), 0x0001000000000000ULL));
        Value* could_be_ptr = builder->CreateAnd(not_zero, in_ptr_range);
        builder->CreateCondBr(could_be_ptr, check_ad_ptr, is_regular_double);

        // CHECK AD POINTER: Try to validate it's actually an AD node
        builder->SetInsertPoint(check_ad_ptr);
        Value* ad_ptr_candidate = builder->CreateIntToPtr(elem_val_int64, PointerType::getUnqual(*context));
        // Check if pointer is non-null and has valid AD node type
        Value* ptr_not_null = builder->CreateICmpNE(elem_val_int64,
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        BasicBlock* check_ad_type = BasicBlock::Create(*context, "check_ad_type", current_func);
        BasicBlock* not_ad_node = BasicBlock::Create(*context, "not_ad_node", current_func);
        builder->CreateCondBr(ptr_not_null, check_ad_type, not_ad_node);

        // Check AD node type field
        builder->SetInsertPoint(check_ad_type);
        Value* type_field_ptr = builder->CreateStructGEP(ad_node_type, ad_ptr_candidate, 0);
        Value* type_field = builder->CreateLoad(Type::getInt32Ty(*context), type_field_ptr);
        // Valid AD node types are 0-7 (CONSTANT, PTR, ADD, SUB, MUL, DIV, SIN, COS)
        // Also check that it's exactly type 1 (AD_NODE_PTR) since that's what variables are
        Value* is_ad_var = builder->CreateICmpEQ(type_field, ConstantInt::get(Type::getInt32Ty(*context), 1));

        BasicBlock* use_existing_ad = BasicBlock::Create(*context, "use_existing_ad", current_func);
        builder->CreateCondBr(is_ad_var, use_existing_ad, not_ad_node);

        // USE EXISTING AD NODE: This element is an AD node from outer gradient
        // CRITICAL FIX: Do NOT reuse the outer AD node directly!
        // The inner backward would write to its gradient field, contaminating it.
        // Instead, create a new AD variable with the same value and record the outer node.
        builder->SetInsertPoint(use_existing_ad);
        Value* detected_outer_node = ad_ptr_candidate;
        // Store outer AD node for double backward connection
        builder->CreateStore(detected_outer_node, outer_ad_node_storage);
        // Extract the VALUE from outer AD node and create NEW variable for inner gradient
        Value* detected_outer_val_ptr = builder->CreateStructGEP(ad_node_type, detected_outer_node, 1);
        Value* detected_outer_val = builder->CreateLoad(Type::getDoubleTy(*context), detected_outer_val_ptr);
        Value* new_inner_var = createADVariable(detected_outer_val, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* use_ad_exit = builder->GetInsertBlock();

        // NOT AN AD NODE: Treat as double
        builder->SetInsertPoint(not_ad_node);
        Value* elem_as_double2 = builder->CreateBitCast(elem_val_int64, Type::getDoubleTy(*context));
        Value* new_var_node2 = createADVariable(elem_as_double2, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* not_ad_exit = builder->GetInsertBlock();

        // REGULAR DOUBLE: Normal case - just treat as double
        builder->SetInsertPoint(is_regular_double);
        Value* elem_val = builder->CreateBitCast(elem_val_int64, Type::getDoubleTy(*context));
        Value* new_var_node = createADVariable(elem_val, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* regular_double_exit = builder->GetInsertBlock();

        // MERGE: PHI to select the right AD node
        builder->SetInsertPoint(merge_elem);
        PHINode* var_node = builder->CreatePHI(PointerType::getUnqual(*context), 3, "var_node_phi");
        var_node->addIncoming(new_inner_var, use_ad_exit);
        var_node->addIncoming(new_var_node2, not_ad_exit);
        var_node->addIncoming(new_var_node, regular_double_exit);
        
        // Store node pointer in array
        Value* node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, j);
        builder->CreateStore(var_node, node_slot);
        
        // Increment init counter
        Value* next_j = builder->CreateAdd(j, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_j, init_idx);
        builder->CreateBr(init_vars_cond);
        
        builder->SetInsertPoint(init_vars_exit);
        
        // Step 3: Get active variable node (the one we're computing gradient for)
        Value* active_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, i);
        Value* active_var_node = builder->CreateLoad(PointerType::getUnqual(*context),
            active_node_slot);
        
        // Step 4: Call function with variable nodes to build computational graph
        // CRITICAL: Function must operate on AD nodes, not raw doubles
        // This requires the function to use recordADNode* operations
        
        // Build tensor of AD node pointers to pass to function
        Value* ad_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* ad_tensor_ptr = builder->CreateCall(malloc_func, {ad_tensor_size});
        Value* typed_ad_tensor_ptr = builder->CreatePointerCast(ad_tensor_ptr, builder->getPtrTy());
        
        // Set AD tensor dimensions (same as input)
        builder->CreateStore(typed_result_dims_ptr,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 3));
        
        // Allocate and fill AD tensor elements with node pointers
        Value* ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* ad_elems_ptr = builder->CreateCall(malloc_func, {ad_elems_size});
        Value* typed_ad_elems_ptr = builder->CreatePointerCast(ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_ad_elems_ptr,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 2));
        
        // Copy node pointers into AD tensor
        BasicBlock* copy_nodes_cond = BasicBlock::Create(*context, "copy_nodes_cond", current_func);
        BasicBlock* copy_nodes_body = BasicBlock::Create(*context, "copy_nodes_body", current_func);
        BasicBlock* copy_nodes_exit = BasicBlock::Create(*context, "copy_nodes_exit", current_func);
        
        Value* copy_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "copy_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), copy_idx);
        builder->CreateBr(copy_nodes_cond);
        
        builder->SetInsertPoint(copy_nodes_cond);
        Value* k = builder->CreateLoad(Type::getInt64Ty(*context), copy_idx);
        Value* k_less_n = builder->CreateICmpULT(k, n);
        builder->CreateCondBr(k_less_n, copy_nodes_body, copy_nodes_exit);
        
        builder->SetInsertPoint(copy_nodes_body);
        Value* src_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, k);
        Value* src_node_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_node_slot);
        Value* node_as_int64 = builder->CreatePtrToInt(src_node_ptr, Type::getInt64Ty(*context));
        
        Value* dst_elem_slot = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_ad_elems_ptr, k);
        builder->CreateStore(node_as_int64, dst_elem_slot);
        
        Value* next_k = builder->CreateAdd(k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_k, copy_idx);
        builder->CreateBr(copy_nodes_cond);
        
        builder->SetInsertPoint(copy_nodes_exit);
        
        // Step 5: Call function with AD node (scalar) or tensor (vector)
        // SCALAR FUNCTION FIX: For n=1, extract the single AD node and pass it directly!
        // This allows scalar functions like (lambda (x) (* x x)) to work
        Value* n_is_one = builder->CreateICmpEQ(n, ConstantInt::get(Type::getInt64Ty(*context), 1));
        
        BasicBlock* scalar_call = BasicBlock::Create(*context, "grad_scalar_call", current_func);
        BasicBlock* vector_call = BasicBlock::Create(*context, "grad_vector_call", current_func);
        BasicBlock* after_func_call = BasicBlock::Create(*context, "grad_after_func_call", current_func);
        
        builder->CreateCondBr(n_is_one, scalar_call, vector_call);
        
        // SCALAR: Extract single AD node and pass directly
        builder->SetInsertPoint(scalar_call);
        Value* single_ad_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* single_ad_node = builder->CreateLoad(PointerType::getUnqual(*context), single_ad_node_slot);
        Value* scalar_ad_tagged = packPtrToTaggedValue(single_ad_node, ESHKOL_VALUE_AD_NODE_PTR);

        std::vector<Value*> scalar_args = {scalar_ad_tagged};

        // CRITICAL FIX: Add captured arguments for scalar path too!
        FunctionType* scalar_func_type = func_ptr->getFunctionType();
        if (scalar_func_type->getNumParams() > 1) {
            size_t scalar_num_captures = scalar_func_type->getNumParams() - 1;
            std::string scalar_lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(scalar_lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t ci = 0; ci < scalar_num_captures; ci++) {
                std::string scalar_var_name;
                if (ci < capture_names.size()) {
                    scalar_var_name = capture_names[ci];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto scalar_arg_it = func_ptr->arg_begin();
                    std::advance(scalar_arg_it, ci + 1);  // Skip first parameter
                    if (scalar_arg_it != func_ptr->arg_end()) {
                        scalar_var_name = scalar_arg_it->getName().str();
                        if (scalar_var_name.find("captured_") == 0) {
                            scalar_var_name = scalar_var_name.substr(9);
                        }
                    }
                }

                std::string scalar_capture_key = scalar_lambda_name + "_capture_" + scalar_var_name;

                // First try local symbol tables
                auto scalar_it = global_symbol_table.find(scalar_capture_key);
                bool found_in_global = (scalar_it != global_symbol_table.end());
                if (!found_in_global) {
                    scalar_it = symbol_table.find(scalar_capture_key);
                }

                bool found = found_in_global ? (scalar_it != global_symbol_table.end()) : (scalar_it != symbol_table.end());

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(scalar_capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(scalar_capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                scalar_capture_key
                            );
                        }
                        Value* scalar_captured_val = builder->CreateLoad(tagged_value_type, capture_global);
                        scalar_args.push_back(scalar_captured_val);
                        continue;
                    }
                }

                if (found && scalar_it->second) {
                    Value* scalar_storage = scalar_it->second;
                    Value* scalar_captured_val = builder->CreateLoad(tagged_value_type, scalar_storage);
                    scalar_args.push_back(scalar_captured_val);
                } else {
                    scalar_args.push_back(packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), 0), true));
                    eshkol_warn("Gradient (scalar): capture '%s' not found, using 0", scalar_var_name.c_str());
                }
            }
        }

        // NESTED GRADIENT FIX: Save outer_ad_node_storage before calling function
        // Nested gradients will overwrite it, so we save and restore to support n-dimensional derivatives
        Value* saved_outer_ad_node_scalar = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);

        // NESTED GRADIENT FIX: Push tape context (saves outer gradient's tape if any)
        pushTapeContext(partial_tape);

        Value* scalar_output = builder->CreateCall(func_ptr, scalar_args);

        // NESTED GRADIENT FIX: Pop tape context (restores outer gradient's tape if any)
        popTapeContext();

        // NESTED GRADIENT FIX: Restore outer_ad_node_storage after function returns
        builder->CreateStore(saved_outer_ad_node_scalar, outer_ad_node_storage);

        builder->CreateBr(after_func_call);
        BasicBlock* scalar_call_exit = builder->GetInsertBlock();
        
        // VECTOR: Pass AD tensor as usual
        builder->SetInsertPoint(vector_call);
        Value* ad_tensor_int = builder->CreatePtrToInt(typed_ad_tensor_ptr, Type::getInt64Ty(*context));
        Value* ad_tensor_tagged = packPtrToTaggedValue(ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        std::vector<Value*> grad_call_args = {ad_tensor_tagged};
        
        FunctionType* grad_func_type = func_ptr->getFunctionType();
        if (grad_func_type->getNumParams() > 1) {
            size_t num_captures = grad_func_type->getNumParams() - 1;
            std::string lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t i = 0; i < num_captures; i++) {
                std::string var_name;
                if (i < capture_names.size()) {
                    var_name = capture_names[i];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto arg_it = func_ptr->arg_begin();
                    std::advance(arg_it, i + 1);  // Skip first parameter
                    if (arg_it != func_ptr->arg_end()) {
                        var_name = arg_it->getName().str();
                        if (var_name.find("captured_") == 0) {
                            var_name = var_name.substr(9);
                        }
                    }
                }

                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try local symbol tables
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                capture_key
                            );
                        }
                        Value* captured_val = builder->CreateLoad(tagged_value_type, capture_global);
                        grad_call_args.push_back(captured_val);
                        continue;
                    }
                }

                if (found && it->second) {
                    Value* storage = it->second;
                    Value* captured_val = builder->CreateLoad(tagged_value_type, storage);
                    grad_call_args.push_back(captured_val);
                } else {
                    grad_call_args.push_back(packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), 0), true));
                    eshkol_warn("Gradient: capture '%s' not found, using 0", var_name.c_str());
                }
            }
        }
        
        // NESTED GRADIENT FIX: Save outer_ad_node_storage before calling function
        // Nested gradients will overwrite it, so we save and restore to support n-dimensional derivatives
        Value* saved_outer_ad_node_vector = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);

        // NESTED GRADIENT FIX: Push tape context (saves outer gradient's tape if any)
        pushTapeContext(partial_tape);

        Value* vector_output = builder->CreateCall(func_ptr, grad_call_args);

        // NESTED GRADIENT FIX: Pop tape context (restores outer gradient's tape if any)
        popTapeContext();

        // NESTED GRADIENT FIX: Restore outer_ad_node_storage after function returns
        builder->CreateStore(saved_outer_ad_node_vector, outer_ad_node_storage);

        builder->CreateBr(after_func_call);
        BasicBlock* vector_call_exit = builder->GetInsertBlock();
        
        // Merge scalar and vector outputs
        builder->SetInsertPoint(after_func_call);
        PHINode* output_tagged = builder->CreatePHI(tagged_value_type, 2, "grad_func_output");
        output_tagged->addIncoming(scalar_output, scalar_call_exit);
        output_tagged->addIncoming(vector_output, vector_call_exit);
        
        // Unpack result back to int64
        Value* output_node_int = unpackInt64FromTaggedValue(output_tagged);
        
        // Convert output to AD node pointer
        Value* output_node_ptr = builder->CreateIntToPtr(output_node_int,
            PointerType::getUnqual(*context));
        
        // CRITICAL FIX: Use type-based detection instead of pointer value heuristic
        // Check if output is actually an AD node by examining its type tag
        Value* output_type = getTaggedValueType(output_tagged);
        Value* output_base_type = builder->CreateAnd(output_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* output_is_ad_node = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        
        BasicBlock* has_valid_output = BasicBlock::Create(*context, "grad_valid_output", current_func);
        BasicBlock* invalid_output = BasicBlock::Create(*context, "grad_invalid_output", current_func);
        BasicBlock* after_backward = BasicBlock::Create(*context, "grad_after_backward", current_func);
        
        // Branch based on type check (robust detection)
        builder->CreateCondBr(output_is_ad_node, has_valid_output, invalid_output);
        
        // Step 6: Run backward pass through computational graph (only for valid AD nodes)
        builder->SetInsertPoint(has_valid_output);

        // DOUBLE BACKWARD SETUP: Store the inner variable node and initialize degree counter
        // This enables degree tracking during backward for proper double backward expressions
        builder->CreateStore(active_var_node, inner_var_node_ptr);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), gradient_x_degree);

        codegenBackward(output_node_ptr, partial_tape);
        builder->CreateBr(after_backward);
        
        // Skip backward pass if output is invalid (placeholder function returning scalar)
        builder->SetInsertPoint(invalid_output);
        eshkol_debug("Gradient: Skipping backward pass - function returned non-AD value");
        builder->CreateBr(after_backward);
        
        builder->SetInsertPoint(after_backward);
        
        // Step 7: Extract gradient from active variable node (or 0 if no backward pass)
        Value* partial_grad_ptr = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "partial_grad");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), partial_grad_ptr);
        
        // Only extract gradient if we had valid AD output
        BasicBlock* extract_grad = BasicBlock::Create(*context, "grad_extract", current_func);
        BasicBlock* use_zero = BasicBlock::Create(*context, "grad_use_zero", current_func);
        BasicBlock* grad_extracted = BasicBlock::Create(*context, "grad_extracted", current_func);
        
        builder->CreateCondBr(output_is_ad_node, extract_grad, use_zero);
        
        builder->SetInsertPoint(extract_grad);
        Value* extracted_grad = loadNodeGradient(active_var_node);
        builder->CreateStore(extracted_grad, partial_grad_ptr);
        builder->CreateBr(grad_extracted);
        
        builder->SetInsertPoint(use_zero);
        builder->CreateBr(grad_extracted);
        
        builder->SetInsertPoint(grad_extracted);
        Value* partial_grad = builder->CreateLoad(Type::getDoubleTy(*context), partial_grad_ptr);
        
        // Step 8: Store partial derivative in result vector at index i
        // CRITICAL FIX: Tensor elements stored as int64, must bitcast double to int64
        Value* partial_grad_as_int64 = builder->CreateBitCast(partial_grad, Type::getInt64Ty(*context));
        Value* result_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_result_elements_ptr, i);
        builder->CreateStore(partial_grad_as_int64, result_elem_ptr);
        
        // Step 9: Reset tape for next iteration (MUST call to zero gradients)
        builder->CreateCall(arena_tape_reset_func, {partial_tape});
        
        // Restore previous tape
        current_tape_ptr = saved_tape;
        
        // Increment component counter
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, component_idx);
        builder->CreateBr(grad_loop_cond);
        
        // Loop exit: Return result gradient vector
        builder->SetInsertPoint(grad_loop_exit);

        eshkol_info("Gradient computation complete, returning vector of size n");

        // DOUBLE BACKWARD: Check if we have a stored outer AD node
        // If so, create result as AD node on outer tape for proper gradient propagation
        Value* stored_outer = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);
        Value* has_outer_node = builder->CreateICmpNE(stored_outer,
            ConstantPointerNull::get(PointerType::getUnqual(*context)));

        // Also check if this is scalar case (n == 1)
        Value* is_scalar_grad = builder->CreateICmpEQ(n, ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* should_return_ad_node = builder->CreateAnd(has_outer_node, is_scalar_grad);

        BasicBlock* return_ad_node = BasicBlock::Create(*context, "grad_return_ad_node", current_func);
        BasicBlock* return_tensor = BasicBlock::Create(*context, "grad_return_tensor", current_func);
        BasicBlock* grad_merge_result = BasicBlock::Create(*context, "grad_merge_result", current_func);

        builder->CreateCondBr(should_return_ad_node, return_ad_node, return_tensor);

        // DOUBLE BACKWARD PATH: Return AD node connected to outer graph
        builder->SetInsertPoint(return_ad_node);

        // Get the scalar gradient value from result tensor
        Value* scalar_grad_ptr = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_result_elements_ptr, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* scalar_grad_int = builder->CreateLoad(Type::getInt64Ty(*context), scalar_grad_ptr);
        Value* scalar_grad_val = builder->CreateBitCast(scalar_grad_int, Type::getDoubleTy(*context));

        // Get current tape (which IS the outer tape after popTapeContext)
        // After inner gradient's push/pop, current_ad_tape is restored to outer tape
        Value* outer_tape_for_result = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);

        // Create an AD expression on outer tape that connects gradient to input
        // For f(x) = x^n, f'(x) = n*x^(n-1)
        // The gradient depends on x, so we need to express this dependency
        //
        // Key insight: For many functions, f'(x) is approximately proportional to some power of x.
        // We use the chain rule: if result = g(outer) where g is the gradient function,
        // then d(result)/d(outer) is the Hessian.
        //
        // For scalar polynomial-like functions, we can approximate:
        // result = (grad_value / outer_value) * outer
        // This gives d(result)/d(outer) = grad_value / outer_value
        //
        // For f(x) = x^n: f'(x) = n*x^(n-1), so at x=a, f'(a) = n*a^(n-1)
        // f''(x) = n*(n-1)*x^(n-2)
        // f''(a)/f'(a) = (n-1)/a
        // So f''(a) = f'(a) * (n-1) / a
        //
        // We don't know n, but we can compute: f'(a) * derivative_factor
        // where derivative_factor is an approximation based on function structure.
        //
        // For now, use a simple linear connection: result = k * outer
        // where k = grad_value / outer_value
        // This gives d(result)/d(outer) = k = grad_value / outer_value

        // Get the stored outer AD node
        Value* outer_node_for_expr = stored_outer;

        // Get outer node's value
        Value* outer_val_ptr = builder->CreateStructGEP(ad_node_type, outer_node_for_expr, 1);
        Value* outer_val = builder->CreateLoad(Type::getDoubleTy(*context), outer_val_ptr);

        // DEGREE-BASED DOUBLE BACKWARD EXPRESSION
        // The gradient_x_degree counter tracks the polynomial degree of f'(x) in x.
        // For f'(x) = k * x^m:
        //   - m = 0 (constant): f'(x) = k, f''(x) = 0
        //   - m = 1 (linear): f'(x) = k*x, f''(x) = k
        //   - m = 2 (quadratic): f'(x) = k*x², f''(x) = 2*k*x
        //
        // We create an AD expression: result = k * x^m where k = grad/x^m
        // This ensures d(result)/dx = k * m * x^(m-1) = correct f''(x)

        // Load the detected degree
        // Note: The counter tracks multiplications by x value during backward.
        // For x²: count=2 (both inputs are x), actual degree = 1
        // For x³: count=3, actual degree = 2
        // So actual_degree = max(0, count - 1)
        Value* raw_count = builder->CreateLoad(Type::getInt64Ty(*context), gradient_x_degree);
        Value* detected_degree = builder->CreateSelect(
            builder->CreateICmpEQ(raw_count, ConstantInt::get(Type::getInt64Ty(*context), 0)),
            ConstantInt::get(Type::getInt64Ty(*context), 0),
            builder->CreateSub(raw_count, ConstantInt::get(Type::getInt64Ty(*context), 1)));

        // N-DIMENSIONAL DERIVATIVES: Support arbitrary polynomial degree
        // For f'(x) = k * x^n:
        //   - Compute outer_val^n to get scale factor k = grad / (outer_val^n)
        //   - Build AD expression: k * x^n using repeated multiplication
        //   - This ensures d(result)/dx = k * n * x^(n-1) = correct higher derivative

        // Create blocks for degree handling
        BasicBlock* degree_0_bb = BasicBlock::Create(*context, "degree_0", current_func);
        BasicBlock* degree_n_bb = BasicBlock::Create(*context, "degree_n", current_func);
        BasicBlock* degree_merge_bb = BasicBlock::Create(*context, "degree_merge", current_func);

        // Check if degree is 0 (constant - no x dependency)
        Value* is_degree_0 = builder->CreateICmpEQ(detected_degree, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_degree_0, degree_0_bb, degree_n_bb);

        // DEGREE 0: Constant gradient, f''(x) = 0
        // Result is just a constant AD node (no x dependency)
        builder->SetInsertPoint(degree_0_bb);
        Value* const_result_node = createADConstantOnTape(outer_tape_for_result, scalar_grad_val);
        builder->CreateBr(degree_merge_bb);
        BasicBlock* degree_0_exit = builder->GetInsertBlock();

        // DEGREE N: Polynomial gradient f'(x) = k*x^n
        // Result = k * x^n where k = grad/x^n
        // We compute x^n both as a double (for k) and as AD expression (for result)
        builder->SetInsertPoint(degree_n_bb);

        // Compute outer_val^n using a loop
        Value* pow_val_ptr = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "pow_val");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 1.0), pow_val_ptr);
        Value* pow_idx_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "pow_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), pow_idx_ptr);

        BasicBlock* pow_loop_cond = BasicBlock::Create(*context, "pow_loop_cond", current_func);
        BasicBlock* pow_loop_body = BasicBlock::Create(*context, "pow_loop_body", current_func);
        BasicBlock* pow_loop_exit = BasicBlock::Create(*context, "pow_loop_exit", current_func);

        builder->CreateBr(pow_loop_cond);

        builder->SetInsertPoint(pow_loop_cond);
        Value* pow_i = builder->CreateLoad(Type::getInt64Ty(*context), pow_idx_ptr);
        Value* pow_continue = builder->CreateICmpULT(pow_i, detected_degree);
        builder->CreateCondBr(pow_continue, pow_loop_body, pow_loop_exit);

        builder->SetInsertPoint(pow_loop_body);
        Value* current_pow = builder->CreateLoad(Type::getDoubleTy(*context), pow_val_ptr);
        Value* next_pow = builder->CreateFMul(current_pow, outer_val);
        builder->CreateStore(next_pow, pow_val_ptr);
        Value* next_pow_i = builder->CreateAdd(pow_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_pow_i, pow_idx_ptr);
        builder->CreateBr(pow_loop_cond);

        builder->SetInsertPoint(pow_loop_exit);
        Value* outer_val_pow_n = builder->CreateLoad(Type::getDoubleTy(*context), pow_val_ptr);

        // Compute scale factor k = grad / x^n
        Value* scale_factor_n = builder->CreateFDiv(scalar_grad_val, outer_val_pow_n);
        Value* scale_const_n = createADConstantOnTape(outer_tape_for_result, scale_factor_n);

        // Build AD expression x^n using repeated multiplication
        // Start with x, then multiply by x (n-1) more times
        Value* ad_pow_ptr = builder->CreateAlloca(PointerType::getUnqual(*context), nullptr, "ad_pow");
        builder->CreateStore(outer_node_for_expr, ad_pow_ptr);
        Value* ad_pow_idx_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "ad_pow_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), ad_pow_idx_ptr);

        BasicBlock* ad_pow_loop_cond = BasicBlock::Create(*context, "ad_pow_loop_cond", current_func);
        BasicBlock* ad_pow_loop_body = BasicBlock::Create(*context, "ad_pow_loop_body", current_func);
        BasicBlock* ad_pow_loop_exit = BasicBlock::Create(*context, "ad_pow_loop_exit", current_func);

        builder->CreateBr(ad_pow_loop_cond);

        builder->SetInsertPoint(ad_pow_loop_cond);
        Value* ad_pow_i = builder->CreateLoad(Type::getInt64Ty(*context), ad_pow_idx_ptr);
        Value* ad_pow_continue = builder->CreateICmpULT(ad_pow_i, detected_degree);
        builder->CreateCondBr(ad_pow_continue, ad_pow_loop_body, ad_pow_loop_exit);

        builder->SetInsertPoint(ad_pow_loop_body);
        Value* current_ad_pow = builder->CreateLoad(PointerType::getUnqual(*context), ad_pow_ptr);
        // Multiply current AD expression by x: current * x
        Value* next_ad_pow = recordADNodeBinaryOnTape(outer_tape_for_result, 4, current_ad_pow, outer_node_for_expr);
        builder->CreateStore(next_ad_pow, ad_pow_ptr);
        Value* next_ad_pow_i = builder->CreateAdd(ad_pow_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_ad_pow_i, ad_pow_idx_ptr);
        builder->CreateBr(ad_pow_loop_cond);

        builder->SetInsertPoint(ad_pow_loop_exit);
        Value* outer_pow_n_ad = builder->CreateLoad(PointerType::getUnqual(*context), ad_pow_ptr);

        // Final result: k * x^n
        Value* poly_result = recordADNodeBinaryOnTape(outer_tape_for_result, 4, scale_const_n, outer_pow_n_ad);
        builder->CreateBr(degree_merge_bb);
        BasicBlock* degree_n_exit = builder->GetInsertBlock();

        // Merge results
        builder->SetInsertPoint(degree_merge_bb);
        PHINode* result_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2, "degree_result");
        result_ad_node->addIncoming(const_result_node, degree_0_exit);
        result_ad_node->addIncoming(poly_result, degree_n_exit);

        // Pack AD node as result
        Value* ad_result_int = builder->CreatePtrToInt(result_ad_node, Type::getInt64Ty(*context));
        Value* ad_result_tagged = packPtrToTaggedValue(ad_result_int, ESHKOL_VALUE_AD_NODE_PTR);

        // Clear the outer AD node storage
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)),
            outer_ad_node_storage);

        builder->CreateBr(grad_merge_result);
        BasicBlock* ad_result_exit = builder->GetInsertBlock();

        // NORMAL PATH: Return tensor as before
        builder->SetInsertPoint(return_tensor);
        Value* grad_result_int = builder->CreatePtrToInt(typed_result_tensor_ptr, Type::getInt64Ty(*context));
        // Tag as TENSOR_PTR for proper display handling (packPtrToTaggedValue handles i64 directly)
        Value* grad_result = packPtrToTaggedValue(grad_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_merge_result);
        BasicBlock* tensor_result_exit = builder->GetInsertBlock();

        // Merge paths
        builder->SetInsertPoint(grad_merge_result);
        PHINode* final_result = builder->CreatePHI(tagged_value_type, 2, "grad_final_result");
        final_result->addIncoming(ad_result_tagged, ad_result_exit);
        final_result->addIncoming(grad_result, tensor_result_exit);

        builder->CreateBr(grad_done);
        BasicBlock* dim_valid_exit = builder->GetInsertBlock();
        
        // Merge valid and invalid paths
        builder->SetInsertPoint(grad_done);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2, "grad_result_final");
        result_phi->addIncoming(null_tagged_grad, dim_invalid);
        result_phi->addIncoming(final_result, dim_valid_exit);  // Use merged result from double backward handling

        return result_phi;
    }
    
    // ===== PHASE 3: JACOBIAN OPERATOR IMPLEMENTATION =====
    // Matrix of partial derivatives for vector-valued functions
    
    Value* codegenJacobian(const eshkol_operations_t* op) {
        if (!op->jacobian_op.function || !op->jacobian_op.point) {
            eshkol_error("Invalid jacobian operation - missing function or point");
            return nullptr;
        }
        
        // Use class member tensor_type (shared by ALL tensor operations)
        // This prevents LLVM IR type conflicts from shadowing the class member
        
        eshkol_info("Computing Jacobian matrix using reverse-mode AD");
        
        // CRITICAL FIX: Must null-check before dyn_cast to avoid LLVM assertion
        Value* func = resolveLambdaFunction(op->jacobian_op.function);
        if (!func) {
            eshkol_error("Failed to resolve function for Jacobian computation");
            return nullptr;
        }
        
        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("Jacobian requires function, got non-function");
            return nullptr;
        }
        
        TypedValue vector_tv = codegenTypedAST(op->jacobian_op.point);
        if (!vector_tv.llvm_value) {
            eshkol_error("Failed to evaluate Jacobian point");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for Jacobian");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Convert TypedValue to tagged_value
        Value* vector_val = typedValueToTaggedValue(vector_tv);

        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* jac_scheme_vector_input = BasicBlock::Create(*context, "jac_scheme_vector", current_func);
        BasicBlock* jac_tensor_input = BasicBlock::Create(*context, "jac_tensor_input", current_func);
        BasicBlock* jac_merge_input = BasicBlock::Create(*context, "jac_merge_input", current_func);

        builder->CreateCondBr(is_scheme_vector, jac_scheme_vector_input, jac_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(jac_scheme_vector_input);

        Value* jac_scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* jac_scheme_vec_ptr = builder->CreateIntToPtr(jac_scheme_vec_ptr_int, builder->getPtrTy());
        Value* jac_scheme_len_ptr = builder->CreateBitCast(jac_scheme_vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* jac_scheme_len = builder->CreateLoad(Type::getInt64Ty(*context), jac_scheme_len_ptr);

        // Allocate tensor
        Value* jac_scheme_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* jac_scheme_tensor_ptr = builder->CreateCall(malloc_func, {jac_scheme_tensor_size});
        Value* jac_typed_scheme_tensor = builder->CreatePointerCast(jac_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* jac_scheme_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* jac_scheme_dims_ptr = builder->CreateCall(malloc_func, {jac_scheme_dims_size});
        Value* jac_typed_scheme_dims = builder->CreatePointerCast(jac_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(jac_scheme_len, jac_typed_scheme_dims);

        builder->CreateStore(jac_typed_scheme_dims, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 1));
        builder->CreateStore(jac_scheme_len, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* jac_scheme_elems_size = builder->CreateMul(jac_scheme_len,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* jac_scheme_elems_ptr = builder->CreateCall(malloc_func, {jac_scheme_elems_size});
        Value* jac_typed_scheme_elems = builder->CreatePointerCast(jac_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(jac_typed_scheme_elems, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 2));

        // Copy elements loop
        Value* jac_scheme_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), jac_scheme_vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* jac_scheme_elem_base_typed = builder->CreateBitCast(jac_scheme_elem_base, PointerType::getUnqual(tagged_value_type));

        BasicBlock* jac_svec_copy_cond = BasicBlock::Create(*context, "jac_svec_copy_cond", current_func);
        BasicBlock* jac_svec_copy_body = BasicBlock::Create(*context, "jac_svec_copy_body", current_func);
        BasicBlock* jac_svec_copy_done = BasicBlock::Create(*context, "jac_svec_copy_done", current_func);

        Value* jac_svec_copy_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "jac_svec_copy_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), jac_svec_copy_i);
        builder->CreateBr(jac_svec_copy_cond);

        builder->SetInsertPoint(jac_svec_copy_cond);
        Value* jac_svec_i = builder->CreateLoad(Type::getInt64Ty(*context), jac_svec_copy_i);
        Value* jac_svec_cond = builder->CreateICmpULT(jac_svec_i, jac_scheme_len);
        builder->CreateCondBr(jac_svec_cond, jac_svec_copy_body, jac_svec_copy_done);

        builder->SetInsertPoint(jac_svec_copy_body);
        Value* jac_svec_src_ptr = builder->CreateGEP(tagged_value_type, jac_scheme_elem_base_typed, jac_svec_i);
        Value* jac_svec_tagged_elem = builder->CreateLoad(tagged_value_type, jac_svec_src_ptr);
        Value* jac_svec_double_val = unpackDoubleFromTaggedValue(jac_svec_tagged_elem);
        Value* jac_svec_as_int64 = builder->CreateBitCast(jac_svec_double_val, Type::getInt64Ty(*context));
        Value* jac_svec_dst_ptr = builder->CreateGEP(Type::getInt64Ty(*context), jac_typed_scheme_elems, jac_svec_i);
        builder->CreateStore(jac_svec_as_int64, jac_svec_dst_ptr);
        Value* jac_svec_next_i = builder->CreateAdd(jac_svec_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(jac_svec_next_i, jac_svec_copy_i);
        builder->CreateBr(jac_svec_copy_cond);

        builder->SetInsertPoint(jac_svec_copy_done);
        Value* jac_scheme_tensor_int = builder->CreatePtrToInt(jac_typed_scheme_tensor, Type::getInt64Ty(*context));
        Value* jac_scheme_vector_tagged = packPtrToTaggedValue(jac_scheme_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(jac_merge_input);
        BasicBlock* jac_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(jac_tensor_input);
        builder->CreateBr(jac_merge_input);
        BasicBlock* jac_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(jac_merge_input);
        PHINode* jac_actual_input = builder->CreatePHI(tagged_value_type, 2, "jac_input");
        jac_actual_input->addIncoming(jac_scheme_vector_tagged, jac_scheme_exit);
        jac_actual_input->addIncoming(vector_val, jac_tensor_exit);

        // Extract tensor pointer from merged input
        Value* vector_ptr_int = safeExtractInt64(jac_actual_input);

        // Extract input dimension n from input vector
        Value* input_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        Value* input_dims_field = builder->CreateStructGEP(tensor_type, input_ptr, 0);
        Value* input_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_dims_field);
        Value* typed_input_dims = builder->CreatePointerCast(input_dims_ptr, builder->getPtrTy());
        
        Value* input_elements_field = builder->CreateStructGEP(tensor_type, input_ptr, 2);
        Value* input_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_elements_field);
        Value* typed_input_elements = builder->CreatePointerCast(input_elements_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_input_dims,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), n_ptr);

        // Call function once to determine output dimension m
        // CRITICAL FIX: Pack as TENSOR_PTR not INT64, so identity lambdas preserve type
        Value* vector_tagged = packPtrToTaggedValue(vector_ptr_int, ESHKOL_VALUE_TENSOR_PTR);
        Value* test_output_tagged = builder->CreateCall(func_ptr, {vector_tagged});
        
        // ENHANCED TYPE CHECK: Accept tensors, AD tensors, AND Scheme vectors as valid outputs
        Value* output_type = getTaggedValueType(test_output_tagged);
        Value* output_base_type = builder->CreateAnd(output_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check for valid vector types (regular tensors, AD tensors, and Scheme vectors)
        Value* output_is_tensor_ptr = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* output_is_ad_tensor = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* output_is_scheme_vector = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));
        Value* output_is_tensor_or_ad = builder->CreateOr(output_is_tensor_ptr, output_is_ad_tensor);
        Value* output_has_vector_type = builder->CreateOr(output_is_tensor_or_ad, output_is_scheme_vector);

        // CRITICAL FIX: Create null tagged value BEFORE branching (for PHI node dominance)
        Value* null_jac_tagged = packInt64ToTaggedValue(
            ConstantInt::get(Type::getInt64Ty(*context), 0), true);

        // Create blocks for validation flow
        BasicBlock* output_valid_block = BasicBlock::Create(*context, "jac_output_valid", current_func);
        BasicBlock* output_invalid_block = BasicBlock::Create(*context, "jac_output_invalid", current_func);
        BasicBlock* jac_return_block = BasicBlock::Create(*context, "jac_return", current_func);

        builder->CreateCondBr(output_has_vector_type, output_valid_block, output_invalid_block);

        // Invalid output: Generate runtime code to extract and report actual type value
        builder->SetInsertPoint(output_invalid_block);
        // This block now only reached for genuinely invalid types (NULL, INT64, DOUBLE, CONS_PTR)
        Function* printf_func_for_error = function_table["printf"];
        if (printf_func_for_error) {
            // Create alloca for type value at function entry to ensure dominance
            IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
            Function* func = builder->GetInsertBlock()->getParent();
            if (func && !func->empty()) {
                BasicBlock& entry = func->getEntryBlock();
                builder->SetInsertPoint(&entry, entry.begin());
            }
            Value* type_storage = builder->CreateAlloca(Type::getInt8Ty(*context), nullptr, "invalid_type");
            builder->restoreIP(saved_ip);

            // Store the runtime type value and extend to int for printf
            builder->CreateStore(output_base_type, type_storage);
            Value* type_val = builder->CreateLoad(Type::getInt8Ty(*context), type_storage);
            Value* type_as_int = builder->CreateZExt(type_val, Type::getInt32Ty(*context));

            // Print error with actual runtime type value (provides better debugging!)
            builder->CreateCall(printf_func_for_error, {
                codegenString("Jacobian ERROR: function returned non-vector type %d (expected 6=TENSOR, 5=AD_TENSOR, or 4=VECTOR_PTR)\n"),
                type_as_int
            });
        }
        builder->CreateBr(jac_return_block);

        // Valid output: Handle both tensor and Scheme vector formats
        builder->SetInsertPoint(output_valid_block);

        Function* printf_func = function_table["printf"];

        // Branch based on whether output is Scheme vector or tensor
        BasicBlock* jac_output_scheme_vec = BasicBlock::Create(*context, "jac_output_scheme_vec", current_func);
        BasicBlock* jac_output_tensor = BasicBlock::Create(*context, "jac_output_tensor", current_func);
        BasicBlock* jac_output_merge = BasicBlock::Create(*context, "jac_output_merge", current_func);

        builder->CreateCondBr(output_is_scheme_vector, jac_output_scheme_vec, jac_output_tensor);

        // SCHEME VECTOR OUTPUT: Extract dimension directly from vector length
        builder->SetInsertPoint(jac_output_scheme_vec);
        Value* jac_out_svec_ptr_int = unpackInt64FromTaggedValue(test_output_tagged);
        Value* jac_out_svec_ptr = builder->CreateIntToPtr(jac_out_svec_ptr_int, builder->getPtrTy());
        Value* jac_out_svec_len_ptr = builder->CreateBitCast(jac_out_svec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* jac_out_svec_m = builder->CreateLoad(Type::getInt64Ty(*context), jac_out_svec_len_ptr);
        builder->CreateBr(jac_output_merge);
        BasicBlock* jac_out_svec_exit = builder->GetInsertBlock();

        // TENSOR OUTPUT: Extract dimension from tensor structure
        builder->SetInsertPoint(jac_output_tensor);
        Value* test_output_int = unpackInt64FromTaggedValue(test_output_tagged);
        Value* test_output_ptr = builder->CreateIntToPtr(test_output_int, builder->getPtrTy());

        Value* output_dims_field = builder->CreateStructGEP(tensor_type, test_output_ptr, 0);
        Value* output_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), output_dims_field);

        Value* typed_output_dims = builder->CreatePointerCast(output_dims_ptr, builder->getPtrTy());

        Value* m_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_output_dims,
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        Value* jac_out_tensor_m = builder->CreateLoad(Type::getInt64Ty(*context), m_ptr);
        builder->CreateBr(jac_output_merge);
        BasicBlock* jac_out_tensor_exit = builder->GetInsertBlock();

        // MERGE: Get m from whichever path we took
        builder->SetInsertPoint(jac_output_merge);
        PHINode* m = builder->CreatePHI(Type::getInt64Ty(*context), 2, "jac_output_m");
        m->addIncoming(jac_out_svec_m, jac_out_svec_exit);
        m->addIncoming(jac_out_tensor_m, jac_out_tensor_exit);
        
        // Allocate Jacobian matrix (m×n, 2D tensor)
        Value* jac_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* jac_ptr = builder->CreateCall(malloc_func, {jac_tensor_size});
        Value* typed_jac_ptr = builder->CreatePointerCast(jac_ptr, builder->getPtrTy());
        
        // Set dimensions [m, n]
        Value* jac_dims_size = builder->CreateMul(
            ConstantInt::get(Type::getInt64Ty(*context), 2),
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* jac_dims_ptr = builder->CreateCall(malloc_func, {jac_dims_size});
        Value* typed_jac_dims = builder->CreatePointerCast(jac_dims_ptr, builder->getPtrTy());
        
        builder->CreateStore(m, typed_jac_dims);
        Value* jac_dim1_slot = builder->CreateGEP(Type::getInt64Ty(*context), typed_jac_dims,
            ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(n, jac_dim1_slot);
        
        // Store dimensions in tensor
        Value* jac_dims_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 0);
        builder->CreateStore(typed_jac_dims, jac_dims_field);
        
        // Set num_dimensions = 2
        Value* jac_num_dims_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 2), jac_num_dims_field);
        
        // Set total_elements = m * n
        Value* total_elems = builder->CreateMul(m, n);
        Value* jac_total_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 3);
        builder->CreateStore(total_elems, jac_total_field);
        
        // Allocate elements array (m*n doubles)
        Value* jac_elems_size = builder->CreateMul(total_elems,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* jac_elems_ptr = builder->CreateCall(malloc_func, {jac_elems_size});
        Value* typed_jac_elems = builder->CreatePointerCast(jac_elems_ptr, builder->getPtrTy());
        
        Value* jac_elems_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 2);
        builder->CreateStore(typed_jac_elems, jac_elems_field);

        BasicBlock* outer_cond = BasicBlock::Create(*context, "jac_outer_cond", current_func);
        BasicBlock* outer_body = BasicBlock::Create(*context, "jac_outer_body", current_func);
        BasicBlock* inner_cond = BasicBlock::Create(*context, "jac_inner_cond", current_func);
        BasicBlock* inner_body = BasicBlock::Create(*context, "jac_inner_body", current_func);
        BasicBlock* inner_exit = BasicBlock::Create(*context, "jac_inner_exit", current_func);
        BasicBlock* outer_exit = BasicBlock::Create(*context, "jac_outer_exit", current_func);
        
        Value* out_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "out_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), out_idx);

        builder->CreateBr(outer_cond);
        
        // Outer: i_out < m
        builder->SetInsertPoint(outer_cond);
        Value* i_out = builder->CreateLoad(Type::getInt64Ty(*context), out_idx);
        Value* i_out_less_m = builder->CreateICmpULT(i_out, m);
        builder->CreateCondBr(i_out_less_m, outer_body, outer_exit);
        
        builder->SetInsertPoint(outer_body);

        Value* in_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "in_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), in_idx);
        builder->CreateBr(inner_cond);
        
        // Inner: j_in < n
        builder->SetInsertPoint(inner_cond);
        Value* j_in = builder->CreateLoad(Type::getInt64Ty(*context), in_idx);
        Value* j_in_less_n = builder->CreateICmpULT(j_in, n);
        builder->CreateCondBr(j_in_less_n, inner_body, inner_exit);
        
        // Compute ∂Fᵢ/∂xⱼ
        builder->SetInsertPoint(inner_body);

        Value* arena_ptr = getArenaPtr();

        Value* jac_tape = builder->CreateCall(arena_allocate_tape_func,
            {arena_ptr, ConstantInt::get(Type::getInt64Ty(*context), 1024)});
        
        // CRITICAL FIX: Use global AD tape pointer, not member variable!
        // current_tape_ptr is compile-time C++ state, jac_tape is runtime LLVM Value*
        // Assigning Value* to member variable corrupts memory - use global instead
        builder->CreateStore(jac_tape, current_ad_tape);
        
        // Create n AD variable nodes
        Value* jac_var_nodes_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(void*)));
        Value* jac_var_nodes = builder->CreateCall(malloc_func, {jac_var_nodes_size});
        Value* typed_jac_var_nodes = builder->CreatePointerCast(jac_var_nodes, builder->getPtrTy());
        
        // Initialize all variable nodes with input values
        BasicBlock* jac_init_cond = BasicBlock::Create(*context, "jac_init_cond", current_func);
        BasicBlock* jac_init_body = BasicBlock::Create(*context, "jac_init_body", current_func);
        BasicBlock* jac_init_exit = BasicBlock::Create(*context, "jac_init_exit", current_func);
        
        Value* jac_init_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "jac_init_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), jac_init_idx);

        builder->CreateBr(jac_init_cond);
        
        builder->SetInsertPoint(jac_init_cond);
        Value* jac_init_i = builder->CreateLoad(Type::getInt64Ty(*context), jac_init_idx);
        Value* jac_init_less = builder->CreateICmpULT(jac_init_i, n);
        builder->CreateCondBr(jac_init_less, jac_init_body, jac_init_exit);
        
        builder->SetInsertPoint(jac_init_body);

        // CRITICAL FIX: Tensor elements stored as int64, load as int64 then convert
        Value* jac_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_input_elements, jac_init_i);
        Value* jac_elem_int64 = builder->CreateLoad(Type::getInt64Ty(*context), jac_elem_ptr);

        // FIX 1b: BitCast preserves IEEE754 bits, SIToFP corrupts them
        Value* jac_elem_val = builder->CreateBitCast(jac_elem_int64, Type::getDoubleTy(*context));
        Value* jac_var_node = createADVariable(jac_elem_val, 0);
        
        Value* jac_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, jac_init_i);
        builder->CreateStore(jac_var_node, jac_node_slot);
        
        Value* jac_next_init = builder->CreateAdd(jac_init_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(jac_next_init, jac_init_idx);
        builder->CreateBr(jac_init_cond);
        
        builder->SetInsertPoint(jac_init_exit);
        
        // Build AD tensor for function call
        Value* jac_ad_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));

        Value* jac_ad_tensor_ptr = builder->CreateCall(malloc_func, {jac_ad_tensor_size});

        Value* typed_jac_ad_tensor = builder->CreatePointerCast(jac_ad_tensor_ptr, builder->getPtrTy());

        // Set AD tensor structure
        Value* jac_ad_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* jac_ad_dims_ptr = builder->CreateCall(malloc_func, {jac_ad_dims_size});

        Value* typed_jac_ad_dims = builder->CreatePointerCast(jac_ad_dims_ptr, builder->getPtrTy());

        builder->CreateStore(n, typed_jac_ad_dims);
        
        // Set tensor fields directly (malloc never returns null in practice)
        builder->CreateStore(typed_jac_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 3));
        
        // CRITICAL FIX: Move elements allocation INSIDE tensor_valid_block
        // Otherwise typed_jac_ad_tensor is not available after the branch!
        Value* jac_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* jac_ad_elems_ptr = builder->CreateCall(malloc_func, {jac_ad_elems_size});
        Value* typed_jac_ad_elems = builder->CreatePointerCast(jac_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_jac_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 2));

        // Copy nodes
        BasicBlock* jac_copy_cond = BasicBlock::Create(*context, "jac_copy_cond", current_func);
        BasicBlock* jac_copy_body = BasicBlock::Create(*context, "jac_copy_body", current_func);
        BasicBlock* jac_copy_exit = BasicBlock::Create(*context, "jac_copy_exit", current_func);
        
        Value* jac_copy_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "jac_copy_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), jac_copy_idx);
        builder->CreateBr(jac_copy_cond);
        
        builder->SetInsertPoint(jac_copy_cond);
        Value* jac_copy_i = builder->CreateLoad(Type::getInt64Ty(*context), jac_copy_idx);
        Value* jac_copy_less = builder->CreateICmpULT(jac_copy_i, n);
        builder->CreateCondBr(jac_copy_less, jac_copy_body, jac_copy_exit);
        
        builder->SetInsertPoint(jac_copy_body);

        Value* jac_src_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, jac_copy_i);
        Value* jac_src_node = builder->CreateLoad(PointerType::getUnqual(*context), jac_src_slot);

        Value* jac_node_int = builder->CreatePtrToInt(jac_src_node, Type::getInt64Ty(*context));

        Value* jac_dst_slot = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_jac_ad_elems, jac_copy_i);
        builder->CreateStore(jac_node_int, jac_dst_slot);
        
        Value* jac_next_copy = builder->CreateAdd(jac_copy_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(jac_next_copy, jac_copy_idx);
        builder->CreateBr(jac_copy_cond);

        builder->SetInsertPoint(jac_copy_exit);
        
        // Call function to get output
        Value* jac_ad_tensor_int = builder->CreatePtrToInt(typed_jac_ad_tensor, Type::getInt64Ty(*context));
        // CRITICAL FIX: Pack as TENSOR_PTR not INT64, so identity lambdas preserve type
        Value* jac_ad_tensor_tagged = packPtrToTaggedValue(jac_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // PHASE 1 FIX: Set AD mode flag to true before calling lambda
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), ad_mode_active);
        
        Value* jac_output_tagged = builder->CreateCall(func_ptr, {jac_ad_tensor_tagged});
        
        // PHASE 1 FIX: Set AD mode flag back to false after lambda call
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), ad_mode_active);
        
        Value* jac_output_int = unpackInt64FromTaggedValue(jac_output_tagged);
        Value* jac_output_ptr = builder->CreateIntToPtr(jac_output_int, builder->getPtrTy());

        // CRITICAL FIX: Handle both tensor and Scheme vector output
        // Check if output is a Scheme vector (VECTOR_PTR)
        Value* jac_loop_output_type = getTaggedValueType(jac_output_tagged);
        Value* jac_loop_output_base = builder->CreateAnd(jac_loop_output_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* jac_loop_is_scheme_vec = builder->CreateICmpEQ(jac_loop_output_base,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* jac_loop_svec_out = BasicBlock::Create(*context, "jac_loop_svec_out", current_func);
        BasicBlock* jac_loop_tensor_out = BasicBlock::Create(*context, "jac_loop_tensor_out", current_func);
        BasicBlock* jac_loop_merge_out = BasicBlock::Create(*context, "jac_loop_merge_out", current_func);

        builder->CreateCondBr(jac_loop_is_scheme_vec, jac_loop_svec_out, jac_loop_tensor_out);

        // SCHEME VECTOR OUTPUT: Extract element from Scheme vector
        builder->SetInsertPoint(jac_loop_svec_out);
        // Scheme vector layout: [len: i64][elem0: tagged_value][elem1: tagged_value]...
        Value* jac_svec_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), jac_output_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));  // Skip length field
        Value* jac_svec_elem_base_typed = builder->CreateBitCast(jac_svec_elem_base, PointerType::getUnqual(tagged_value_type));
        Value* jac_svec_elem_ptr = builder->CreateGEP(tagged_value_type, jac_svec_elem_base_typed, i_out);
        Value* jac_svec_elem_tagged = builder->CreateLoad(tagged_value_type, jac_svec_elem_ptr);
        // Extract the int64 component from the tagged value (could be AD node ptr or double bits)
        Value* jac_svec_elem_int = safeExtractInt64(jac_svec_elem_tagged);
        builder->CreateBr(jac_loop_merge_out);
        BasicBlock* jac_svec_out_exit = builder->GetInsertBlock();

        // TENSOR OUTPUT: Extract element from tensor structure
        builder->SetInsertPoint(jac_loop_tensor_out);
        Value* out_elems_field = builder->CreateStructGEP(tensor_type, jac_output_ptr, 2);
        Value* out_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), out_elems_field);
        Value* typed_out_elems = builder->CreatePointerCast(out_elems_ptr, builder->getPtrTy());
        Value* jac_tensor_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_out_elems, i_out);
        Value* jac_tensor_elem_int = builder->CreateLoad(Type::getInt64Ty(*context), jac_tensor_elem_ptr);
        builder->CreateBr(jac_loop_merge_out);
        BasicBlock* jac_tensor_out_exit = builder->GetInsertBlock();

        // MERGE: Get output component from whichever path
        builder->SetInsertPoint(jac_loop_merge_out);
        PHINode* out_comp_int = builder->CreatePHI(Type::getInt64Ty(*context), 2, "jac_out_comp");
        out_comp_int->addIncoming(jac_svec_elem_int, jac_svec_out_exit);
        out_comp_int->addIncoming(jac_tensor_elem_int, jac_tensor_out_exit);
        
        // CRITICAL SAFETY CHECK: Detect if output element is AD node or regular value
        // AD nodes are allocated in heap (> 1000), doubles have IEEE754 exponent bits
        Value* is_small_value = builder->CreateICmpULT(out_comp_int,
            ConstantInt::get(Type::getInt64Ty(*context), 1000));
        
        // Check IEEE754 exponent for doubles (bit pattern detection)
        Value* exp_mask_jac = ConstantInt::get(Type::getInt64Ty(*context), 0x7FF0000000000000ULL);
        Value* exp_bits_jac = builder->CreateAnd(out_comp_int, exp_mask_jac);
        Value* has_exponent_jac = builder->CreateICmpNE(exp_bits_jac,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        // If has exponent, it's a double, not an AD node pointer
        Value* is_likely_double_jac = builder->CreateAnd(has_exponent_jac,
            builder->CreateNot(is_small_value));
        
        // Output is AD node only if: not small AND not double
        Value* elem_is_ad_node = builder->CreateAnd(
            builder->CreateNot(is_small_value),
            builder->CreateNot(is_likely_double_jac));
        
        // Allocate storage for partial derivative result (accessible across blocks)
        Value* partial_deriv_storage = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "jac_partial_storage");
        
        BasicBlock* run_jac_backward = BasicBlock::Create(*context, "jac_run_backward", current_func);
        BasicBlock* skip_jac_backward = BasicBlock::Create(*context, "jac_skip_backward", current_func);
        BasicBlock* after_jac_backward = BasicBlock::Create(*context, "jac_after_backward", current_func);
        
        builder->CreateCondBr(elem_is_ad_node, run_jac_backward, skip_jac_backward);
        
        // Run backward pass only if output element is AD node
        builder->SetInsertPoint(run_jac_backward);

        Value* out_comp_node = builder->CreateIntToPtr(out_comp_int, PointerType::getUnqual(*context));
        codegenBackward(out_comp_node, jac_tape);
        
        // Extract gradient from variable j_in
        Value* jac_grad_var_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, j_in);
        Value* jac_grad_var_node = builder->CreateLoad(PointerType::getUnqual(*context), jac_grad_var_slot);
        Value* computed_partial_deriv = loadNodeGradient(jac_grad_var_node);
        builder->CreateStore(computed_partial_deriv, partial_deriv_storage);
        builder->CreateBr(after_jac_backward);
        
        // Skip backward pass if output is not AD node (constant function)
        builder->SetInsertPoint(skip_jac_backward);

        Value* zero_deriv_jac = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        builder->CreateStore(zero_deriv_jac, partial_deriv_storage);
        builder->CreateBr(after_jac_backward);
        
        // Merge paths - load result from storage
        builder->SetInsertPoint(after_jac_backward);
        Value* partial_deriv = builder->CreateLoad(Type::getDoubleTy(*context), partial_deriv_storage);
        
        // Store J[i_out,j_in] at linear index: i_out*n + j_in
        Value* linear_idx = builder->CreateMul(i_out, n);
        linear_idx = builder->CreateAdd(linear_idx, j_in);
        
        Value* jac_result_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context),
            typed_jac_elems, linear_idx);
        builder->CreateStore(partial_deriv, jac_result_elem_ptr);
        
        builder->CreateCall(arena_tape_reset_func, {jac_tape});
        
        // CRITICAL FIX: Clear global tape pointer (like gradient does)
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* next_j_in = builder->CreateAdd(j_in, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_j_in, in_idx);
        builder->CreateBr(inner_cond);
        
        builder->SetInsertPoint(inner_exit);
        Value* next_i_out = builder->CreateAdd(i_out, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i_out, out_idx);
        builder->CreateBr(outer_cond);
        
        builder->SetInsertPoint(outer_exit);
        
        // JACOBIAN NESTED LIST FIX: Convert m×n tensor to nested list structure ((row1) (row2) ...)
        // This allows existing display() to show proper matrix structure without modifications
        
        // Get Jacobian elements for conversion
        Value* jac_convert_elems_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 2);
        Value* jac_convert_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), jac_convert_elems_field);
        Value* typed_jac_convert_elems = builder->CreatePointerCast(jac_convert_elems_ptr, builder->getPtrTy());
        
        // Build nested list: start from last row, build backwards
        Value* outer_list = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "jac_outer_list");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), outer_list); // Start with null
        
        // Outer loop: i from m-1 down to 0 (build list backwards)
        BasicBlock* convert_outer_cond = BasicBlock::Create(*context, "jac_convert_outer_cond", current_func);
        BasicBlock* convert_outer_body = BasicBlock::Create(*context, "jac_convert_outer_body", current_func);
        BasicBlock* convert_outer_exit = BasicBlock::Create(*context, "jac_convert_outer_exit", current_func);
        
        Value* convert_row_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "convert_row_idx");
        builder->CreateStore(m, convert_row_idx); // Start at m (will decrement before use)
        builder->CreateBr(convert_outer_cond);
        
        builder->SetInsertPoint(convert_outer_cond);
        Value* row_count = builder->CreateLoad(Type::getInt64Ty(*context), convert_row_idx);
        Value* row_gt_zero = builder->CreateICmpUGT(row_count, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(row_gt_zero, convert_outer_body, convert_outer_exit);
        
        builder->SetInsertPoint(convert_outer_body);
        
        // Decrement to get current row index (0-based)
        Value* current_row = builder->CreateSub(row_count, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(current_row, convert_row_idx);
        
        // Build row list: collect n elements from this row
        Value* row_list = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "jac_row_list");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), row_list); // Start with null
        
        // Inner loop: j from n-1 down to 0 (build row list backwards)
        BasicBlock* convert_inner_cond = BasicBlock::Create(*context, "jac_convert_inner_cond", current_func);
        BasicBlock* convert_inner_body = BasicBlock::Create(*context, "jac_convert_inner_body", current_func);
        BasicBlock* convert_inner_exit = BasicBlock::Create(*context, "jac_convert_inner_exit", current_func);
        
        Value* convert_col_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "convert_col_idx");
        builder->CreateStore(n, convert_col_idx); // Start at n (will decrement before use)
        builder->CreateBr(convert_inner_cond);
        
        builder->SetInsertPoint(convert_inner_cond);
        Value* col_count = builder->CreateLoad(Type::getInt64Ty(*context), convert_col_idx);
        Value* col_gt_zero = builder->CreateICmpUGT(col_count, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(col_gt_zero, convert_inner_body, convert_inner_exit);
        
        builder->SetInsertPoint(convert_inner_body);
        
        // Decrement to get current column index (0-based)
        Value* current_col = builder->CreateSub(col_count, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(current_col, convert_col_idx);
        
        // Get element at [current_row, current_col]
        Value* elem_linear_idx = builder->CreateMul(current_row, n);
        elem_linear_idx = builder->CreateAdd(elem_linear_idx, current_col);
        Value* elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_jac_convert_elems, elem_linear_idx);
        Value* elem_double = builder->CreateLoad(Type::getDoubleTy(*context), elem_ptr);
        
        // Pack element as tagged_value
        Value* elem_tagged = packDoubleToTaggedValue(elem_double);
        
        // Get current row list
        Value* current_row_list = builder->CreateLoad(Type::getInt64Ty(*context), row_list);
        Value* row_list_tagged = (current_row_list == ConstantInt::get(Type::getInt64Ty(*context), 0)) ?
            packNullToTaggedValue() :
            packPtrToTaggedValue(builder->CreateIntToPtr(current_row_list, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        
        // Cons element onto row list
        Value* new_row_cons = codegenTaggedArenaConsCellFromTaggedValue(elem_tagged, row_list_tagged);
        builder->CreateStore(new_row_cons, row_list);
        
        builder->CreateBr(convert_inner_cond);
        
        builder->SetInsertPoint(convert_inner_exit);
        
        // Row complete - cons it onto outer list
        Value* completed_row_list = builder->CreateLoad(Type::getInt64Ty(*context), row_list);
        Value* completed_row_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(completed_row_list, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* current_outer_list = builder->CreateLoad(Type::getInt64Ty(*context), outer_list);
        Value* outer_list_tagged = (current_outer_list == ConstantInt::get(Type::getInt64Ty(*context), 0)) ?
            packNullToTaggedValue() :
            packPtrToTaggedValue(builder->CreateIntToPtr(current_outer_list, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        
        // Cons row onto outer list
        Value* new_outer_cons = codegenTaggedArenaConsCellFromTaggedValue(completed_row_tagged, outer_list_tagged);
        builder->CreateStore(new_outer_cons, outer_list);
        
        builder->CreateBr(convert_outer_cond);
        
        builder->SetInsertPoint(convert_outer_exit);
        
        // JACOBIAN FIX: Create 1D tensor containing row lists as elements
        // This displays as #((row1) (row2)) - tensor prefix with nested row structure
        
        // Allocate result tensor (1D, m elements where each is a row list pointer)
        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions: [m] (1D vector of m rows)
        Value* result_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(m, typed_result_dims);
        
        // Set tensor fields
        builder->CreateStore(typed_result_dims,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 0)); // dimensions
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 1)); // num_dimensions = 1
        builder->CreateStore(m,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 3)); // total_elements = m
        
        // Allocate elements array (m pointers to row lists)
        Value* result_elems_size = builder->CreateMul(m,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* result_elems_ptr = builder->CreateCall(malloc_func, {result_elems_size});
        Value* typed_result_elems = builder->CreatePointerCast(result_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_result_elems,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 2)); // elements
        
        // Fill elements array with row list pointers (extract from nested list)
        BasicBlock* fill_tensor_cond = BasicBlock::Create(*context, "jac_fill_tensor_cond", current_func);
        BasicBlock* fill_tensor_body = BasicBlock::Create(*context, "jac_fill_tensor_body", current_func);
        BasicBlock* fill_tensor_exit = BasicBlock::Create(*context, "jac_fill_tensor_exit", current_func);
        
        Value* fill_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "fill_idx");
        Value* list_walker = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "list_walker");
        
        Value* final_nested_list = builder->CreateLoad(Type::getInt64Ty(*context), outer_list);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), fill_idx);
        builder->CreateStore(final_nested_list, list_walker);
        builder->CreateBr(fill_tensor_cond);
        
        builder->SetInsertPoint(fill_tensor_cond);
        Value* fill_i = builder->CreateLoad(Type::getInt64Ty(*context), fill_idx);
        Value* walker_val = builder->CreateLoad(Type::getInt64Ty(*context), list_walker);
        Value* fill_i_less_m = builder->CreateICmpULT(fill_i, m);
        Value* walker_not_null = builder->CreateICmpNE(walker_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_fill = builder->CreateAnd(fill_i_less_m, walker_not_null);
        builder->CreateCondBr(continue_fill, fill_tensor_body, fill_tensor_exit);
        
        builder->SetInsertPoint(fill_tensor_body);
        
        // Extract car (row list pointer) from current cons cell
        Value* walker_cons_ptr = builder->CreateIntToPtr(walker_val, builder->getPtrTy());
        Value* row_list_tagged_fill = extractCarAsTaggedValue(walker_val);
        Value* row_list_ptr = unpackInt64FromTaggedValue(row_list_tagged_fill);
        
        // Store row list pointer in tensor elements array
        Value* elem_slot = builder->CreateGEP(Type::getInt64Ty(*context), typed_result_elems, fill_i);
        builder->CreateStore(row_list_ptr, elem_slot);
        
        // Move to next row (cdr)
        Value* is_cdr_walker = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* next_walker = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {walker_cons_ptr, is_cdr_walker});
        builder->CreateStore(next_walker, list_walker);
        
        Value* next_fill_idx = builder->CreateAdd(fill_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_fill_idx, fill_idx);
        builder->CreateBr(fill_tensor_cond);
        
        builder->SetInsertPoint(fill_tensor_exit);
        
        // Return tensor of row lists as TENSOR_PTR
        Value* jac_result_int = builder->CreatePtrToInt(typed_result_tensor, Type::getInt64Ty(*context));
        Value* jac_result = packPtrToTaggedValue(jac_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(jac_return_block);
        
        // Merge null and valid results
        builder->SetInsertPoint(jac_return_block);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2, "jac_result");
        result_phi->addIncoming(null_jac_tagged, output_invalid_block);
        result_phi->addIncoming(jac_result, fill_tensor_exit);
        
        return result_phi;
    }
    
    // ===== PHASE 3: HESSIAN OPERATOR IMPLEMENTATION =====
    // Matrix of second derivatives (Jacobian of gradient)
    
    Value* codegenHessian(const eshkol_operations_t* op) {
        if (!op->hessian_op.function || !op->hessian_op.point) {
            eshkol_error("Invalid hessian operation");
            return nullptr;
        }
        
        eshkol_info("Computing Hessian matrix (second derivatives)");
        
        // CRITICAL FIX: Must null-check before dyn_cast to avoid LLVM assertion
        Value* func = resolveLambdaFunction(op->hessian_op.function);
        if (!func) {
            eshkol_error("Failed to resolve function for Hessian computation");
            return nullptr;
        }
        
        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("Hessian requires function");
            return nullptr;
        }
        
        TypedValue vector_tv = codegenTypedAST(op->hessian_op.point);
        if (!vector_tv.llvm_value) {
            eshkol_error("Failed to evaluate Hessian point");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Convert TypedValue to tagged_value
        Value* vector_val = typedValueToTaggedValue(vector_tv);

        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* hess_scheme_vector_input = BasicBlock::Create(*context, "hess_scheme_vector", current_func);
        BasicBlock* hess_tensor_input = BasicBlock::Create(*context, "hess_tensor_input", current_func);
        BasicBlock* hess_merge_input = BasicBlock::Create(*context, "hess_merge_input", current_func);

        builder->CreateCondBr(is_scheme_vector, hess_scheme_vector_input, hess_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(hess_scheme_vector_input);

        Value* hess_scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* hess_scheme_vec_ptr = builder->CreateIntToPtr(hess_scheme_vec_ptr_int, builder->getPtrTy());
        Value* hess_scheme_len_ptr = builder->CreateBitCast(hess_scheme_vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* hess_scheme_len = builder->CreateLoad(Type::getInt64Ty(*context), hess_scheme_len_ptr);

        // Allocate tensor
        Value* hess_scheme_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* hess_scheme_tensor_ptr = builder->CreateCall(malloc_func, {hess_scheme_tensor_size});
        Value* hess_typed_scheme_tensor = builder->CreatePointerCast(hess_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* hess_scheme_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* hess_scheme_dims_ptr = builder->CreateCall(malloc_func, {hess_scheme_dims_size});
        Value* hess_typed_scheme_dims = builder->CreatePointerCast(hess_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(hess_scheme_len, hess_typed_scheme_dims);

        builder->CreateStore(hess_typed_scheme_dims, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 1));
        builder->CreateStore(hess_scheme_len, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* hess_scheme_elems_size = builder->CreateMul(hess_scheme_len,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(int64_t)));
        Value* hess_scheme_elems_ptr = builder->CreateCall(malloc_func, {hess_scheme_elems_size});
        Value* hess_typed_scheme_elems = builder->CreatePointerCast(hess_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(hess_typed_scheme_elems, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 2));

        // Copy elements loop
        Value* hess_scheme_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), hess_scheme_vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* hess_scheme_elem_base_typed = builder->CreateBitCast(hess_scheme_elem_base, PointerType::getUnqual(tagged_value_type));

        BasicBlock* hess_svec_copy_cond = BasicBlock::Create(*context, "hess_svec_copy_cond", current_func);
        BasicBlock* hess_svec_copy_body = BasicBlock::Create(*context, "hess_svec_copy_body", current_func);
        BasicBlock* hess_svec_copy_done = BasicBlock::Create(*context, "hess_svec_copy_done", current_func);

        Value* hess_svec_copy_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "hess_svec_copy_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), hess_svec_copy_i);
        builder->CreateBr(hess_svec_copy_cond);

        builder->SetInsertPoint(hess_svec_copy_cond);
        Value* hess_svec_i = builder->CreateLoad(Type::getInt64Ty(*context), hess_svec_copy_i);
        Value* hess_svec_cond = builder->CreateICmpULT(hess_svec_i, hess_scheme_len);
        builder->CreateCondBr(hess_svec_cond, hess_svec_copy_body, hess_svec_copy_done);

        builder->SetInsertPoint(hess_svec_copy_body);
        Value* hess_svec_src_ptr = builder->CreateGEP(tagged_value_type, hess_scheme_elem_base_typed, hess_svec_i);
        Value* hess_svec_tagged_elem = builder->CreateLoad(tagged_value_type, hess_svec_src_ptr);
        Value* hess_svec_double_val = unpackDoubleFromTaggedValue(hess_svec_tagged_elem);
        Value* hess_svec_as_int64 = builder->CreateBitCast(hess_svec_double_val, Type::getInt64Ty(*context));
        Value* hess_svec_dst_ptr = builder->CreateGEP(Type::getInt64Ty(*context), hess_typed_scheme_elems, hess_svec_i);
        builder->CreateStore(hess_svec_as_int64, hess_svec_dst_ptr);
        Value* hess_svec_next_i = builder->CreateAdd(hess_svec_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(hess_svec_next_i, hess_svec_copy_i);
        builder->CreateBr(hess_svec_copy_cond);

        builder->SetInsertPoint(hess_svec_copy_done);
        Value* hess_scheme_tensor_int = builder->CreatePtrToInt(hess_typed_scheme_tensor, Type::getInt64Ty(*context));
        Value* hess_scheme_vector_tagged = packPtrToTaggedValue(hess_scheme_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(hess_merge_input);
        BasicBlock* hess_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(hess_tensor_input);
        builder->CreateBr(hess_merge_input);
        BasicBlock* hess_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(hess_merge_input);
        PHINode* hess_actual_input = builder->CreatePHI(tagged_value_type, 2, "hess_input");
        hess_actual_input->addIncoming(hess_scheme_vector_tagged, hess_scheme_exit);
        hess_actual_input->addIncoming(vector_val, hess_tensor_exit);

        // Extract tensor pointer from merged input
        Value* vector_ptr_int = safeExtractInt64(hess_actual_input);

        // Use class member tensor_type (shared by all tensor operations)

        // Extract input dimension n
        Value* input_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        Value* input_dims_field = builder->CreateStructGEP(tensor_type, input_ptr, 0);
        Value* input_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_dims_field);
        Value* typed_input_dims = builder->CreatePointerCast(input_dims_ptr, builder->getPtrTy());
        
        Value* input_elements_field = builder->CreateStructGEP(tensor_type, input_ptr, 2);
        Value* input_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_elements_field);
        Value* typed_input_elements = builder->CreatePointerCast(input_elements_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_input_dims,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), n_ptr);

        // Allocate n×n Hessian matrix
        Value* hess_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* hess_ptr = builder->CreateCall(malloc_func, {hess_tensor_size});
        Value* typed_hess_ptr = builder->CreatePointerCast(hess_ptr, builder->getPtrTy());
        
        // Set dimensions [n, n]
        Value* hess_dims_size = builder->CreateMul(
            ConstantInt::get(Type::getInt64Ty(*context), 2),
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* hess_dims_ptr = builder->CreateCall(malloc_func, {hess_dims_size});
        Value* typed_hess_dims = builder->CreatePointerCast(hess_dims_ptr, builder->getPtrTy());
        
        builder->CreateStore(n, typed_hess_dims);
        Value* hess_dim1_slot = builder->CreateGEP(Type::getInt64Ty(*context), typed_hess_dims,
            ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(n, hess_dim1_slot);
        
        Value* hess_dims_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 0);
        builder->CreateStore(typed_hess_dims, hess_dims_field);
        
        Value* hess_num_dims_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 2), hess_num_dims_field);
        
        Value* total_hess_elems = builder->CreateMul(n, n);
        Value* hess_total_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 3);
        builder->CreateStore(total_hess_elems, hess_total_field);
        
        // Allocate elements array
        Value* hess_elems_size = builder->CreateMul(total_hess_elems,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* hess_elems_ptr = builder->CreateCall(malloc_func, {hess_elems_size});
        Value* typed_hess_elems = builder->CreatePointerCast(hess_elems_ptr, builder->getPtrTy());
        
        Value* hess_elems_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 2);
        builder->CreateStore(typed_hess_elems, hess_elems_field);
        
        // Numerical differentiation epsilon
        Value* epsilon = ConstantFP::get(Type::getDoubleTy(*context), 1e-8);
        
        // Compute gradient at original point first
        // Create gradient operation structure - but we can't easily do this
        // Instead, inline the gradient computation
        
        // Allocate array for base gradient
        Value* base_grad_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* base_grad_ptr = builder->CreateCall(malloc_func, {base_grad_size});
        Value* typed_base_grad = builder->CreatePointerCast(base_grad_ptr, builder->getPtrTy());
        
        // Compute base gradient (similar to codegenGradient but store in array)
        BasicBlock* base_grad_loop_cond = BasicBlock::Create(*context, "base_grad_cond", current_func);
        BasicBlock* base_grad_loop_body = BasicBlock::Create(*context, "base_grad_body", current_func);
        BasicBlock* base_grad_loop_exit = BasicBlock::Create(*context, "base_grad_exit", current_func);
        
        Value* base_grad_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "base_grad_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), base_grad_idx);
        builder->CreateBr(base_grad_loop_cond);
        
        builder->SetInsertPoint(base_grad_loop_cond);
        Value* bg_i = builder->CreateLoad(Type::getInt64Ty(*context), base_grad_idx);
        Value* bg_i_less_n = builder->CreateICmpULT(bg_i, n);
        builder->CreateCondBr(bg_i_less_n, base_grad_loop_body, base_grad_loop_exit);
        
        builder->SetInsertPoint(base_grad_loop_body);
        
        // Create tape and AD nodes
        Value* arena_ptr = getArenaPtr();
        Value* bg_tape = builder->CreateCall(arena_allocate_tape_func,
            {arena_ptr, ConstantInt::get(Type::getInt64Ty(*context), 1024)});
        
        // CRITICAL: Set global tape pointer (runtime Value*, not compile-time member)
        builder->CreateStore(bg_tape, current_ad_tape);
        
        // Create variable nodes
        Value* bg_nodes_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(void*)));
        Value* bg_nodes_ptr = builder->CreateCall(malloc_func, {bg_nodes_size});
        Value* typed_bg_nodes = builder->CreatePointerCast(bg_nodes_ptr, builder->getPtrTy());
        
        // Initialize nodes loop
        BasicBlock* bg_init_cond = BasicBlock::Create(*context, "bg_init_cond", current_func);
        BasicBlock* bg_init_body = BasicBlock::Create(*context, "bg_init_body", current_func);
        BasicBlock* bg_init_exit = BasicBlock::Create(*context, "bg_init_exit", current_func);
        
        Value* bg_init_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "bg_init_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), bg_init_idx);
        builder->CreateBr(bg_init_cond);
        
        builder->SetInsertPoint(bg_init_cond);
        Value* bg_j = builder->CreateLoad(Type::getInt64Ty(*context), bg_init_idx);
        Value* bg_j_less_n = builder->CreateICmpULT(bg_j, n);
        builder->CreateCondBr(bg_j_less_n, bg_init_body, bg_init_exit);
        
        builder->SetInsertPoint(bg_init_body);
        // CRITICAL FIX: Tensor elements stored as int64, load as int64 then convert
        Value* bg_elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_input_elements, bg_j);
        Value* bg_elem_int64 = builder->CreateLoad(Type::getInt64Ty(*context), bg_elem_ptr);
        // FIX 1c: BitCast preserves IEEE754 bits, SIToFP corrupts them
        Value* bg_elem = builder->CreateBitCast(bg_elem_int64, Type::getDoubleTy(*context));
        Value* bg_node = createADVariable(bg_elem, 0);
        
        Value* bg_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_j);
        builder->CreateStore(bg_node, bg_node_slot);
        
        Value* bg_next_j = builder->CreateAdd(bg_j, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(bg_next_j, bg_init_idx);
        builder->CreateBr(bg_init_cond);
        
        builder->SetInsertPoint(bg_init_exit);
        
        // Build and call function (similar to gradient)
        Value* bg_ad_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* bg_ad_tensor_ptr = builder->CreateCall(malloc_func, {bg_ad_tensor_size});
        Value* typed_bg_ad_tensor = builder->CreatePointerCast(bg_ad_tensor_ptr, builder->getPtrTy());
        
        Value* bg_ad_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* bg_ad_dims_ptr = builder->CreateCall(malloc_func, {bg_ad_dims_size});
        Value* typed_bg_ad_dims = builder->CreatePointerCast(bg_ad_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_bg_ad_dims);
        
        builder->CreateStore(typed_bg_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 3));
        
        Value* bg_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* bg_ad_elems_ptr = builder->CreateCall(malloc_func, {bg_ad_elems_size});
        Value* typed_bg_ad_elems = builder->CreatePointerCast(bg_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_bg_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 2));
        
        // Copy nodes
        BasicBlock* bg_copy_cond = BasicBlock::Create(*context, "bg_copy_cond", current_func);
        BasicBlock* bg_copy_body = BasicBlock::Create(*context, "bg_copy_body", current_func);
        BasicBlock* bg_copy_exit = BasicBlock::Create(*context, "bg_copy_exit", current_func);
        
        Value* bg_copy_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "bg_copy_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), bg_copy_idx);
        builder->CreateBr(bg_copy_cond);
        
        builder->SetInsertPoint(bg_copy_cond);
        Value* bg_k = builder->CreateLoad(Type::getInt64Ty(*context), bg_copy_idx);
        Value* bg_k_less_n = builder->CreateICmpULT(bg_k, n);
        builder->CreateCondBr(bg_k_less_n, bg_copy_body, bg_copy_exit);
        
        builder->SetInsertPoint(bg_copy_body);
        Value* bg_src_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_k);
        Value* bg_src_node = builder->CreateLoad(PointerType::getUnqual(*context), bg_src_slot);
        Value* bg_node_int = builder->CreatePtrToInt(bg_src_node, Type::getInt64Ty(*context));
        
        Value* bg_dst_slot = builder->CreateGEP(Type::getInt64Ty(*context),
            typed_bg_ad_elems, bg_k);
        builder->CreateStore(bg_node_int, bg_dst_slot);
        
        Value* bg_next_k = builder->CreateAdd(bg_k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(bg_next_k, bg_copy_idx);
        builder->CreateBr(bg_copy_cond);
        
        builder->SetInsertPoint(bg_copy_exit);
        
        // Call function
        Value* bg_ad_tensor_int = builder->CreatePtrToInt(typed_bg_ad_tensor, Type::getInt64Ty(*context));
        Value* bg_ad_tensor_tagged = packPtrToTaggedValue(bg_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // PHASE 1 FIX: Set AD mode flag to true before calling lambda
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), ad_mode_active);
        
        Value* bg_output_tagged = builder->CreateCall(func_ptr, {bg_ad_tensor_tagged});
        
        // PHASE 1 FIX: Set AD mode flag back to false after lambda call
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), ad_mode_active);
        
        Value* bg_output_int = unpackInt64FromTaggedValue(bg_output_tagged);
        Value* bg_output_node = builder->CreateIntToPtr(bg_output_int, PointerType::getUnqual(*context));
        
        // Backward pass
        codegenBackward(bg_output_node, bg_tape);
        
        // Extract gradient for component bg_i
        Value* bg_active_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_i);
        Value* bg_active_node = builder->CreateLoad(PointerType::getUnqual(*context), bg_active_slot);
        Value* bg_partial = loadNodeGradient(bg_active_node);
        
        // Store in base gradient array
        Value* bg_store_ptr = builder->CreateGEP(Type::getDoubleTy(*context),
            typed_base_grad, bg_i);
        builder->CreateStore(bg_partial, bg_store_ptr);
        
        builder->CreateCall(arena_tape_reset_func, {bg_tape});
        
        // Clear global tape pointer
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* bg_next_i = builder->CreateAdd(bg_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(bg_next_i, base_grad_idx);
        builder->CreateBr(base_grad_loop_cond);
        
        builder->SetInsertPoint(base_grad_loop_exit);
        
        // NUMERICAL DIFFERENTIATION: Compute Hessian H[i,j] = ∂²f/∂xᵢ∂xⱼ
        // Using finite difference: H[i,j] ≈ (∇ᵢf(v+ε·eⱼ) - ∇ᵢf(v)) / ε
        // Outer loop: for each column j (variable to perturb)
        
        // CRITICAL: Load arena_ptr ONCE before loops to ensure dominance
        Value* hess_arena_ptr = getArenaPtr();
        
        BasicBlock* hess_col_cond = BasicBlock::Create(*context, "hess_col_cond", current_func);
        BasicBlock* hess_col_body = BasicBlock::Create(*context, "hess_col_body", current_func);
        BasicBlock* hess_col_exit = BasicBlock::Create(*context, "hess_col_exit", current_func);
        
        Value* hess_j_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "hess_j_col");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), hess_j_idx);
        builder->CreateBr(hess_col_cond);
        
        // Column loop condition: j < n
        builder->SetInsertPoint(hess_col_cond);
        Value* hess_j = builder->CreateLoad(Type::getInt64Ty(*context), hess_j_idx);
        Value* hess_j_less_n = builder->CreateICmpULT(hess_j, n);
        builder->CreateCondBr(hess_j_less_n, hess_col_body, hess_col_exit);
        
        builder->SetInsertPoint(hess_col_body);
        
        // Step 1: Create perturbed vector v_j = v + ε·e_j
        Value* perturbed_vec_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* perturbed_vec_ptr = builder->CreateCall(malloc_func, {perturbed_vec_size});
        Value* typed_perturbed_vec = builder->CreatePointerCast(perturbed_vec_ptr, builder->getPtrTy());
        
        // Copy input vector and perturb j-th component
        BasicBlock* copy_loop_cond = BasicBlock::Create(*context, "hess_copy_cond", current_func);
        BasicBlock* copy_loop_body = BasicBlock::Create(*context, "hess_copy_body", current_func);
        BasicBlock* copy_loop_exit = BasicBlock::Create(*context, "hess_copy_exit", current_func);
        
        Value* copy_k_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "copy_k");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), copy_k_idx);
        builder->CreateBr(copy_loop_cond);
        
        builder->SetInsertPoint(copy_loop_cond);
        Value* copy_k = builder->CreateLoad(Type::getInt64Ty(*context), copy_k_idx);
        Value* copy_k_less_n = builder->CreateICmpULT(copy_k, n);
        builder->CreateCondBr(copy_k_less_n, copy_loop_body, copy_loop_exit);
        
        builder->SetInsertPoint(copy_loop_body);
        
        // Load input[k]
        Value* input_k_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_input_elements, copy_k);
        Value* input_k_int64 = builder->CreateLoad(Type::getInt64Ty(*context), input_k_ptr);
        Value* input_k_double = builder->CreateBitCast(input_k_int64, Type::getDoubleTy(*context));
        
        // If k == j, add epsilon; otherwise copy as-is
        Value* k_is_j = builder->CreateICmpEQ(copy_k, hess_j);
        Value* perturbed_val = builder->CreateSelect(k_is_j,
            builder->CreateFAdd(input_k_double, epsilon),
            input_k_double);
        
        // Store in perturbed vector
        Value* pert_k_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_perturbed_vec, copy_k);
        builder->CreateStore(perturbed_val, pert_k_ptr);
        
        Value* copy_k_next = builder->CreateAdd(copy_k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(copy_k_next, copy_k_idx);
        builder->CreateBr(copy_loop_cond);
        
        builder->SetInsertPoint(copy_loop_exit);
        
        // Step 2: Compute gradient at perturbed point
        // Create tape for perturbed gradient computation
        Value* pert_tape = builder->CreateCall(arena_allocate_tape_func,
            {hess_arena_ptr, ConstantInt::get(Type::getInt64Ty(*context), 1024)});
        
        // Create AD variable nodes from perturbed vector
        Value* pert_nodes_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(void*)));
        Value* pert_nodes_ptr = builder->CreateCall(malloc_func, {pert_nodes_size});
        Value* typed_pert_nodes = builder->CreatePointerCast(pert_nodes_ptr, builder->getPtrTy());
        
        // Initialize perturbed variable nodes
        BasicBlock* pert_init_cond = BasicBlock::Create(*context, "pert_init_cond", current_func);
        BasicBlock* pert_init_body = BasicBlock::Create(*context, "pert_init_body", current_func);
        BasicBlock* pert_init_exit = BasicBlock::Create(*context, "pert_init_exit", current_func);
        
        Value* pert_init_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "pert_init_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), pert_init_idx);
        builder->CreateBr(pert_init_cond);
        
        builder->SetInsertPoint(pert_init_cond);
        Value* pert_k = builder->CreateLoad(Type::getInt64Ty(*context), pert_init_idx);
        Value* pert_k_less_n = builder->CreateICmpULT(pert_k, n);
        builder->CreateCondBr(pert_k_less_n, pert_init_body, pert_init_exit);
        
        builder->SetInsertPoint(pert_init_body);
        
        Value* pert_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_perturbed_vec, pert_k);
        Value* pert_elem_val = builder->CreateLoad(Type::getDoubleTy(*context), pert_elem_ptr);
        Value* hess_pert_var_node = createADVariable(pert_elem_val, 0);
        
        Value* hess_pert_node_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, pert_k);
        builder->CreateStore(hess_pert_var_node, hess_pert_node_slot);
        
        Value* pert_k_next = builder->CreateAdd(pert_k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(pert_k_next, pert_init_idx);
        builder->CreateBr(pert_init_cond);
        
        builder->SetInsertPoint(pert_init_exit);
        
        // Build AD tensor from perturbed nodes
        Value* pert_ad_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* pert_ad_tensor_ptr = builder->CreateCall(malloc_func, {pert_ad_tensor_size});
        Value* typed_pert_ad_tensor = builder->CreatePointerCast(pert_ad_tensor_ptr, builder->getPtrTy());
        
        // Set tensor dimensions
        Value* pert_ad_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* pert_ad_dims_ptr = builder->CreateCall(malloc_func, {pert_ad_dims_size});
        Value* typed_pert_ad_dims = builder->CreatePointerCast(pert_ad_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_pert_ad_dims);
        
        builder->CreateStore(typed_pert_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 3));
        
        // Allocate and fill AD tensor elements
        Value* pert_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t)));
        Value* pert_ad_elems_ptr = builder->CreateCall(malloc_func, {pert_ad_elems_size});
        Value* typed_pert_ad_elems = builder->CreatePointerCast(pert_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_pert_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 2));
        
        // Copy perturbed node pointers into AD tensor
        BasicBlock* pert_copy_cond = BasicBlock::Create(*context, "pert_copy_cond", current_func);
        BasicBlock* pert_copy_body = BasicBlock::Create(*context, "pert_copy_body", current_func);
        BasicBlock* pert_copy_exit = BasicBlock::Create(*context, "pert_copy_exit", current_func);
        
        Value* pert_copy_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "pert_copy_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), pert_copy_idx);
        builder->CreateBr(pert_copy_cond);
        
        builder->SetInsertPoint(pert_copy_cond);
        Value* pert_copy_k = builder->CreateLoad(Type::getInt64Ty(*context), pert_copy_idx);
        Value* pert_copy_less_n = builder->CreateICmpULT(pert_copy_k, n);
        builder->CreateCondBr(pert_copy_less_n, pert_copy_body, pert_copy_exit);
        
        builder->SetInsertPoint(pert_copy_body);
        
        Value* pert_src_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, pert_copy_k);
        Value* pert_src_node = builder->CreateLoad(PointerType::getUnqual(*context), pert_src_slot);
        Value* pert_node_int = builder->CreatePtrToInt(pert_src_node, Type::getInt64Ty(*context));
        
        Value* pert_dst_slot = builder->CreateGEP(Type::getInt64Ty(*context), typed_pert_ad_elems, pert_copy_k);
        builder->CreateStore(pert_node_int, pert_dst_slot);
        
        Value* pert_copy_next = builder->CreateAdd(pert_copy_k, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(pert_copy_next, pert_copy_idx);
        builder->CreateBr(pert_copy_cond);
        
        builder->SetInsertPoint(pert_copy_exit);
        
        // Call function with perturbed AD tensor
        Value* pert_ad_tensor_int = builder->CreatePtrToInt(typed_pert_ad_tensor, Type::getInt64Ty(*context));
        Value* pert_ad_tensor_tagged = packPtrToTaggedValue(pert_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // Set AD mode and tape
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 1), ad_mode_active);
        builder->CreateStore(pert_tape, current_ad_tape);
        
        Value* pert_output_tagged = builder->CreateCall(func_ptr, {pert_ad_tensor_tagged});
        
        // Reset AD mode and tape
        builder->CreateStore(ConstantInt::get(Type::getInt1Ty(*context), 0), ad_mode_active);
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* pert_output_int = unpackInt64FromTaggedValue(pert_output_tagged);
        Value* pert_output_node = builder->CreateIntToPtr(pert_output_int, PointerType::getUnqual(*context));
        
        // Run backward pass
        codegenBackward(pert_output_node, pert_tape);
        
        // Allocate array for perturbed gradient
        Value* pert_grad_size = builder->CreateMul(n,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* pert_grad_ptr = builder->CreateCall(malloc_func, {pert_grad_size});
        Value* typed_pert_grad = builder->CreatePointerCast(pert_grad_ptr, builder->getPtrTy());
        
        // Extract perturbed gradient into array
        BasicBlock* pert_extract_cond = BasicBlock::Create(*context, "pert_extract_cond", current_func);
        BasicBlock* pert_extract_body = BasicBlock::Create(*context, "pert_extract_body", current_func);
        BasicBlock* pert_extract_exit = BasicBlock::Create(*context, "pert_extract_exit", current_func);
        
        Value* pert_extract_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "pert_extract_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), pert_extract_idx);
        builder->CreateBr(pert_extract_cond);
        
        builder->SetInsertPoint(pert_extract_cond);
        Value* extract_i = builder->CreateLoad(Type::getInt64Ty(*context), pert_extract_idx);
        Value* extract_less_n = builder->CreateICmpULT(extract_i, n);
        builder->CreateCondBr(extract_less_n, pert_extract_body, pert_extract_exit);
        
        builder->SetInsertPoint(pert_extract_body);
        
        // Get gradient from variable node i
        Value* hess_pert_var_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, extract_i);
        Value* hess_pert_var_node_load = builder->CreateLoad(PointerType::getUnqual(*context), hess_pert_var_slot);
        Value* hess_pert_grad_i = loadNodeGradient(hess_pert_var_node_load);
        
        // Store in perturbed gradient array
        Value* hess_pert_grad_store_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_pert_grad, extract_i);
        builder->CreateStore(hess_pert_grad_i, hess_pert_grad_store_ptr);
        
        Value* extract_next = builder->CreateAdd(extract_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(extract_next, pert_extract_idx);
        builder->CreateBr(pert_extract_cond);
        
        builder->SetInsertPoint(pert_extract_exit);
        
        // Step 3: Compute H[i,j] for all rows i
        BasicBlock* hess_row_cond = BasicBlock::Create(*context, "hess_row_cond", current_func);
        BasicBlock* hess_row_body = BasicBlock::Create(*context, "hess_row_body", current_func);
        BasicBlock* hess_row_exit = BasicBlock::Create(*context, "hess_row_exit", current_func);
        
        Value* hess_i_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "hess_i_row");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), hess_i_idx);
        builder->CreateBr(hess_row_cond);
        
        builder->SetInsertPoint(hess_row_cond);
        Value* hess_i = builder->CreateLoad(Type::getInt64Ty(*context), hess_i_idx);
        Value* hess_i_less_n = builder->CreateICmpULT(hess_i, n);
        builder->CreateCondBr(hess_i_less_n, hess_row_body, hess_row_exit);
        
        builder->SetInsertPoint(hess_row_body);
        
        // Load base_grad[i]
        Value* base_grad_i_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_base_grad, hess_i);
        Value* base_grad_i = builder->CreateLoad(Type::getDoubleTy(*context), base_grad_i_ptr);
        
        // Load pert_grad[i]
        Value* hess_pert_grad_i_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_pert_grad, hess_i);
        Value* hess_pert_grad_i_val = builder->CreateLoad(Type::getDoubleTy(*context), hess_pert_grad_i_ptr);
        
        // Compute H[i,j] = (pert_grad[i] - base_grad[i]) / epsilon
        Value* grad_diff = builder->CreateFSub(hess_pert_grad_i_val, base_grad_i);
        Value* second_deriv = builder->CreateFDiv(grad_diff, epsilon);
        
        // Store H[i,j] in Hessian matrix (row-major: i*n + j)
        Value* hess_linear_idx = builder->CreateMul(hess_i, n);
        hess_linear_idx = builder->CreateAdd(hess_linear_idx, hess_j);
        Value* hess_store_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_hess_elems, hess_linear_idx);
        builder->CreateStore(second_deriv, hess_store_ptr);
        
        Value* hess_i_next = builder->CreateAdd(hess_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(hess_i_next, hess_i_idx);
        builder->CreateBr(hess_row_cond);
        
        builder->SetInsertPoint(hess_row_exit);
        
        // Reset tape for next column
        builder->CreateCall(arena_tape_reset_func, {pert_tape});
        
        // Next column
        Value* hess_j_next = builder->CreateAdd(hess_j, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(hess_j_next, hess_j_idx);
        builder->CreateBr(hess_col_cond);
        
        builder->SetInsertPoint(hess_col_exit);
        
        eshkol_info("Hessian computation complete");
        // Tag as TENSOR_PTR for proper display handling
        Value* hess_result_int = builder->CreatePtrToInt(typed_hess_ptr, Type::getInt64Ty(*context));
        return packPtrToTaggedValue(hess_result_int, ESHKOL_VALUE_TENSOR_PTR);
    }
    // ===== N-DIMENSIONAL NULL VECTOR HELPER =====
    // Create n-dimensional null vector (all zeros) for error handling
    // Handles ANY dimension at runtime - NEVER hardcode dimensions!
    Value* createNullVectorTensor(Value* dimension) {
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for null vector creation");
            return ConstantInt::get(Type::getInt64Ty(*context), 0);
        }
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Allocate tensor structure
        Value* tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());
        
        // Allocate dimensions array (1D vector of given dimension)
        Value* dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        builder->CreateStore(dimension, typed_dims_ptr);  // Runtime dimension!
        
        // Store tensor metadata
        builder->CreateStore(typed_dims_ptr,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0));  // dimensions
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1));  // num_dimensions = 1
        builder->CreateStore(dimension,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3));  // total_elements = dimension
        
        // Allocate elements array (dimension * sizeof(double))
        Value* elems_size = builder->CreateMul(dimension,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* elems_ptr = builder->CreateCall(malloc_func, {elems_size});
        Value* typed_elems_ptr = builder->CreatePointerCast(elems_ptr, builder->getPtrTy());
        
        // Zero all elements using RUNTIME LOOP (n-dimensional!)
        BasicBlock* zero_cond = BasicBlock::Create(*context, "null_vec_zero_cond", current_func);
        BasicBlock* zero_body = BasicBlock::Create(*context, "null_vec_zero_body", current_func);
        BasicBlock* zero_exit = BasicBlock::Create(*context, "null_vec_zero_exit", current_func);
        
        Value* idx_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "zero_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), idx_ptr);
        builder->CreateBr(zero_cond);
        
        builder->SetInsertPoint(zero_cond);
        Value* idx = builder->CreateLoad(Type::getInt64Ty(*context), idx_ptr);
        Value* idx_less = builder->CreateICmpULT(idx, dimension);
        builder->CreateCondBr(idx_less, zero_body, zero_exit);
        
        builder->SetInsertPoint(zero_body);
        Value* elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_elems_ptr, idx);
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), elem_ptr);
        Value* next_idx = builder->CreateAdd(idx, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_idx, idx_ptr);
        builder->CreateBr(zero_cond);
        
        builder->SetInsertPoint(zero_exit);
        
        builder->CreateStore(typed_elems_ptr,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2));  // elements
        
        // Return tensor pointer as i64
        return builder->CreatePtrToInt(typed_tensor_ptr, Type::getInt64Ty(*context));
    }
    
    
    // Helper: Extract J[row,col] from Jacobian's nested list structure
    // Jacobian tensor elements are int64 list pointers (rows), not doubles!
    Value* extractJacobianElement(Value* jacobian_ptr, Value* row_idx, Value* col_idx, Value* n) {
        // Get Jacobian elements array (contains list pointers)
        Value* jac_elements_field = builder->CreateStructGEP(tensor_type, jacobian_ptr, 2);
        Value* jac_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), jac_elements_field);
        Value* typed_jac_elements = builder->CreatePointerCast(jac_elements_ptr, builder->getPtrTy());
        
        // Load row list pointer at row_idx
        Value* row_ptr_slot = builder->CreateGEP(Type::getInt64Ty(*context), typed_jac_elements, row_idx);
        Value* row_list_int = builder->CreateLoad(Type::getInt64Ty(*context), row_ptr_slot);
        
        // Traverse row list to column position col_idx
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* traverse_cond = BasicBlock::Create(*context, "jac_traverse_cond", current_func);
        BasicBlock* traverse_body = BasicBlock::Create(*context, "jac_traverse_body", current_func);
        BasicBlock* traverse_exit = BasicBlock::Create(*context, "jac_traverse_exit", current_func);
        
        Value* current_list = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "current_list");
        Value* current_col = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "current_col");
        builder->CreateStore(row_list_int, current_list);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), current_col);
        builder->CreateBr(traverse_cond);
        
        builder->SetInsertPoint(traverse_cond);
        Value* col = builder->CreateLoad(Type::getInt64Ty(*context), current_col);
        Value* list_ptr = builder->CreateLoad(Type::getInt64Ty(*context), current_list);
        Value* col_matches = builder->CreateICmpEQ(col, col_idx);
        Value* list_not_null = builder->CreateICmpNE(list_ptr, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_traverse = builder->CreateAnd(builder->CreateNot(col_matches), list_not_null);
        builder->CreateCondBr(continue_traverse, traverse_body, traverse_exit);
        
        builder->SetInsertPoint(traverse_body);
        // Move to cdr
        Value* cons_ptr = builder->CreateIntToPtr(list_ptr, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* next_list = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(next_list, current_list);
        Value* next_col = builder->CreateAdd(col, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_col, current_col);
        builder->CreateBr(traverse_cond);
        
        builder->SetInsertPoint(traverse_exit);
        Value* final_list = builder->CreateLoad(Type::getInt64Ty(*context), current_list);

        // CRITICAL FIX: Check if final_list is NULL (list was shorter than expected)
        // This can happen if the Jacobian row has fewer elements than the column index
        Value* final_list_is_null = builder->CreateICmpEQ(final_list,
            ConstantInt::get(Type::getInt64Ty(*context), 0));

        BasicBlock* extract_valid = BasicBlock::Create(*context, "jac_extract_valid", current_func);
        BasicBlock* extract_null = BasicBlock::Create(*context, "jac_extract_null", current_func);
        BasicBlock* extract_merge = BasicBlock::Create(*context, "jac_extract_merge", current_func);

        builder->CreateCondBr(final_list_is_null, extract_null, extract_valid);

        // NULL case: return 0.0 as a safe default
        builder->SetInsertPoint(extract_null);
        Value* zero_elem = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        builder->CreateBr(extract_merge);
        BasicBlock* null_exit = builder->GetInsertBlock();

        // Valid case: extract car from the cons cell
        builder->SetInsertPoint(extract_valid);
        Value* elem_tagged = extractCarAsTaggedValue(final_list);
        Value* elem_double = unpackDoubleFromTaggedValue(elem_tagged);
        builder->CreateBr(extract_merge);
        BasicBlock* valid_exit = builder->GetInsertBlock();

        // Merge: return extracted value or 0.0
        builder->SetInsertPoint(extract_merge);
        PHINode* result_phi = builder->CreatePHI(Type::getDoubleTy(*context), 2, "jac_elem_result");
        result_phi->addIncoming(zero_elem, null_exit);
        result_phi->addIncoming(elem_double, valid_exit);

        return result_phi;
    }
    
    // ===== END PHASE 3 OPERATORS =====
    // ===== PHASE 4: VECTOR CALCULUS OPERATORS =====
    // Differential geometry operators for physics simulations and field theory
    
    // Divergence: ∇·F for vector field F: ℝⁿ → ℝⁿ
    // Returns scalar: ∇·F = ∂F₁/∂x₁ + ∂F₂/∂x₂ + ... + ∂Fₙ/∂xₙ
    // This is the trace of the Jacobian matrix
    Value* codegenDivergence(const eshkol_operations_t* op) {
        if (!op->divergence_op.function || !op->divergence_op.point) {
            eshkol_error("Invalid divergence operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing divergence of vector field");
        
        // The divergence is the sum of diagonal elements of the Jacobian
        // For F: ℝⁿ → ℝⁿ, Jacobian is n×n, divergence is trace(J)
        
        // Compute Jacobian matrix first
        eshkol_operations_t jacobian_temp;
        jacobian_temp.op = ESHKOL_JACOBIAN_OP;
        jacobian_temp.jacobian_op.function = op->divergence_op.function;
        jacobian_temp.jacobian_op.point = op->divergence_op.point;
        
        Value* jacobian_tagged = codegenJacobian(&jacobian_temp);
        if (!jacobian_tagged) {
            eshkol_error("Failed to compute Jacobian for divergence");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Jacobian is a valid tensor (same fix as Jacobian operator)
        Value* jacobian_type = getTaggedValueType(jacobian_tagged);
        Value* jacobian_base_type = builder->CreateAnd(jacobian_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        Value* jac_is_tensor_ptr = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* jac_is_ad_tensor = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* jac_is_valid = builder->CreateOr(jac_is_tensor_ptr, jac_is_ad_tensor);
        
        Function* div_current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* jacobian_valid = BasicBlock::Create(*context, "div_jac_valid", div_current_func);
        BasicBlock* jacobian_invalid = BasicBlock::Create(*context, "div_jac_invalid", div_current_func);
        BasicBlock* div_final = BasicBlock::Create(*context, "div_final", div_current_func);
        
        builder->CreateCondBr(jac_is_valid, jacobian_valid, jacobian_invalid);
        
        // Invalid jacobian: return 0.0 instead of crashing (only for genuinely invalid types)
        builder->SetInsertPoint(jacobian_invalid);
        eshkol_debug("Divergence: Jacobian returned non-tensor type, returning 0.0");
        Value* zero_result = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        builder->CreateBr(div_final);
        
        // Valid jacobian: continue with normal computation
        builder->SetInsertPoint(jacobian_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* jacobian_ptr_int = safeExtractInt64(jacobian_tagged);
        Value* jacobian_ptr = builder->CreateIntToPtr(jacobian_ptr_int, builder->getPtrTy());
        
        // Extract dimension n from Jacobian (it's n×n)
        Value* dims_field = builder->CreateStructGEP(tensor_type, jacobian_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), n_ptr);
        
        // Get Jacobian elements
        Value* elements_field = builder->CreateStructGEP(tensor_type, jacobian_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Sum diagonal elements: J[0,0] + J[1,1] + ... + J[n-1,n-1]
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* sum_loop_cond = BasicBlock::Create(*context, "div_sum_cond", current_func);
        BasicBlock* sum_loop_body = BasicBlock::Create(*context, "div_sum_body", current_func);
        BasicBlock* sum_loop_exit = BasicBlock::Create(*context, "div_sum_exit", current_func);
        
        Value* sum_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "sum_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), sum_idx);
        
        Value* divergence_acc = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "div_acc");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), divergence_acc);
        
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), sum_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, sum_loop_body, sum_loop_exit);
        
        builder->SetInsertPoint(sum_loop_body);
        
        // Extract J[i,i] from nested list structure (not direct double access!)
        Value* diagonal_elem = extractJacobianElement(jacobian_ptr, i, i, n);
        
        // Add to accumulator
        Value* current_div = builder->CreateLoad(Type::getDoubleTy(*context), divergence_acc);
        Value* new_div = builder->CreateFAdd(current_div, diagonal_elem);
        builder->CreateStore(new_div, divergence_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, sum_idx);
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_exit);
        Value* divergence_result = builder->CreateLoad(Type::getDoubleTy(*context), divergence_acc);
        builder->CreateBr(div_final);
        
        // Merge valid and invalid paths
        builder->SetInsertPoint(div_final);
        PHINode* result_phi = builder->CreatePHI(Type::getDoubleTy(*context), 2, "div_result");
        result_phi->addIncoming(zero_result, jacobian_invalid);
        result_phi->addIncoming(divergence_result, sum_loop_exit);
        
        eshkol_info("Divergence computation complete");
        return result_phi;
    }
    
    // Curl: ∇×F for vector field F: ℝ³ → ℝ³
    // Returns vector: (∇×F) = [∂F₃/∂x₂ - ∂F₂/∂x₃, ∂F₁/∂x₃ - ∂F₃/∂x₁, ∂F₂/∂x₁ - ∂F₁/∂x₂]
    // ONLY defined for 3D vector fields
    Value* codegenCurl(const eshkol_operations_t* op) {
        if (!op->curl_op.function || !op->curl_op.point) {
            eshkol_error("Invalid curl operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing curl of 3D vector field");
        
        // First, validate that input is 3D
        Value* vector_val = codegenAST(op->curl_op.point);
        if (!vector_val) {
            eshkol_error("Failed to evaluate curl point");
            return nullptr;
        }
        
        // CRITICAL FIX: Handle both tensor and Scheme vector inputs
        Value* curl_input_type = getTaggedValueType(vector_val);
        Value* curl_input_base_type = builder->CreateAnd(curl_input_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* curl_is_scheme_vector = builder->CreateICmpEQ(curl_input_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* curl_scheme_input = BasicBlock::Create(*context, "curl_scheme_input", current_func);
        BasicBlock* curl_tensor_input = BasicBlock::Create(*context, "curl_tensor_input", current_func);
        BasicBlock* curl_merge_n = BasicBlock::Create(*context, "curl_merge_n", current_func);

        builder->CreateCondBr(curl_is_scheme_vector, curl_scheme_input, curl_tensor_input);

        // SCHEME VECTOR: Extract dimension from vector length
        builder->SetInsertPoint(curl_scheme_input);
        Value* curl_svec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* curl_svec_ptr = builder->CreateIntToPtr(curl_svec_ptr_int, builder->getPtrTy());
        Value* curl_svec_len_ptr = builder->CreateBitCast(curl_svec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* curl_svec_n = builder->CreateLoad(Type::getInt64Ty(*context), curl_svec_len_ptr);
        builder->CreateBr(curl_merge_n);
        BasicBlock* curl_scheme_exit = builder->GetInsertBlock();

        // TENSOR: Extract dimension from tensor structure
        builder->SetInsertPoint(curl_tensor_input);
        Value* curl_tensor_ptr_int = safeExtractInt64(vector_val);
        Value* curl_tensor_ptr = builder->CreateIntToPtr(curl_tensor_ptr_int, builder->getPtrTy());
        Value* dims_field = builder->CreateStructGEP(tensor_type, curl_tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        Value* n_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* curl_tensor_n = builder->CreateLoad(Type::getInt64Ty(*context), n_ptr);
        builder->CreateBr(curl_merge_n);
        BasicBlock* curl_tensor_exit = builder->GetInsertBlock();

        // MERGE: Get n from whichever path
        builder->SetInsertPoint(curl_merge_n);
        PHINode* n = builder->CreatePHI(Type::getInt64Ty(*context), 2, "curl_n");
        n->addIncoming(curl_svec_n, curl_scheme_exit);
        n->addIncoming(curl_tensor_n, curl_tensor_exit);

        // ENHANCED VALIDATION: Accept n>=2 for general differential 2-forms
        // Classic curl is 3D, but generalized exterior derivative works in any dimension >= 2
        Value* n_ge_2 = builder->CreateICmpUGE(n, ConstantInt::get(Type::getInt64Ty(*context), 2));

        BasicBlock* dim_valid = BasicBlock::Create(*context, "curl_dim_valid", current_func);
        BasicBlock* dim_invalid = BasicBlock::Create(*context, "curl_dim_invalid", current_func);
        BasicBlock* curl_done = BasicBlock::Create(*context, "curl_done", current_func);
        
        builder->CreateCondBr(n_ge_2, dim_valid, dim_invalid);
        
        // Invalid dimension: return null vector for dim < 2
        builder->SetInsertPoint(dim_invalid);
        eshkol_debug("Curl: dimension < 2, differential forms require at least 2D");
        Value* null_result_int = createNullVectorTensor(n);  // Use actual dimension, not hardcoded 3
        Value* null_result = packPtrToTaggedValue(null_result_int, ESHKOL_VALUE_TENSOR_PTR);
        BasicBlock* dim_invalid_exit = builder->GetInsertBlock();
        builder->CreateBr(curl_done);
        
        // Valid dimension: compute curl (differential 2-form)
        // NOTE: For n!=3, this computes the generalized exterior derivative
        builder->SetInsertPoint(dim_valid);
        
        // Compute Jacobian matrix (3×3)
        eshkol_operations_t jacobian_temp;
        jacobian_temp.op = ESHKOL_JACOBIAN_OP;
        jacobian_temp.jacobian_op.function = op->curl_op.function;
        jacobian_temp.jacobian_op.point = op->curl_op.point;
        
        Value* jacobian_tagged = codegenJacobian(&jacobian_temp);
        if (!jacobian_tagged) {
            eshkol_error("Failed to compute Jacobian for curl");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Jacobian is a valid tensor (same fix as Jacobian operator)
        Value* jacobian_type = getTaggedValueType(jacobian_tagged);
        Value* jacobian_base_type = builder->CreateAnd(jacobian_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        Value* jac_is_tensor_ptr = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* jac_is_ad_tensor = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* jac_is_valid = builder->CreateOr(jac_is_tensor_ptr, jac_is_ad_tensor);
        
        BasicBlock* jac_valid = BasicBlock::Create(*context, "curl_jac_valid", current_func);
        BasicBlock* jac_invalid = BasicBlock::Create(*context, "curl_jac_invalid", current_func);
        
        // If IS valid tensor type, proceed; if NOT, error path
        builder->CreateCondBr(jac_is_valid, jac_valid, jac_invalid);
        
        // Invalid jacobian: return null 3D vector (only for genuinely invalid types)
        builder->SetInsertPoint(jac_invalid);
        eshkol_debug("Curl: Jacobian returned non-tensor type, returning null vector");
        Value* null_curl_int = createNullVectorTensor(
            ConstantInt::get(Type::getInt64Ty(*context), 3)
        );
        // Tag as TENSOR_PTR for proper display
        Value* null_curl = packPtrToTaggedValue(null_curl_int, ESHKOL_VALUE_TENSOR_PTR);
        BasicBlock* jac_invalid_exit = builder->GetInsertBlock(); // Capture actual exit block!
        builder->CreateBr(curl_done);
        
        // Valid jacobian: continue with normal computation
        builder->SetInsertPoint(jac_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* jacobian_ptr_int = safeExtractInt64(jacobian_tagged);
        Value* jacobian_ptr = builder->CreateIntToPtr(jacobian_ptr_int, builder->getPtrTy());
        Value* n_const = ConstantInt::get(Type::getInt64Ty(*context), 3);
        
        // Extract specific partial derivatives from Jacobian's nested list structure
        // J[i,j] = ∂Fᵢ/∂xⱼ (row i, column j)
        // Jacobian elements are LIST POINTERS (rows), not doubles!
        
        // curl_x = ∂F₃/∂y - ∂F₂/∂z = J[2,1] - J[1,2]
        Value* dF3_dx2 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 2),  // row 2
            ConstantInt::get(Type::getInt64Ty(*context), 1),  // col 1
            n_const);
        Value* dF2_dx3 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 1),  // row 1
            ConstantInt::get(Type::getInt64Ty(*context), 2),  // col 2
            n_const);
        Value* curl_x = builder->CreateFSub(dF3_dx2, dF2_dx3);
        
        // curl_y = ∂F₁/∂z - ∂F₃/∂x = J[0,2] - J[2,0]
        Value* dF1_dx3 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0),  // row 0
            ConstantInt::get(Type::getInt64Ty(*context), 2),  // col 2
            n_const);
        Value* dF3_dx1 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 2),  // row 2
            ConstantInt::get(Type::getInt64Ty(*context), 0),  // col 0
            n_const);
        Value* curl_y = builder->CreateFSub(dF1_dx3, dF3_dx1);
        
        // curl_z = ∂F₂/∂x - ∂F₁/∂y = J[1,0] - J[0,1]
        Value* dF2_dx1 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 1),  // row 1
            ConstantInt::get(Type::getInt64Ty(*context), 0),  // col 0
            n_const);
        Value* dF1_dx2 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0),  // row 0
            ConstantInt::get(Type::getInt64Ty(*context), 1),  // col 1
            n_const);
        Value* curl_z = builder->CreateFSub(dF2_dx1, dF1_dx2);
        
        // Create result 3D vector
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for curl result");
            return nullptr;
        }
        
        // Allocate result tensor (3D vector)
        Value* result_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_ptr = builder->CreatePointerCast(result_ptr, builder->getPtrTy());
        
        // Set dimensions [3]
        Value* result_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 3), typed_result_dims);
        
        Value* result_dims_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 0);
        builder->CreateStore(typed_result_dims, result_dims_field);
        
        Value* result_num_dims_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 1);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1), result_num_dims_field);
        
        Value* result_total_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 3);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 3), result_total_field);
        
        // Allocate and fill elements [curl_x, curl_y, curl_z]
        Value* result_elems_size = ConstantInt::get(Type::getInt64Ty(*context), 3 * sizeof(double));
        Value* result_elems_ptr = builder->CreateCall(malloc_func, {result_elems_size});
        Value* typed_result_elems = builder->CreatePointerCast(result_elems_ptr, builder->getPtrTy());
        
        Value* result_elems_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 2);
        builder->CreateStore(typed_result_elems, result_elems_field);
        
        // Store curl components
        Value* elem0_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_result_elems,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateStore(curl_x, elem0_ptr);
        
        Value* elem1_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_result_elems,
            ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(curl_y, elem1_ptr);
        
        Value* elem2_ptr = builder->CreateGEP(Type::getDoubleTy(*context), typed_result_elems,
            ConstantInt::get(Type::getInt64Ty(*context), 2));
        builder->CreateStore(curl_z, elem2_ptr);
        
        eshkol_info("Curl computation complete, returning 3D vector");
        Value* curl_result_int = builder->CreatePtrToInt(typed_result_ptr, Type::getInt64Ty(*context));
        // Tag as TENSOR_PTR for proper display and type consistency
        Value* curl_result = packPtrToTaggedValue(curl_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(curl_done);
        BasicBlock* dim_valid_exit = builder->GetInsertBlock(); // Capture actual predecessor!
        
        // Merge all paths with tagged_value results (type-consistent!)
        builder->SetInsertPoint(curl_done);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 3, "curl_result");
        result_phi->addIncoming(null_result, dim_invalid_exit);   // Already tagged
        result_phi->addIncoming(null_curl, jac_invalid_exit);     // Already tagged
        result_phi->addIncoming(curl_result, dim_valid_exit);
        
        return result_phi;
    }
    
    // Laplacian: ∇²f for scalar field f: ℝⁿ → ℝ
    // Returns scalar: ∇²f = ∂²f/∂x₁² + ∂²f/∂x₂² + ... + ∂²f/∂xₙ²
    // This is the trace of the Hessian matrix
    Value* codegenLaplacian(const eshkol_operations_t* op) {
        if (!op->laplacian_op.function || !op->laplacian_op.point) {
            eshkol_error("Invalid laplacian operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing Laplacian of scalar field");
        
        // The Laplacian is the sum of diagonal elements of the Hessian
        // For f: ℝⁿ → ℝ, Hessian is n×n, Laplacian is trace(H)
        
        // Compute Hessian matrix first
        eshkol_operations_t hessian_temp;
        hessian_temp.op = ESHKOL_HESSIAN_OP;
        hessian_temp.hessian_op.function = op->laplacian_op.function;
        hessian_temp.hessian_op.point = op->laplacian_op.point;
        
        Value* hessian_tagged = codegenHessian(&hessian_temp);
        if (!hessian_tagged) {
            eshkol_error("Failed to compute Hessian for Laplacian");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Hessian is a valid tensor (same fix as Jacobian operator)
        Value* hessian_type = getTaggedValueType(hessian_tagged);
        Value* hessian_base_type = builder->CreateAnd(hessian_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        
        Value* hess_is_tensor_ptr = builder->CreateICmpEQ(hessian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_TENSOR_PTR));
        Value* hess_is_ad_tensor = builder->CreateICmpEQ(hessian_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_AD_NODE_PTR));
        Value* hess_is_valid = builder->CreateOr(hess_is_tensor_ptr, hess_is_ad_tensor);
        
        Function* lap_current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* hessian_valid = BasicBlock::Create(*context, "lap_hess_valid", lap_current_func);
        BasicBlock* hessian_invalid = BasicBlock::Create(*context, "lap_hess_invalid", lap_current_func);
        BasicBlock* lap_final = BasicBlock::Create(*context, "lap_final", lap_current_func);
        
        builder->CreateCondBr(hess_is_valid, hessian_valid, hessian_invalid);
        
        // Invalid hessian: return 0.0 instead of crashing (only for genuinely invalid types)
        builder->SetInsertPoint(hessian_invalid);
        eshkol_debug("Laplacian: Hessian returned non-tensor type, returning 0.0");
        Value* zero_lap_result = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
        builder->CreateBr(lap_final);
        
        // Valid hessian: continue with normal computation
        builder->SetInsertPoint(hessian_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* hessian_ptr_int = safeExtractInt64(hessian_tagged);
        Value* hessian_ptr = builder->CreateIntToPtr(hessian_ptr_int, builder->getPtrTy());
        
        // Extract dimension n from Hessian (it's n×n)
        Value* dims_field = builder->CreateStructGEP(tensor_type, hessian_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), n_ptr);
        
        // Get Hessian elements
        Value* elements_field = builder->CreateStructGEP(tensor_type, hessian_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Sum diagonal elements: H[0,0] + H[1,1] + ... + H[n-1,n-1]
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* sum_loop_cond = BasicBlock::Create(*context, "lap_sum_cond", current_func);
        BasicBlock* sum_loop_body = BasicBlock::Create(*context, "lap_sum_body", current_func);
        BasicBlock* sum_loop_exit = BasicBlock::Create(*context, "lap_sum_exit", current_func);
        
        Value* sum_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "sum_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), sum_idx);
        
        Value* laplacian_acc = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "lap_acc");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), laplacian_acc);
        
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), sum_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, sum_loop_body, sum_loop_exit);
        
        builder->SetInsertPoint(sum_loop_body);
        
        // Calculate diagonal index: i*n + i
        Value* linear_idx = builder->CreateMul(i, n);
        linear_idx = builder->CreateAdd(linear_idx, i);
        
        // Load H[i,i]
        Value* elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context),
            typed_elements_ptr, linear_idx);
        Value* diagonal_elem = builder->CreateLoad(Type::getDoubleTy(*context), elem_ptr);
        
        // Add to accumulator
        Value* current_lap = builder->CreateLoad(Type::getDoubleTy(*context), laplacian_acc);
        Value* new_lap = builder->CreateFAdd(current_lap, diagonal_elem);
        builder->CreateStore(new_lap, laplacian_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, sum_idx);
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_exit);
        Value* laplacian_result = builder->CreateLoad(Type::getDoubleTy(*context), laplacian_acc);
        builder->CreateBr(lap_final);
        
        // Merge valid and invalid paths
        builder->SetInsertPoint(lap_final);
        PHINode* lap_result_phi = builder->CreatePHI(Type::getDoubleTy(*context), 2, "lap_result");
        lap_result_phi->addIncoming(zero_lap_result, hessian_invalid);
        lap_result_phi->addIncoming(laplacian_result, sum_loop_exit);
        
        eshkol_info("Laplacian computation complete");
        return lap_result_phi;
    }
    
    // Directional Derivative: D_v f = ∇f · v
    // Computes the derivative of scalar field f in direction v
    Value* codegenDirectionalDerivative(const eshkol_operations_t* op) {
        if (!op->directional_deriv_op.function || !op->directional_deriv_op.point ||
            !op->directional_deriv_op.direction) {
            eshkol_error("Invalid directional-derivative operation - missing function, point, or direction");
            return nullptr;
        }
        
        eshkol_info("Computing directional derivative");
        
        // Step 1: Compute gradient ∇f
        eshkol_operations_t gradient_temp;
        gradient_temp.op = ESHKOL_GRADIENT_OP;
        gradient_temp.gradient_op.function = op->directional_deriv_op.function;
        gradient_temp.gradient_op.point = op->directional_deriv_op.point;
        
        Value* gradient_tagged = codegenGradient(&gradient_temp);
        if (!gradient_tagged) {
            eshkol_error("Failed to compute gradient for directional derivative");
            return nullptr;
        }
        
        // CRITICAL FIX: Unpack tensor pointer from tagged_value
        Value* gradient_ptr_int = safeExtractInt64(gradient_tagged);
        
        // Step 2: Get direction vector
        Value* direction_val = codegenAST(op->directional_deriv_op.direction);
        if (!direction_val) {
            eshkol_error("Failed to evaluate direction vector");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for directional derivative");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        Function* current_func = builder->GetInsertBlock()->getParent();

        Value* dir_type = getTaggedValueType(direction_val);
        Value* dir_base_type = builder->CreateAnd(dir_type,
            ConstantInt::get(Type::getInt8Ty(*context), 0x0F));

        Value* dir_is_scheme_vector = builder->CreateICmpEQ(dir_base_type,
            ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* dd_scheme_vector = BasicBlock::Create(*context, "dd_scheme_vector", current_func);
        BasicBlock* dd_tensor_input = BasicBlock::Create(*context, "dd_tensor_input", current_func);
        BasicBlock* dd_merge_input = BasicBlock::Create(*context, "dd_merge_input", current_func);

        builder->CreateCondBr(dir_is_scheme_vector, dd_scheme_vector, dd_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(dd_scheme_vector);

        Value* dd_scheme_vec_ptr_int = unpackInt64FromTaggedValue(direction_val);
        Value* dd_scheme_vec_ptr = builder->CreateIntToPtr(dd_scheme_vec_ptr_int, builder->getPtrTy());
        Value* dd_scheme_len_ptr = builder->CreateBitCast(dd_scheme_vec_ptr, PointerType::getUnqual(Type::getInt64Ty(*context)));
        Value* dd_scheme_len = builder->CreateLoad(Type::getInt64Ty(*context), dd_scheme_len_ptr);

        // Allocate tensor
        Value* dd_scheme_tensor_size = ConstantInt::get(Type::getInt64Ty(*context),
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* dd_scheme_tensor_ptr = builder->CreateCall(malloc_func, {dd_scheme_tensor_size});
        Value* dd_typed_scheme_tensor = builder->CreatePointerCast(dd_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* dd_scheme_dims_size = ConstantInt::get(Type::getInt64Ty(*context), sizeof(uint64_t));
        Value* dd_scheme_dims_ptr = builder->CreateCall(malloc_func, {dd_scheme_dims_size});
        Value* dd_typed_scheme_dims = builder->CreatePointerCast(dd_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(dd_scheme_len, dd_typed_scheme_dims);

        builder->CreateStore(dd_typed_scheme_dims, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 1),
            builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 1));
        builder->CreateStore(dd_scheme_len, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* dd_scheme_elems_size = builder->CreateMul(dd_scheme_len,
            ConstantInt::get(Type::getInt64Ty(*context), sizeof(double)));
        Value* dd_scheme_elems_ptr = builder->CreateCall(malloc_func, {dd_scheme_elems_size});
        Value* dd_typed_scheme_elems = builder->CreatePointerCast(dd_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(dd_typed_scheme_elems, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 2));

        // Copy elements loop (extract doubles from tagged values)
        Value* dd_scheme_elem_base = builder->CreateGEP(Type::getInt8Ty(*context), dd_scheme_vec_ptr,
            ConstantInt::get(Type::getInt64Ty(*context), 8));
        Value* dd_scheme_elem_base_typed = builder->CreateBitCast(dd_scheme_elem_base, PointerType::getUnqual(tagged_value_type));

        BasicBlock* dd_svec_copy_cond = BasicBlock::Create(*context, "dd_svec_copy_cond", current_func);
        BasicBlock* dd_svec_copy_body = BasicBlock::Create(*context, "dd_svec_copy_body", current_func);
        BasicBlock* dd_svec_copy_done = BasicBlock::Create(*context, "dd_svec_copy_done", current_func);

        Value* dd_svec_copy_i = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "dd_svec_copy_i");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), dd_svec_copy_i);
        builder->CreateBr(dd_svec_copy_cond);

        builder->SetInsertPoint(dd_svec_copy_cond);
        Value* dd_svec_i = builder->CreateLoad(Type::getInt64Ty(*context), dd_svec_copy_i);
        Value* dd_svec_cond = builder->CreateICmpULT(dd_svec_i, dd_scheme_len);
        builder->CreateCondBr(dd_svec_cond, dd_svec_copy_body, dd_svec_copy_done);

        builder->SetInsertPoint(dd_svec_copy_body);
        Value* dd_svec_src_ptr = builder->CreateGEP(tagged_value_type, dd_scheme_elem_base_typed, dd_svec_i);
        Value* dd_svec_tagged_elem = builder->CreateLoad(tagged_value_type, dd_svec_src_ptr);
        Value* dd_svec_double_val = unpackDoubleFromTaggedValue(dd_svec_tagged_elem);
        Value* dd_svec_dst_ptr = builder->CreateGEP(Type::getDoubleTy(*context), dd_typed_scheme_elems, dd_svec_i);
        builder->CreateStore(dd_svec_double_val, dd_svec_dst_ptr);
        Value* dd_svec_next_i = builder->CreateAdd(dd_svec_i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(dd_svec_next_i, dd_svec_copy_i);
        builder->CreateBr(dd_svec_copy_cond);

        builder->SetInsertPoint(dd_svec_copy_done);
        Value* dd_scheme_tensor_int = builder->CreatePtrToInt(dd_typed_scheme_tensor, Type::getInt64Ty(*context));
        builder->CreateBr(dd_merge_input);
        BasicBlock* dd_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(dd_tensor_input);
        Value* dd_tensor_ptr_int = safeExtractInt64(direction_val);
        builder->CreateBr(dd_merge_input);
        BasicBlock* dd_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(dd_merge_input);
        PHINode* direction_ptr_int = builder->CreatePHI(Type::getInt64Ty(*context), 2, "dd_dir_ptr");
        direction_ptr_int->addIncoming(dd_scheme_tensor_int, dd_scheme_exit);
        direction_ptr_int->addIncoming(dd_tensor_ptr_int, dd_tensor_exit);

        // Step 3: Compute dot product: ∇f · v
        // Use class member tensor_type (shared by all tensor operations)

        Value* gradient_ptr = builder->CreateIntToPtr(gradient_ptr_int, builder->getPtrTy());
        Value* direction_ptr = builder->CreateIntToPtr(direction_ptr_int, builder->getPtrTy());
        
        // Get gradient elements
        Value* grad_elements_field = builder->CreateStructGEP(tensor_type, gradient_ptr, 2);
        Value* grad_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), grad_elements_field);
        Value* typed_grad_elements = builder->CreatePointerCast(grad_elements_ptr, builder->getPtrTy());
        
        // Get direction elements
        Value* dir_elements_field = builder->CreateStructGEP(tensor_type, direction_ptr, 2);
        Value* dir_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dir_elements_field);
        Value* typed_dir_elements = builder->CreatePointerCast(dir_elements_ptr, builder->getPtrTy());
        
        // Get dimension n
        Value* grad_total_field = builder->CreateStructGEP(tensor_type, gradient_ptr, 3);
        Value* n = builder->CreateLoad(Type::getInt64Ty(*context), grad_total_field);
        
        // Compute dot product: sum(grad[i] * dir[i])
        // current_func already defined above
        BasicBlock* dot_loop_cond = BasicBlock::Create(*context, "dirderiv_dot_cond", current_func);
        BasicBlock* dot_loop_body = BasicBlock::Create(*context, "dirderiv_dot_body", current_func);
        BasicBlock* dot_loop_exit = BasicBlock::Create(*context, "dirderiv_dot_exit", current_func);
        
        Value* dot_idx = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "dot_idx");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), dot_idx);
        
        Value* dot_acc = builder->CreateAlloca(Type::getDoubleTy(*context), nullptr, "dot_acc");
        builder->CreateStore(ConstantFP::get(Type::getDoubleTy(*context), 0.0), dot_acc);
        
        builder->CreateBr(dot_loop_cond);
        
        builder->SetInsertPoint(dot_loop_cond);
        Value* i = builder->CreateLoad(Type::getInt64Ty(*context), dot_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, dot_loop_body, dot_loop_exit);
        
        builder->SetInsertPoint(dot_loop_body);
        
        // Load grad[i]
        Value* grad_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context),
            typed_grad_elements, i);
        Value* grad_elem = builder->CreateLoad(Type::getDoubleTy(*context), grad_elem_ptr);
        
        // Load dir[i]
        Value* dir_elem_ptr = builder->CreateGEP(Type::getDoubleTy(*context),
            typed_dir_elements, i);
        Value* dir_elem = builder->CreateLoad(Type::getDoubleTy(*context), dir_elem_ptr);
        
        // Multiply and accumulate
        Value* prod = builder->CreateFMul(grad_elem, dir_elem);
        Value* current_dot = builder->CreateLoad(Type::getDoubleTy(*context), dot_acc);
        Value* new_dot = builder->CreateFAdd(current_dot, prod);
        builder->CreateStore(new_dot, dot_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_i, dot_idx);
        builder->CreateBr(dot_loop_cond);
        
        builder->SetInsertPoint(dot_loop_exit);
        Value* result = builder->CreateLoad(Type::getDoubleTy(*context), dot_acc);
        
        eshkol_info("Directional derivative computation complete");
        return result;
    }
    
    // ===== END PHASE 4: VECTOR CALCULUS OPERATORS =====
    
    
    // Core symbolic differentiation function
    // Now works within lambda context - variable comes from lambda parameter
    Value* differentiate(const eshkol_ast_t* expr, const char* var) {
        if (!expr || !var) return nullptr;
        
        // Variable should already be in symbol table from lambda parameter
        // No need to create placeholder - we're building symbolic expressions!
        
        Value* result = nullptr;
        
        switch (expr->type) {
            case ESHKOL_INT64:
                // Derivative of integer constant is 0 (int64)
                result = ConstantInt::get(Type::getInt64Ty(*context), 0);
                break;
                
            case ESHKOL_DOUBLE:
                // Derivative of double constant is 0.0 (double)
                result = ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                break;
                
            case ESHKOL_VAR:
                // Derivative of variable
                if (expr->variable.id && strcmp(expr->variable.id, var) == 0) {
                    // d/dx(x) = 1
                    // Use int64 by default - type-aware ops will convert if needed
                    result = ConstantInt::get(Type::getInt64Ty(*context), 1);
                } else {
                    // d/dx(y) = 0 (where y != x)
                    // Use int64 by default - type-aware ops will convert if needed
                    result = ConstantInt::get(Type::getInt64Ty(*context), 0);
                }
                break;
                
            case ESHKOL_OP:
                result = differentiateOperation(&expr->operation, var);
                break;
                
            default:
                // Unsupported expression type - return 0
                result = ConstantInt::get(Type::getInt64Ty(*context), 0);
                break;
        }
        
        // No symbol table restoration needed - variable stays from lambda context
        return result;
    }
    
    // Differentiate operations (arithmetic, functions, etc.)
    Value* differentiateOperation(const eshkol_operations_t* op, const char* var) {
        if (!op) return ConstantInt::get(Type::getInt64Ty(*context), 0);
        
        if (op->op == ESHKOL_CALL_OP && op->call_op.func &&
            op->call_op.func->type == ESHKOL_VAR && op->call_op.func->variable.id) {
            
            std::string func_name = op->call_op.func->variable.id;
            
            // Construct reference AST for type detection (use first operand)
            const eshkol_ast_t* type_ref = (op->call_op.num_vars > 0) ?
                &op->call_op.variables[0] : nullptr;
            
            // Addition rule: d/dx(f + g) = f' + g'
            if (func_name == "+" && op->call_op.num_vars >= 2) {
                Value* result = differentiate(&op->call_op.variables[0], var);
                for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
                    Value* term_derivative = differentiate(&op->call_op.variables[i], var);
                    // Type-aware addition
                    result = createTypedAdd(result, term_derivative, &op->call_op.variables[0]);
                }
                return result;
            }
            
            // Subtraction rule: d/dx(f - g) = f' - g'
            else if (func_name == "-" && op->call_op.num_vars == 2) {
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                return createTypedSub(f_prime, g_prime, &op->call_op.variables[0]);
            }
            
            // Product rule: d/dx(f * g) = f' * g + f * g'
            // PHASE 0 FIX: Complete product rule implementation with type handling
            else if (func_name == "*" && op->call_op.num_vars == 2) {
                // Compute derivatives
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                
                // Generate f and g values
                Value* f = codegenAST(&op->call_op.variables[0]);
                Value* g = codegenAST(&op->call_op.variables[1]);
                
                // FIX 2a: Unpack tagged_value if needed (codegenAST now returns tagged_value)
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                if (g && g->getType() == tagged_value_type) g = safeExtractInt64(g);
                
                if (!f || !g || !f_prime || !g_prime) {
                    return ConstantInt::get(Type::getInt64Ty(*context), 0);
                }
                
                // General product rule: f' * g + f * g'
                // Handles all cases including x*x -> 1*x + x*1 = 2x
                Value* term1 = createTypedMul(f_prime, g, &op->call_op.variables[0]);
                Value* term2 = createTypedMul(f, g_prime, &op->call_op.variables[0]);
                return createTypedAdd(term1, term2, &op->call_op.variables[0]);
            }
            
            // Division rule: d/dx(f/g) = (f'g - fg')/g²
            // PHASE 0: NEW - Division rule implementation
            else if (func_name == "/" && op->call_op.num_vars == 2) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                Value* g = codegenAST(&op->call_op.variables[1]);
                
                // FIX 2b: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                if (g && g->getType() == tagged_value_type) g = safeExtractInt64(g);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                
                if (!f || !g || !f_prime || !g_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // (f'*g - f*g') / g²
                Value* f_prime_g = createTypedMul(f_prime, g, &op->call_op.variables[0]);
                Value* f_g_prime = createTypedMul(f, g_prime, &op->call_op.variables[0]);
                Value* numerator = createTypedSub(f_prime_g, f_g_prime, &op->call_op.variables[0]);
                Value* g_squared = createTypedMul(g, g, &op->call_op.variables[0]);
                
                // Division always returns double
                return createTypedDiv(numerator, g_squared, &op->call_op.variables[0]);
            }
            
            // Sin: d/dx(sin(f)) = cos(f) * f'
            // PHASE 0 FIX: Proper chain rule with cos(f) multiplication
            else if (func_name == "sin" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2c: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // Convert f to double for trig functions
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                }
                
                // cos(f) * f'
                Value* cos_f = builder->CreateCall(function_table["cos"], {f});
                return createTypedMul(cos_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Cos: d/dx(cos(f)) = -sin(f) * f'
            // PHASE 0 FIX: Proper chain rule with -sin(f) multiplication
            else if (func_name == "cos" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2d: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // Convert f to double for trig functions
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                }
                
                // -sin(f) * f'
                Value* sin_f = builder->CreateCall(function_table["sin"], {f});
                Value* neg_sin_f = builder->CreateFNeg(sin_f);
                return createTypedMul(neg_sin_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Exponential: d/dx(exp(f)) = exp(f) * f'
            // PHASE 0: NEW - Exponential rule
            else if (func_name == "exp" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2e: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // Convert f to double for exp
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                }
                
                // Declare exp function if not already declared
                if (function_table.find("exp") == function_table.end()) {
                    std::vector<Type*> exp_args = {Type::getDoubleTy(*context)};
                    FunctionType* exp_type = FunctionType::get(
                        Type::getDoubleTy(*context), exp_args, false);
                    Function* exp_func = Function::Create(
                        exp_type, Function::ExternalLinkage, "exp", module.get());
                    function_table["exp"] = exp_func;
                }
                
                // exp(f) * f'
                Value* exp_f = builder->CreateCall(function_table["exp"], {f});
                return createTypedMul(exp_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Natural log: d/dx(log(f)) = f' / f
            // PHASE 0: NEW - Logarithm rule
            else if (func_name == "log" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2f: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // Convert f to double for log
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                }
                
                // Declare log function if not already declared
                if (function_table.find("log") == function_table.end()) {
                    std::vector<Type*> log_args = {Type::getDoubleTy(*context)};
                    FunctionType* log_type = FunctionType::get(
                        Type::getDoubleTy(*context), log_args, false);
                    Function* log_func = Function::Create(
                        log_type, Function::ExternalLinkage, "log", module.get());
                    function_table["log"] = log_func;
                }
                
                // f' / f (division always returns double)
                return createTypedDiv(f_prime, f, &op->call_op.variables[0]);
            }
            
            // Power rule: d/dx(f^n) = n * f^(n-1) * f' (for constant exponent)
            // PHASE 0: NEW - Power rule (constant exponent only)
            else if (func_name == "pow" && op->call_op.num_vars == 2) {
                // Check if exponent is constant
                if (op->call_op.variables[1].type == ESHKOL_INT64 ||
                    op->call_op.variables[1].type == ESHKOL_DOUBLE) {
                    
                    Value* f = codegenAST(&op->call_op.variables[0]);
                    Value* n = codegenAST(&op->call_op.variables[1]);
                    
                    // FIX 2g: Unpack tagged_value if needed
                    if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                    if (n && n->getType() == tagged_value_type) n = safeExtractInt64(n);
                    
                    Value* f_prime = differentiate(&op->call_op.variables[0], var);
                    
                    if (!f || !n || !f_prime) {
                        return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                    }
                    
                    // Convert to double for pow
                    if (f->getType()->isIntegerTy()) {
                        f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                    }
                    if (n->getType()->isIntegerTy()) {
                        n = builder->CreateSIToFP(n, Type::getDoubleTy(*context));
                    }
                    
                    // n * f^(n-1) * f'
                    Value* one = ConstantFP::get(Type::getDoubleTy(*context), 1.0);
                    Value* n_minus_1 = builder->CreateFSub(n, one);
                    Value* f_power = builder->CreateCall(function_table["pow"], {f, n_minus_1});
                    Value* n_times_power = builder->CreateFMul(n, f_power);
                    
                    // Result is always double for pow
                    if (f_prime->getType()->isIntegerTy()) {
                        f_prime = builder->CreateSIToFP(f_prime, Type::getDoubleTy(*context));
                    }
                    return builder->CreateFMul(n_times_power, f_prime);
                }
                // For non-constant exponent, return 0 for now (will implement in Phase 2)
                else {
                    eshkol_warn("Power rule with non-constant exponent not yet implemented");
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
            }
            
            // Square root: d/dx(sqrt(f)) = f' / (2*sqrt(f))
            // PHASE 0: BONUS - Sqrt rule
            else if (func_name == "sqrt" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2h: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(Type::getDoubleTy(*context), 0.0);
                }
                
                // Convert to double for sqrt
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, Type::getDoubleTy(*context));
                }
                
                // f' / (2*sqrt(f))
                Value* sqrt_f = builder->CreateCall(function_table["sqrt"], {f});
                Value* two = ConstantFP::get(Type::getDoubleTy(*context), 2.0);
                Value* two_sqrt_f = builder->CreateFMul(two, sqrt_f);
                
                if (f_prime->getType()->isIntegerTy()) {
                    f_prime = builder->CreateSIToFP(f_prime, Type::getDoubleTy(*context));
                }
                return builder->CreateFDiv(f_prime, two_sqrt_f);
            }
        }
        
        // Unknown operation - return 0
        return ConstantInt::get(Type::getInt64Ty(*context), 0);
    }
    
    Value* codegenVectorToString(const eshkol_operations_t* op) {
        // vector-to-string: (vector-to-string vector)
        // Converts a vector to a string representation like "[1, 2, 3]"
        if (op->call_op.num_vars != 1) {
            eshkol_error("vector-to-string requires exactly 1 argument: vector");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        if (!tensor_var_ptr) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get tensor properties
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* total_elements = builder->CreateLoad(Type::getInt64Ty(*context), total_elements_field_ptr);
        
        // Check if it's actually a vector (1D tensor)
        Value* is_vector = builder->CreateICmpEQ(num_dims, ConstantInt::get(Type::getInt64Ty(*context), 1));
        
        // For simplicity, allocate a fixed-size buffer for the string
        // In a full implementation, this would calculate the needed size
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        // Allocate buffer for result string (assuming max 1024 chars)
        Value* buffer_size = ConstantInt::get(Type::getInt64Ty(*context), 1024);
        Value* string_buffer = builder->CreateCall(malloc_func, {buffer_size});
        Value* typed_string_buffer = builder->CreatePointerCast(string_buffer, builder->getPtrTy());
        
        // Start with opening bracket "["
        Value* bracket_str = codegenString("[");
        Function* strcpy_func = function_table["strcpy"];
        if (!strcpy_func) {
            // Create strcpy declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcpy_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcpy_func = Function::Create(strcpy_type, Function::ExternalLinkage, "strcpy", module.get());
            function_table["strcpy"] = strcpy_func;
        }
        Function* strcat_func = function_table["strcat"];
        if (!strcat_func) {
            // Create strcat declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcat_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcat_func = Function::Create(strcat_type, Function::ExternalLinkage, "strcat", module.get());
            function_table["strcat"] = strcat_func;
        }
        Function* sprintf_func = function_table["sprintf"];
        if (!sprintf_func) {
            // Create sprintf declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            Type* int_type = Type::getInt32Ty(*context);
            FunctionType* sprintf_type = FunctionType::get(int_type, {char_ptr_type, char_ptr_type}, true);
            sprintf_func = Function::Create(sprintf_type, Function::ExternalLinkage, "sprintf", module.get());
            function_table["sprintf"] = sprintf_func;
        }
        
        // Copy opening bracket to buffer
        builder->CreateCall(strcpy_func, {typed_string_buffer, bracket_str});
        
        // Create loop to add each element
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "vec_str_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "vec_str_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "vec_str_loop_exit", current_func);
        
        // Initialize loop counter
        Value* loop_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "vec_str_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), loop_counter);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < total_elements
        builder->SetInsertPoint(loop_condition);
        Value* current_index = builder->CreateLoad(Type::getInt64Ty(*context), loop_counter);
        Value* loop_cmp = builder->CreateICmpULT(current_index, total_elements);
        builder->CreateCondBr(loop_cmp, loop_body, loop_exit);
        
        // Loop body: append current element to string
        builder->SetInsertPoint(loop_body);
        
        // Load current element
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, current_index);
        Value* current_elem = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
        
        // Check if this is not the first element (add comma and space)
        Value* is_first = builder->CreateICmpEQ(current_index, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* add_comma = BasicBlock::Create(*context, "add_comma", current_func);
        BasicBlock* skip_comma = BasicBlock::Create(*context, "skip_comma", current_func);
        BasicBlock* add_number = BasicBlock::Create(*context, "add_number", current_func);
        
        builder->CreateCondBr(is_first, skip_comma, add_comma);
        
        // Add comma and space for non-first elements
        builder->SetInsertPoint(add_comma);
        Value* comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, comma_str});
        builder->CreateBr(add_number);
        
        // Skip comma for first element
        builder->SetInsertPoint(skip_comma);
        builder->CreateBr(add_number);
        
        // Add the number
        builder->SetInsertPoint(add_number);
        
        // Create a small buffer for the number string
        Value* num_buffer_size = ConstantInt::get(Type::getInt64Ty(*context), 32);
        Value* num_buffer = builder->CreateCall(malloc_func, {num_buffer_size});
        Value* typed_num_buffer = builder->CreatePointerCast(num_buffer, builder->getPtrTy());
        
        // Format number as string using sprintf
        Value* format_str = codegenString("%ld");
        builder->CreateCall(sprintf_func, {typed_num_buffer, format_str, current_elem});
        
        // Concatenate number to result string
        builder->CreateCall(strcat_func, {typed_string_buffer, typed_num_buffer});
        
        // Increment loop counter
        Value* next_index = builder->CreateAdd(current_index, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_index, loop_counter);
        
        // Jump back to condition check
        builder->CreateBr(loop_condition);
        
        // Loop exit: add closing bracket
        builder->SetInsertPoint(loop_exit);
        Value* close_bracket_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, close_bracket_str});
        
        // Return string buffer as int64 (pointer)
        return builder->CreatePtrToInt(typed_string_buffer, Type::getInt64Ty(*context));
    }
    
    Value* codegenMatrixToString(const eshkol_operations_t* op) {
        // matrix-to-string: (matrix-to-string matrix)
        // Converts a matrix to a string representation like "[[1, 2], [3, 4]]"
        if (op->call_op.num_vars != 1) {
            eshkol_error("matrix-to-string requires exactly 1 argument: matrix");
            return nullptr;
        }
        
        Value* tensor_var_ptr = codegenAST(&op->call_op.variables[0]);
        if (!tensor_var_ptr) return nullptr;
        
        // Load the tensor pointer value from the variable
        Value* tensor_ptr_int = builder->CreateLoad(Type::getInt64Ty(*context), tensor_var_ptr);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get tensor properties
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(Type::getInt64Ty(*context), num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Get dimensions (assuming 2D matrix)
        Value* rows_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                            ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* rows = builder->CreateLoad(Type::getInt64Ty(*context), rows_ptr);
        
        Value* cols_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_dims_ptr, 
                                            ConstantInt::get(Type::getInt64Ty(*context), 1));
        Value* cols = builder->CreateLoad(Type::getInt64Ty(*context), cols_ptr);
        
        // Allocate buffer for result string (assuming max 2048 chars)
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* buffer_size = ConstantInt::get(Type::getInt64Ty(*context), 2048);
        Value* string_buffer = builder->CreateCall(malloc_func, {buffer_size});
        Value* typed_string_buffer = builder->CreatePointerCast(string_buffer, builder->getPtrTy());
        
        // Get string functions - create declarations if they don't exist
        Function* strcpy_func = function_table["strcpy"];
        if (!strcpy_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcpy_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcpy_func = Function::Create(strcpy_type, Function::ExternalLinkage, "strcpy", module.get());
            function_table["strcpy"] = strcpy_func;
        }
        
        Function* strcat_func = function_table["strcat"];
        if (!strcat_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcat_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcat_func = Function::Create(strcat_type, Function::ExternalLinkage, "strcat", module.get());
            function_table["strcat"] = strcat_func;
        }
        
        Function* sprintf_func = function_table["sprintf"];
        if (!sprintf_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            Type* int_type = Type::getInt32Ty(*context);
            FunctionType* sprintf_type = FunctionType::get(int_type, {char_ptr_type, char_ptr_type}, true);
            sprintf_func = Function::Create(sprintf_type, Function::ExternalLinkage, "sprintf", module.get());
            function_table["sprintf"] = sprintf_func;
        }
        
        // Start with opening bracket "["
        Value* open_bracket_str = codegenString("[");
        builder->CreateCall(strcpy_func, {typed_string_buffer, open_bracket_str});
        
        // Create nested loops for rows and columns
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* outer_loop_cond = BasicBlock::Create(*context, "matrix_outer_cond", current_func);
        BasicBlock* outer_loop_body = BasicBlock::Create(*context, "matrix_outer_body", current_func);
        BasicBlock* inner_loop_cond = BasicBlock::Create(*context, "matrix_inner_cond", current_func);
        BasicBlock* inner_loop_body = BasicBlock::Create(*context, "matrix_inner_body", current_func);
        BasicBlock* inner_loop_exit = BasicBlock::Create(*context, "matrix_inner_exit", current_func);
        BasicBlock* outer_loop_exit = BasicBlock::Create(*context, "matrix_outer_exit", current_func);
        
        // Initialize row counter
        Value* row_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "row_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), row_counter);
        
        // Jump to outer loop condition
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop condition: check if row < rows
        builder->SetInsertPoint(outer_loop_cond);
        Value* current_row = builder->CreateLoad(Type::getInt64Ty(*context), row_counter);
        Value* outer_cmp = builder->CreateICmpULT(current_row, rows);
        builder->CreateCondBr(outer_cmp, outer_loop_body, outer_loop_exit);
        
        // Outer loop body: process each row
        builder->SetInsertPoint(outer_loop_body);
        
        // Add comma for non-first rows
        Value* is_first_row = builder->CreateICmpEQ(current_row, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* add_row_comma = BasicBlock::Create(*context, "add_row_comma", current_func);
        BasicBlock* skip_row_comma = BasicBlock::Create(*context, "skip_row_comma", current_func);
        
        builder->CreateCondBr(is_first_row, skip_row_comma, add_row_comma);
        
        builder->SetInsertPoint(add_row_comma);
        Value* row_comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_comma_str});
        builder->CreateBr(skip_row_comma);
        
        builder->SetInsertPoint(skip_row_comma);
        
        // Add opening bracket for row
        Value* row_open_str = codegenString("[");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_open_str});
        
        // Initialize column counter
        Value* col_counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "col_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), col_counter);
        
        // Jump to inner loop
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop condition: check if col < cols
        builder->SetInsertPoint(inner_loop_cond);
        Value* current_col = builder->CreateLoad(Type::getInt64Ty(*context), col_counter);
        Value* inner_cmp = builder->CreateICmpULT(current_col, cols);
        builder->CreateCondBr(inner_cmp, inner_loop_body, inner_loop_exit);
        
        // Inner loop body: process each element
        builder->SetInsertPoint(inner_loop_body);
        
        // Add comma for non-first columns
        Value* is_first_col = builder->CreateICmpEQ(current_col, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* add_col_comma = BasicBlock::Create(*context, "add_col_comma", current_func);
        BasicBlock* skip_col_comma = BasicBlock::Create(*context, "skip_col_comma", current_func);
        BasicBlock* add_element = BasicBlock::Create(*context, "add_element", current_func);
        
        builder->CreateCondBr(is_first_col, skip_col_comma, add_col_comma);
        
        builder->SetInsertPoint(add_col_comma);
        Value* col_comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, col_comma_str});
        builder->CreateBr(add_element);
        
        builder->SetInsertPoint(skip_col_comma);
        builder->CreateBr(add_element);
        
        builder->SetInsertPoint(add_element);
        
        // Calculate linear index: row * cols + col
        Value* linear_index = builder->CreateMul(current_row, cols);
        linear_index = builder->CreateAdd(linear_index, current_col);
        
        // Load element
        Value* elem_ptr = builder->CreateGEP(Type::getInt64Ty(*context), typed_elements_ptr, linear_index);
        Value* current_elem = builder->CreateLoad(Type::getInt64Ty(*context), elem_ptr);
        
        // Format element as string
        Value* num_buffer_size = ConstantInt::get(Type::getInt64Ty(*context), 32);
        Value* num_buffer = builder->CreateCall(malloc_func, {num_buffer_size});
        Value* typed_num_buffer = builder->CreatePointerCast(num_buffer, builder->getPtrTy());
        
        Value* format_str = codegenString("%ld");
        builder->CreateCall(sprintf_func, {typed_num_buffer, format_str, current_elem});
        
        // Add element to result
        builder->CreateCall(strcat_func, {typed_string_buffer, typed_num_buffer});
        
        // Increment column counter
        Value* next_col = builder->CreateAdd(current_col, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_col, col_counter);
        
        // Jump back to inner condition
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop exit: close row bracket
        builder->SetInsertPoint(inner_loop_exit);
        Value* row_close_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_close_str});
        
        // Increment row counter
        Value* next_row = builder->CreateAdd(current_row, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(next_row, row_counter);
        
        // Jump back to outer condition
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop exit: close matrix bracket
        builder->SetInsertPoint(outer_loop_exit);
        Value* close_bracket_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, close_bracket_str});
        
        // Return string buffer as int64 (pointer)
        return builder->CreatePtrToInt(typed_string_buffer, Type::getInt64Ty(*context));
    }
    
    // Production implementation: Compound car/cdr operations using TAGGED cons cells
    Value* codegenCompoundCarCdr(const eshkol_operations_t* op, const std::string& pattern) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("compound car/cdr requires exactly 1 argument");
            return nullptr;
        }
        
        Value* current = codegenAST(&op->call_op.variables[0]);
        if (!current) return nullptr;
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Apply each operation in reverse order (right-to-left)
        // For cadr: apply 'd' (cdr) first, then 'a' (car)
        for (int i = pattern.length() - 1; i >= 0; i--) {
            char c = pattern[i];
            
            // CRITICAL FIX: Safely extract i64 from possibly-tagged value
            Value* ptr_int = safeExtractInt64(current);
            
            // NULL CHECK
            Value* is_null = builder->CreateICmpEQ(ptr_int,
                ConstantInt::get(Type::getInt64Ty(*context), 0));
            
            BasicBlock* null_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_null", current_func);
            BasicBlock* valid_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_valid", current_func);
            BasicBlock* continue_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_continue", current_func);
            
            builder->CreateCondBr(is_null, null_block, valid_block);
            
            // NULL: return null tagged value
            builder->SetInsertPoint(null_block);
            Value* null_tagged = packInt64ToTaggedValue(
                ConstantInt::get(Type::getInt64Ty(*context), 0), true);
            builder->CreateBr(continue_block);
            
            // VALID: extract car or cdr using tagged cons cell helpers
            builder->SetInsertPoint(valid_block);
            Value* cons_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
            
            Value* is_car_op = ConstantInt::get(Type::getInt1Ty(*context), (c == 'a') ? 0 : 1);
            Value* field_type = builder->CreateCall(arena_tagged_cons_get_type_func,
                {cons_ptr, is_car_op});
            
            // Mask to get base type
            Value* base_type = builder->CreateAnd(field_type,
                ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
            
            // Check type: double, int64, or cons_ptr
            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
            Value* is_cons_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR));
            
            BasicBlock* double_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_double", current_func);
            BasicBlock* check_ptr_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_ptr", current_func);
            BasicBlock* ptr_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_ptr", current_func);
            BasicBlock* int_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_int", current_func);
            BasicBlock* merge_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_merge", current_func);
            
            builder->CreateCondBr(is_double, double_block, check_ptr_block);
            
            // Extract double
            builder->SetInsertPoint(double_block);
            Value* double_val = builder->CreateCall(arena_tagged_cons_get_double_func,
                {cons_ptr, is_car_op});
            Value* tagged_double = packDoubleToTaggedValue(double_val);
            builder->CreateBr(merge_block);
            
            // Check if cons_ptr
            builder->SetInsertPoint(check_ptr_block);
            builder->CreateCondBr(is_cons_ptr, ptr_block, int_block);
            
            // Extract cons_ptr
            builder->SetInsertPoint(ptr_block);
            Value* ptr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func,
                {cons_ptr, is_car_op});
            // CRITICAL: Use packPtrToTaggedValue with CONS_PTR type, not packInt64ToTaggedValue!
            Value* tagged_ptr = packPtrToTaggedValue(builder->CreateIntToPtr(ptr_val, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
            builder->CreateBr(merge_block);
            
            // Extract int64
            builder->SetInsertPoint(int_block);
            Value* int_val = builder->CreateCall(arena_tagged_cons_get_int64_func,
                {cons_ptr, is_car_op});
            Value* tagged_int = packInt64ToTaggedValue(int_val, true);
            builder->CreateBr(merge_block);
            
            // Merge all three types
            builder->SetInsertPoint(merge_block);
            PHINode* extract_phi = builder->CreatePHI(tagged_value_type, 3);
            extract_phi->addIncoming(tagged_double, double_block);
            extract_phi->addIncoming(tagged_ptr, ptr_block);
            extract_phi->addIncoming(tagged_int, int_block);
            builder->CreateBr(continue_block);
            
            // Continue: merge null and valid results
            builder->SetInsertPoint(continue_block);
            PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2);
            result_phi->addIncoming(null_tagged, null_block);
            result_phi->addIncoming(extract_phi, merge_block);
            
            current = result_phi;
        }
        
        return current;
    }
    
    // Production implementation: List length
    Value* codegenLength(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("length requires exactly 1 argument");
            return nullptr;
        }

        Value* list = codegenAST(&op->call_op.variables[0]);
        if (!list) return nullptr;

        // CRITICAL FIX: Safely extract i64 from possibly-tagged value (e.g., from quote)
        Value* list_int = safeExtractInt64(list);

        // Create loop to count list elements
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "length_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "length_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "length_loop_exit", current_func);

        // Initialize counter and current pointer
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "length_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);

        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "current_ptr");
        builder->CreateStore(list_int, current_ptr);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: increment counter and move to cdr
        builder->SetInsertPoint(loop_body);
        Value* count = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* new_count = builder->CreateAdd(count, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        // Jump back to condition
        builder->CreateBr(loop_condition);
        
        // Loop exit: return counter
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(Type::getInt64Ty(*context), counter);
    }
    
    // Clean iterative implementation: List append (NO recursive C++ calls)
    Value* codegenAppend(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 2) {
            eshkol_warn("append requires at least 2 arguments");
            return nullptr;
        }
        
        if (op->call_op.num_vars == 2) {
            // Simple binary append
            Value* list1 = codegenAST(&op->call_op.variables[0]);
            Value* list2 = codegenAST(&op->call_op.variables[1]);
            return codegenIterativeAppend(list1, list2);
        }
        
        // Multi-list append: chain binary appends
        Value* result = codegenAST(&op->call_op.variables[0]);
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            Value* next_list = codegenAST(&op->call_op.variables[i]);
            if (next_list) {
                result = codegenIterativeAppend(result, next_list);
            }
        }
        
        return result;
    }
    
    // Clean iterative append implementation (NO recursion, NO arena scoping)
    Value* codegenIterativeAppend(Value* list1, Value* list2) {
        if (!list1 || !list2) return nullptr;

        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        list1 = safeExtractInt64(list1);
        list2 = safeExtractInt64(list2);

        // CRITICAL FIX: No arena scoping - append results must persist
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list1 is empty
        Value* is_empty = builder->CreateICmpEQ(list1, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* empty_case = BasicBlock::Create(*context, "append_empty", current_func);
        BasicBlock* copy_case = BasicBlock::Create(*context, "append_copy", current_func);
        BasicBlock* copy_loop_cond = BasicBlock::Create(*context, "copy_loop_cond", current_func);
        BasicBlock* copy_loop_body = BasicBlock::Create(*context, "copy_loop_body", current_func);
        BasicBlock* copy_loop_exit = BasicBlock::Create(*context, "copy_loop_exit", current_func);
        BasicBlock* final_block = BasicBlock::Create(*context, "append_final", current_func);
        
        builder->CreateCondBr(is_empty, empty_case, copy_case);
        
        // Empty case: return list2
        builder->SetInsertPoint(empty_case);
        builder->CreateBr(final_block);
        
        // Copy case: iteratively copy list1 and append list2
        builder->SetInsertPoint(copy_case);
        
        // Allocate stack variables for iteration
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "result_tail");
        Value* source_current = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "source_current");
        
        // Initialize: empty result, source starts at list1
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        builder->CreateStore(list1, source_current);
        
        builder->CreateBr(copy_loop_cond);
        
        // Copy loop condition: while source_current != null
        builder->SetInsertPoint(copy_loop_cond);
        Value* current_src = builder->CreateLoad(Type::getInt64Ty(*context), source_current);
        Value* src_not_null = builder->CreateICmpNE(current_src, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(src_not_null, copy_loop_body, copy_loop_exit);
        
        // Copy loop body: copy current element and advance
        builder->SetInsertPoint(copy_loop_body);
        
        Value* src_cons_ptr = builder->CreateIntToPtr(current_src, builder->getPtrTy());
        
        // Extract car as tagged_value
        Value* src_car_tagged = extractCarAsTaggedValue(current_src);
        
        // Create NULL tagged value
        Value* cdr_null_tagged = packNullToTaggedValue();
        
        // Create new cons cell directly from tagged values (preserves types!)
        Value* new_cons = codegenTaggedArenaConsCellFromTaggedValue(
            src_car_tagged, cdr_null_tagged);
        
        // Update result head/tail
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "update_tail", current_func);
        BasicBlock* continue_copy = BasicBlock::Create(*context, "continue_copy", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        // Set head if this is first element
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_cons, result_head);
        builder->CreateStore(new_cons, result_tail);
        builder->CreateBr(continue_copy);
        
        // Update tail if not first element
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_cons, ptr_type_tag});
        builder->CreateStore(new_cons, result_tail);
        builder->CreateBr(continue_copy);
        
        // Continue: move to next source element using tagged helper
        builder->SetInsertPoint(continue_copy);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* src_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {src_cons_ptr, is_cdr_get});
        builder->CreateStore(src_cdr, source_current);
        
        builder->CreateBr(copy_loop_cond);
        
        // Copy loop exit: connect tail to list2
        builder->SetInsertPoint(copy_loop_exit);
        Value* final_tail = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_not_null = builder->CreateICmpNE(final_tail, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* connect_tail = BasicBlock::Create(*context, "connect_tail", current_func);
        BasicBlock* done_copy = BasicBlock::Create(*context, "done_copy", current_func);
        
        builder->CreateCondBr(tail_not_null, connect_tail, done_copy);
        
        builder->SetInsertPoint(connect_tail);
        Value* final_tail_cons_ptr = builder->CreateIntToPtr(final_tail, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to connect tail to list2
        Value* is_cdr_final = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_final = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {final_tail_cons_ptr, is_cdr_final, list2, ptr_type_final});
        builder->CreateBr(done_copy);
        
        builder->SetInsertPoint(done_copy);
        Value* final_head = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        builder->CreateBr(final_block);
        
        // Final result selection
        builder->SetInsertPoint(final_block);
        PHINode* phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "append_result");
        phi->addIncoming(list2, empty_case);
        phi->addIncoming(final_head, done_copy);
        
        return phi;
    }
    
    // Production implementation: List reverse
    Value* codegenReverse(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("reverse requires exactly 1 argument");
            return nullptr;
        }
        
        Value* list = codegenAST(&op->call_op.variables[0]);
        if (!list) return nullptr;
        
        // CRITICAL FIX: No arena scoping - reverse results must persist
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "reverse_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "reverse_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "reverse_loop_exit", current_func);
        
        // Initialize result (accumulator) and current pointer
        Value* result = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "reverse_result");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result); // Start with empty list
        
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "reverse_current");
        builder->CreateStore(list, current_ptr);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: cons car onto result and move to cdr
        builder->SetInsertPoint(loop_body);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value
        Value* car_tagged = extractCarAsTaggedValue(current_val);
        
        // Get result as tagged value - check if NULL or CONS_PTR
        Value* result_val = builder->CreateLoad(Type::getInt64Ty(*context), result);
        Value* result_is_null = builder->CreateICmpEQ(result_val,
            ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        // Pack result correctly based on whether it's null or cons pointer
        Value* null_tagged_result = packNullToTaggedValue();
        Value* ptr_tagged_result = packPtrToTaggedValue(
            builder->CreateIntToPtr(result_val, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        Value* result_tagged = builder->CreateSelect(result_is_null,
            null_tagged_result, ptr_tagged_result);
        
        // Create new cons cell directly from tagged values (preserves types!)
        Value* new_result = codegenTaggedArenaConsCellFromTaggedValue(
            car_tagged, result_tagged);
        builder->CreateStore(new_result, result);
        
        // Move to cdr using tagged helper
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {cons_ptr, is_cdr_get});
        builder->CreateStore(cdr_val, current_ptr);
        
        // Jump back to condition
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(Type::getInt64Ty(*context), result);
    }
    
    // Production implementation: List reference by index
    Value* codegenListRef(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("list-ref requires exactly 2 arguments: list and index");
            return nullptr;
        }

        Value* list = codegenAST(&op->call_op.variables[0]);
        Value* index = codegenAST(&op->call_op.variables[1]);
        if (!list || !index) return nullptr;

        // CRITICAL FIX: Handle tagged_value input - extract cons cell pointer
        Value* list_ptr;
        if (list->getType() == tagged_value_type) {
            list_ptr = unpackInt64FromTaggedValue(list);
        } else if (list->getType()->isIntegerTy(64)) {
            list_ptr = list;
        } else {
            eshkol_error("list-ref: list argument has unexpected type");
            return nullptr;
        }

        // CRITICAL FIX: Handle tagged_value index - extract int64
        Value* index_val;
        if (index->getType() == tagged_value_type) {
            index_val = unpackInt64FromTaggedValue(index);
        } else if (index->getType()->isIntegerTy(64)) {
            index_val = index;
        } else if (index->getType()->isIntegerTy()) {
            index_val = builder->CreateSExt(index, Type::getInt64Ty(*context));
        } else {
            eshkol_error("list-ref: index argument has unexpected type");
            return nullptr;
        }

        // Traverse list to index position
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "listref_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "listref_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "listref_loop_exit", current_func);

        // Initialize counter and current pointer
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "listref_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);

        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "listref_current");
        builder->CreateStore(list_ptr, current_ptr);

        // Jump to loop condition
        builder->CreateBr(loop_condition);

        // Loop condition: check if counter < index AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);

        Value* count_less = builder->CreateICmpULT(count_val, index_val);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_loop = builder->CreateAnd(count_less, current_not_null);
        
        builder->CreateCondBr(continue_loop, loop_body, loop_exit);
        
        // Loop body: increment counter and move to cdr
        builder->SetInsertPoint(loop_body);
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        builder->SetInsertPoint(loop_exit);
        Value* final_current = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* final_not_null = builder->CreateICmpNE(final_current, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* return_car = BasicBlock::Create(*context, "listref_return_car", current_func);
        BasicBlock* return_null = BasicBlock::Create(*context, "listref_return_null", current_func);
        BasicBlock* final_return = BasicBlock::Create(*context, "listref_final_return", current_func);
        
        builder->CreateCondBr(final_not_null, return_car, return_null);
        
        builder->SetInsertPoint(return_car);
        Value* final_cons_ptr = builder->CreateIntToPtr(final_current, builder->getPtrTy());
        Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
        Value* car_type = builder->CreateCall(arena_tagged_cons_get_type_func, {final_cons_ptr, is_car});
        Value* car_base_type = builder->CreateAnd(car_type, ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
        Value* car_is_double = builder->CreateICmpEQ(car_base_type, ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
        
        BasicBlock* car_double_block = BasicBlock::Create(*context, "listref_car_double", current_func);
        BasicBlock* car_int_block = BasicBlock::Create(*context, "listref_car_int", current_func);
        BasicBlock* car_merge = BasicBlock::Create(*context, "listref_car_merge", current_func);
        
        builder->CreateCondBr(car_is_double, car_double_block, car_int_block);
        
        builder->SetInsertPoint(car_double_block);
        Value* car_double = builder->CreateCall(arena_tagged_cons_get_double_func, {final_cons_ptr, is_car});
        Value* tagged_car_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(car_merge);
        
        builder->SetInsertPoint(car_int_block);
        Value* car_int = builder->CreateCall(arena_tagged_cons_get_int64_func, {final_cons_ptr, is_car});
        Value* tagged_car_int = packInt64ToTaggedValue(car_int, true);
        builder->CreateBr(car_merge);
        
        builder->SetInsertPoint(car_merge);
        PHINode* car_phi = builder->CreatePHI(tagged_value_type, 2);
        car_phi->addIncoming(tagged_car_double, car_double_block);
        car_phi->addIncoming(tagged_car_int, car_int_block);
        builder->CreateBr(final_return);
        
        builder->SetInsertPoint(return_null);
        Value* null_tagged = packNullToTaggedValue();
        builder->CreateBr(final_return);
        
        builder->SetInsertPoint(final_return);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "listref_result");
        phi->addIncoming(car_phi, car_merge);
        phi->addIncoming(null_tagged, return_null);
        
        return phi;
    }
    
    // Production implementation: List tail
    Value* codegenListTail(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("list-tail requires exactly 2 arguments: list and index");
            return nullptr;
        }
        
        Value* list = codegenAST(&op->call_op.variables[0]);
        Value* index = codegenAST(&op->call_op.variables[1]);
        if (!list || !index) return nullptr;
        
        // Traverse list to index position and return remaining tail
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "listtail_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "listtail_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "listtail_loop_exit", current_func);
        
        // Initialize counter and current pointer
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "listtail_counter");
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "listtail_current");
        builder->CreateStore(list, current_ptr);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < index AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        Value* count_less = builder->CreateICmpULT(count_val, index);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_loop = builder->CreateAnd(count_less, current_not_null);
        
        builder->CreateCondBr(continue_loop, loop_body, loop_exit);
        
        // Loop body: increment counter and move to cdr
        builder->SetInsertPoint(loop_body);
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return current (the tail)
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
    }
    
    // Production implementation: Set car (mutable)
    Value* codegenSetCar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("set-car! requires exactly 2 arguments: pair and new-value");
            return nullptr;
        }
        
        Value* pair = codegenAST(&op->call_op.variables[0]);
        Value* new_value = codegenAST(&op->call_op.variables[1]);
        if (!pair || !new_value) return nullptr;

        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        Value* pair_int = safeExtractInt64(pair);

        // Mutate the car of the pair using tagged helper
        Value* cons_ptr = builder->CreateIntToPtr(pair_int, builder->getPtrTy());
        
        // Detect new value type and use appropriate setter
        TypedValue new_val_typed = detectValueType(new_value);
        Value* is_car = ConstantInt::get(Type::getInt1Ty(*context), 0);
        uint8_t type_tag = new_val_typed.type;
        
        if (new_val_typed.isInt64()) {
            builder->CreateCall(arena_tagged_cons_set_int64_func,
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        } else if (new_val_typed.isDouble()) {
            builder->CreateCall(arena_tagged_cons_set_double_func,
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        } else {
            // Pointer/other types
            builder->CreateCall(arena_tagged_cons_set_ptr_func,
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        }
        
        // Return the new value (Scheme convention)
        return new_value;
    }
    
    // Production implementation: Set cdr (mutable)
    Value* codegenSetCdr(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("set-cdr! requires exactly 2 arguments: pair and new-value");
            return nullptr;
        }

        Value* pair = codegenAST(&op->call_op.variables[0]);
        Value* new_value = codegenAST(&op->call_op.variables[1]);
        if (!pair || !new_value) return nullptr;

        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        Value* pair_int = safeExtractInt64(pair);

        // Mutate the cdr of the pair using tagged helper
        Value* cons_ptr = builder->CreateIntToPtr(pair_int, builder->getPtrTy());
        
        // Detect new value type and use appropriate setter
        TypedValue new_val_typed = detectValueType(new_value);
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        uint8_t type_tag = new_val_typed.type;
        
        if (new_val_typed.isInt64()) {
            builder->CreateCall(arena_tagged_cons_set_int64_func,
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        } else if (new_val_typed.isDouble()) {
            builder->CreateCall(arena_tagged_cons_set_double_func,
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        } else {
            // Pointer/other types
            builder->CreateCall(arena_tagged_cons_set_ptr_func,
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(Type::getInt8Ty(*context), type_tag)});
        }
        
        // Return the new value (Scheme convention)
        return new_value;
    }
    
    // Production implementation: Map function with lambda integration (Enhanced for multi-list)
    Value* codegenMap(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 2) {
            eshkol_warn("map requires at least 2 arguments: procedure and list");
            return nullptr;
        }
        
        // Add function context isolation
        pushFunctionContext();
        
        // Calculate required arity for builtin functions (number of lists)
        size_t num_lists = op->call_op.num_vars - 1;  // Total args minus procedure
        
        // Get procedure/function to apply with arity information
        Value* proc = resolveLambdaFunction(&op->call_op.variables[0], num_lists);
        if (!proc) {
            eshkol_error("Failed to resolve procedure for map");
            return nullptr;
        }
        
        Function* proc_func = dyn_cast<Function>(proc);
        if (!proc_func) {
            eshkol_error("map procedure must be a function");
            return nullptr;
        }
        
        // Single-list map: (map proc list)
        if (op->call_op.num_vars == 2) {
            Value* list = codegenAST(&op->call_op.variables[1]);
            if (!list) return nullptr;
            
            return codegenMapSingleList(proc_func, list);
        }
        
        // Multi-list map: (map proc list1 list2 ...)
        std::vector<Value*> lists;
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            Value* list = codegenAST(&op->call_op.variables[i]);
            if (list) {
                lists.push_back(list);
            }
        }
        
        if (lists.empty()) {
            eshkol_error("map requires at least one list argument");
            return nullptr;
        }
        
        Value* result = codegenMapMultiList(proc_func, lists);
        
        // Pop function context to clean up
        popFunctionContext();
        
        return result;
    }
    
    // Helper function to resolve lambda/function from AST with arity-specific builtin handling
    Value* resolveLambdaFunction(const eshkol_ast_t* func_ast, size_t required_arity = 0) {
        if (!func_ast) {
            eshkol_error("resolveLambdaFunction: func_ast is nullptr");
            return nullptr;
        }
        
        // Handle inline lambda expressions
        if (func_ast->type == ESHKOL_OP && func_ast->operation.op == ESHKOL_LAMBDA_OP) {
            eshkol_debug("Generating inline lambda for gradient/jacobian/etc.");
            Value* lambda_result = codegenLambda(&func_ast->operation);
            if (!lambda_result) {
                eshkol_error("codegenLambda returned nullptr for inline lambda");
            } else {
                eshkol_debug("Successfully generated inline lambda: %p", lambda_result);
            }
            return lambda_result;
        }
        
        if (func_ast->type == ESHKOL_VAR) {
            std::string func_name = func_ast->variable.id;

            // Strategy 0: Check function_table FIRST for regular defined functions
            auto direct_it = function_table.find(func_name);
            if (direct_it != function_table.end() && direct_it->second) {
                return direct_it->second;
            }
            
            // Strategy 1: Try to find lambda function directly with _func suffix in LOCAL table
            std::string func_key = func_name + "_func";
            auto func_it = symbol_table.find(func_key);
            if (func_it != symbol_table.end() && func_it->second) {
                if (isa<Function>(func_it->second)) {
                    return func_it->second;
                }
            }
            
            // Strategy 2: Try global symbol table
            func_it = global_symbol_table.find(func_key);
            if (func_it != global_symbol_table.end() && func_it->second) {
                if (isa<Function>(func_it->second)) {
                    return func_it->second;
                }
            }

            // Strategy 3: Try REPL context (for cross-evaluation function calls)
            Function* repl_func = tryResolveReplFunction(func_name);
            if (repl_func) {
                return repl_func;
            }
            repl_func = tryResolveReplFunction(func_key);
            if (repl_func) {
                return repl_func;
            }

            // Handle builtin functions using polymorphic arithmetic (Phase 2.4)
            // Note: For now we only support binary operations (arity 2)
            if (func_name == "+" && required_arity == 2) {
                return polymorphicAdd();
            }
            if (func_name == "*" && required_arity == 2) {
                return polymorphicMul();
            }
            if (func_name == "-" && required_arity == 2) {
                return polymorphicSub();
            }
            if (func_name == "/" && required_arity == 2) {
                return polymorphicDiv();
            }
            
            // Handle all arities with polymorphic functions
            if (func_name == "+" || func_name == "*" || func_name == "-" || func_name == "/") {
                return createBuiltinArithmeticFunction(func_name, required_arity);
            }
            
            // Handle display builtin function
            if (func_name == "display") {
                // Create wrapper for display that takes tagged_value and returns 0
                static int display_counter = 0;
                std::string wrapper_name = "builtin_display_" + std::to_string(display_counter++);
                
                // FIX: Accept tagged_value parameter, not i64
                FunctionType* wrapper_type = FunctionType::get(
                    Type::getInt64Ty(*context),
                    {tagged_value_type},  // FIXED: Accept tagged_value
                    false
                );
                
                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );
                
                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);
                
                // Call display function with tagged_value
                Value* arg_tagged = &*wrapper_func->arg_begin();
                Function* printf_func = function_table["printf"];
                if (printf_func) {
                    // Extract type and value from tagged_value
                    Value* arg_type = getTaggedValueType(arg_tagged);
                    Value* arg_base_type = builder->CreateAnd(arg_type,
                        ConstantInt::get(Type::getInt8Ty(*context), 0x0F));
                    Value* is_double = builder->CreateICmpEQ(arg_base_type,
                        ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_DOUBLE));
                    
                    BasicBlock* double_display = BasicBlock::Create(*context, "display_double", wrapper_func);
                    BasicBlock* int_display = BasicBlock::Create(*context, "display_int", wrapper_func);
                    BasicBlock* display_done = BasicBlock::Create(*context, "display_done", wrapper_func);
                    
                    builder->CreateCondBr(is_double, double_display, int_display);
                    
                    builder->SetInsertPoint(double_display);
                    Value* double_val = unpackDoubleFromTaggedValue(arg_tagged);
                    builder->CreateCall(printf_func, {codegenString("%g"), double_val});
                    builder->CreateBr(display_done);
                    
                    builder->SetInsertPoint(int_display);
                    Value* int_val = unpackInt64FromTaggedValue(arg_tagged);
                    builder->CreateCall(printf_func, {codegenString("%lld"), int_val});
                    builder->CreateBr(display_done);
                    
                    builder->SetInsertPoint(display_done);
                }
                builder->CreateRet(ConstantInt::get(Type::getInt64Ty(*context), 0));
                
                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                
                return wrapper_func;
            }
            
        }
        
        return nullptr;
    }
    
    // Single-list map implementation with arena integration and tagged value support
    Value* codegenMapSingleList(Function* proc_func, Value* list) {
        if (!proc_func || !list) return nullptr;

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping for map operations!
        // Arena scoping resets the used pointer, making cons cell memory available for reuse
        // This causes memory corruption when subsequent operations overwrite list data
        // Map results must persist beyond their creation scope
        eshkol_debug("Single-list map starting - no arena scoping to prevent memory corruption");

        // CRITICAL FIX: Handle tagged_value input - extract cons cell pointer
        Value* list_ptr;
        if (list->getType() == tagged_value_type) {
            // Extract pointer from tagged_value's data field
            list_ptr = unpackInt64FromTaggedValue(list);
        } else if (list->getType()->isIntegerTy(64)) {
            list_ptr = list;
        } else {
            eshkol_error("Map: list argument has unexpected type");
            return nullptr;
        }

        // Initialize result list
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "map_result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "map_result_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "map_current");

        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        builder->CreateStore(list_ptr, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "map_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "map_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "map_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: apply procedure and build result
        builder->SetInsertPoint(loop_body);
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* car_tagged = extractCarAsTaggedValue(current_val);
        
        // CRITICAL FIX (Bug #4): Check if lambda has captured variables (closure)
        // If lambda expects more params than we're passing, load actual captured values
        FunctionType* proc_type = proc_func->getFunctionType();
        size_t expected_params = proc_type->getNumParams();

        std::vector<Value*> proc_args;
        proc_args.push_back(car_tagged);  // First arg is always the list element

        // Load actual captured values (not zeros!) for closure parameters
        if (expected_params > 1) {
            std::string lambda_name = proc_func->getName().str();
            size_t num_captures = expected_params - 1;

            for (size_t i = 0; i < num_captures; i++) {
                // Get variable name from parameter (e.g., "captured_s" -> "s")
                std::string var_name;
                auto arg_it = proc_func->arg_begin();
                std::advance(arg_it, i + 1);  // Skip first parameter (the list element)
                if (arg_it != proc_func->arg_end()) {
                    var_name = arg_it->getName().str();
                    if (var_name.find("captured_") == 0) {
                        var_name = var_name.substr(9);  // Remove "captured_" prefix
                    }
                }

                // Construct capture storage key
                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try local symbol tables
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                if (found && it->second) {
                    Value* storage = it->second;
                    Value* captured_val = builder->CreateLoad(tagged_value_type, storage);
                    proc_args.push_back(captured_val);
                } else {
                    // Fallback to zero if capture not found
                    proc_args.push_back(packInt64ToTaggedValue(
                        ConstantInt::get(Type::getInt64Ty(*context), 0), true));
                    eshkol_warn("Map: capture '%s' not found for lambda '%s', using 0",
                                var_name.c_str(), lambda_name.c_str());
                }
            }
        }
        
        // Apply procedure to current element with correct number of args
        Value* proc_result = builder->CreateCall(proc_func, proc_args);
        
        // Create new cons cell for result - proc_result is already tagged_value!
        // Create proper NULL tagged value (type=NULL 0, not INT64 1!)
        Value* cdr_null_tagged = packNullToTaggedValue();
        Value* new_result_cons = codegenTaggedArenaConsCellFromTaggedValue(
            proc_result, cdr_null_tagged);
        
        // Update result list
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "map_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "map_update_tail", current_func);
        BasicBlock* continue_map = BasicBlock::Create(*context, "map_continue", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        // Set head if this is first result
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_map);
        
        // Update tail if not first result
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // MIGRATION ISSUE 3: Set cdr using tagged value system
        // Old: CreateStructGEP(arena_cons_type, tail_cons_ptr, 1) + Store
        // New: arena_tagged_cons_set_ptr_func(tail_cons_ptr, is_cdr=1, value, type)
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_map);
        
        // Continue: move to next input element
        builder->SetInsertPoint(continue_map);
        
        // MIGRATION ISSUE 2: Get cdr using tagged value system
        // Old: CreateStructGEP(arena_cons_type, input_cons_ptr, 1) + Load
        // New: arena_tagged_cons_get_ptr_func(input_cons_ptr, is_cdr=1)
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result as properly tagged CONS_PTR
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result_head);

        // CRITICAL FIX: No arena scope cleanup for map operations
        // Map results must persist in arena memory for later car/cdr operations
        eshkol_debug("Single-list map completed - cons cells remain persistent in arena memory");

        // CRITICAL FIX: Return as tagged CONS_PTR (type 3), not INT64!
        // This ensures display and other operations recognize it as a list
        return packPtrToTaggedValue(builder->CreateIntToPtr(final_result, builder->getPtrTy()),
                                     ESHKOL_VALUE_CONS_PTR);
    }
    
    // Multi-list map implementation with synchronized traversal
    Value* codegenMapMultiList(Function* proc_func, const std::vector<Value*>& lists) {
        if (!proc_func || lists.empty()) return nullptr;
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // CRITICAL FIX: Do not use arena scoping for map operations!
        // Arena scoping resets the used pointer, making cons cell memory available for reuse
        // This causes memory corruption when subsequent operations overwrite list data
        // Map results must persist beyond their creation scope, so no scope management needed
        eshkol_debug("Map operation starting - no arena scoping to prevent memory corruption");
        
        // Initialize result list
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "multimap_result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "multimap_result_tail");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        
        // Initialize current pointers for each input list
        // CRITICAL FIX: Handle tagged_value input - extract cons cell pointer
        std::vector<Value*> current_ptrs;
        for (size_t i = 0; i < lists.size(); i++) {
            Value* list_ptr;
            if (lists[i]->getType() == tagged_value_type) {
                // Extract pointer from tagged_value's data field
                list_ptr = unpackInt64FromTaggedValue(lists[i]);
            } else if (lists[i]->getType()->isIntegerTy(64)) {
                list_ptr = lists[i];
            } else {
                eshkol_error("MultiMap: list %zu has unexpected type", i);
                return nullptr;
            }

            Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr,
                                                     ("multimap_current_" + std::to_string(i)).c_str());
            builder->CreateStore(list_ptr, current_ptr);
            current_ptrs.push_back(current_ptr);
        }
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "multimap_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "multimap_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "multimap_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if ALL lists still have elements
        builder->SetInsertPoint(loop_condition);
        Value* all_not_null = ConstantInt::get(Type::getInt1Ty(*context), 1); // Start with true
        
        for (size_t i = 0; i < current_ptrs.size(); i++) {
            Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptrs[i]);
            Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
            all_not_null = builder->CreateAnd(all_not_null, is_not_null);
        }
        
        builder->CreateCondBr(all_not_null, loop_body, loop_exit);
        
        // Loop body: extract elements, apply procedure, build result
        builder->SetInsertPoint(loop_body);
        
        StructType* arena_cons_type = StructType::get(Type::getInt64Ty(*context), Type::getInt64Ty(*context));
        
        // Extract car from each list for procedure arguments as tagged_value
        // CRITICAL FIX: Pass tagged_value directly to polymorphic functions, no unpacking needed!
        std::vector<Value*> proc_args;
        for (size_t i = 0; i < current_ptrs.size(); i++) {
            Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptrs[i]);
            
            // Extract car as tagged_value - polymorphic functions expect tagged_value!
            Value* car_tagged = extractCarAsTaggedValue(current_val);
            proc_args.push_back(car_tagged);
        }
        
        // CRITICAL DEBUG: Add instrumentation to track corruption
        eshkol_debug("MultiMap: About to call %s function with %zu arguments",
                    proc_func->getName().str().c_str(), proc_args.size());
        
        // Apply procedure to extracted elements
        Value* proc_result = builder->CreateCall(proc_func, proc_args);
        
        // Create new cons cell for result - proc_result is already tagged_value!
        // Create proper NULL tagged value (type=NULL 0, not INT64 1!)
        Value* cdr_null_tagged = packNullToTaggedValue();
        Value* new_result_cons = codegenTaggedArenaConsCellFromTaggedValue(
            proc_result, cdr_null_tagged);
        
        // Update result list
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "multimap_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "multimap_update_tail", current_func);
        BasicBlock* continue_multimap = BasicBlock::Create(*context, "multimap_continue", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        // Set head if this is first result
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_multimap);
        
        // Update tail if not first result using tagged value system
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_multimap);
        
        // Continue: advance all list pointers to their cdr using tagged value system
        builder->SetInsertPoint(continue_multimap);
        for (size_t i = 0; i < current_ptrs.size(); i++) {
            Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptrs[i]);
            Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
            
            // Use arena_tagged_cons_get_ptr_func to get cdr
            Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
            Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func,
                {cons_ptr, is_cdr_get});
            builder->CreateStore(cdr_val, current_ptrs[i]);
        }
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result_head);

        // CRITICAL FIX: No arena scope cleanup for map operations
        // Map results must persist in arena memory for later car/cdr operations
        eshkol_debug("Multi-list map completed - cons cells remain persistent in arena memory");

        // CRITICAL FIX: Return as tagged CONS_PTR (type 3), not raw i64!
        return packPtrToTaggedValue(builder->CreateIntToPtr(final_result, builder->getPtrTy()),
                                    ESHKOL_VALUE_CONS_PTR);
    }
    
    // Production implementation: Filter function
    Value* codegenFilter(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("filter requires exactly 2 arguments: predicate and list");
            return nullptr;
        }
        
        // Get predicate function
        Value* predicate = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!predicate) {
            eshkol_error("Failed to resolve predicate for filter");
            return nullptr;
        }
        
        Function* pred_func = dyn_cast<Function>(predicate);
        if (!pred_func) {
            eshkol_error("filter predicate must be a function");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Create arena scope for filter operations
        // CRITICAL FIX: Do not use arena scoping for multi-list map operations!
        // Arena scoping causes memory corruption by resetting used pointer
        eshkol_debug("Multi-list map starting - no arena scoping to prevent memory corruption");

        // Initialize result list
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "filter_result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "filter_result_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "filter_current");

        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        builder->CreateStore(list, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "filter_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "filter_loop_body", current_func);
        BasicBlock* add_element = BasicBlock::Create(*context, "filter_add_elem", current_func);
        BasicBlock* skip_element = BasicBlock::Create(*context, "filter_skip_elem", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "filter_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: get current element and check predicate
        builder->SetInsertPoint(loop_body);
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Apply predicate to current element (pass tagged_value directly)
        Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});
        
        // Predicate returns tagged_value - unpack to check boolean result
        Value* pred_result_int = unpackInt64FromTaggedValue(pred_result);
        
        // Check if predicate returned true (non-zero)
        Value* pred_is_true = builder->CreateICmpNE(pred_result_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(pred_is_true, add_element, skip_element);
        
        // Add element to result if predicate is true
        // Convert tagged_value to TypedValue for cons cell creation
        builder->SetInsertPoint(add_element);
        TypedValue elem_typed = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null = TypedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL);
        Value* new_result_cons = codegenTaggedArenaConsCell(elem_typed, cdr_null);
        
        // Update result list
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "filter_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "filter_update_tail", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type_tag});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        // Skip element: move to next input element
        builder->SetInsertPoint(skip_element);
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_get_ptr_func to get cdr
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        
        // CRITICAL FIX: No arena scope cleanup for map operations
        // Cons cells must remain persistent in arena memory
        eshkol_debug("Multi-list map completed - persistent cons cells in arena");
        
        return final_result;
    }
    
    // Production implementation: Fold (left fold) function
    Value* codegenFold(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("fold requires exactly 3 arguments: procedure, initial-value, and list");
            return nullptr;
        }
        
        // Get procedure function
        Value* proc = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!proc) {
            eshkol_error("Failed to resolve procedure for fold");
            return nullptr;
        }
        
        Function* proc_func = dyn_cast<Function>(proc);
        if (!proc_func) {
            eshkol_error("fold procedure must be a function");
            return nullptr;
        }
        
        Value* initial_value = codegenAST(&op->call_op.variables[1]);
        Value* list = codegenAST(&op->call_op.variables[2]);
        if (!initial_value || !list) return nullptr;

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Handle tagged_value input - extract cons cell pointer
        Value* list_ptr;
        if (list->getType() == tagged_value_type) {
            // Extract pointer from tagged_value's data field
            list_ptr = unpackInt64FromTaggedValue(list);
        } else if (list->getType()->isIntegerTy(64)) {
            list_ptr = list;
        } else {
            eshkol_error("Fold: list argument has unexpected type");
            return nullptr;
        }

        // Initialize accumulator with initial value - use tagged_value type to preserve types!
        Value* accumulator = builder->CreateAlloca(tagged_value_type, nullptr, "fold_accumulator");

        // Pack initial_value to tagged_value if needed
        Value* initial_tagged = (initial_value->getType() == tagged_value_type) ? initial_value :
            packInt64ToTaggedValue(initial_value, true);
        builder->CreateStore(initial_tagged, accumulator);

        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "fold_current");
        builder->CreateStore(list_ptr, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "fold_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "fold_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "fold_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: apply procedure to accumulator and current element
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Get current accumulator value (already tagged_value)
        Value* acc_tagged = builder->CreateLoad(tagged_value_type, accumulator);
        
        // Apply procedure: proc(accumulator, current_element) with tagged values
        Value* new_acc_tagged = builder->CreateCall(proc_func, {acc_tagged, input_element_tagged});
        
        // Store result as tagged_value (preserves type!)
        builder->CreateStore(new_acc_tagged, accumulator);
        
        // Move to next input element using tagged helper
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return final accumulator as tagged_value
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(tagged_value_type, accumulator);
    }
    
    // Production implementation: Make-list constructor
    Value* codegenMakeList(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("make-list requires 1 or 2 arguments: count and optional fill");
            return nullptr;
        }
        
        Value* count = codegenAST(&op->call_op.variables[0]);
        if (!count) return nullptr;
        
        // Default fill value is 0 if not provided
        Value* fill_value = ConstantInt::get(Type::getInt64Ty(*context), 0);
        if (op->call_op.num_vars == 2) {
            fill_value = codegenAST(&op->call_op.variables[1]);
            if (!fill_value) fill_value = ConstantInt::get(Type::getInt64Ty(*context), 0);
        }
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // CRITICAL FIX: Do not use arena scoping - make-list results must persist
        // Arena scoping causes memory corruption by resetting used pointer
        
        // Initialize loop counter and result
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "makelist_counter");
        Value* result = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "makelist_result");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result); // Start with empty list
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "makelist_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "makelist_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "makelist_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < count
        builder->SetInsertPoint(loop_condition);
        Value* counter_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* counter_less = builder->CreateICmpULT(counter_val, count);
        builder->CreateCondBr(counter_less, loop_body, loop_exit);
        
        // Loop body: cons fill_value onto result
        builder->SetInsertPoint(loop_body);
        Value* result_val = builder->CreateLoad(Type::getInt64Ty(*context), result);
        
        // CRITICAL FIX: Use tagged cons cells for type preservation
        TypedValue fill_typed = detectValueType(fill_value);
        TypedValue result_typed = TypedValue(result_val,
            result_val == ConstantInt::get(Type::getInt64Ty(*context), 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR,
            true);
        Value* new_cons = codegenTaggedArenaConsCell(fill_typed, result_typed);
        builder->CreateStore(new_cons, result);
        
        // Increment counter
        Value* new_counter = builder->CreateAdd(counter_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_counter, counter);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return final_result;
    }
    
    // Production implementation: Member function family
    Value* codegenMember(const eshkol_operations_t* op, const std::string& comparison_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("member requires exactly 2 arguments: item and list");
            return nullptr;
        }
        
        Value* item = codegenAST(&op->call_op.variables[0]);
        Value* list = codegenAST(&op->call_op.variables[1]);
        if (!item || !list) return nullptr;
        
        // POLYMORPHIC FIX: Keep item as tagged_value for proper type comparison
        TypedValue item_typed = detectValueType(item);
        Value* item_tagged = typedValueToTaggedValue(item_typed);
        Value* list_int = safeExtractInt64(list);
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Initialize current pointer
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "member_current");
        builder->CreateStore(list_int, current_ptr);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "member_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "member_loop_body", current_func);
        BasicBlock* found_match = BasicBlock::Create(*context, "member_found", current_func);
        BasicBlock* continue_search = BasicBlock::Create(*context, "member_continue", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "member_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: compare current element with item
        builder->SetInsertPoint(loop_body);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value for polymorphic comparison
        Value* current_element_tagged = extractCarAsTaggedValue(current_val);
        
        // POLYMORPHIC FIX: Use polymorphicCompare for mixed-type equality with proper comparison type
        // Map comparison_type to polymorphicCompare operations: "equal"/"eq"/"eqv" all map to "eq" for value equality
        std::string poly_cmp_type = "eq";  // All variants use value equality for tagged values
        Value* comparison_result = polymorphicCompare(item_tagged, current_element_tagged, poly_cmp_type);
        Value* comparison_int = unpackInt64FromTaggedValue(comparison_result);
        Value* is_match = builder->CreateICmpNE(comparison_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        builder->CreateCondBr(is_match, found_match, continue_search);
        
        // Found match: return rest of list starting with this element
        builder->SetInsertPoint(found_match);
        builder->CreateBr(loop_exit);
        
        // Continue search: move to next element using tagged helper
        builder->SetInsertPoint(continue_search);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {cons_ptr, is_cdr_get});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return current (or null if not found)
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        return final_result;
    }
    
    // Production implementation: For-each function (side effects)
    Value* codegenForEach(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 2) {
            eshkol_warn("for-each requires at least 2 arguments: procedure and list");
            return nullptr;
        }
        
        // Get procedure/function to apply
        Value* proc = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!proc) {
            eshkol_error("Failed to resolve procedure for for-each");
            return nullptr;
        }
        
        Function* proc_func = dyn_cast<Function>(proc);
        if (!proc_func) {
            eshkol_error("for-each procedure must be a function");
            return nullptr;
        }
        
        // For now, implement single-list for-each: (for-each proc list)
        if (op->call_op.num_vars == 2) {
            Value* list_raw = codegenAST(&op->call_op.variables[1]);
            if (!list_raw) return nullptr;
            // CRITICAL FIX: Safely extract i64 from possibly-tagged value
            Value* list = safeExtractInt64(list_raw);

            return codegenForEachSingleList(proc_func, list);
        }
        
        // Multi-list for-each will be implemented in Phase 2A
        eshkol_warn("Multi-list for-each not yet implemented");
        return ConstantInt::get(Type::getInt64Ty(*context), 0);
    }
    
    // Single-list for-each implementation (side effects only)
    Value* codegenForEachSingleList(Function* proc_func, Value* list) {
        if (!proc_func || !list) return nullptr;
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Initialize iteration
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "foreach_current");
        builder->CreateStore(list, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "foreach_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "foreach_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "foreach_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: apply procedure for side effects
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Apply procedure to current element (ignore return value - side effects only)
        builder->CreateCall(proc_func, {input_element_tagged});
        
        // Move to next input element using tagged helper
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return unspecified value (0 in our implementation)
        builder->SetInsertPoint(loop_exit);
        return ConstantInt::get(Type::getInt64Ty(*context), 0);
    }
    
    // Stub implementations for remaining functions (to be implemented)
    Value* codegenFoldRight(const eshkol_operations_t* op) {
        eshkol_warn("fold-right not yet implemented");
        return ConstantInt::get(Type::getInt64Ty(*context), 0);
    }

    // any: (any pred list) - returns true if any element satisfies predicate
    Value* codegenAny(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("any requires 2 arguments: predicate and list");
            return nullptr;
        }

        // Resolve the predicate function (arity 1 for single-list any)
        Value* pred = resolveLambdaFunction(&op->call_op.variables[0], 1);
        if (!pred) {
            eshkol_warn("any: could not resolve predicate function");
            return nullptr;
        }
        Function* pred_func = dyn_cast<Function>(pred);
        if (!pred_func) {
            eshkol_warn("any: predicate must be a function");
            return nullptr;
        }

        // Get the list
        Value* list = codegenAST(&op->call_op.variables[1]);
        if (!list) return nullptr;

        // Extract list pointer from tagged_value if needed
        Value* list_ptr;
        if (list->getType() == tagged_value_type) {
            list_ptr = unpackInt64FromTaggedValue(list);
        } else if (list->getType()->isIntegerTy(64)) {
            list_ptr = list;
        } else {
            return nullptr;
        }

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Allocate current pointer for iteration
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "any_current");
        builder->CreateStore(list_ptr, current_input);

        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "any_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "any_loop_body", current_func);
        BasicBlock* loop_continue = BasicBlock::Create(*context, "any_loop_continue", current_func);
        BasicBlock* found_true = BasicBlock::Create(*context, "any_found_true", current_func);
        BasicBlock* not_found = BasicBlock::Create(*context, "any_not_found", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "any_loop_exit", current_func);

        builder->CreateBr(loop_condition);

        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, not_found);

        // Loop body: apply predicate and check result
        builder->SetInsertPoint(loop_body);

        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());

        // Extract car as tagged_value
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);

        // Apply predicate to current element
        Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});

        // Check if result is truthy - if so, exit with true
        Value* is_truthy_val = isTruthy(pred_result);
        builder->CreateCondBr(is_truthy_val, found_true, loop_continue);

        // Loop continue: move to next element
        builder->SetInsertPoint(loop_continue);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        builder->CreateBr(loop_condition);

        // Found true: return true
        builder->SetInsertPoint(found_true);
        Value* true_result = packBoolToTaggedValue(ConstantInt::getTrue(*context));
        builder->CreateBr(loop_exit);

        // Not found: return false
        builder->SetInsertPoint(not_found);
        Value* false_result = packBoolToTaggedValue(ConstantInt::getFalse(*context));
        builder->CreateBr(loop_exit);

        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        PHINode* result = builder->CreatePHI(tagged_value_type, 2, "any_result");
        result->addIncoming(true_result, found_true);
        result->addIncoming(false_result, not_found);

        return result;
    }

    // every: (every pred list) - returns true if all elements satisfy predicate
    Value* codegenEvery(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("every requires 2 arguments: predicate and list");
            return nullptr;
        }

        // Resolve the predicate function (arity 1 for single-list every)
        Value* pred = resolveLambdaFunction(&op->call_op.variables[0], 1);
        if (!pred) {
            eshkol_warn("every: could not resolve predicate function");
            return nullptr;
        }
        Function* pred_func = dyn_cast<Function>(pred);
        if (!pred_func) {
            eshkol_warn("every: predicate must be a function");
            return nullptr;
        }

        // Get the list
        Value* list = codegenAST(&op->call_op.variables[1]);
        if (!list) return nullptr;

        // Extract list pointer from tagged_value if needed
        Value* list_ptr;
        if (list->getType() == tagged_value_type) {
            list_ptr = unpackInt64FromTaggedValue(list);
        } else if (list->getType()->isIntegerTy(64)) {
            list_ptr = list;
        } else {
            return nullptr;
        }

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Allocate current pointer for iteration
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "every_current");
        builder->CreateStore(list_ptr, current_input);

        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "every_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "every_loop_body", current_func);
        BasicBlock* loop_continue = BasicBlock::Create(*context, "every_loop_continue", current_func);
        BasicBlock* found_false = BasicBlock::Create(*context, "every_found_false", current_func);
        BasicBlock* all_passed = BasicBlock::Create(*context, "every_all_passed", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "every_loop_exit", current_func);

        builder->CreateBr(loop_condition);

        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, all_passed);

        // Loop body: apply predicate and check result
        builder->SetInsertPoint(loop_body);

        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());

        // Extract car as tagged_value
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);

        // Apply predicate to current element
        Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});

        // Check if result is falsy - if so, exit early with false
        Value* is_truthy_val = isTruthy(pred_result);
        builder->CreateCondBr(is_truthy_val, loop_continue, found_false);

        // Loop continue: move to next element
        builder->SetInsertPoint(loop_continue);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        builder->CreateBr(loop_condition);

        // Found false: return false
        builder->SetInsertPoint(found_false);
        Value* false_result = packBoolToTaggedValue(ConstantInt::getFalse(*context));
        builder->CreateBr(loop_exit);

        // All passed: return true
        builder->SetInsertPoint(all_passed);
        Value* true_result = packBoolToTaggedValue(ConstantInt::getTrue(*context));
        builder->CreateBr(loop_exit);

        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        PHINode* result = builder->CreatePHI(tagged_value_type, 2, "every_result");
        result->addIncoming(false_result, found_false);
        result->addIncoming(true_result, all_passed);

        return result;
    }

    // Production implementation: Apply function
    // (apply fn args-list) - calls fn with arguments from args-list
    Value* codegenApply(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 2) {
            eshkol_warn("apply requires at least 2 arguments: function and argument list");
            return nullptr;
        }

        // Get the function argument
        const eshkol_ast_t* func_arg = &op->call_op.variables[0];

        // Get the argument list
        Value* arg_list = codegenAST(&op->call_op.variables[1]);
        if (!arg_list) return nullptr;

        // Safely extract i64 from possibly-tagged value
        Value* list_int = safeExtractInt64(arg_list);

        // Check if function is a symbol (built-in or user-defined)
        if (func_arg->type == ESHKOL_VAR) {
            std::string func_name = func_arg->variable.id;

            // Handle variadic built-in arithmetic operations
            if (func_name == "+" || func_name == "-" || func_name == "*" || func_name == "/") {
                return codegenApplyArithmetic(func_name, list_int);
            }

            // Handle list operation
            if (func_name == "list") {
                // (apply list '(1 2 3)) returns the list itself
                return arg_list;
            }

            // Handle cons
            if (func_name == "cons") {
                return codegenApplyCons(list_int);
            }

            // Try to find function by name
            Function* named_func = module->getFunction(func_name);
            if (named_func) {
                return codegenApplyUserFunction(named_func, list_int);
            }

            eshkol_warn("apply: Unknown function: %s", func_name.c_str());
            return packNullToTaggedValue();
        }

        // Handle lambda expression passed directly
        if (func_arg->type == ESHKOL_OP && func_arg->operation.op == ESHKOL_LAMBDA_OP) {
            // For lambdas, we need to compile the lambda and get its function
            Value* lambda_val = codegenAST(func_arg);
            if (!lambda_val) {
                eshkol_warn("apply: Could not compile lambda");
                return packNullToTaggedValue();
            }
            // Lambda creates a closure/function pointer, but apply with lambda is complex
            // For now, warn and return null
            eshkol_warn("apply: Direct lambda application not yet supported");
            return packNullToTaggedValue();
        }

        eshkol_warn("apply: First argument must be a function");
        return packNullToTaggedValue();
    }

    // Helper: Apply cons to a 2-element list
    Value* codegenApplyCons(Value* list_int) {
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list has at least 2 elements
        Value* is_null = builder->CreateICmpEQ(list_int, ConstantInt::get(Type::getInt64Ty(*context), 0));

        BasicBlock* valid_block = BasicBlock::Create(*context, "apply_cons_valid", current_func);
        BasicBlock* error_block = BasicBlock::Create(*context, "apply_cons_error", current_func);

        builder->CreateCondBr(is_null, error_block, valid_block);

        builder->SetInsertPoint(error_block);
        Value* error_result = packNullToTaggedValue();
        BasicBlock* error_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(valid_block);
        Value* first_cons = builder->CreateIntToPtr(list_int, builder->getPtrTy());
        // Use type-safe extraction (avoids ABI issues with returning 16-byte structs)
        Value* first_elem = extractConsCarAsTaggedValue(first_cons);
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* rest_int = builder->CreateCall(arena_tagged_cons_get_ptr_func, {first_cons, is_cdr});

        // Get second element
        Value* rest_null = builder->CreateICmpEQ(rest_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        BasicBlock* has_second = BasicBlock::Create(*context, "apply_cons_has_second", current_func);
        BasicBlock* continue_block = BasicBlock::Create(*context, "apply_cons_continue", current_func);
        builder->CreateCondBr(rest_null, error_block, has_second);

        builder->SetInsertPoint(has_second);
        Value* second_cons = builder->CreateIntToPtr(rest_int, builder->getPtrTy());
        // Use type-safe extraction (avoids ABI issues with returning 16-byte structs)
        Value* second_elem = extractConsCarAsTaggedValue(second_cons);

        // Create cons cell
        Value* result = codegenTaggedArenaConsCellFromTaggedValue(first_elem, second_elem);
        BasicBlock* valid_exit = builder->GetInsertBlock();
        builder->CreateBr(continue_block);

        builder->SetInsertPoint(continue_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "apply_cons_result");
        phi->addIncoming(error_result, error_exit);
        phi->addIncoming(result, valid_exit);

        return phi;
    }

    // Helper: Apply arithmetic operation to list elements
    Value* codegenApplyArithmetic(const std::string& op, Value* list_int) {
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Determine identity element
        Value* identity;
        if (op == "+" || op == "-") {
            identity = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
        } else { // "*" or "/"
            identity = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 1), true);
        }

        // For subtraction and division with list (- a b c) = a - b - c
        // We need to get the first element first, then accumulate
        Value* is_empty = builder->CreateICmpEQ(list_int, ConstantInt::get(Type::getInt64Ty(*context), 0));

        BasicBlock* empty_block = BasicBlock::Create(*context, "apply_arith_empty", current_func);
        BasicBlock* non_empty = BasicBlock::Create(*context, "apply_arith_non_empty", current_func);
        BasicBlock* loop_cond = BasicBlock::Create(*context, "apply_arith_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "apply_arith_body", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "apply_arith_done", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "apply_arith_exit", current_func);

        builder->CreateCondBr(is_empty, empty_block, non_empty);

        // Empty list: return identity
        builder->SetInsertPoint(empty_block);
        builder->CreateBr(loop_exit);

        // Non-empty list: get first element as initial accumulator
        builder->SetInsertPoint(non_empty);
        Value* first_cons = builder->CreateIntToPtr(list_int, builder->getPtrTy());
        // Use type-safe extraction (avoids ABI issues with returning 16-byte structs)
        Value* first_elem = extractConsCarAsTaggedValue(first_cons);
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* rest_list = builder->CreateCall(arena_tagged_cons_get_ptr_func, {first_cons, is_cdr});

        // Allocate accumulator and current pointer
        Value* accum_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "apply_accum");
        builder->CreateStore(first_elem, accum_ptr);
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "apply_current");
        builder->CreateStore(rest_list, current_ptr);

        builder->CreateBr(loop_cond);

        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_cond);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, done_block);

        // Loop body: apply operation
        builder->SetInsertPoint(loop_body);
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        // Use type-safe extraction (avoids ABI issues with returning 16-byte structs)
        Value* elem = extractConsCarAsTaggedValue(cons_ptr);
        Value* accum = builder->CreateLoad(tagged_value_type, accum_ptr);

        // Apply the operation using polymorphic functions
        Value* new_accum;
        if (op == "+") {
            new_accum = polymorphicAdd(accum, elem);
        } else if (op == "-") {
            new_accum = polymorphicSub(accum, elem);
        } else if (op == "*") {
            new_accum = polymorphicMul(accum, elem);
        } else { // "/"
            new_accum = polymorphicDiv(accum, elem);
        }

        builder->CreateStore(new_accum, accum_ptr);

        // Move to next element
        Value* next_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(next_val, current_ptr);
        builder->CreateBr(loop_cond);

        // Done block: load final accumulator value
        builder->SetInsertPoint(done_block);
        Value* final_accum = builder->CreateLoad(tagged_value_type, accum_ptr);
        builder->CreateBr(loop_exit);

        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        PHINode* result = builder->CreatePHI(tagged_value_type, 2, "apply_result");
        result->addIncoming(identity, empty_block);
        result->addIncoming(final_accum, done_block);

        return result;
    }

    // Helper: Apply user-defined function to list arguments
    Value* codegenApplyUserFunction(Function* func, Value* list_int) {
        // Get function parameter count
        size_t num_params = func->arg_size();

        // If function expects 0 arguments, just call it
        if (num_params == 0) {
            return builder->CreateCall(func, {});
        }

        // Extract arguments from list
        std::vector<Value*> args;
        Value* current = list_int;

        for (size_t i = 0; i < num_params; i++) {
            // Check if we have more elements
            Value* is_null = builder->CreateICmpEQ(current, ConstantInt::get(Type::getInt64Ty(*context), 0));

            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* has_elem = BasicBlock::Create(*context, "apply_has_elem", current_func);
            BasicBlock* no_elem = BasicBlock::Create(*context, "apply_no_elem", current_func);
            BasicBlock* continue_block = BasicBlock::Create(*context, "apply_continue", current_func);

            builder->CreateCondBr(is_null, no_elem, has_elem);

            // No element: use null as default
            builder->SetInsertPoint(no_elem);
            Value* default_val = packNullToTaggedValue();
            builder->CreateBr(continue_block);

            // Has element: extract it
            builder->SetInsertPoint(has_elem);
            Value* cons_ptr = builder->CreateIntToPtr(current, builder->getPtrTy());
            // Use type-safe extraction (avoids ABI issues with returning 16-byte structs)
            Value* elem = extractConsCarAsTaggedValue(cons_ptr);
            Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
            Value* next = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
            builder->CreateBr(continue_block);

            // Continue: use PHI to merge
            builder->SetInsertPoint(continue_block);
            PHINode* arg_phi = builder->CreatePHI(tagged_value_type, 2, "apply_arg");
            arg_phi->addIncoming(default_val, no_elem);
            arg_phi->addIncoming(elem, has_elem);

            PHINode* next_phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "apply_next");
            next_phi->addIncoming(ConstantInt::get(Type::getInt64Ty(*context), 0), no_elem);
            next_phi->addIncoming(next, has_elem);

            args.push_back(arg_phi);
            current = next_phi;
        }

        // Call the function with extracted arguments
        return builder->CreateCall(func, args);
    }

    // Production implementation: Association list functions
    Value* codegenAssoc(const eshkol_operations_t* op, const std::string& comparison_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("assoc requires exactly 2 arguments: key and alist");
            return nullptr;
        }
        
        Value* key = codegenAST(&op->call_op.variables[0]);
        Value* alist = codegenAST(&op->call_op.variables[1]);
        if (!key || !alist) return nullptr;
        
        // POLYMORPHIC FIX: Keep key as tagged_value for proper type comparison
        TypedValue key_typed = detectValueType(key);
        Value* key_tagged = typedValueToTaggedValue(key_typed);
        Value* alist_int = safeExtractInt64(alist);
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Initialize current pointer for alist traversal
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "assoc_current");
        builder->CreateStore(alist_int, current_ptr);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "assoc_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "assoc_loop_body", current_func);
        BasicBlock* check_key = BasicBlock::Create(*context, "assoc_check_key", current_func);
        BasicBlock* found_match = BasicBlock::Create(*context, "assoc_found", current_func);
        BasicBlock* continue_search = BasicBlock::Create(*context, "assoc_continue", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "assoc_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: get current association pair
        builder->SetInsertPoint(loop_body);
        
        Value* alist_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car of alist element (should be a pair) using tagged helper
        Value* current_pair_tagged = extractCarAsTaggedValue(current_val);
        Value* current_pair = unpackInt64FromTaggedValue(current_pair_tagged);
        
        // Check if current_pair is actually a pair (not null)
        Value* pair_is_valid = builder->CreateICmpNE(current_pair, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(pair_is_valid, check_key, continue_search);
        
        // Check key: extract key from pair and compare
        builder->SetInsertPoint(check_key);
        
        // Extract key from pair (car of the pair) using tagged helper
        Value* pair_key_tagged = extractCarAsTaggedValue(current_pair);
        
        // POLYMORPHIC FIX: Use polymorphicCompare for mixed-type equality
        Value* comparison_result = polymorphicCompare(key_tagged, pair_key_tagged, "eq");
        Value* comparison_int = unpackInt64FromTaggedValue(comparison_result);
        Value* keys_match = builder->CreateICmpNE(comparison_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        builder->CreateCondBr(keys_match, found_match, continue_search);
        
        // Found match: return the entire pair
        builder->SetInsertPoint(found_match);
        builder->CreateBr(loop_exit);
        
        // Continue search: move to next element in alist using tagged helper
        builder->SetInsertPoint(continue_search);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* alist_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {alist_cons_ptr, is_cdr_get});
        builder->CreateStore(alist_cdr, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return current_pair if found, or null if not found
        builder->SetInsertPoint(loop_exit);
        Value* final_current = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        // If we're here from found_match, we want to return the pair
        // If we're here from normal loop exit, current_ptr will be null
        Value* is_found = builder->CreateICmpNE(final_current, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* return_pair = BasicBlock::Create(*context, "assoc_return_pair", current_func);
        BasicBlock* return_false = BasicBlock::Create(*context, "assoc_return_false", current_func);
        BasicBlock* final_return = BasicBlock::Create(*context, "assoc_final_return", current_func);
        
        builder->CreateCondBr(is_found, return_pair, return_false);
        
        // FIX: Return the pair if found using tagged helper
        builder->SetInsertPoint(return_pair);
        Value* found_pair_tagged = extractCarAsTaggedValue(final_current);
        Value* found_pair = unpackInt64FromTaggedValue(found_pair_tagged);
        builder->CreateBr(final_return);
        BasicBlock* return_pair_exit = builder->GetInsertBlock(); // CRITICAL FIX: Capture actual predecessor!
        
        // Return false/null if not found
        builder->SetInsertPoint(return_false);
        Value* false_result = ConstantInt::get(Type::getInt64Ty(*context), 0);
        builder->CreateBr(final_return);
        BasicBlock* return_false_exit = builder->GetInsertBlock();
        
        // FIX: Use actual predecessor blocks in PHI node
        builder->SetInsertPoint(final_return);
        PHINode* phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "assoc_result");
        phi->addIncoming(found_pair, return_pair_exit);  // FIXED: Use actual predecessor
        phi->addIncoming(false_result, return_false_exit);
        
        return phi;
    }
    
    // Production implementation: List* (improper list constructor)
    Value* codegenListStar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars == 0) {
            eshkol_warn("list* requires at least 1 argument");
            return nullptr;
        }
        
        // Single argument case: just return the argument itself
        if (op->call_op.num_vars == 1) {
            return codegenAST(&op->call_op.variables[0]);
        }
        
        // Multiple arguments: build improper list where last element is the terminal
        // (list* 1 2 3 4) => (1 . (2 . (3 . 4)))  (4 is terminal, not null)
        
        // Start with the last element as terminal
        Value* result = codegenAST(&op->call_op.variables[op->call_op.num_vars - 1]);
        if (!result) return ConstantInt::get(Type::getInt64Ty(*context), 0);
        
        // Build cons chain from second-to-last element backwards to first
        for (int64_t i = op->call_op.num_vars - 2; i >= 0; i--) {
            Value* element = codegenAST(&op->call_op.variables[i]);
            if (element) {
                // Create cons cell: (element . result) with type preservation
                TypedValue element_typed = detectValueType(element);
                TypedValue result_typed = detectValueType(result);
                result = codegenTaggedArenaConsCell(element_typed, result_typed);
            }
        }
        
        return result;
    }
    
    // Production implementation: Acons (association constructor)
    Value* codegenAcons(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("acons requires exactly 3 arguments: key, value, and alist");
            return nullptr;
        }
        
        Value* key = codegenAST(&op->call_op.variables[0]);
        Value* value = codegenAST(&op->call_op.variables[1]);
        Value* alist = codegenAST(&op->call_op.variables[2]);
        
        if (!key || !value || !alist) return nullptr;
        
        // Create new key-value pair: (key . value) with type preservation
        TypedValue key_typed = detectValueType(key);
        TypedValue value_typed = detectValueType(value);
        Value* new_pair = codegenTaggedArenaConsCell(key_typed, value_typed);
        
        // Cons the new pair onto the existing alist: ((key . value) . alist)
        TypedValue pair_typed = TypedValue(new_pair, ESHKOL_VALUE_CONS_PTR, true);
        TypedValue alist_typed = detectValueType(alist);
        Value* new_alist = codegenTaggedArenaConsCell(pair_typed, alist_typed);
        
        return new_alist;
    }
    
    // Production implementation: Take function (first n elements)
    Value* codegenTake(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("take requires exactly 2 arguments: list and n");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        Value* n_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw || !n_raw) return nullptr;

        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);
        Value* n = safeExtractInt64(n_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - causes memory corruption
        // Arena scope pop resets used pointer, making cons cells available for reuse
        // Take results must persist in arena memory
        
        // Initialize result list
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "take_result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "take_result_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "take_current");
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "take_counter");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        builder->CreateStore(list, current_input);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "take_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "take_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "take_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < n AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        
        Value* count_less = builder->CreateICmpULT(count_val, n);
        Value* input_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_take = builder->CreateAnd(count_less, input_not_null);
        
        builder->CreateCondBr(continue_take, loop_body, loop_exit);
        
        // Loop body: take current element and advance
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Create NULL tagged value
        Value* cdr_null_tagged = packNullToTaggedValue();
        
        // Create new cons cell directly from tagged values (preserves types!)
        Value* new_result_cons = codegenTaggedArenaConsCellFromTaggedValue(
            input_element_tagged, cdr_null_tagged);
        
        // Update result list (similar to map)
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "take_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "take_update_tail", current_func);
        BasicBlock* continue_take_loop = BasicBlock::Create(*context, "take_continue", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_take_loop);
        
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type_tag});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(continue_take_loop);
        
        // Continue: move to next input element and increment counter
        builder->SetInsertPoint(continue_take_loop);
        
        // Use arena_tagged_cons_get_ptr_func to get cdr
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return final_result;
    }
    
    // Production implementation: Drop function (skip first n elements)
    Value* codegenDrop(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("drop requires exactly 2 arguments: list and n");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        Value* n_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw || !n_raw) return nullptr;

        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);
        Value* n = safeExtractInt64(n_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Initialize current pointer and counter
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "drop_current");
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "drop_counter");

        builder->CreateStore(list, current_ptr);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "drop_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "drop_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "drop_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < n AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        Value* count_less = builder->CreateICmpULT(count_val, n);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_drop = builder->CreateAnd(count_less, current_not_null);
        
        builder->CreateCondBr(continue_drop, loop_body, loop_exit);
        
        builder->SetInsertPoint(loop_body);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        // Increment counter
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return remaining list
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
    }
    
    // Production implementation: Find function (first element matching predicate)
    Value* codegenFind(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("find requires exactly 2 arguments: predicate and list");
            return nullptr;
        }
        
        // Get predicate function
        Value* predicate = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!predicate) {
            eshkol_error("Failed to resolve predicate for find");
            return nullptr;
        }
        
        Function* pred_func = dyn_cast<Function>(predicate);
        if (!pred_func) {
            eshkol_error("find predicate must be a function");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Initialize current pointer
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "find_current");
        builder->CreateStore(list, current_ptr);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "find_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "find_loop_body", current_func);
        BasicBlock* found_element = BasicBlock::Create(*context, "find_found", current_func);
        BasicBlock* continue_search = BasicBlock::Create(*context, "find_continue", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "find_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: check predicate on current element
        builder->SetInsertPoint(loop_body);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* current_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Apply predicate to current element (pass tagged_value directly)
        Value* pred_result = builder->CreateCall(pred_func, {current_element_tagged});
        
        // Predicate returns tagged_value - unpack to check boolean result
        Value* pred_result_int = unpackInt64FromTaggedValue(pred_result);
        
        // Check if predicate returned true (non-zero)
        Value* pred_is_true = builder->CreateICmpNE(pred_result_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(pred_is_true, found_element, continue_search);
        
        // Found element: return the element itself
        builder->SetInsertPoint(found_element);
        builder->CreateBr(loop_exit);
        
        // Continue search: move to next element using tagged helper
        builder->SetInsertPoint(continue_search);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {cons_ptr, is_cdr_get});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return element if found, or null if not found
        builder->SetInsertPoint(loop_exit);
        Value* final_current = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        Value* is_found = builder->CreateICmpNE(final_current, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* return_element = BasicBlock::Create(*context, "find_return_elem", current_func);
        BasicBlock* return_null = BasicBlock::Create(*context, "find_return_null", current_func);
        BasicBlock* final_return = BasicBlock::Create(*context, "find_final_return", current_func);
        
        builder->CreateCondBr(is_found, return_element, return_null);
        
        // Return the element if found using tagged helper
        builder->SetInsertPoint(return_element);
        Value* found_element_tagged = extractCarAsTaggedValue(final_current);
        Value* found_element_val = unpackInt64FromTaggedValue(found_element_tagged);
        builder->CreateBr(final_return);
        BasicBlock* return_element_exit = builder->GetInsertBlock(); // CRITICAL FIX: Capture actual predecessor
        
        // Return null if not found
        builder->SetInsertPoint(return_null);
        Value* null_result = ConstantInt::get(Type::getInt64Ty(*context), 0);
        builder->CreateBr(final_return);
        BasicBlock* return_null_exit = builder->GetInsertBlock();
        
        builder->SetInsertPoint(final_return);
        PHINode* phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "find_result");
        phi->addIncoming(found_element_val, return_element_exit);  // Use actual predecessor
        phi->addIncoming(null_result, return_null_exit);
        
        return phi;
    }
    
    // Production implementation: Partition function (split list by predicate)
    Value* codegenPartition(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("partition requires exactly 2 arguments: predicate and list");
            return nullptr;
        }
        
        // Get predicate function
        Value* predicate = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!predicate) {
            eshkol_error("Failed to resolve predicate for partition");
            return nullptr;
        }
        
        Function* pred_func = dyn_cast<Function>(predicate);
        if (!pred_func) {
            eshkol_error("partition predicate must be a function");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - partition results must persist
        // Arena scoping causes memory corruption by resetting used pointer
        
        // Initialize two result lists: true_list and false_list
        Value* true_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "partition_true_head");
        Value* true_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "partition_true_tail");
        Value* false_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "partition_false_head");
        Value* false_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "partition_false_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "partition_current");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), true_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), true_tail);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), false_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), false_tail);
        builder->CreateStore(list, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "partition_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "partition_loop_body", current_func);
        BasicBlock* add_to_true = BasicBlock::Create(*context, "partition_add_true", current_func);
        BasicBlock* add_to_false = BasicBlock::Create(*context, "partition_add_false", current_func);
        BasicBlock* continue_partition = BasicBlock::Create(*context, "partition_continue", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "partition_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: get current element and check predicate
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Apply predicate to current element (pass tagged_value directly)
        Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});
        
        // Predicate returns tagged_value - unpack to check boolean result
        Value* pred_result_int = unpackInt64FromTaggedValue(pred_result);
        
        // Check if predicate returned true (non-zero)
        Value* pred_is_true = builder->CreateICmpNE(pred_result_int, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(pred_is_true, add_to_true, add_to_false);
        
        // Add element to true list if predicate is true
        builder->SetInsertPoint(add_to_true);
        TypedValue elem_typed_true = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null_true = TypedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL);
        Value* new_true_cons = codegenTaggedArenaConsCell(elem_typed_true, cdr_null_true);
        
        // Update true list
        Value* true_head_val = builder->CreateLoad(Type::getInt64Ty(*context), true_head);
        Value* true_head_empty = builder->CreateICmpEQ(true_head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_true_head = BasicBlock::Create(*context, "partition_set_true_head", current_func);
        BasicBlock* update_true_tail = BasicBlock::Create(*context, "partition_update_true_tail", current_func);
        
        builder->CreateCondBr(true_head_empty, set_true_head, update_true_tail);
        
        builder->SetInsertPoint(set_true_head);
        builder->CreateStore(new_true_cons, true_head);
        builder->CreateStore(new_true_cons, true_tail);
        builder->CreateBr(continue_partition);
        
        builder->SetInsertPoint(update_true_tail);
        Value* true_tail_val = builder->CreateLoad(Type::getInt64Ty(*context), true_tail);
        Value* true_tail_cons_ptr = builder->CreateIntToPtr(true_tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set_true = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {true_tail_cons_ptr, is_cdr_set_true, new_true_cons, ptr_type_tag});
        builder->CreateStore(new_true_cons, true_tail);
        builder->CreateBr(continue_partition);
        
        // Add element to false list if predicate is false
        builder->SetInsertPoint(add_to_false);
        TypedValue elem_typed_false = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null_false = TypedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL);
        Value* new_false_cons = codegenTaggedArenaConsCell(elem_typed_false, cdr_null_false);
        
        // Update false list
        Value* false_head_val = builder->CreateLoad(Type::getInt64Ty(*context), false_head);
        Value* false_head_empty = builder->CreateICmpEQ(false_head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_false_head = BasicBlock::Create(*context, "partition_set_false_head", current_func);
        BasicBlock* update_false_tail = BasicBlock::Create(*context, "partition_update_false_tail", current_func);
        
        builder->CreateCondBr(false_head_empty, set_false_head, update_false_tail);
        
        builder->SetInsertPoint(set_false_head);
        builder->CreateStore(new_false_cons, false_head);
        builder->CreateStore(new_false_cons, false_tail);
        builder->CreateBr(continue_partition);
        
        builder->SetInsertPoint(update_false_tail);
        Value* false_tail_val = builder->CreateLoad(Type::getInt64Ty(*context), false_tail);
        Value* false_tail_cons_ptr = builder->CreateIntToPtr(false_tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set_false = ConstantInt::get(Type::getInt1Ty(*context), 1);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {false_tail_cons_ptr, is_cdr_set_false, new_false_cons, ptr_type_tag});
        builder->CreateStore(new_false_cons, false_tail);
        builder->CreateBr(continue_partition);
        
        // Continue: move to next input element using tagged helper
        builder->SetInsertPoint(continue_partition);
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return pair of (true_list . false_list)
        builder->SetInsertPoint(loop_exit);
        Value* final_true_list = builder->CreateLoad(Type::getInt64Ty(*context), true_head);
        Value* final_false_list = builder->CreateLoad(Type::getInt64Ty(*context), false_head);
        
        // Create result pair: (true_list . false_list) with type preservation
        TypedValue true_typed = TypedValue(final_true_list,
            final_true_list == ConstantInt::get(Type::getInt64Ty(*context), 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        TypedValue false_typed = TypedValue(final_false_list,
            final_false_list == ConstantInt::get(Type::getInt64Ty(*context), 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        Value* result_pair = codegenTaggedArenaConsCell(true_typed, false_typed);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return result_pair;
    }
    
    // Production implementation: Split-at function (split list at index)
    Value* codegenSplitAt(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("split-at requires exactly 2 arguments: list and index");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        Value* index_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw || !index_raw) return nullptr;

        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);
        Value* index = safeExtractInt64(index_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - split-at results must persist
        // Arena scoping causes memory corruption by resetting used pointer

        // Initialize result lists: prefix and suffix
        Value* prefix_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "splitat_prefix_head");
        Value* prefix_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "splitat_prefix_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "splitat_current");
        Value* counter = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "splitat_counter");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), prefix_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), prefix_tail);
        builder->CreateStore(list, current_input);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), counter);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "splitat_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "splitat_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "splitat_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < index AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(Type::getInt64Ty(*context), counter);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        
        Value* count_less = builder->CreateICmpULT(count_val, index);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        Value* continue_loop = builder->CreateAnd(count_less, current_not_null);
        
        builder->CreateCondBr(continue_loop, loop_body, loop_exit);
        
        // Loop body: take current element for prefix and advance
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value and convert to TypedValue
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        TypedValue input_element_typed = taggedValueToTypedValue(input_element_tagged);
        
        // Create new cons cell for prefix with type preservation
        TypedValue cdr_null = TypedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL);
        Value* new_prefix_cons = codegenTaggedArenaConsCell(input_element_typed, cdr_null);
        
        // Update prefix list (similar to take)
        Value* prefix_head_val = builder->CreateLoad(Type::getInt64Ty(*context), prefix_head);
        Value* prefix_head_empty = builder->CreateICmpEQ(prefix_head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_prefix_head = BasicBlock::Create(*context, "splitat_set_prefix_head", current_func);
        BasicBlock* update_prefix_tail = BasicBlock::Create(*context, "splitat_update_prefix_tail", current_func);
        BasicBlock* continue_splitat = BasicBlock::Create(*context, "splitat_continue", current_func);
        
        builder->CreateCondBr(prefix_head_empty, set_prefix_head, update_prefix_tail);
        
        builder->SetInsertPoint(set_prefix_head);
        builder->CreateStore(new_prefix_cons, prefix_head);
        builder->CreateStore(new_prefix_cons, prefix_tail);
        builder->CreateBr(continue_splitat);
        
        builder->SetInsertPoint(update_prefix_tail);
        Value* prefix_tail_val = builder->CreateLoad(Type::getInt64Ty(*context), prefix_tail);
        Value* prefix_tail_cons_ptr = builder->CreateIntToPtr(prefix_tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {prefix_tail_cons_ptr, is_cdr_set, new_prefix_cons, ptr_type_tag});
        builder->CreateStore(new_prefix_cons, prefix_tail);
        builder->CreateBr(continue_splitat);
        
        // Continue: move to next input element and increment counter
        builder->SetInsertPoint(continue_splitat);
        
        // Use arena_tagged_cons_get_ptr_func to get cdr
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(Type::getInt64Ty(*context), 1));
        builder->CreateStore(new_count, counter);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return pair of (prefix . suffix)
        builder->SetInsertPoint(loop_exit);
        Value* final_prefix = builder->CreateLoad(Type::getInt64Ty(*context), prefix_head);
        Value* final_suffix = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        
        // Create result pair: (prefix . suffix) with type preservation
        TypedValue prefix_typed = TypedValue(final_prefix,
            final_prefix == ConstantInt::get(Type::getInt64Ty(*context), 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        TypedValue suffix_typed = TypedValue(final_suffix,
            final_suffix == ConstantInt::get(Type::getInt64Ty(*context), 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        Value* result_pair = codegenTaggedArenaConsCell(prefix_typed, suffix_typed);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return result_pair;
    }
    
    // Production implementation: Remove function family (remove elements that match)
    Value* codegenRemove(const eshkol_operations_t* op, const std::string& comparison_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("remove requires exactly 2 arguments: item and list");
            return nullptr;
        }
        
        Value* item = codegenAST(&op->call_op.variables[0]);
        Value* list = codegenAST(&op->call_op.variables[1]);
        if (!item || !list) return nullptr;
        
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* item_int = safeExtractInt64(item);
        Value* list_int = safeExtractInt64(list);
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // CRITICAL FIX: Do not use arena scoping - remove results must persist
        // Arena scoping causes memory corruption by resetting used pointer
        
        // Initialize result list
        Value* result_head = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "remove_result_head");
        Value* result_tail = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "remove_result_tail");
        Value* current_input = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "remove_current");
        
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_head);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), result_tail);
        builder->CreateStore(list_int, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "remove_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "remove_loop_body", current_func);
        BasicBlock* skip_element = BasicBlock::Create(*context, "remove_skip_elem", current_func);
        BasicBlock* keep_element = BasicBlock::Create(*context, "remove_keep_elem", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "remove_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: get current element and check if it matches item to remove
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        Value* input_element = unpackInt64FromTaggedValue(input_element_tagged);
        
        // Compare current element with item to remove
        Value* is_match = nullptr;
        if (comparison_type == "equal" || comparison_type == "eqv") {
            // Value equality comparison
            is_match = builder->CreateICmpEQ(input_element, item_int);
        } else if (comparison_type == "eq") {
            // Pointer equality comparison (same as eqv for our int64 values)
            is_match = builder->CreateICmpEQ(input_element, item_int);
        }
        
        // If it matches, skip it; if it doesn't match, keep it
        builder->CreateCondBr(is_match, skip_element, keep_element);
        
        // Keep element (doesn't match item to remove)
        builder->SetInsertPoint(keep_element);
        TypedValue elem_typed = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null = TypedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), ESHKOL_VALUE_NULL);
        Value* new_result_cons = codegenTaggedArenaConsCell(elem_typed, cdr_null);
        
        // Update result list
        Value* head_val = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "remove_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "remove_update_tail", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(Type::getInt64Ty(*context), result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use arena_tagged_cons_set_ptr_func to set cdr
        Value* is_cdr_set = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* ptr_type_tag = ConstantInt::get(Type::getInt8Ty(*context), ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(arena_tagged_cons_set_ptr_func,
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type_tag});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        // Skip element: move to next input element (for both keep and remove cases)
        builder->SetInsertPoint(skip_element);
        
        // Use arena_tagged_cons_get_ptr_func to get cdr
        Value* is_cdr_get = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* input_cdr = builder->CreateCall(arena_tagged_cons_get_ptr_func,
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(Type::getInt64Ty(*context), result_head);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return final_result;
    }
    
    // Production implementation: Last function (return last element)
    Value* codegenLast(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("last requires exactly 1 argument: list");
            return nullptr;
        }

        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list is empty
        Value* list_is_empty = builder->CreateICmpEQ(list, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* empty_case = BasicBlock::Create(*context, "last_empty", current_func);
        BasicBlock* traverse_case = BasicBlock::Create(*context, "last_traverse", current_func);
        BasicBlock* loop_condition = BasicBlock::Create(*context, "last_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "last_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "last_loop_exit", current_func);
        BasicBlock* final_block = BasicBlock::Create(*context, "last_final", current_func);
        
        builder->CreateCondBr(list_is_empty, empty_case, traverse_case);
        
        // Empty case: return null (0)
        builder->SetInsertPoint(empty_case);
        Value* null_tagged_for_empty = packNullToTaggedValue();  // CRITICAL FIX: Create before branching!
        builder->CreateBr(final_block);
        
        // Traverse case: find last element
        builder->SetInsertPoint(traverse_case);
        
        // Initialize current and previous pointers
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "last_current");
        Value* previous_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "last_previous");
        
        builder->CreateStore(list, current_ptr);
        builder->CreateStore(ConstantInt::get(Type::getInt64Ty(*context), 0), previous_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(current_not_null, loop_body, loop_exit);
        
        // Loop body: advance to next element
        builder->SetInsertPoint(loop_body);
        
        // Store current as previous
        builder->CreateStore(current_val, previous_ptr);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        builder->SetInsertPoint(loop_exit);
        Value* last_cons = builder->CreateLoad(Type::getInt64Ty(*context), previous_ptr);
        
        // CRITICAL FIX: Use extractCarAsTaggedValue - no bitcast needed!
        // Extract last element as tagged_value (preserves type correctly)
        Value* last_element_tagged = extractCarAsTaggedValue(last_cons);
        BasicBlock* actual_loop_exit = builder->GetInsertBlock();  // CAPTURE ACTUAL PREDECESSOR!
        builder->CreateBr(final_block);
        
        // Final result selection - return tagged_value
        // CRITICAL FIX: PHI nodes must be first in basic block!
        builder->SetInsertPoint(final_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "last_result");
        phi->addIncoming(null_tagged_for_empty, empty_case); // null for empty list
        phi->addIncoming(last_element_tagged, actual_loop_exit);  // USE ACTUAL PREDECESSOR!
        
        return phi;
    }
    
    // Production implementation: Last-pair function (return last cons cell)
    Value* codegenLastPair(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("last-pair requires exactly 1 argument: list");
            return nullptr;
        }

        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list is empty
        Value* list_is_empty = builder->CreateICmpEQ(list, ConstantInt::get(Type::getInt64Ty(*context), 0));
        
        BasicBlock* empty_case = BasicBlock::Create(*context, "lastpair_empty", current_func);
        BasicBlock* traverse_case = BasicBlock::Create(*context, "lastpair_traverse", current_func);
        BasicBlock* loop_condition = BasicBlock::Create(*context, "lastpair_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "lastpair_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "lastpair_loop_exit", current_func);
        BasicBlock* final_block = BasicBlock::Create(*context, "lastpair_final", current_func);
        
        builder->CreateCondBr(list_is_empty, empty_case, traverse_case);
        
        // Empty case: return null (0)
        builder->SetInsertPoint(empty_case);
        builder->CreateBr(final_block);
        
        // Traverse case: find last pair (cons cell where cdr is null)
        builder->SetInsertPoint(traverse_case);
        
        // Initialize current pointer
        Value* current_ptr = builder->CreateAlloca(Type::getInt64Ty(*context), nullptr, "lastpair_current");
        builder->CreateStore(list, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(Type::getInt1Ty(*context), 1);
        Value* cdr_val = builder->CreateCall(arena_tagged_cons_get_ptr_func, {cons_ptr, is_cdr});
        
        // Check if cdr is null (this is the last pair)
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_val, ConstantInt::get(Type::getInt64Ty(*context), 0));
        builder->CreateCondBr(cdr_is_null, loop_exit, loop_body);
        
        // Loop body: advance to next element
        builder->SetInsertPoint(loop_body);
        builder->CreateStore(cdr_val, current_ptr);
        builder->CreateBr(loop_condition);
        
        // Loop exit: current contains the last pair
        builder->SetInsertPoint(loop_exit);
        Value* last_pair = builder->CreateLoad(Type::getInt64Ty(*context), current_ptr);
        builder->CreateBr(final_block);
        
        // Final result selection
        builder->SetInsertPoint(final_block);
        PHINode* phi = builder->CreatePHI(Type::getInt64Ty(*context), 2, "lastpair_result");
        phi->addIncoming(ConstantInt::get(Type::getInt64Ty(*context), 0), empty_case); // null for empty list
        phi->addIncoming(last_pair, loop_exit);
        
        return phi;
    }
    
    // Production implementation: Create arity-specific builtin arithmetic functions (POLYMORPHIC)
    Function* createBuiltinArithmeticFunction(const std::string& operation, size_t arity) {
        // FIX: For arity=0, just use arity=2 (fold will call with 2 args anyway)
        if (arity == 0) {
            eshkol_debug("Arity 0 requested for %s, using arity 2 instead", operation.c_str());
            arity = 2;
        }
        
        // Use deterministic names based on operation and arity only
        std::string func_name = "builtin_" + operation + "_" + std::to_string(arity) + "arg";
        
        // Check if function already exists
        auto existing_it = function_table.find(func_name);
        if (existing_it != function_table.end()) {
            return existing_it->second;
        }
        
        // Create polymorphic function type with tagged_value parameters
        std::vector<Type*> param_types(arity, tagged_value_type);
        FunctionType* func_type = FunctionType::get(
            tagged_value_type,  // Return tagged_value
            param_types,
            false // not varargs
        );
        
        Function* builtin_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );
        
        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", builtin_func);
        builder->SetInsertPoint(entry);
        
        // Apply polymorphic operation to all arguments (binary reduction)
        auto arg_it = builtin_func->arg_begin();
        Value* result = &*arg_it++;
        
        for (size_t i = 1; i < arity && arg_it != builtin_func->arg_end(); ++i, ++arg_it) {
            Value* operand = &*arg_it;
            
            if (operation == "+") {
                result = polymorphicAdd(result, operand);
            } else if (operation == "-") {
                result = polymorphicSub(result, operand);
            } else if (operation == "*") {
                result = polymorphicMul(result, operand);
            } else if (operation == "/") {
                result = polymorphicDiv(result, operand);
            } else {
                eshkol_error("Unknown arithmetic operation: %s", operation.c_str());
                result = packInt64ToTaggedValue(ConstantInt::get(Type::getInt64Ty(*context), 0), true);
                break;
            }
        }
        
        builder->CreateRet(result);
        
        // Restore IRBuilder state
        if (old_point.isSet()) {
            builder->restoreIP(old_point);
        }
        
        // Add to function table
        registerContextFunction(func_name, builtin_func);
        
        eshkol_debug("Created polymorphic builtin function: %s for operation '%s' with arity %zu",
                    func_name.c_str(), operation.c_str(), arity);
        
        return builtin_func;
    }
};

extern "C" {

LLVMModuleRef eshkol_generate_llvm_ir(const eshkol_ast_t* asts, size_t num_asts, const char* module_name) {
    try {
        EshkolLLVMCodeGen codegen(module_name);
        auto result = codegen.generateIR(asts, num_asts);
        
        if (!result.first || !result.second) {
            return nullptr;
        }
        
        // Create wrapper and store in global map for lifetime management
        Module* raw_module = result.first.get();
        LLVMModuleRef module_ref = wrap(raw_module);
        
        auto wrapper = std::make_unique<EshkolLLVMModule>(std::move(result.first), std::move(result.second));
        g_llvm_modules[module_ref] = std::move(wrapper);
        
        return module_ref;
    } catch (const std::exception& e) {
        eshkol_error("Failed to generate LLVM IR: %s", e.what());
        return nullptr;
    }
}

// REPL MODE API FUNCTIONS

void eshkol_repl_enable() {
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_mode_enabled = true;
}

void eshkol_repl_disable() {
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_mode_enabled = false;
    g_repl_symbol_addresses.clear();
    g_repl_function_addresses.clear();
    g_repl_function_arities.clear();
}

void eshkol_repl_register_symbol(const char* name, uint64_t address) {
    if (!name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_symbol_addresses[name] = address;
}

void eshkol_repl_register_function(const char* name, uint64_t address, size_t arity) {
    if (!name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_function_addresses[name] = address;
    g_repl_function_arities[name] = arity;
}

void eshkol_repl_register_lambda_name(const char* var_name, const char* lambda_name) {
    if (!var_name || !lambda_name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_lambda_names[var_name] = lambda_name;
}

void eshkol_repl_register_sexpr(const char* sexpr_name, uint64_t sexpr_value) {
    if (!sexpr_name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_sexpr_values[sexpr_name] = sexpr_value;
}

void eshkol_print_llvm_ir(LLVMModuleRef module_ref) {
    if (!module_ref) return;
    
    Module* module = unwrap(module_ref);
    module->print(outs(), nullptr);
}

int eshkol_dump_llvm_ir_to_file(LLVMModuleRef module_ref, const char* filename) {
    if (!module_ref || !filename) return -1;
    
    Module* module = unwrap(module_ref);
    
    std::error_code ec;
    raw_fd_ostream file(filename, ec, sys::fs::OF_None);
    
    if (ec) {
        eshkol_error("Failed to open file %s: %s", filename, ec.message().c_str());
        return -1;
    }
    
    module->print(file, nullptr);
    return 0;
}

int eshkol_compile_llvm_ir_to_object(LLVMModuleRef module_ref, const char* filename) {
    if (!module_ref || !filename) return -1;
    
    auto it = g_llvm_modules.find(module_ref);
    if (it == g_llvm_modules.end()) {
        eshkol_error("Invalid LLVM module reference");
        return -1;
    }
    
    Module* module = it->second->module.get();
    // LLVMContext* context = it->second->context.get(); // Unused for object compilation
    
    try {
        // Initialize target
        Triple target_triple(sys::getDefaultTargetTriple());
        module->setTargetTriple(target_triple);
        
        std::string error;
        const Target* target = TargetRegistry::lookupTarget(target_triple.getTriple(), error);
        if (!target) {
            eshkol_error("Failed to lookup target: %s", error.c_str());
            return -1;
        }
        
        // Create target machine
        TargetOptions target_options;
        std::unique_ptr<TargetMachine> target_machine(
            target->createTargetMachine(target_triple, "generic", "", target_options, 
                                       Reloc::PIC_));
        
        if (!target_machine) {
            eshkol_error("Failed to create target machine");
            return -1;
        }
        
        // Set data layout
        module->setDataLayout(target_machine->createDataLayout());
        
        // Open output file
        std::error_code ec;
        raw_fd_ostream dest(filename, ec, sys::fs::OF_None);
        if (ec) {
            eshkol_error("Failed to open object file %s: %s", filename, ec.message().c_str());
            return -1;
        }
        
        // Create pass manager and emit object file
        legacy::PassManager pass_manager;
        if (target_machine->addPassesToEmitFile(pass_manager, dest, nullptr, 
                                              CodeGenFileType::ObjectFile)) {
            eshkol_error("Target machine cannot emit object files");
            return -1;
        }
        
        pass_manager.run(*module);
        dest.flush();
        
        eshkol_info("Successfully generated object file: %s", filename);
        return 0;
        
    } catch (const std::exception& e) {
        eshkol_error("Exception during object file generation: %s", e.what());
        return -1;
    }
}

int eshkol_compile_llvm_ir_to_executable(LLVMModuleRef module_ref, const char* filename, 
                                        const char* const* lib_paths, size_t num_lib_paths,
                                        const char* const* linked_libs, size_t num_linked_libs) {
    if (!module_ref || !filename) return -1;
    
    // First compile to temporary object file
    std::string temp_obj = std::string(filename) + ".tmp.o";
    if (eshkol_compile_llvm_ir_to_object(module_ref, temp_obj.c_str()) != 0) {
        return -1;
    }
    
    try {
        // Get absolute path to build directory where libeshkol-static.a is located
        char cwd[4096];
        if (getcwd(cwd, sizeof(cwd)) != nullptr) {
            std::string build_dir = std::string(cwd) + "/build";
            eshkol_debug("Adding library search path: %s", build_dir.c_str());
        }
        
        // Use system linker to create executable
        std::string link_cmd = "c++ -fPIE " + temp_obj + " -lm";
        
        // Add library search paths FIRST (before -l flags)
        if (lib_paths && num_lib_paths > 0) {
            for (size_t i = 0; i < num_lib_paths; i++) {
                if (lib_paths[i]) {
                    link_cmd += " -L" + std::string(lib_paths[i]);
                }
            }
        }
        
        // CRITICAL FIX: Use direct path to library file instead of -L flag
        // This avoids directory search path issues
        char build_path[4096];
        if (getcwd(build_path, sizeof(build_path)) != nullptr) {
            std::string cwd_str = std::string(build_path);
            std::string lib_path;
            // Check if we're already in the build directory
            if (cwd_str.length() >= 5 && cwd_str.substr(cwd_str.length() - 5) == "build") {
                lib_path = cwd_str + "/libeshkol-static.a";
            } else {
                lib_path = cwd_str + "/build/libeshkol-static.a";
            }
            link_cmd += " " + lib_path;
            eshkol_debug("Linking with library: %s", lib_path.c_str());
        } else {
            // Fallback to search path method
            link_cmd += " -L./build -leshkol-static";
        }
        
        // Add linked libraries
        if (linked_libs && num_linked_libs > 0) {
            for (size_t i = 0; i < num_linked_libs; i++) {
                if (linked_libs[i]) {
                    link_cmd += " -l" + std::string(linked_libs[i]);
                }
            }
        }
        
        link_cmd += " -o " + std::string(filename);
        
        eshkol_info("Linking executable: %s", link_cmd.c_str());
        int result = system(link_cmd.c_str());
        
        // Clean up temporary object file
        std::remove(temp_obj.c_str());
        
        if (result != 0) {
            eshkol_error("Linking failed with exit code %d", result);
            return -1;
        }
        
        eshkol_info("Successfully generated executable: %s", filename);
        return 0;
        
    } catch (const std::exception& e) {
        eshkol_error("Exception during executable generation: %s", e.what());
        // Clean up temp file on error
        std::remove(temp_obj.c_str());
        return -1;
    }
}

void eshkol_dispose_llvm_module(LLVMModuleRef module_ref) {
    if (!module_ref) return;

    auto it = g_llvm_modules.find(module_ref);
    if (it != g_llvm_modules.end()) {
        // This will automatically destroy both the module and context
        g_llvm_modules.erase(it);
    }
}

void eshkol_release_module_for_jit(LLVMModuleRef module_ref) {
    if (!module_ref) return;

    auto it = g_llvm_modules.find(module_ref);
    if (it != g_llvm_modules.end()) {
        // Release ownership of the module (JIT will take it)
        // But keep the context alive by not erasing the entry, just releasing the module pointer
        it->second->module.release();  // Don't delete module - JIT owns it now
        // Note: Context stays alive in g_llvm_modules until process exit
        // This is intentional - the context must outlive the JIT-compiled code
    }
}

} // extern "C"

#endif // ESHKOL_LLVM_BACKEND_ENABLED

