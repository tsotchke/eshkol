/*
 * Copyright (C) tsotchke
 *
 * SPDX-License-Identifier: MIT
 *
 */
#include "eshkol/eshkol.h"
#include <eshkol/llvm_backend.h>
#include <eshkol/backend/type_system.h>
#include <eshkol/backend/function_cache.h>
#include <eshkol/backend/memory_codegen.h>
#include <eshkol/backend/codegen_context.h>
#include <eshkol/backend/tagged_value_codegen.h>
#include <eshkol/backend/builtin_declarations.h>
#include <eshkol/backend/arithmetic_codegen.h>
#include <eshkol/backend/control_flow_codegen.h>
#include <eshkol/backend/string_io_codegen.h>
#include <eshkol/backend/binding_codegen.h>
#include <eshkol/backend/collection_codegen.h>
#include <eshkol/backend/function_codegen.h>
#include <eshkol/backend/tensor_codegen.h>
#include <eshkol/backend/autodiff_codegen.h>
#include <eshkol/backend/homoiconic_codegen.h>
#include <eshkol/backend/call_apply_codegen.h>
#include <eshkol/backend/map_codegen.h>
#include <eshkol/backend/tail_call_codegen.h>
#include <eshkol/backend/system_codegen.h>
#include <eshkol/backend/hash_codegen.h>
#include <eshkol/types/type_checker.h>
#include <eshkol/logger.h>
#include "../core/arena_memory.h"

#ifdef ESHKOL_LLVM_BACKEND_ENABLED

#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/raw_os_ostream.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/TargetParser/Host.h>
#include <llvm/TargetParser/Triple.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Target/TargetOptions.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/TargetParser/SubtargetFeature.h>
#include <llvm/CodeGen/CommandFlags.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/Transforms/InstCombine/InstCombine.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Scalar/GVN.h>
#include <llvm/IR/GlobalValue.h>

#include <memory>
#include <map>
#include <unordered_map>
#include <set>
#include <string>
#include <vector>
#include <deque>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <cctype>
#include <stack>
#include <unistd.h>

using namespace llvm;

// Global storage for LLVM contexts to ensure proper lifetime management
struct EshkolLLVMModule {
    std::unique_ptr<LLVMContext> context;
    std::unique_ptr<Module> module;
    
    EshkolLLVMModule(std::unique_ptr<Module> mod, std::unique_ptr<LLVMContext> ctx) 
        : context(std::move(ctx)), module(std::move(mod)) {}
};

static std::unordered_map<LLVMModuleRef, std::unique_ptr<EshkolLLVMModule>> g_llvm_modules;

// STDLIB LINKAGE: Flag to track whether the program uses stdlib
// When set, the generated code will call __eshkol_lib_init__ for homoiconic display
static bool g_uses_stdlib = false;

// REPL MODE: Global symbol persistence across CodeGenerator instances
// When REPL mode is enabled, symbols persist across evaluations
namespace {
    bool g_repl_mode_enabled = false;
    std::unordered_map<std::string, uint64_t> g_repl_symbol_addresses;     // var_name -> JIT address
    std::unordered_map<std::string, uint64_t> g_repl_function_addresses;   // func_name -> JIT address
    std::unordered_map<std::string, size_t> g_repl_function_arities;       // func_name -> arity
    std::unordered_map<std::string, std::string> g_repl_lambda_names;      // var_name -> lambda_name (e.g., "square" -> "lambda_name")
    std::unordered_map<std::string, uint64_t> g_repl_sexpr_values;         // sexpr_name -> s-expression pointer value
    std::unordered_map<std::string, std::vector<std::string>> g_repl_lambda_captures;  // lambda_name -> capture variable names
    std::mutex g_repl_mutex;  // Thread safety for REPL symbol access

    // CACHED TARGET INFO: Avoid recomputing on every compilation
    bool g_target_info_cached = false;
    std::string g_cached_target_triple;
    std::string g_cached_cpu_name;
    std::string g_cached_features;
}

// TypedValue structure to carry both LLVM value and type information
struct TypedValue {
    Value* llvm_value;              // LLVM IR value
    eshkol_value_type_t type;       // Our type tag from eshkol.h
    bool is_exact;                  // Scheme exactness tracking
    uint8_t flags;                  // Additional flags (e.g., indirect reference flag)
    eshkol::hott::TypeId hott_type; // HoTT compile-time type (for gradual typing)

    // HoTT PARAMETERIZED TYPE: For tracking List<Int64>, Vector<Float64>, etc.
    // This is optional - only set for collection types with known element types
    std::optional<eshkol::hott::ParameterizedType> param_type;

    // Flag constants
    static constexpr uint8_t FLAG_INDIRECT = 0x01;  // Value is address of global to load from
    static constexpr uint8_t FLAG_LINEAR   = 0x02;  // Must be consumed exactly once (linear type)
    static constexpr uint8_t FLAG_PROOF    = 0x04;  // Compile-time only, erased at runtime

    TypedValue()
        : llvm_value(nullptr), type(ESHKOL_VALUE_NULL), is_exact(true), flags(0),
          hott_type(eshkol::hott::BuiltinTypes::Null), param_type(std::nullopt) {}

    TypedValue(Value* val, eshkol_value_type_t t, bool exact = true, uint8_t f = 0)
        : llvm_value(val), type(t), is_exact(exact), flags(f),
          hott_type(eshkol::hott::BuiltinTypes::Value), param_type(std::nullopt) {}

    // Constructor with explicit HoTT type
    TypedValue(Value* val, eshkol_value_type_t t, eshkol::hott::TypeId hott_t, bool exact = true, uint8_t f = 0)
        : llvm_value(val), type(t), is_exact(exact), flags(f), hott_type(hott_t), param_type(std::nullopt) {}

    // Constructor with parameterized type (for List<T>, Vector<T>, etc.)
    TypedValue(Value* val, eshkol_value_type_t t, eshkol::hott::TypeId hott_t,
               const eshkol::hott::ParameterizedType& ptype, bool exact = true, uint8_t f = 0)
        : llvm_value(val), type(t), is_exact(exact), flags(f), hott_type(hott_t), param_type(ptype) {}

    // Helper methods
    bool isInt64() const { return type == ESHKOL_VALUE_INT64; }
    bool isDouble() const { return type == ESHKOL_VALUE_DOUBLE; }
    bool isNull() const { return type == ESHKOL_VALUE_NULL; }
    bool isIndirect() const { return (flags & FLAG_INDIRECT) != 0; }

    // HoTT type helpers
    bool hasKnownType() const { return hott_type != eshkol::hott::BuiltinTypes::Value; }
    bool isHottInt64() const { return hott_type == eshkol::hott::BuiltinTypes::Int64; }
    bool isHottFloat64() const { return hott_type == eshkol::hott::BuiltinTypes::Float64; }
    bool isHottNumeric() const {
        return hott_type == eshkol::hott::BuiltinTypes::Int64 ||
               hott_type == eshkol::hott::BuiltinTypes::Float64 ||
               hott_type == eshkol::hott::BuiltinTypes::Integer ||
               hott_type == eshkol::hott::BuiltinTypes::Real ||
               hott_type == eshkol::hott::BuiltinTypes::Number;
    }

    // HoTT parameterized type helpers
    bool hasParameterizedType() const { return param_type.has_value(); }
    eshkol::hott::TypeId elementType() const {
        if (param_type.has_value()) {
            return param_type->elementType();
        }
        return eshkol::hott::BuiltinTypes::Value;
    }
    bool isList() const { return type == ESHKOL_VALUE_CONS_PTR; }
    bool isVector() const { return type == ESHKOL_VALUE_VECTOR_PTR; }

    // Linear and proof type helpers (HoTT Phase 4)
    bool isLinear() const { return (flags & FLAG_LINEAR) != 0; }
    bool isProof() const { return (flags & FLAG_PROOF) != 0; }
    bool shouldErase() const { return isProof(); }  // Proofs are erased at runtime

    // Create an erased value (for proof types that don't exist at runtime)
    static TypedValue makeErased(eshkol::hott::TypeId proof_type) {
        return TypedValue(nullptr, ESHKOL_VALUE_NULL, proof_type, true, FLAG_PROOF);
    }

    // Create an erased value with a unit placeholder (for contexts that need a valid LLVM value)
    static TypedValue makeErasedWithPlaceholder(llvm::Value* unit_value, eshkol::hott::TypeId proof_type) {
        return TypedValue(unit_value, ESHKOL_VALUE_NULL, proof_type, true, FLAG_PROOF);
    }
};

// OPTION 3: Deferred Lambda S-Expression Generation
// Structure to track lambdas that need S-expression generation
struct LambdaSExprMetadata {
    const eshkol_operations_t* lambda_ast;
    std::string lambda_name;
};

// Global vector to accumulate lambdas during compilation
static std::vector<LambdaSExprMetadata> pending_lambda_sexprs;

// Track the most recently generated lambda name for codegenList
static std::string last_generated_lambda_name;

// HOMOICONIC FIX: Map lambda Function* pointers to their S-expression global names
// This allows codegenList to find the correct S-expression for each inline lambda
static std::unordered_map<Function*, std::string> lambda_sexpr_map;

// MEMOIZATION FIX: Map AST operation pointers to their lambda names
// This prevents exponential IR generation when processing nested lambdas in S-expression generation
static std::unordered_map<const eshkol_operations_t*, std::string> lambda_ast_to_name;

// Helper function to check if a function name is a lambda name
// Handles both old format "lambda_N" and new format "prefix_lambda_N"
static bool isLambdaName(const std::string& name) {
    // Check for "_lambda_" anywhere (new format with module prefix)
    if (name.find("_lambda_") != std::string::npos) return true;
    // Check for "lambda_" at start (old format, still supported)
    if (name.find("lambda_") == 0) return true;
    return false;
}

// Helper to check if a name is a letrec lambda
static bool isLetrecLambdaName(const std::string& name) {
    return name.find("_letrec_lambda_") != std::string::npos ||
           name.find("letrec_lambda_") == 0;
}

// Forward declaration for callback wrappers
class EshkolLLVMCodeGen;

// Static callback wrappers for ControlFlowCodegen
// These allow the extracted module to call back into the main codegen
namespace ControlFlowCallbacks {
    // Wrapper for codegenAST - returns LLVM Value*
    static llvm::Value* codegenASTWrapper(const void* ast, void* context);
    // Wrapper for codegenTypedAST - returns pointer to TypedValue (caller owns)
    static void* codegenTypedASTWrapper(const void* ast, void* context);
    // Wrapper for typedValueToTaggedValue
    static llvm::Value* typedToTaggedWrapper(void* typed_value, void* context);
    // Wrapper for codegenNestedFunctionDefinition
    static void codegenFuncDefineWrapper(const void* op, void* context);
    // Wrapper for codegenVariableDefinition
    static void codegenVarDefineWrapper(const void* op, void* context);
    // Wrapper for callBuiltinEqv
    static llvm::Value* eqvCompareWrapper(llvm::Value* a, llvm::Value* b, void* context);
    // Wrapper for detectValueType + typedValueToTaggedValue
    static llvm::Value* detectAndPackWrapper(llvm::Value* val, void* context);
    // Wrapper for codegenTaggedArenaConsCellFromTaggedValue
    static llvm::Value* consCreateWrapper(llvm::Value* car, llvm::Value* cdr, void* context);
    // Wrapper to get TypedValue type
    static int getTypedValueTypeWrapper(void* typed_value, void* context);
    // Wrapper to register function binding
    static void registerFuncBindingWrapper(const char* var_name, void* typed_value, void* context);
    // Wrapper for extractConsCarAsTaggedValue (for CallApplyCodegen)
    static llvm::Value* extractConsCarWrapper(llvm::Value* cons_ptr, void* context);
    // Wrapper for getTaggedConsGetPtrFunc (for CallApplyCodegen)
    static llvm::Function* getConsAccessorWrapper(void* context);
    // Wrapper for codegenAST with typed signature (for CallApplyCodegen)
    static llvm::Value* codegenASTTypedWrapper(const eshkol_ast_t* ast, void* context);
    // Wrappers for MapCodegen
    static llvm::Value* codegenLambdaWrapper(const eshkol_operations_t* op, void* context);
    static llvm::Value* closureCallWrapper(llvm::Value* closure, const std::vector<llvm::Value*>& args, void* context);
    static llvm::Function* getConsSetPtrWrapper(void* context);
    static llvm::Value* resolveLambdaWrapper(const eshkol_ast_t* ast, size_t arity, void* context);
    static llvm::Value* indirectCallWrapper(llvm::Value* arg, size_t arity, void* context);
    static void pushFunctionContextWrapper(void* context);
    static void popFunctionContextWrapper(void* context);
    // TCO callback for checking self-tail-recursion
    static bool isSelfTailRecursiveWrapper(const void* lambda_op, const char* func_name, void* context);
}

class EshkolLLVMCodeGen {
    // Friend declarations for ControlFlowCodegen callbacks
    friend llvm::Value* ControlFlowCallbacks::codegenASTWrapper(const void* ast, void* context);
    friend void* ControlFlowCallbacks::codegenTypedASTWrapper(const void* ast, void* context);
    friend llvm::Value* ControlFlowCallbacks::typedToTaggedWrapper(void* typed_value, void* context);
    friend void ControlFlowCallbacks::codegenFuncDefineWrapper(const void* op, void* context);
    friend void ControlFlowCallbacks::codegenVarDefineWrapper(const void* op, void* context);
    friend llvm::Value* ControlFlowCallbacks::eqvCompareWrapper(llvm::Value* a, llvm::Value* b, void* context);
    friend llvm::Value* ControlFlowCallbacks::detectAndPackWrapper(llvm::Value* val, void* context);
    friend llvm::Value* ControlFlowCallbacks::consCreateWrapper(llvm::Value* car, llvm::Value* cdr, void* context);
    friend int ControlFlowCallbacks::getTypedValueTypeWrapper(void* typed_value, void* context);
    friend void ControlFlowCallbacks::registerFuncBindingWrapper(const char* var_name, void* typed_value, void* context);
    // Friend declarations for CallApplyCodegen callbacks
    friend llvm::Value* ControlFlowCallbacks::extractConsCarWrapper(llvm::Value* cons_ptr, void* context);
    friend llvm::Function* ControlFlowCallbacks::getConsAccessorWrapper(void* context);
    friend llvm::Value* ControlFlowCallbacks::codegenASTTypedWrapper(const eshkol_ast_t* ast, void* context);
    // Friend declarations for MapCodegen callbacks
    friend llvm::Value* ControlFlowCallbacks::codegenLambdaWrapper(const eshkol_operations_t* op, void* context);
    friend llvm::Value* ControlFlowCallbacks::closureCallWrapper(llvm::Value* closure, const std::vector<llvm::Value*>& args, void* context);
    friend llvm::Function* ControlFlowCallbacks::getConsSetPtrWrapper(void* context);
    friend llvm::Value* ControlFlowCallbacks::resolveLambdaWrapper(const eshkol_ast_t* ast, size_t arity, void* context);
    friend llvm::Value* ControlFlowCallbacks::indirectCallWrapper(llvm::Value* arg, size_t arity, void* context);
    friend void ControlFlowCallbacks::pushFunctionContextWrapper(void* context);
    friend void ControlFlowCallbacks::popFunctionContextWrapper(void* context);
    friend bool ControlFlowCallbacks::isSelfTailRecursiveWrapper(const void* lambda_op, const char* func_name, void* context);

private:
    std::unique_ptr<LLVMContext> context;
    std::unique_ptr<Module> module;
    std::unique_ptr<IRBuilder<>> builder;

    // Type system (manages all LLVM types)
    std::unique_ptr<eshkol::TypeSystem> types;

    // Function cache (lazy-loaded C library functions)
    std::unique_ptr<eshkol::FunctionCache> funcs;

    // Memory codegen (arena function declarations)
    std::unique_ptr<eshkol::MemoryCodegen> mem;

    // CodegenContext - Shared state for extracted modules
    // This provides clean access to LLVM infrastructure, symbol tables, and function caches
    // for modules like TaggedValueCodegen, ArithmeticCodegen, etc.
    std::unique_ptr<eshkol::CodegenContext> ctx_;

    // TaggedValueCodegen - Pack/unpack operations for tagged values
    // This module handles the runtime type system's tagged value representation
    std::unique_ptr<eshkol::TaggedValueCodegen> tagged_;

    // BuiltinDeclarations - External runtime function declarations
    // Handles deep_equal, display_value, lambda_registry functions
    std::unique_ptr<eshkol::BuiltinDeclarations> builtins_;

    // ArithmeticCodegen - Polymorphic arithmetic operations
    // Note: Main polymorphic implementations still in this file; module provides interface
    std::unique_ptr<eshkol::ArithmeticCodegen> arith_;

    // CallApplyCodegen - Function call and apply operations
    // Handles Scheme's apply and closure dispatch
    std::unique_ptr<eshkol::CallApplyCodegen> call_apply_;

    // MapCodegen - Higher-order list mapping operations
    // Handles (map proc list1 ...) with closure and capture support
    std::unique_ptr<eshkol::MapCodegen> map_;

    // ControlFlowCodegen - Control flow operations (and, or, if, cond, begin)
    // Note: Main implementations still in this file; module provides isTruthy helper
    std::unique_ptr<eshkol::ControlFlowCodegen> flow_;

    // StringIOCodegen - String and I/O operations
    // Note: Main implementations still in this file; module provides string creation and printf
    std::unique_ptr<eshkol::StringIOCodegen> strio_;

    // CollectionCodegen - List and vector operations
    // Note: Main implementations still in this file; module provides allocConsCell helper
    std::unique_ptr<eshkol::CollectionCodegen> coll_;

    // FunctionCodegen - Lambda and closure operations
    // Note: Main implementations still in this file; module provides createClosure helper
    std::unique_ptr<eshkol::FunctionCodegen> func_;

    // TensorCodegen - Tensor operations
    // Note: Main implementations still in this file; module provides interface
    std::unique_ptr<eshkol::TensorCodegen> tensor_;

    // AutodiffCodegen - Automatic differentiation operations
    // Note: Main implementations still in this file; module provides interface
    std::unique_ptr<eshkol::AutodiffCodegen> autodiff_;

    // BindingCodegen - Variable binding operations (define, let, letrec, set!)
    std::unique_ptr<eshkol::BindingCodegen> binding_;

    // HomoiconicCodegen - Quote and S-expression operations
    std::unique_ptr<eshkol::HomoiconicCodegen> homoiconic_;

    // TailCallCodegen - Tail call optimization support
    std::unique_ptr<eshkol::TailCallCodegen> tailcall_;

    // SystemCodegen - System, environment, and file operations
    std::unique_ptr<eshkol::SystemCodegen> system_;

    // HashCodegen - Hash table operations
    std::unique_ptr<eshkol::HashCodegen> hash_;

    // Local type pointers (initialized from TypeSystem for backward compatibility)
    // TODO: Gradually migrate code to use types-> accessors directly
    StructType* tagged_value_type;
    StructType* dual_number_type;
    StructType* ad_node_type;
    StructType* tensor_type;
    
    // PHASE 3: Current tape for reverse-mode AD
    Value* current_tape_ptr;
    size_t next_node_id;
    
    std::unordered_map<std::string, Value*> symbol_table;
    std::unordered_map<std::string, Value*> global_symbol_table; // Persistent global symbols
    std::unordered_map<std::string, Function*> function_table;
    std::unordered_map<std::string, std::vector<std::string>> nested_function_captures; // Free vars for nested defines
    std::unordered_map<std::string, std::string> functions_returning_lambda; // Maps function name -> lambda name it returns

    // HoTT TYPE TRACKING: Maps variable names to their compile-time HoTT types
    // This enables type-directed optimizations when both operand types are known
    std::unordered_map<std::string, eshkol::hott::TypeId> symbol_hott_types;
    std::unordered_map<std::string, eshkol::hott::TypeId> global_symbol_hott_types;

    // HoTT PARAMETERIZED TYPE TRACKING: Maps variable names to parameterized types (List<T>, Vector<T>)
    // This enables element type propagation through car/cdr, vector-ref, etc.
    std::unordered_map<std::string, eshkol::hott::ParameterizedType> symbol_param_types;
    std::unordered_map<std::string, eshkol::hott::ParameterizedType> global_symbol_param_types;

    // HoTT FUNCTION RETURN TYPE TRACKING: Maps function names to their return types
    // Enables type-directed optimization for function call results
    std::unordered_map<std::string, eshkol::hott::TypeId> function_return_types;

    // LETREC REFACTOR: Set of names to exclude from free variable capture (letrec-bound names)
    // This is set by BindingCodegen::letrec before generating lambda bindings and cleared after
    std::set<std::string> letrec_excluded_capture_names;

    // VARIADIC FUNCTION TRACKING: Maps function name to (fixed_param_count, is_variadic)
    // For variadic functions, when calling, extra args beyond fixed_param_count are packaged into a list
    std::unordered_map<std::string, std::pair<uint64_t, bool>> variadic_function_info;

    // FUNCTION-AS-VALUE FIX: Maps function name to user-facing arity (excludes captures)
    // Used when functions are referenced as values (first-class functions) to wrap them in closures
    std::unordered_map<std::string, uint64_t> function_arity_table;

    // MIGRATED: String interning moved to CodegenContext::interned_strings_
    // StringIOCodegen::createString() handles string interning now

    // Current function being generated
    Function* current_function;
    BasicBlock* main_entry;
    
    // Arena management for list operations - GLOBAL ARENA ARCHITECTURE
    GlobalVariable* global_arena; // Global arena pointer (shared across all scopes)
    size_t arena_scope_depth; // Track nested arena scopes
    
    // PHASE 1 AUTODIFF FIX: Global AD mode flag for runtime context detection
    GlobalVariable* ad_mode_active; // Global flag: true when executing in AD context

    // PHASE 1 AUTODIFF FIX: Global tape pointer for runtime graph recording
    GlobalVariable* current_ad_tape; // Global tape pointer: set by gradient/jacobian/etc operators

    // NESTED GRADIENT FIX: Tape stack for arbitrary-depth nested gradients
    // Allows inner gradients to save/restore outer gradient context
    static const size_t MAX_TAPE_DEPTH = 32; // Support up to 32 levels of nesting
    GlobalVariable* ad_tape_stack;  // Array of tape pointers [MAX_TAPE_DEPTH]
    GlobalVariable* ad_tape_depth;  // Current stack depth (0 = no active gradient)

    // DOUBLE BACKWARD: Storage for outer AD node when in nested gradient
    // Used to connect inner gradient's result to outer's computation graph
    GlobalVariable* outer_ad_node_storage;  // Pointer to outer AD node (or null if not nested)
    GlobalVariable* outer_ad_node_to_inner; // Maps outer AD node to inner variable node
    GlobalVariable* outer_grad_accumulator; // AD node accumulating gradient on outer tape
    GlobalVariable* inner_var_node_ptr;     // Pointer to the inner variable node (for matching)
    GlobalVariable* gradient_x_degree;      // Polynomial degree of gradient in x (for double backward)

    // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes for arbitrary depth nesting
    GlobalVariable* outer_ad_node_stack;    // Array of outer AD node pointers [MAX_TAPE_DEPTH]
    GlobalVariable* outer_ad_node_depth;    // Current depth in the outer AD node stack

    // Note: Arena functions are now in MemoryCodegen (mem->)
    // Forwarding accessors are provided below for backward compatibility

    // Deep equality comparison for nested lists
    Function* eshkol_deep_equal_func;

    // Unified display system (Phase 4 - homoiconic display)
    Function* eshkol_display_value_func;
    Function* eshkol_lambda_registry_init_func;
    Function* eshkol_lambda_registry_add_func;
    Function* eshkol_lambda_registry_lookup_func;
    
    // List operation function declarations (clean, non-redundant)
    Function* length_impl_func;
    Function* append_impl_func;
    Function* reverse_impl_func;
    Function* list_ref_impl_func;
    Function* list_tail_impl_func;

    // Recursive tensor display helper (N-dimensional nested structure)
    Function* display_tensor_recursive_func;

    // Cached LLVM types (avoid repeated lookups - massive performance win)
    // Note: C library functions are now in FunctionCache (funcs->)
    IntegerType* int64_type;
    IntegerType* int32_type;
    IntegerType* int16_type;
    IntegerType* int8_type;
    IntegerType* int1_type;
    Type* double_type;
    Type* void_type;
    Type* ptr_type;

    // LIBRARY MODE: When true, skip main function creation and export all symbols
    bool library_mode;

    // Module prefix for unique lambda naming (prevents symbol collision when linking)
    std::string module_prefix;

public:
    EshkolLLVMCodeGen(const char* module_name, bool is_library_mode = false) {
        library_mode = is_library_mode;
        // Create a sanitized module prefix for lambda naming
        module_prefix = module_name;
        // Replace non-alphanumeric chars with underscore
        for (char& c : module_prefix) {
            if (!std::isalnum(c)) c = '_';
        }
        context = std::make_unique<LLVMContext>();
        module = std::make_unique<Module>(module_name, *context);
        builder = std::make_unique<IRBuilder<>>(*context);

        // Initialize type system (creates and caches all LLVM types)
        types = std::make_unique<eshkol::TypeSystem>(*context);

        // Set local type pointers from TypeSystem for backward compatibility
        // TODO: Gradually migrate code to use types-> accessors directly
        int64_type = types->getInt64Type();
        int32_type = types->getInt32Type();
        int16_type = types->getInt16Type();
        int8_type = types->getInt8Type();
        int1_type = types->getInt1Type();
        double_type = types->getDoubleType();
        void_type = types->getVoidType();
        ptr_type = types->getPtrType();
        tagged_value_type = types->getTaggedValueType();

        // Initialize function cache (lazy-loaded C library functions)
        funcs = std::make_unique<eshkol::FunctionCache>(*module, *types);

        current_function = nullptr;
        global_arena = nullptr; // Will be created in generateIR()
        arena_scope_depth = 0; // Initialize arena scope tracking
        ad_mode_active = nullptr; // Will be created in generateIR()
        ad_tape_stack = nullptr; // Will be created in generateIR()
        ad_tape_depth = nullptr; // Will be created in generateIR()

        // Initialize LLVM targets first (required before creating target machine)
        InitializeAllTargetInfos();
        InitializeAllTargets();
        InitializeAllTargetMCs();
        InitializeAllAsmParsers();
        InitializeAllAsmPrinters();

        // Set target triple
        std::string target_triple_str = sys::getDefaultTargetTriple();
        module->setTargetTriple(Triple(target_triple_str));

        // CRITICAL: Set DataLayout early so getTypeAllocSize returns correct values
        // This must be done before any allocations that depend on struct sizes
        std::string error;
        const Target* target = TargetRegistry::lookupTarget(target_triple_str, error);
        if (target) {
            TargetOptions options;
            std::unique_ptr<TargetMachine> target_machine(
                target->createTargetMachine(target_triple_str, "generic", "",
                                           options, Reloc::PIC_));
            if (target_machine) {
                module->setDataLayout(target_machine->createDataLayout());
                eshkol_debug("Set data layout for target: %s", target_triple_str.c_str());
            }
        }

        // Register HoTT return types for builtin functions
        registerBuiltinReturnTypes();
    }

    // Register return types for builtin functions
    void registerBuiltinReturnTypes() {
        using namespace eshkol::hott;

        // Arithmetic functions return Number (polymorphic)
        function_return_types["+"] = BuiltinTypes::Number;
        function_return_types["-"] = BuiltinTypes::Number;
        function_return_types["*"] = BuiltinTypes::Number;
        function_return_types["/"] = BuiltinTypes::Real;  // Division always returns real

        // Comparison functions return Boolean
        function_return_types["<"] = BuiltinTypes::Boolean;
        function_return_types[">"] = BuiltinTypes::Boolean;
        function_return_types["<="] = BuiltinTypes::Boolean;
        function_return_types[">="] = BuiltinTypes::Boolean;
        function_return_types["="] = BuiltinTypes::Boolean;
        function_return_types["eq?"] = BuiltinTypes::Boolean;
        function_return_types["equal?"] = BuiltinTypes::Boolean;
        function_return_types["null?"] = BuiltinTypes::Boolean;
        function_return_types["pair?"] = BuiltinTypes::Boolean;
        function_return_types["list?"] = BuiltinTypes::Boolean;
        function_return_types["number?"] = BuiltinTypes::Boolean;
        function_return_types["zero?"] = BuiltinTypes::Boolean;
        function_return_types["positive?"] = BuiltinTypes::Boolean;
        function_return_types["negative?"] = BuiltinTypes::Boolean;
        function_return_types["even?"] = BuiltinTypes::Boolean;
        function_return_types["odd?"] = BuiltinTypes::Boolean;

        // Math functions return Float64
        function_return_types["sin"] = BuiltinTypes::Float64;
        function_return_types["cos"] = BuiltinTypes::Float64;
        function_return_types["tan"] = BuiltinTypes::Float64;
        function_return_types["exp"] = BuiltinTypes::Float64;
        function_return_types["log"] = BuiltinTypes::Float64;
        function_return_types["sqrt"] = BuiltinTypes::Float64;
        function_return_types["abs"] = BuiltinTypes::Number;
        function_return_types["fabs"] = BuiltinTypes::Float64;

        // List functions
        function_return_types["list"] = BuiltinTypes::List;
        function_return_types["cons"] = BuiltinTypes::List;
        function_return_types["car"] = BuiltinTypes::Value;  // Can be any type
        function_return_types["cdr"] = BuiltinTypes::List;
        function_return_types["length"] = BuiltinTypes::Int64;
        function_return_types["append"] = BuiltinTypes::List;
        function_return_types["reverse"] = BuiltinTypes::List;
        function_return_types["map"] = BuiltinTypes::List;
        function_return_types["filter"] = BuiltinTypes::List;
        function_return_types["take"] = BuiltinTypes::List;
        function_return_types["drop"] = BuiltinTypes::List;
        function_return_types["range"] = BuiltinTypes::List;

        // Vector functions
        function_return_types["vector"] = BuiltinTypes::Vector;
        function_return_types["make-vector"] = BuiltinTypes::Vector;
        function_return_types["vector-length"] = BuiltinTypes::Int64;
        function_return_types["vector-ref"] = BuiltinTypes::Value;

        // Type conversions
        function_return_types["exact->inexact"] = BuiltinTypes::Float64;
        function_return_types["inexact->exact"] = BuiltinTypes::Int64;

        // IO returns Null
        function_return_types["display"] = BuiltinTypes::Null;
        function_return_types["newline"] = BuiltinTypes::Null;
    }
    
    std::pair<std::unique_ptr<Module>, std::unique_ptr<LLVMContext>> generateIR(const eshkol_ast_t* asts, size_t num_asts) {
        try {
            // REPL FIX: Clear stale static state from previous evaluations
            // This prevents duplicate symbol errors when creating lambda_X_sexpr globals
            if (g_repl_mode_enabled) {
                pending_lambda_sexprs.clear();
                lambda_sexpr_map.clear();
                lambda_ast_to_name.clear();
                eshkol_debug("REPL: Cleared stale lambda sexpr state");
            }

            // Create global arena variable (shared across all functions and scopes)
            // Use ExternalLinkage so the arena can be shared between main program and linked libraries
            // In library mode: external declaration (no initializer) - provided by main
            // In normal mode: external definition (with initializer) - defines the symbol
            global_arena = new GlobalVariable(
                *module,
                PointerType::getUnqual(*context),
                false, // not constant
                GlobalValue::ExternalLinkage, // Always external for cross-module visibility
                library_mode ? nullptr : ConstantPointerNull::get(PointerType::getUnqual(*context)),
                "__global_arena"
            );
            eshkol_debug("Created global arena variable: __global_arena (mode=%s)",
                        library_mode ? "external-declaration" : "external-definition");

            // Create global variables for command-line arguments
            // These are set by main() and read by (command-line)
            new GlobalVariable(
                *module,
                int32_type,
                false, // not constant
                GlobalValue::ExternalLinkage,
                library_mode ? nullptr : ConstantInt::get(int32_type, 0),
                "__eshkol_argc"
            );
            new GlobalVariable(
                *module,
                PointerType::getUnqual(*context),
                false, // not constant
                GlobalValue::ExternalLinkage,
                library_mode ? nullptr : ConstantPointerNull::get(PointerType::getUnqual(*context)),
                "__eshkol_argv"
            );
            eshkol_debug("Created global command-line argument variables");
            
            // PHASE 1 AUTODIFF FIX: Create global AD mode flag
            // CRITICAL BUG FIX: In REPL mode, use ExternalLinkage to share flag across JIT modules
            // This allows lambdas compiled in one module to see AD mode set by another module
            // Without this fix, gradient calls on the same function with different vectors crash
            if (g_repl_mode_enabled) {
                ad_mode_active = new GlobalVariable(
                    *module,
                    int1_type,
                    false, // not constant
                    GlobalValue::ExternalLinkage, // External - shared across REPL modules
                    nullptr, // External - no initializer (defined in arena_memory.cpp)
                    "__ad_mode_active"
                );
            } else {
                ad_mode_active = new GlobalVariable(
                    *module,
                    int1_type,
                    false, // not constant
                    GlobalValue::InternalLinkage, // Internal linkage for compiled mode
                    ConstantInt::get(int1_type, 0), // Initialize to false
                    "__ad_mode_active"
                );
                eshkol_debug("Created global AD mode flag: __ad_mode_active (initialized to false)");
            }

            // PHASE 1 AUTODIFF FIX: Create global tape pointer
            // In REPL mode, use ExternalLinkage to share tape across JIT modules
            // In compiler mode, use InternalLinkage with null initializer
            if (g_repl_mode_enabled) {
                current_ad_tape = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false, // not constant
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - no initializer (registered by REPL JIT)
                    "__current_ad_tape"
                );
                eshkol_debug("Created global AD tape pointer: __current_ad_tape (external for REPL cross-module sharing)");
            } else {
                current_ad_tape = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false, // not constant
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)), // Initialize to null
                    "__current_ad_tape"
                );
                eshkol_debug("Created global AD tape pointer: __current_ad_tape (initialized to null)");
            }

            // NESTED GRADIENT FIX: Create tape stack and depth counter
            // These enable arbitrary-depth nested gradient operations
            ArrayType* tape_stack_type = ArrayType::get(PointerType::getUnqual(*context), MAX_TAPE_DEPTH);

            if (g_repl_mode_enabled) {
                // REPL mode: external linkage for cross-module sharing
                ad_tape_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__ad_tape_stack"
                );
                ad_tape_depth = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__ad_tape_depth"
                );

                // DOUBLE BACKWARD: Create outer AD node storage globals (external for REPL)
                outer_ad_node_storage = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__outer_ad_node_storage"
                );
                outer_ad_node_to_inner = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr, // External - defined in arena_memory.cpp
                    "__outer_ad_node_to_inner"
                );
                outer_grad_accumulator = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_grad_accumulator"
                );
                inner_var_node_ptr = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__inner_var_node_ptr"
                );
                gradient_x_degree = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__gradient_x_degree"
                );

                // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes
                outer_ad_node_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,  // Same type as tape stack (array of pointers)
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_ad_node_stack"
                );
                outer_ad_node_depth = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::ExternalLinkage,
                    nullptr,
                    "__outer_ad_node_depth"
                );
                eshkol_debug("Created tape stack globals (external for REPL)");
            } else {
                // Compiler mode: internal linkage with zero initializers
                std::vector<Constant*> null_tapes(MAX_TAPE_DEPTH,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)));
                ad_tape_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantArray::get(tape_stack_type, null_tapes),
                    "__ad_tape_stack"
                );
                ad_tape_depth = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(int64_type, 0),
                    "__ad_tape_depth"
                );

                // DOUBLE BACKWARD: Create outer AD node storage globals (internal with null init)
                outer_ad_node_storage = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_ad_node_storage"
                );
                outer_ad_node_to_inner = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_ad_node_to_inner"
                );
                outer_grad_accumulator = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__outer_grad_accumulator"
                );
                inner_var_node_ptr = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantPointerNull::get(PointerType::getUnqual(*context)),
                    "__inner_var_node_ptr"
                );
                gradient_x_degree = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(int64_type, 0),
                    "__gradient_x_degree"
                );
                // N-DIMENSIONAL DERIVATIVES: Stack of outer AD nodes
                outer_ad_node_stack = new GlobalVariable(
                    *module,
                    tape_stack_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantArray::get(tape_stack_type, null_tapes),
                    "__outer_ad_node_stack"
                );
                outer_ad_node_depth = new GlobalVariable(
                    *module,
                    int64_type,
                    false,
                    GlobalValue::InternalLinkage,
                    ConstantInt::get(int64_type, 0),
                    "__outer_ad_node_depth"
                );
                eshkol_debug("Created tape stack globals (internal with zero init)");
            }

            // Create built-in function declarations
            createBuiltinFunctions();

            // ========== HoTT TYPE CHECKING PHASE ==========
            // Run type checker before code generation for gradual typing support
            // This populates type information that will be used during codegen
            {
                eshkol::hott::TypeEnvironment& type_env = ctx_->hottTypes();
                eshkol::hott::TypeChecker type_checker(type_env);

                // Type check all top-level definitions
                // Note: const_cast is safe here because we're intentionally annotating
                // the AST with inferred types during type checking phase
                for (size_t i = 0; i < num_asts; i++) {
                    if (asts[i].type == ESHKOL_OP) {
                        // Process type definitions first to register type aliases
                        if (asts[i].operation.op == ESHKOL_DEFINE_TYPE_OP) {
                            type_checker.synthesize(const_cast<eshkol_ast_t*>(&asts[i]));
                        }
                        // Then process regular definitions
                        else if (asts[i].operation.op == ESHKOL_DEFINE_OP) {
                            auto result = type_checker.synthesize(const_cast<eshkol_ast_t*>(&asts[i]));
                            if (!result.success) {
                                // Type error - report but continue for gradual typing
                                eshkol_warn("HoTT type check warning in '%s': %s",
                                           asts[i].operation.define_op.name,
                                           result.error_message.c_str());
                            } else {
                                eshkol_debug("HoTT: type checked '%s' successfully",
                                            asts[i].operation.define_op.name);
                            }
                        }
                    }
                }

                // Report any accumulated type errors (but don't fail compilation - gradual typing)
                if (type_checker.hasErrors()) {
                    eshkol_warn("HoTT: %zu type warnings detected (gradual typing continues)",
                               type_checker.errors().size());
                }
            }
            eshkol_debug("HoTT type checking phase complete");

            // SAFE ORDER: Function declarations → Function bodies → Global variables in main()
            // Global variables (including lambdas) are processed ONLY in main function context
            // This avoids issues with processing lambdas without a function context
            
            // Step 1: Create function declarations FIRST (including nested functions)
            for (size_t i = 0; i < num_asts; i++) {
                if (asts[i].type == ESHKOL_OP && asts[i].operation.op == ESHKOL_DEFINE_OP) {
                    if (asts[i].operation.define_op.is_function) {
                        // Create function declaration for top-level function
                        createFunctionDeclaration(&asts[i]);
                        // Also recursively declare any nested functions inside this function
                        if (asts[i].operation.define_op.value) {
                            declareNestedFunctions(asts[i].operation.define_op.value);
                        }
                    }
                }
                // Also check for nested functions in non-function top-level expressions
                declareNestedFunctions(&asts[i]);
            }
            eshkol_debug("Created all function declarations (including nested)");

            // Step 1.5: Pre-declare global variables so functions can reference them
            // This creates GlobalVariables for non-function top-level defines
            for (size_t i = 0; i < num_asts; i++) {
                if (asts[i].type == ESHKOL_OP && asts[i].operation.op == ESHKOL_DEFINE_OP &&
                    !asts[i].operation.define_op.is_function) {
                    const char* var_name = asts[i].operation.define_op.name;
                    if (var_name && !module->getNamedGlobal(var_name)) {
                        // Create GlobalVariable with tagged_value type for maximum compatibility
                        GlobalVariable* global_var = new GlobalVariable(
                            *module,
                            tagged_value_type,
                            false, // not constant
                            GlobalValue::ExternalLinkage,
                            UndefValue::get(tagged_value_type),
                            var_name
                        );
                        symbol_table[var_name] = global_var;
                        global_symbol_table[var_name] = global_var;
                        eshkol_debug("Pre-declared global variable: %s", var_name);
                    }
                }
            }
            eshkol_debug("Pre-declared all global variables");

            // Step 1.75: Pre-generate lambda functions for top-level (define var (lambda ...)) patterns
            // This is CRITICAL: user's main may reference these lambdas in gradient/derivative calls,
            // and those need to resolve the lambda function at compile time (Step 2)
            preGenerateTopLevelLambdas(asts, num_asts);
            eshkol_debug("Pre-generated all top-level lambdas");

            // Step 2: Generate function definitions
            for (size_t i = 0; i < num_asts; i++) {
                if (asts[i].type == ESHKOL_OP && asts[i].operation.op == ESHKOL_DEFINE_OP &&
                    asts[i].operation.define_op.is_function) {
                    codegenAST(&asts[i]);
                }
            }

            // Global variable definitions are now handled in the main function context
            // to avoid issues with parentless instructions

            // LIBRARY MODE: Skip main creation, create init function instead
            if (library_mode) {
                eshkol_info("Compiling in library mode - no main function will be created");
                createLibraryInitFunction(asts, num_asts);
                // In library mode, we're done after creating the init function
                // All function definitions are already compiled above
            } else {
                // Check if there's a user-defined main function
                bool has_user_main = function_table.find("main") != function_table.end();

                if (!has_user_main) {
                    // No user main - create main function wrapper for top-level expressions
                    createMainWrapper();
                
                // Then generate code for top-level expressions in main
                if (main_entry) {
                    builder->SetInsertPoint(main_entry);
                    current_function = function_table["main"];

                    // SEQUENTIAL PROCESSING FIX: Process all top-level expressions in order
                    // This fixes the issue where defines were hoisted before other expressions,
                    // breaking sequential semantics for file I/O and other side-effecting operations.
                    //
                    // Lambda captures are handled by calling __lambda_init__ after each lambda define,
                    // rather than hoisting all defines first.

                    for (size_t i = 0; i < num_asts; i++) {
                        bool is_function_def = (asts[i].type == ESHKOL_OP &&
                                               asts[i].operation.op == ESHKOL_DEFINE_OP &&
                                               asts[i].operation.define_op.is_function);

                        // Skip function definitions - they were already compiled in earlier pass
                        if (is_function_def) {
                            continue;
                        }

                        // Process all other expressions (defines AND non-defines) sequentially
                        codegenAST(&asts[i]);

                        // After each expression that might define a lambda, generate its S-expression
                        // and call __lambda_init__ to initialize captures immediately
                        if (!pending_lambda_sexprs.empty()) {
                            for (size_t j = 0; j < pending_lambda_sexprs.size(); j++) {
                                const auto& meta = pending_lambda_sexprs[j];

                                Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);

                                // Create or get global variable for this lambda's S-expression
                                std::string sexpr_key = meta.lambda_name + "_sexpr";
                                GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                                if (!sexpr_global) {
                                    sexpr_global = new GlobalVariable(
                                        *module, int64_type, false,
                                        GlobalValue::ExternalLinkage,
                                        ConstantInt::get(int64_type, 0),
                                        sexpr_key
                                    );
                                }

                                builder->CreateStore(sexpr_ptr, sexpr_global);

                                // Add to global symbol table for display lookup
                                global_symbol_table[sexpr_key] = sexpr_global;
                                eshkol_debug("Generated S-expression for lambda %s", meta.lambda_name.c_str());

                                // Register this lambda in the registry for homoiconic display
                                Function* reg_lambda_func = module->getFunction(meta.lambda_name);
                                if (reg_lambda_func) {
                                    Value* reg_func_ptr_int = builder->CreatePtrToInt(reg_lambda_func, int64_type);
                                    // sexpr_ptr is already i64 from codegenLambdaToSExpr, use directly
                                    Value* reg_name_str = builder->CreateGlobalString(meta.lambda_name);
                                    builder->CreateCall(eshkol_lambda_registry_add_func,
                                        {reg_func_ptr_int, sexpr_ptr, reg_name_str});
                                    eshkol_debug("Registered lambda '%s' in homoiconic registry (user main case)", meta.lambda_name.c_str());
                                }

                                // Also create variable alias if this lambda was bound to a variable
                                // CRITICAL FIX: Search for which variable maps to this lambda function
                                // The variable is stored as "varname_func" -> Function*, where Function->getName() == meta.lambda_name
                                Function* lambda_func_ref = module->getFunction(meta.lambda_name);
                                if (lambda_func_ref) {
                                    for (auto& entry : global_symbol_table) {
                                        // Look for keys ending in "_func"
                                        if (entry.first.length() > 5 &&
                                            entry.first.substr(entry.first.length() - 5) == "_func" &&
                                            entry.second == lambda_func_ref) {
                                            // Found the variable that maps to this lambda
                                            std::string var_name = entry.first.substr(0, entry.first.length() - 5);
                                            std::string var_sexpr_key = var_name + "_sexpr";
                                            GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                                            if (!var_sexpr_global) {
                                                var_sexpr_global = new GlobalVariable(
                                                    *module, int64_type, false,
                                                    GlobalValue::ExternalLinkage,
                                                    ConstantInt::get(int64_type, 0),
                                                    var_sexpr_key
                                                );
                                            }
                                            Value* lambda_sexpr_val = builder->CreateLoad(int64_type, sexpr_global);
                                            builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                                            global_symbol_table[var_sexpr_key] = var_sexpr_global;
                                            eshkol_debug("Created variable alias: %s -> %s", var_sexpr_key.c_str(), sexpr_key.c_str());
                                            break;  // Found the mapping, exit loop
                                        }
                                    }
                                }
                            }

                            // Clear pending list after generation
                            pending_lambda_sexprs.clear();

                            // Call __lambda_init__ after each lambda define to initialize captures
                            Function* lambda_init_func = module->getFunction("__lambda_init__");
                            if (lambda_init_func) {
                                builder->CreateCall(lambda_init_func);
                                eshkol_debug("Called __lambda_init__ to initialize lambda captures");
                            }
                        }
                    }
                    
                    // Add terminator to main function if it doesn't have one
                    if (!builder->GetInsertBlock()->getTerminator()) {
                        // GLOBAL ARENA FIX: Cleanup arena before return (SKIP IN REPL MODE)
                        // In REPL mode, s-expressions need to persist across evaluations
                        if (!g_repl_mode_enabled) {
                            Value* arena_to_destroy = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                            builder->CreateCall(getArenaDestroyFunc(), {arena_to_destroy});
                            eshkol_debug("Added global arena cleanup before main return (top-level expressions)");
                        } else {
                            eshkol_debug("Skipped arena cleanup in REPL mode to preserve s-expressions (top-level)");
                        }

                        builder->CreateRet(ConstantInt::get(int32_type, 0));
                    }
                }
            } else {
                // User has defined main - need to initialize global variables before calling scheme_main
                // createMainWrapper creates the C main function that calls scheme_main
                // But we need to process global variable definitions first

                // Step 1: Create the main wrapper structure
                Function* user_main = function_table["main"];
                user_main->setName("scheme_main");  // Rename user's main

                // Create C-style main function with argc, argv
                std::vector<Type*> main_args = {int32_type, PointerType::getUnqual(*context)};
                FunctionType* c_main_type = FunctionType::get(int32_type, main_args, false);
                Function* c_main = Function::Create(c_main_type, Function::ExternalLinkage, "main", module.get());

                // Name the arguments
                auto arg_it = c_main->arg_begin();
                Value* argc_val = arg_it++;
                argc_val->setName("argc");
                Value* argv_val = arg_it;
                argv_val->setName("argv");

                main_entry = BasicBlock::Create(*context, "entry", c_main);
                builder->SetInsertPoint(main_entry);

                // Store argc and argv to globals for (command-line)
                GlobalVariable* g_argc = module->getGlobalVariable("__eshkol_argc");
                GlobalVariable* g_argv = module->getGlobalVariable("__eshkol_argv");
                if (g_argc && g_argv) {
                    builder->CreateStore(argc_val, g_argc);
                    builder->CreateStore(argv_val, g_argv);
                }

                // Step 2: Initialize arena
                Value* arena_ptr;
                if (g_repl_mode_enabled) {
                    GlobalVariable* shared_arena_ref = new GlobalVariable(
                        *module,
                        PointerType::getUnqual(*context),
                        false,
                        GlobalValue::ExternalLinkage,
                        nullptr,
                        "__repl_shared_arena"
                    );
                    arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                } else {
                    Value* arena_size = ConstantInt::get(int64_type, 8192);
                    arena_ptr = builder->CreateCall(getArenaCreateFunc(), {arena_size});
                }
                builder->CreateStore(arena_ptr, global_arena);

                // Step 2.5: Initialize lambda registry for homoiconic display
                builder->CreateCall(eshkol_lambda_registry_init_func);
                eshkol_debug("Initialized lambda registry for homoiconic display");

                // Step 3: Process global variable definitions BEFORE calling scheme_main
                current_function = c_main;
                for (size_t i = 0; i < num_asts; i++) {
                    // Process non-function top-level defines to initialize global variables
                    if (asts[i].type == ESHKOL_OP &&
                        asts[i].operation.op == ESHKOL_DEFINE_OP &&
                        !asts[i].operation.define_op.is_function) {
                        codegenAST(&asts[i]);
                        eshkol_debug("Initialized global variable: %s", asts[i].operation.define_op.name);
                    }
                }

                // Step 3.5: Call __lambda_init__ to initialize captures AFTER global variables are defined
                // This copies values from global variables (like @x) to capture globals (like @lambda_0_capture_x)
                Function* lambda_init_func = module->getFunction("__lambda_init__");
                if (lambda_init_func) {
                    builder->CreateCall(lambda_init_func);
                    eshkol_debug("Called __lambda_init__ to initialize lambda captures (user main case)");
                }

                // Step 4: Generate S-expressions for lambdas
                if (!pending_lambda_sexprs.empty()) {
                    for (size_t j = 0; j < pending_lambda_sexprs.size(); j++) {
                        const auto& meta = pending_lambda_sexprs[j];
                        Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);
                        std::string sexpr_key = meta.lambda_name + "_sexpr";
                        GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                        if (!sexpr_global) {
                            sexpr_global = new GlobalVariable(
                                *module, int64_type, false,
                                GlobalValue::ExternalLinkage,
                                ConstantInt::get(int64_type, 0),
                                sexpr_key
                            );
                        }
                        builder->CreateStore(sexpr_ptr, sexpr_global);
                        global_symbol_table[sexpr_key] = sexpr_global;

                        // Register this lambda in the registry for homoiconic display
                        Function* lambda_func = module->getFunction(meta.lambda_name);
                        if (lambda_func) {
                            Value* func_ptr_int = builder->CreatePtrToInt(lambda_func, int64_type);
                            // sexpr_ptr is already i64 from codegenLambdaToSExpr, use directly
                            Value* name_str = builder->CreateGlobalString(meta.lambda_name);
                            builder->CreateCall(eshkol_lambda_registry_add_func,
                                {func_ptr_int, sexpr_ptr, name_str});
                            eshkol_debug("Registered lambda '%s' in homoiconic registry", meta.lambda_name.c_str());
                        }
                    }
                    pending_lambda_sexprs.clear();

                    // CRITICAL: Create S-expression aliases for variable-bound lambdas
                    // This copies lambda_sexpr values to var_sexpr globals AFTER they're populated
                    for (const auto& entry : global_symbol_table) {
                        if (entry.first.length() > 5 &&
                            entry.first.substr(entry.first.length() - 5) == "_func" &&
                            entry.second && isa<Function>(entry.second)) {

                            Function* func = cast<Function>(entry.second);
                            std::string func_name = func->getName().str();
                            std::string var_name = entry.first.substr(0, entry.first.length() - 5);
                            std::string lambda_sexpr_key = func_name + "_sexpr";

                            auto lambda_sexpr_it = global_symbol_table.find(lambda_sexpr_key);
                            if (lambda_sexpr_it != global_symbol_table.end()) {
                                std::string var_sexpr_key = var_name + "_sexpr";
                                GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                                if (var_sexpr_global) {
                                    // Copy lambda_sexpr value to var_sexpr
                                    Value* lambda_sexpr_val = builder->CreateLoad(
                                        int64_type, lambda_sexpr_it->second);
                                    builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                                    eshkol_debug("Initialized var_sexpr alias: %s = %s",
                                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                                }
                            }
                        }
                    }
                }

                // Step 5: Call scheme_main
                Value* result = builder->CreateCall(user_main);
                Value* result_int64 = unpackInt64FromTaggedValue(result);

                // Step 6: Cleanup arena
                if (!g_repl_mode_enabled) {
                    Value* arena_to_destroy = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                    builder->CreateCall(getArenaDestroyFunc(), {arena_to_destroy});
                }

                // Step 7: Return
                Value* int32_result = builder->CreateTrunc(result_int64, int32_type);
                builder->CreateRet(int32_result);

                function_table["main"] = c_main;
            }
            } // end else (not library_mode)

            // Verify the module
            std::string error_str;
            std::string ir_str;
            raw_string_ostream error_stream(error_str);
            raw_string_ostream ir_stream(ir_str);
            if (verifyModule(*module, &error_stream)) {
                module->print(ir_stream, nullptr);
                eshkol_error("LLVM module verification failed: %s", error_str.c_str());
                eshkol_debug("LLVM IR:\n%s", ir_str.c_str());
                return std::make_pair(nullptr, nullptr);
            }

            // Transfer ownership of both module and context
            return std::make_pair(std::move(module), std::move(context));
            
        } catch (const std::exception& e) {
            eshkol_error("Exception in LLVM code generation: %s", e.what());
            return std::make_pair(nullptr, nullptr);
        }
    }
    
private:
    // C library function getters (forwarding to FunctionCache)
    Function* getStrlenFunc() { return funcs->getStrlen(); }
    Function* getMallocFunc() { return funcs->getMalloc(); }
    Function* getMemcpyFunc() { return funcs->getMemcpy(); }
    Function* getMemsetFunc() { return funcs->getMemset(); }
    Function* getStrcmpFunc() { return funcs->getStrcmp(); }
    Function* getStrcpyFunc() { return funcs->getStrcpy(); }
    Function* getStrcatFunc() { return funcs->getStrcat(); }
    Function* getStrstrFunc() { return funcs->getStrstr(); }
    Function* getSnprintfFunc() { return funcs->getSnprintf(); }
    Function* getStrtodFunc() { return funcs->getStrtod(); }

    void createBuiltinFunctions() {
        // malloc function declaration for dynamic allocation
        std::vector<Type*> malloc_args;
        malloc_args.push_back(int64_type); // size_t size

        FunctionType* malloc_type = FunctionType::get(
            PointerType::getUnqual(*context), // return void*
            malloc_args,
            false // not varargs
        );

        Function* malloc_func = Function::Create(
            malloc_type,
            Function::ExternalLinkage,
            "malloc",
            module.get()
        );

        function_table["malloc"] = malloc_func;

        // printf function declaration
        std::vector<Type*> printf_args;
        printf_args.push_back(PointerType::getUnqual(*context)); // const char* format
        
        FunctionType* printf_type = FunctionType::get(
            int32_type, // return int
            printf_args,
            true // varargs
        );
        
        Function* printf_func = Function::Create(
            printf_type,
            Function::ExternalLinkage,
            "printf",
            module.get()
        );
        
        function_table["printf"] = printf_func;

        // sin function declaration (from libm)
        std::vector<Type*> sin_args;
        sin_args.push_back(double_type); // double x

        FunctionType* sin_type = FunctionType::get(
            double_type, // return double
            sin_args,
            false // not varargs
        );

        Function* sin_func = Function::Create(
            sin_type,
            Function::ExternalLinkage,
            "sin",
            module.get()
        );

        function_table["sin"] = sin_func;

        // cos function declaration (from libm)
        std::vector<Type*> cos_args;
        cos_args.push_back(double_type); // double x

        FunctionType* cos_type = FunctionType::get(
            double_type, // return double
            cos_args,
            false // not varargs
        );

        Function* cos_func = Function::Create(
            cos_type,
            Function::ExternalLinkage,
            "cos",
            module.get()
        );

        function_table["cos"] = cos_func;

        // sqrt function declaration (from libm)
        std::vector<Type*> sqrt_args;
        sqrt_args.push_back(double_type); // double x

        FunctionType* sqrt_type = FunctionType::get(
            double_type, // return double
            sqrt_args,
            false // not varargs
        );

        Function* sqrt_func = Function::Create(
            sqrt_type,
            Function::ExternalLinkage,
            "sqrt",
            module.get()
        );

        function_table["sqrt"] = sqrt_func;

        // pow function declaration (from libm)
        std::vector<Type*> pow_args;
        pow_args.push_back(double_type); // double base
        pow_args.push_back(double_type); // double exponent

        FunctionType* pow_type = FunctionType::get(
            double_type, // return double
            pow_args,
            false // not varargs
        );

        Function* pow_func = Function::Create(
            pow_type,
            Function::ExternalLinkage,
            "pow",
            module.get()
        );

        function_table["pow"] = pow_func;

        // exit function declaration (from stdlib.h)
        std::vector<Type*> exit_args;
        exit_args.push_back(int32_type); // int status

        FunctionType* exit_type = FunctionType::get(
            void_type, // returns void (actually noreturn)
            exit_args,
            false // not varargs
        );

        Function* exit_func = Function::Create(
            exit_type,
            Function::ExternalLinkage,
            "exit",
            module.get()
        );
        exit_func->addFnAttr(Attribute::NoReturn);

        function_table["exit"] = exit_func;

        // ============================================================================
        // FILE I/O FUNCTIONS (from stdio.h)
        // ============================================================================

        // fopen: FILE* fopen(const char* filename, const char* mode)
        std::vector<Type*> fopen_args;
        fopen_args.push_back(PointerType::get(*context, 0));  // filename
        fopen_args.push_back(PointerType::get(*context, 0));  // mode
        FunctionType* fopen_type = FunctionType::get(
            PointerType::get(*context, 0), fopen_args, false);
        Function* fopen_func = Function::Create(
            fopen_type, Function::ExternalLinkage, "fopen", module.get());
        function_table["fopen"] = fopen_func;

        // fclose: int fclose(FILE* stream)
        std::vector<Type*> fclose_args;
        fclose_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fclose_type = FunctionType::get(
            int32_type, fclose_args, false);
        Function* fclose_func = Function::Create(
            fclose_type, Function::ExternalLinkage, "fclose", module.get());
        function_table["fclose"] = fclose_func;

        // fgets: char* fgets(char* str, int n, FILE* stream)
        std::vector<Type*> fgets_args;
        fgets_args.push_back(PointerType::get(*context, 0));  // str
        fgets_args.push_back(int32_type);      // n
        fgets_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fgets_type = FunctionType::get(
            PointerType::get(*context, 0), fgets_args, false);
        Function* fgets_func = Function::Create(
            fgets_type, Function::ExternalLinkage, "fgets", module.get());
        function_table["fgets"] = fgets_func;

        // feof: int feof(FILE* stream)
        std::vector<Type*> feof_args;
        feof_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* feof_type = FunctionType::get(
            int32_type, feof_args, false);
        Function* feof_func = Function::Create(
            feof_type, Function::ExternalLinkage, "feof", module.get());
        function_table["feof"] = feof_func;

        // fputs: int fputs(const char* str, FILE* stream)
        std::vector<Type*> fputs_args;
        fputs_args.push_back(PointerType::get(*context, 0));  // str
        fputs_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fputs_type = FunctionType::get(
            int32_type, fputs_args, false);
        Function* fputs_func = Function::Create(
            fputs_type, Function::ExternalLinkage, "fputs", module.get());
        function_table["fputs"] = fputs_func;

        // fputc: int fputc(int c, FILE* stream)
        std::vector<Type*> fputc_args;
        fputc_args.push_back(int32_type);      // c
        fputc_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fputc_type = FunctionType::get(
            int32_type, fputc_args, false);
        Function* fputc_func = Function::Create(
            fputc_type, Function::ExternalLinkage, "fputc", module.get());
        function_table["fputc"] = fputc_func;

        // strlen: size_t strlen(const char* str)
        std::vector<Type*> strlen_args;
        strlen_args.push_back(PointerType::get(*context, 0));  // str
        FunctionType* strlen_type = FunctionType::get(
            int64_type, strlen_args, false);
        Function* strlen_func = Function::Create(
            strlen_type, Function::ExternalLinkage, "strlen", module.get());
        function_table["strlen"] = strlen_func;

        // ============================================================================
        // RANDOM NUMBER FUNCTIONS (from stdlib.h)
        // ============================================================================

        // drand48: double drand48(void) - returns random double in [0.0, 1.0)
        FunctionType* drand48_type = FunctionType::get(
            double_type, {}, false);
        Function* drand48_func = Function::Create(
            drand48_type, Function::ExternalLinkage, "drand48", module.get());
        function_table["drand48"] = drand48_func;

        // srand48: void srand48(long seed) - seeds the random number generator
        std::vector<Type*> srand48_args;
        srand48_args.push_back(int64_type);  // seed
        FunctionType* srand48_type = FunctionType::get(
            void_type, srand48_args, false);
        Function* srand48_func = Function::Create(
            srand48_type, Function::ExternalLinkage, "srand48", module.get());
        function_table["srand48"] = srand48_func;

        // ============================================================================
        // QUANTUM RANDOM NUMBER GENERATOR (from lib/quantum/quantum_rng_wrapper.h)
        // ============================================================================

        // eshkol_qrng_double: double eshkol_qrng_double(void) - quantum random in [0,1)
        FunctionType* qrng_double_type = FunctionType::get(double_type, {}, false);
        Function* qrng_double_func = Function::Create(
            qrng_double_type, Function::ExternalLinkage, "eshkol_qrng_double", module.get());
        function_table["eshkol_qrng_double"] = qrng_double_func;

        // eshkol_qrng_uint64: uint64_t eshkol_qrng_uint64(void) - quantum random uint64
        FunctionType* qrng_uint64_type = FunctionType::get(int64_type, {}, false);
        Function* qrng_uint64_func = Function::Create(
            qrng_uint64_type, Function::ExternalLinkage, "eshkol_qrng_uint64", module.get());
        function_table["eshkol_qrng_uint64"] = qrng_uint64_func;

        // eshkol_qrng_range: int64_t eshkol_qrng_range(int64_t min, int64_t max) - quantum random in range
        std::vector<Type*> qrng_range_args = {int64_type, int64_type};
        FunctionType* qrng_range_type = FunctionType::get(int64_type, qrng_range_args, false);
        Function* qrng_range_func = Function::Create(
            qrng_range_type, Function::ExternalLinkage, "eshkol_qrng_range", module.get());
        function_table["eshkol_qrng_range"] = qrng_range_func;

        // time: time_t time(time_t* timer) - for seeding random
        std::vector<Type*> time_args;
        time_args.push_back(PointerType::get(*context, 0));  // timer (can be NULL)
        FunctionType* time_type = FunctionType::get(
            int64_type, time_args, false);
        Function* time_func = Function::Create(
            time_type, Function::ExternalLinkage, "time", module.get());
        function_table["time"] = time_func;

        // ============================================================================
        // SYSTEM & ENVIRONMENT FUNCTIONS (from stdlib.h, unistd.h)
        // ============================================================================

        // getenv: char* getenv(const char* name) - get environment variable
        std::vector<Type*> getenv_args;
        getenv_args.push_back(PointerType::get(*context, 0));  // name
        FunctionType* getenv_type = FunctionType::get(
            PointerType::get(*context, 0), getenv_args, false);
        Function* getenv_func = Function::Create(
            getenv_type, Function::ExternalLinkage, "getenv", module.get());
        function_table["getenv"] = getenv_func;

        // setenv: int setenv(const char* name, const char* value, int overwrite)
        std::vector<Type*> setenv_args;
        setenv_args.push_back(PointerType::get(*context, 0));  // name
        setenv_args.push_back(PointerType::get(*context, 0));  // value
        setenv_args.push_back(int32_type);                     // overwrite
        FunctionType* setenv_type = FunctionType::get(
            int32_type, setenv_args, false);
        Function* setenv_func = Function::Create(
            setenv_type, Function::ExternalLinkage, "setenv", module.get());
        function_table["setenv"] = setenv_func;

        // unsetenv: int unsetenv(const char* name)
        std::vector<Type*> unsetenv_args;
        unsetenv_args.push_back(PointerType::get(*context, 0));  // name
        FunctionType* unsetenv_type = FunctionType::get(
            int32_type, unsetenv_args, false);
        Function* unsetenv_func = Function::Create(
            unsetenv_type, Function::ExternalLinkage, "unsetenv", module.get());
        function_table["unsetenv"] = unsetenv_func;

        // system: int system(const char* command)
        std::vector<Type*> system_args;
        system_args.push_back(PointerType::get(*context, 0));  // command
        FunctionType* system_type = FunctionType::get(
            int32_type, system_args, false);
        Function* system_func = Function::Create(
            system_type, Function::ExternalLinkage, "system", module.get());
        function_table["system"] = system_func;

        // usleep: int usleep(useconds_t usec) - sleep for microseconds
        std::vector<Type*> usleep_args;
        usleep_args.push_back(int32_type);  // usec (microseconds)
        FunctionType* usleep_type = FunctionType::get(
            int32_type, usleep_args, false);
        Function* usleep_func = Function::Create(
            usleep_type, Function::ExternalLinkage, "usleep", module.get());
        function_table["usleep"] = usleep_func;

        // access: int access(const char* path, int mode) - check file access
        std::vector<Type*> access_args;
        access_args.push_back(PointerType::get(*context, 0));  // path
        access_args.push_back(int32_type);                     // mode
        FunctionType* access_type = FunctionType::get(
            int32_type, access_args, false);
        Function* access_func = Function::Create(
            access_type, Function::ExternalLinkage, "access", module.get());
        function_table["access"] = access_func;

        // remove: int remove(const char* path) - delete file
        std::vector<Type*> remove_args;
        remove_args.push_back(PointerType::get(*context, 0));  // path
        FunctionType* remove_type = FunctionType::get(
            int32_type, remove_args, false);
        Function* remove_func = Function::Create(
            remove_type, Function::ExternalLinkage, "remove", module.get());
        function_table["remove"] = remove_func;

        // rename: int rename(const char* old, const char* new)
        std::vector<Type*> rename_args;
        rename_args.push_back(PointerType::get(*context, 0));  // old path
        rename_args.push_back(PointerType::get(*context, 0));  // new path
        FunctionType* rename_type = FunctionType::get(
            int32_type, rename_args, false);
        Function* rename_func = Function::Create(
            rename_type, Function::ExternalLinkage, "rename", module.get());
        function_table["rename"] = rename_func;

        // mkdir: int mkdir(const char* path, mode_t mode)
        std::vector<Type*> mkdir_args;
        mkdir_args.push_back(PointerType::get(*context, 0));  // path
        mkdir_args.push_back(int32_type);                     // mode
        FunctionType* mkdir_type = FunctionType::get(
            int32_type, mkdir_args, false);
        Function* mkdir_func = Function::Create(
            mkdir_type, Function::ExternalLinkage, "mkdir", module.get());
        function_table["mkdir"] = mkdir_func;

        // rmdir: int rmdir(const char* path)
        std::vector<Type*> rmdir_args;
        rmdir_args.push_back(PointerType::get(*context, 0));  // path
        FunctionType* rmdir_type = FunctionType::get(
            int32_type, rmdir_args, false);
        Function* rmdir_func = Function::Create(
            rmdir_type, Function::ExternalLinkage, "rmdir", module.get());
        function_table["rmdir"] = rmdir_func;

        // getcwd: char* getcwd(char* buf, size_t size)
        std::vector<Type*> getcwd_args;
        getcwd_args.push_back(PointerType::get(*context, 0));  // buf
        getcwd_args.push_back(int64_type);                     // size
        FunctionType* getcwd_type = FunctionType::get(
            PointerType::get(*context, 0), getcwd_args, false);
        Function* getcwd_func = Function::Create(
            getcwd_type, Function::ExternalLinkage, "getcwd", module.get());
        function_table["getcwd"] = getcwd_func;

        // chdir: int chdir(const char* path)
        std::vector<Type*> chdir_args;
        chdir_args.push_back(PointerType::get(*context, 0));  // path
        FunctionType* chdir_type = FunctionType::get(
            int32_type, chdir_args, false);
        Function* chdir_func = Function::Create(
            chdir_type, Function::ExternalLinkage, "chdir", module.get());
        function_table["chdir"] = chdir_func;

        // stat: int stat(const char* path, struct stat* buf)
        std::vector<Type*> stat_args;
        stat_args.push_back(PointerType::get(*context, 0));  // path
        stat_args.push_back(PointerType::get(*context, 0));  // stat buf
        FunctionType* stat_type = FunctionType::get(
            int32_type, stat_args, false);
        Function* stat_func = Function::Create(
            stat_type, Function::ExternalLinkage, "stat", module.get());
        function_table["stat"] = stat_func;

        // opendir: DIR* opendir(const char* name)
        std::vector<Type*> opendir_args;
        opendir_args.push_back(PointerType::get(*context, 0));  // name
        FunctionType* opendir_type = FunctionType::get(
            PointerType::get(*context, 0), opendir_args, false);
        Function* opendir_func = Function::Create(
            opendir_type, Function::ExternalLinkage, "opendir", module.get());
        function_table["opendir"] = opendir_func;

        // readdir: struct dirent* readdir(DIR* dirp)
        std::vector<Type*> readdir_args;
        readdir_args.push_back(PointerType::get(*context, 0));  // dirp
        FunctionType* readdir_type = FunctionType::get(
            PointerType::get(*context, 0), readdir_args, false);
        Function* readdir_func = Function::Create(
            readdir_type, Function::ExternalLinkage, "readdir", module.get());
        function_table["readdir"] = readdir_func;

        // closedir: int closedir(DIR* dirp)
        std::vector<Type*> closedir_args;
        closedir_args.push_back(PointerType::get(*context, 0));  // dirp
        FunctionType* closedir_type = FunctionType::get(
            int32_type, closedir_args, false);
        Function* closedir_func = Function::Create(
            closedir_type, Function::ExternalLinkage, "closedir", module.get());
        function_table["closedir"] = closedir_func;

        // fseek: int fseek(FILE* stream, long offset, int whence)
        std::vector<Type*> fseek_args;
        fseek_args.push_back(PointerType::get(*context, 0));  // stream
        fseek_args.push_back(int64_type);                     // offset
        fseek_args.push_back(int32_type);                     // whence
        FunctionType* fseek_type = FunctionType::get(
            int32_type, fseek_args, false);
        Function* fseek_func = Function::Create(
            fseek_type, Function::ExternalLinkage, "fseek", module.get());
        function_table["fseek"] = fseek_func;

        // ftell: long ftell(FILE* stream)
        std::vector<Type*> ftell_args;
        ftell_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* ftell_type = FunctionType::get(
            int64_type, ftell_args, false);
        Function* ftell_func = Function::Create(
            ftell_type, Function::ExternalLinkage, "ftell", module.get());
        function_table["ftell"] = ftell_func;

        // fread: size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream)
        std::vector<Type*> fread_args;
        fread_args.push_back(PointerType::get(*context, 0));  // ptr
        fread_args.push_back(int64_type);                     // size
        fread_args.push_back(int64_type);                     // nmemb
        fread_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fread_type = FunctionType::get(
            int64_type, fread_args, false);
        Function* fread_func = Function::Create(
            fread_type, Function::ExternalLinkage, "fread", module.get());
        function_table["fread"] = fread_func;

        // fwrite: size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream)
        std::vector<Type*> fwrite_args;
        fwrite_args.push_back(PointerType::get(*context, 0));  // ptr
        fwrite_args.push_back(int64_type);                     // size
        fwrite_args.push_back(int64_type);                     // nmemb
        fwrite_args.push_back(PointerType::get(*context, 0));  // stream
        FunctionType* fwrite_type = FunctionType::get(
            int64_type, fwrite_args, false);
        Function* fwrite_func = Function::Create(
            fwrite_type, Function::ExternalLinkage, "fwrite", module.get());
        function_table["fwrite"] = fwrite_func;

        // ============================================================================
        // COMPREHENSIVE C STANDARD MATH FUNCTIONS
        // ============================================================================

        // Helper to declare a single-arg math function (double -> double)
        auto declareUnaryMathFunc = [this](const char* name) {
            std::vector<Type*> args = {double_type};
            FunctionType* type = FunctionType::get(double_type, args, false);
            Function* func = Function::Create(type, Function::ExternalLinkage, name, module.get());
            function_table[name] = func;
        };

        // Helper to declare a two-arg math function (double, double -> double)
        auto declareBinaryMathFunc = [this](const char* name) {
            std::vector<Type*> args = {double_type, double_type};
            FunctionType* type = FunctionType::get(double_type, args, false);
            Function* func = Function::Create(type, Function::ExternalLinkage, name, module.get());
            function_table[name] = func;
        };

        // Trigonometric functions
        declareUnaryMathFunc("tan");
        declareUnaryMathFunc("asin");
        declareUnaryMathFunc("acos");
        declareUnaryMathFunc("atan");
        declareBinaryMathFunc("atan2");

        // Hyperbolic functions
        declareUnaryMathFunc("sinh");
        declareUnaryMathFunc("cosh");
        declareUnaryMathFunc("tanh");
        declareUnaryMathFunc("asinh");
        declareUnaryMathFunc("acosh");
        declareUnaryMathFunc("atanh");

        // Exponential
        declareUnaryMathFunc("exp2");

        // Logarithmic
        declareUnaryMathFunc("log");  // natural log
        declareUnaryMathFunc("log10");
        declareUnaryMathFunc("log2");

        // Numeric/rounding functions
        declareUnaryMathFunc("fabs");   // absolute value
        declareUnaryMathFunc("floor");
        declareUnaryMathFunc("ceil");
        declareUnaryMathFunc("round");
        declareUnaryMathFunc("trunc");
        declareBinaryMathFunc("fmod");  // modulo for floats
        declareBinaryMathFunc("remainder");  // IEEE remainder
        declareBinaryMathFunc("fmin");
        declareBinaryMathFunc("fmax");
        declareUnaryMathFunc("cbrt");   // cube root

        // Note: Builtin runtime function declarations (eshkol_deep_equal, eshkol_display_value,
        // eshkol_lambda_registry_*) are now created via BuiltinDeclarations after CodegenContext
        // is initialized. See the builtins_ initialization below.

        // Get struct types from TypeSystem (types are created once in constructor)
        dual_number_type = types->getDualNumberType();
        ad_node_type = types->getAdNodeType();
        tensor_type = types->getTensorType();

        // Initialize tape state
        current_tape_ptr = nullptr;
        next_node_id = 0;

        eshkol_debug("Using TypeSystem-managed struct types (dual_number, ad_node, tensor)");

        // Initialize memory codegen (creates arena function declarations)
        mem = std::make_unique<eshkol::MemoryCodegen>(*module, *types);

        // Initialize CodegenContext - shared state for extracted modules
        // This must happen after types, funcs, and mem are all initialized
        ctx_ = std::make_unique<eshkol::CodegenContext>(
            *context, *module, *builder, *types, *funcs, *mem
        );
        ctx_->setLibraryMode(library_mode);
        ctx_->setModulePrefix(module_prefix);
        ctx_->setGlobalArena(global_arena);
        ctx_->setAdModeActive(ad_mode_active);
        ctx_->setCurrentAdTape(current_ad_tape);
        ctx_->setAdTapeStack(ad_tape_stack);
        ctx_->setAdTapeDepth(ad_tape_depth);
        ctx_->setOuterAdNodeStorage(outer_ad_node_storage);
        ctx_->setOuterAdNodeToInner(outer_ad_node_to_inner);
        ctx_->setOuterGradAccumulator(outer_grad_accumulator);
        ctx_->setInnerVarNodePtr(inner_var_node_ptr);
        ctx_->setGradientXDegree(gradient_x_degree);
        ctx_->setOuterAdNodeStack(outer_ad_node_stack);
        ctx_->setOuterAdNodeDepth(outer_ad_node_depth);
        if (g_repl_mode_enabled) {
            ctx_->setReplMode(true);
        }
        eshkol_debug("Created CodegenContext for module '%s'", module_prefix.c_str());

        // Initialize TaggedValueCodegen - pack/unpack operations for tagged values
        tagged_ = std::make_unique<eshkol::TaggedValueCodegen>(*ctx_);
        eshkol_debug("Created TaggedValueCodegen");

        // Initialize BuiltinDeclarations - runtime function declarations
        // Creates: eshkol_deep_equal, eshkol_display_value, eshkol_lambda_registry_*
        builtins_ = std::make_unique<eshkol::BuiltinDeclarations>(*ctx_);
        // Update member pointers for backward compatibility
        eshkol_deep_equal_func = builtins_->getDeepEqual();
        eshkol_display_value_func = builtins_->getDisplayValue();
        eshkol_lambda_registry_init_func = builtins_->getLambdaRegistryInit();
        eshkol_lambda_registry_add_func = builtins_->getLambdaRegistryAdd();
        eshkol_lambda_registry_lookup_func = builtins_->getLambdaRegistryLookup();
        eshkol_debug("Created BuiltinDeclarations");

        // Initialize TensorCodegen - tensor operations (needed by ArithmeticCodegen)
        tensor_ = std::make_unique<eshkol::TensorCodegen>(*ctx_, *tagged_, *mem);
        // Set up callbacks for AST evaluation (uses same pattern as other modules)
        tensor_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            ControlFlowCallbacks::typedToTaggedWrapper,
            this
        );
        eshkol_debug("Created TensorCodegen with callbacks");

        // Initialize AutodiffCodegen - automatic differentiation operations (needed by ArithmeticCodegen)
        autodiff_ = std::make_unique<eshkol::AutodiffCodegen>(*ctx_, *tagged_, *mem);
        // Set up function table reference for math operations (sin, cos, exp, etc.)
        autodiff_->setFunctionTable(&function_table);
        // Set up symbol tables for variable/capture lookup
        autodiff_->setSymbolTables(&symbol_table, &global_symbol_table);
        // Set up REPL mode flag
        autodiff_->setReplMode(&g_repl_mode_enabled);
        // Set up REPL state for cross-evaluation function resolution
        autodiff_->setReplState(&g_repl_mutex, &g_repl_lambda_captures, &g_repl_symbol_addresses);
        // Set up AST codegen callback
        autodiff_->setCodegenASTCallback(ControlFlowCallbacks::codegenASTTypedWrapper, this);
        // Set up lambda resolution callback
        autodiff_->setResolveLambdaCallback(ControlFlowCallbacks::resolveLambdaWrapper);
        eshkol_debug("Created AutodiffCodegen with function table and callbacks");

        // Initialize ArithmeticCodegen - polymorphic arithmetic operations
        // Now fully functional with tensor and autodiff support
        arith_ = std::make_unique<eshkol::ArithmeticCodegen>(*ctx_, *tagged_, *tensor_, *autodiff_);
        eshkol_debug("Created ArithmeticCodegen");

        // Initialize CallApplyCodegen - function call and apply operations
        call_apply_ = std::make_unique<eshkol::CallApplyCodegen>(*ctx_, *tagged_, *arith_);
        call_apply_->setSymbolTables(&symbol_table, &global_symbol_table);
        call_apply_->setVariadicFunctionInfo(&variadic_function_info);
        call_apply_->setCodegenASTCallback(ControlFlowCallbacks::codegenASTTypedWrapper, this);
        call_apply_->setExtractConsCarCallback(ControlFlowCallbacks::extractConsCarWrapper);
        call_apply_->setGetConsAccessorCallback(ControlFlowCallbacks::getConsAccessorWrapper);
        call_apply_->setCreateConsCallback(ControlFlowCallbacks::consCreateWrapper);
        eshkol_debug("Created CallApplyCodegen with callbacks");

        // Initialize MapCodegen - higher-order list mapping operations
        map_ = std::make_unique<eshkol::MapCodegen>(*ctx_, *tagged_);
        map_->setSymbolTables(&symbol_table, &global_symbol_table);
        map_->setFunctionTable(&function_table);
        map_->setNestedFunctionCaptures(&nested_function_captures);
        map_->setLastGeneratedLambdaName(&last_generated_lambda_name);
        map_->setCurrentFunction(&current_function);
        map_->setCodegenASTCallback(ControlFlowCallbacks::codegenASTTypedWrapper, this);
        map_->setCodegenLambdaCallback(ControlFlowCallbacks::codegenLambdaWrapper);
        map_->setClosureCallCallback(ControlFlowCallbacks::closureCallWrapper);
        map_->setExtractCarCallback(ControlFlowCallbacks::extractConsCarWrapper);
        map_->setCreateConsCallback(ControlFlowCallbacks::consCreateWrapper);
        map_->setGetConsGetPtrCallback(ControlFlowCallbacks::getConsAccessorWrapper);
        map_->setGetConsSetPtrCallback(ControlFlowCallbacks::getConsSetPtrWrapper);
        map_->setResolveLambdaCallback(ControlFlowCallbacks::resolveLambdaWrapper);
        map_->setIndirectCallCallback(ControlFlowCallbacks::indirectCallWrapper);
        map_->setFunctionContextCallbacks(ControlFlowCallbacks::pushFunctionContextWrapper,
                                          ControlFlowCallbacks::popFunctionContextWrapper);
        eshkol_debug("Created MapCodegen with callbacks");

        // Initialize ControlFlowCodegen - control flow operations
        // Now fully functional with callback-based AST evaluation
        flow_ = std::make_unique<eshkol::ControlFlowCodegen>(*ctx_, *tagged_);
        // Set up callbacks for AST evaluation
        flow_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            ControlFlowCallbacks::typedToTaggedWrapper,
            ControlFlowCallbacks::codegenFuncDefineWrapper,
            ControlFlowCallbacks::codegenVarDefineWrapper,
            ControlFlowCallbacks::eqvCompareWrapper,
            ControlFlowCallbacks::detectAndPackWrapper,
            this
        );
        eshkol_debug("Created ControlFlowCodegen with callbacks");

        // Initialize StringIOCodegen - string and I/O operations
        strio_ = std::make_unique<eshkol::StringIOCodegen>(*ctx_, *tagged_);
        // Set up callbacks for AST evaluation (reuse ControlFlowCallbacks wrappers)
        strio_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            ControlFlowCallbacks::typedToTaggedWrapper,
            ControlFlowCallbacks::consCreateWrapper,
            this
        );
        strio_->setDisplayValueFunc(eshkol_display_value_func);
        eshkol_debug("Created StringIOCodegen with callbacks");

        // Initialize BindingCodegen - variable binding operations
        binding_ = std::make_unique<eshkol::BindingCodegen>(*ctx_, *tagged_);
        binding_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            ControlFlowCallbacks::typedToTaggedWrapper,
            ControlFlowCallbacks::getTypedValueTypeWrapper,
            ControlFlowCallbacks::registerFuncBindingWrapper,
            this
        );
        binding_->setSymbolTables(&symbol_table, &global_symbol_table);
        binding_->setCurrentFunction(&current_function);
        binding_->setReplMode(&g_repl_mode_enabled);
        binding_->setLambdaTracking(&last_generated_lambda_name, &function_table);
        binding_->setLetrecExcludedCaptureNames(&letrec_excluded_capture_names);
        // Set up TCO callbacks for tail call optimization
        binding_->setTCOCallbacks(ControlFlowCallbacks::isSelfTailRecursiveWrapper);
        eshkol_debug("Created BindingCodegen with callbacks and TCO support");

        // Initialize CollectionCodegen - list and vector operations
        coll_ = std::make_unique<eshkol::CollectionCodegen>(*ctx_, *tagged_, *mem);
        // Set up callbacks for AST evaluation (reuse ControlFlowCallbacks wrappers)
        coll_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            ControlFlowCallbacks::typedToTaggedWrapper,
            this
        );
        eshkol_debug("Created CollectionCodegen with callbacks");

        // Initialize HomoiconicCodegen - quote and S-expression operations
        homoiconic_ = std::make_unique<eshkol::HomoiconicCodegen>(*ctx_, *tagged_, *coll_, *strio_);
        eshkol_debug("Created HomoiconicCodegen");

        // Initialize TailCallCodegen - tail call optimization support
        tailcall_ = std::make_unique<eshkol::TailCallCodegen>(*ctx_, *tagged_, *mem);
        tailcall_->generateTrampolineRuntime();
        eshkol_debug("Created TailCallCodegen with trampoline runtime");

        // Initialize SystemCodegen - system, environment, and file operations
        system_ = std::make_unique<eshkol::SystemCodegen>(*ctx_, *tagged_, *mem, function_table);
        system_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            this
        );
        eshkol_debug("Created SystemCodegen");

        // Initialize HashCodegen - hash table operations
        hash_ = std::make_unique<eshkol::HashCodegen>(*ctx_, *tagged_, *mem, function_table);
        hash_->setCodegenCallbacks(
            ControlFlowCallbacks::codegenASTWrapper,
            ControlFlowCallbacks::codegenTypedASTWrapper,
            this
        );
        eshkol_debug("Created HashCodegen");

        // Initialize FunctionCodegen - lambda and closure operations
        // Note: The main implementations remain in this file for now
        func_ = std::make_unique<eshkol::FunctionCodegen>(*ctx_, *tagged_, *mem);
        eshkol_debug("Created FunctionCodegen");

        // Populate function_table for backward compatibility
        registerArenaFunctions();
    }

    void registerArenaFunctions() {
        // Register arena functions in function_table for name-based lookups
        function_table["arena_create"] = mem->getArenaCreate();
        function_table["arena_destroy"] = mem->getArenaDestroy();
        function_table["arena_allocate"] = mem->getArenaAllocate();
        function_table["arena_push_scope"] = mem->getArenaPushScope();
        function_table["arena_pop_scope"] = mem->getArenaPopScope();
        function_table["arena_allocate_cons_cell"] = mem->getArenaAllocateConsCell();
        function_table["arena_allocate_closure"] = mem->getArenaAllocateClosure();
        function_table["arena_allocate_tagged_cons_cell"] = mem->getArenaAllocateTaggedConsCell();
        function_table["arena_tagged_cons_get_int64"] = mem->getTaggedConsGetInt64();
        function_table["arena_tagged_cons_get_double"] = mem->getTaggedConsGetDouble();
        function_table["arena_tagged_cons_get_ptr"] = mem->getTaggedConsGetPtr();
        function_table["arena_tagged_cons_set_int64"] = mem->getTaggedConsSetInt64();
        function_table["arena_tagged_cons_set_double"] = mem->getTaggedConsSetDouble();
        function_table["arena_tagged_cons_set_ptr"] = mem->getTaggedConsSetPtr();
        function_table["arena_tagged_cons_set_null"] = mem->getTaggedConsSetNull();
        function_table["arena_tagged_cons_get_type"] = mem->getTaggedConsGetType();
        function_table["arena_tagged_cons_get_flags"] = mem->getTaggedConsGetFlags();
        function_table["arena_tagged_cons_set_tagged_value"] = mem->getTaggedConsSetTaggedValue();
        function_table["arena_tagged_cons_get_tagged_value"] = mem->getTaggedConsGetTaggedValue();
        function_table["arena_allocate_tape"] = mem->getArenaAllocateTape();
        function_table["arena_tape_add_node"] = mem->getArenaTapeAddNode();
        function_table["arena_tape_reset"] = mem->getArenaTapeReset();
        function_table["arena_tape_get_node"] = mem->getArenaTapeGetNode();
        function_table["arena_tape_get_node_count"] = mem->getArenaTapeGetNodeCount();
        function_table["arena_allocate_ad_node"] = mem->getArenaAllocateAdNode();

        eshkol_debug("Registered arena functions from MemoryCodegen");

        // Create additional display/utility functions (these need full codegen, not just declarations)
        createDisplayTensorRecursiveFunction();
    }

    // Note: Old createArenaFunctions was ~600 lines - now in MemoryCodegen

    // Arena function accessors (forwarding to MemoryCodegen)
    Function* getArenaCreateFunc() { return mem->getArenaCreate(); }
    Function* getArenaDestroyFunc() { return mem->getArenaDestroy(); }
    Function* getArenaAllocateFunc() { return mem->getArenaAllocate(); }
    Function* getArenaPushScopeFunc() { return mem->getArenaPushScope(); }
    Function* getArenaPopScopeFunc() { return mem->getArenaPopScope(); }
    Function* getArenaAllocateConsCellFunc() { return mem->getArenaAllocateConsCell(); }
    Function* getArenaAllocateClosureFunc() { return mem->getArenaAllocateClosure(); }
    Function* getArenaAllocateTaggedConsCellFunc() { return mem->getArenaAllocateTaggedConsCell(); }
    Function* getTaggedConsGetInt64Func() { return mem->getTaggedConsGetInt64(); }
    Function* getTaggedConsGetDoubleFunc() { return mem->getTaggedConsGetDouble(); }
    Function* getTaggedConsGetPtrFunc() { return mem->getTaggedConsGetPtr(); }
    Function* getTaggedConsSetInt64Func() { return mem->getTaggedConsSetInt64(); }
    Function* getTaggedConsSetDoubleFunc() { return mem->getTaggedConsSetDouble(); }
    Function* getTaggedConsSetPtrFunc() { return mem->getTaggedConsSetPtr(); }
    Function* getTaggedConsSetNullFunc() { return mem->getTaggedConsSetNull(); }
    Function* getTaggedConsGetTypeFunc() { return mem->getTaggedConsGetType(); }
    Function* getTaggedConsGetFlagsFunc() { return mem->getTaggedConsGetFlags(); }
    Function* getTaggedConsSetTaggedValueFunc() { return mem->getTaggedConsSetTaggedValue(); }
    Function* getTaggedConsGetTaggedValueFunc() { return mem->getTaggedConsGetTaggedValue(); }
    Function* getArenaAllocateTapeFunc() { return mem->getArenaAllocateTape(); }
    Function* getArenaTapeAddNodeFunc() { return mem->getArenaTapeAddNode(); }
    Function* getArenaTapeResetFunc() { return mem->getArenaTapeReset(); }
    Function* getArenaTapeGetNodeFunc() { return mem->getArenaTapeGetNode(); }
    Function* getArenaTapeGetNodeCountFunc() { return mem->getArenaTapeGetNodeCount(); }
    Function* getArenaAllocateAdNodeFunc() { return mem->getArenaAllocateAdNode(); }

    // Legacy code removed - arena functions are now in MemoryCodegen (~600 lines saved)
    // The old createArenaFunctions() method has been replaced by:
    //   1. MemoryCodegen construction in generateIR()
    //   2. registerArenaFunctions() for function_table population
    //   3. Forwarding accessors above for direct function pointer access

    // ===== OLD ARENA FUNCTION DECLARATIONS REMOVED (see memory_codegen.cpp) =====
    // Approximately 560 lines of arena function declarations were moved to MemoryCodegen

    void createDisplayTensorRecursiveFunction() {
        // Recursive helper function for displaying tensors with proper dimensional nesting
        // Signature: void displayTensorRecursive(double* elements, uint64_t* dims, uint64_t num_dims, uint64_t current_dim, uint64_t offset)
        
        
        std::vector<Type*> params;
        params.push_back(PointerType::getUnqual(*context));  // double* elements
        params.push_back(PointerType::getUnqual(*context));  // uint64_t* dims
        params.push_back(int64_type);        // uint64_t num_dims
        params.push_back(int64_type);        // uint64_t current_dim
        params.push_back(int64_type);        // uint64_t offset
        
        FunctionType* func_type = FunctionType::get(
            void_type,
            params,
            false  // not varargs
        );
        
        display_tensor_recursive_func = Function::Create(
            func_type,
            Function::InternalLinkage,
            "displayTensorRecursive",
            module.get()
        );
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", display_tensor_recursive_func);
        
        // Save old insertion point
        IRBuilderBase::InsertPoint old_ip = builder->saveIP();
        builder->SetInsertPoint(entry);
        
        // Get parameters
        auto arg_it = display_tensor_recursive_func->arg_begin();
        Value* elements = &*arg_it++;
        elements->setName("elements");
        Value* dims = &*arg_it++;
        dims->setName("dims");
        Value* num_dims = &*arg_it++;
        num_dims->setName("num_dims");
        Value* current_dim = &*arg_it++;
        current_dim->setName("current_dim");
        Value* offset = &*arg_it;
        offset->setName("offset");
        
        Function* printf_func = function_table["printf"];
        
        // Check: current_dim == num_dims - 1? (base case)
        Value* num_dims_minus_1 = builder->CreateSub(num_dims, ConstantInt::get(int64_type, 1));
        Value* is_base_case = builder->CreateICmpEQ(current_dim, num_dims_minus_1);
        
        BasicBlock* base_case = BasicBlock::Create(*context, "base_case", display_tensor_recursive_func);
        BasicBlock* recursive_case = BasicBlock::Create(*context, "recursive_case", display_tensor_recursive_func);
        BasicBlock* func_exit = BasicBlock::Create(*context, "exit", display_tensor_recursive_func);
        
        builder->CreateCondBr(is_base_case, base_case, recursive_case);
        
        // === BASE CASE: Print innermost dimension ===
        builder->SetInsertPoint(base_case);
        builder->CreateCall(printf_func, {codegenString("(")});
        
        // Get dimension size at current_dim
        Value* dim_size_ptr = builder->CreateGEP(int64_type, dims, current_dim);
        Value* dim_size = builder->CreateLoad(int64_type, dim_size_ptr);
        
        // Loop: print elements
        BasicBlock* base_loop_cond = BasicBlock::Create(*context, "base_loop_cond", display_tensor_recursive_func);
        BasicBlock* base_loop_body = BasicBlock::Create(*context, "base_loop_body", display_tensor_recursive_func);
        BasicBlock* base_loop_exit = BasicBlock::Create(*context, "base_loop_exit", display_tensor_recursive_func);
        
        Value* base_i = builder->CreateAlloca(int64_type, nullptr, "base_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), base_i);
        builder->CreateBr(base_loop_cond);
        
        builder->SetInsertPoint(base_loop_cond);
        Value* i_val = builder->CreateLoad(int64_type, base_i);
        Value* i_less = builder->CreateICmpULT(i_val, dim_size);
        builder->CreateCondBr(i_less, base_loop_body, base_loop_exit);
        
        builder->SetInsertPoint(base_loop_body);
        // Add space before non-first elements
        Value* i_is_zero = builder->CreateICmpEQ(i_val, ConstantInt::get(int64_type, 0));
        BasicBlock* skip_space = BasicBlock::Create(*context, "skip_space", display_tensor_recursive_func);
        BasicBlock* print_space = BasicBlock::Create(*context, "print_space", display_tensor_recursive_func);
        BasicBlock* print_elem = BasicBlock::Create(*context, "print_elem", display_tensor_recursive_func);
        
        builder->CreateCondBr(i_is_zero, skip_space, print_space);
        
        builder->SetInsertPoint(print_space);
        builder->CreateCall(printf_func, {codegenString(" ")});
        builder->CreateBr(print_elem);
        
        builder->SetInsertPoint(skip_space);
        builder->CreateBr(print_elem);
        
        builder->SetInsertPoint(print_elem);
        // Print element at offset + i
        // Elements are stored as int64 (bit representation of doubles), need to bitcast
        Value* elem_idx = builder->CreateAdd(offset, i_val);
        Value* elem_ptr = builder->CreateGEP(int64_type, elements, elem_idx);
        Value* elem_bits = builder->CreateLoad(int64_type, elem_ptr);
        Value* elem_val = builder->CreateBitCast(elem_bits, double_type);
        builder->CreateCall(printf_func, {codegenString("%g"), elem_val});
        
        // Increment i
        Value* i_next = builder->CreateAdd(i_val, ConstantInt::get(int64_type, 1));
        builder->CreateStore(i_next, base_i);
        builder->CreateBr(base_loop_cond);
        
        builder->SetInsertPoint(base_loop_exit);
        builder->CreateCall(printf_func, {codegenString(")")});
        builder->CreateBr(func_exit);
        
        // === RECURSIVE CASE: Process outer dimension ===
        builder->SetInsertPoint(recursive_case);
        builder->CreateCall(printf_func, {codegenString("(")});
        
        // Calculate stride = product of dims[current_dim+1..num_dims-1]
        Value* stride = builder->CreateAlloca(int64_type, nullptr, "stride");
        builder->CreateStore(ConstantInt::get(int64_type, 1), stride);
        
        // Compute stride using loop
        Value* next_dim = builder->CreateAdd(current_dim, ConstantInt::get(int64_type, 1));
        
        BasicBlock* stride_loop_cond = BasicBlock::Create(*context, "stride_cond", display_tensor_recursive_func);
        BasicBlock* stride_loop_body = BasicBlock::Create(*context, "stride_body", display_tensor_recursive_func);
        BasicBlock* stride_loop_exit = BasicBlock::Create(*context, "stride_exit", display_tensor_recursive_func);
        
        Value* k = builder->CreateAlloca(int64_type, nullptr, "k");
        builder->CreateStore(next_dim, k);
        builder->CreateBr(stride_loop_cond);
        
        builder->SetInsertPoint(stride_loop_cond);
        Value* k_val = builder->CreateLoad(int64_type, k);
        Value* k_less = builder->CreateICmpULT(k_val, num_dims);
        builder->CreateCondBr(k_less, stride_loop_body, stride_loop_exit);
        
        builder->SetInsertPoint(stride_loop_body);
        Value* dim_k_ptr = builder->CreateGEP(int64_type, dims, k_val);
        Value* dim_k = builder->CreateLoad(int64_type, dim_k_ptr);
        Value* current_stride = builder->CreateLoad(int64_type, stride);
        Value* new_stride = builder->CreateMul(current_stride, dim_k);
        builder->CreateStore(new_stride, stride);
        Value* k_next = builder->CreateAdd(k_val, ConstantInt::get(int64_type, 1));
        builder->CreateStore(k_next, k);
        builder->CreateBr(stride_loop_cond);
        
        builder->SetInsertPoint(stride_loop_exit);
        Value* final_stride = builder->CreateLoad(int64_type, stride);
        
        // Get current dimension size
        Value* curr_dim_ptr = builder->CreateGEP(int64_type, dims, current_dim);
        Value* curr_dim_size = builder->CreateLoad(int64_type, curr_dim_ptr);
        
        // Loop over current dimension, recursing for each slice
        BasicBlock* rec_loop_cond = BasicBlock::Create(*context, "rec_loop_cond", display_tensor_recursive_func);
        BasicBlock* rec_loop_body = BasicBlock::Create(*context, "rec_loop_body", display_tensor_recursive_func);
        BasicBlock* rec_loop_exit = BasicBlock::Create(*context, "rec_loop_exit", display_tensor_recursive_func);
        
        Value* rec_i = builder->CreateAlloca(int64_type, nullptr, "rec_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), rec_i);
        builder->CreateBr(rec_loop_cond);
        
        builder->SetInsertPoint(rec_loop_cond);
        Value* i_val_rec = builder->CreateLoad(int64_type, rec_i);
        Value* i_less_rec = builder->CreateICmpULT(i_val_rec, curr_dim_size);
        builder->CreateCondBr(i_less_rec, rec_loop_body, rec_loop_exit);
        
        builder->SetInsertPoint(rec_loop_body);
        // Add space before non-first slices
        Value* i_is_zero_rec = builder->CreateICmpEQ(i_val_rec, ConstantInt::get(int64_type, 0));
        BasicBlock* skip_space_rec = BasicBlock::Create(*context, "skip_space_rec", display_tensor_recursive_func);
        BasicBlock* print_space_rec = BasicBlock::Create(*context, "print_space_rec", display_tensor_recursive_func);
        BasicBlock* make_recursive_call = BasicBlock::Create(*context, "recursive_call", display_tensor_recursive_func);
        
        builder->CreateCondBr(i_is_zero_rec, skip_space_rec, print_space_rec);
        
        builder->SetInsertPoint(print_space_rec);
        builder->CreateCall(printf_func, {codegenString(" ")});
        builder->CreateBr(make_recursive_call);
        
        builder->SetInsertPoint(skip_space_rec);
        builder->CreateBr(make_recursive_call);
        
        builder->SetInsertPoint(make_recursive_call);
        // RECURSIVE CALL: Process next dimension at offset + i*stride
        Value* new_offset = builder->CreateAdd(offset, builder->CreateMul(i_val_rec, final_stride));
        builder->CreateCall(display_tensor_recursive_func, {
            elements,
            dims,
            num_dims,
            next_dim,
            new_offset
        });
        
        // Increment i
        Value* i_next_rec = builder->CreateAdd(i_val_rec, ConstantInt::get(int64_type, 1));
        builder->CreateStore(i_next_rec, rec_i);
        builder->CreateBr(rec_loop_cond);
        
        builder->SetInsertPoint(rec_loop_exit);
        builder->CreateCall(printf_func, {codegenString(")")});
        builder->CreateBr(func_exit);
        
        // Exit point
        builder->SetInsertPoint(func_exit);
        builder->CreateRetVoid();
        
        // Restore insertion point
        builder->restoreIP(old_ip);
        
        function_table["displayTensorRecursive"] = display_tensor_recursive_func;
        eshkol_debug("Created recursive N-dimensional tensor display helper function");
    }
    
    void createFunctionDeclaration(const eshkol_ast_t* ast) {
        if (ast->type != ESHKOL_OP || ast->operation.op != ESHKOL_DEFINE_OP ||
            !ast->operation.define_op.is_function) {
            return;
        }

        const char* func_name = ast->operation.define_op.name;
        uint64_t num_params = ast->operation.define_op.num_params;
        bool is_variadic = ast->operation.define_op.is_variadic && ast->operation.define_op.rest_param;

        // Create polymorphic function type - all parameters and return type are tagged_value
        std::vector<Type*> param_types(num_params, tagged_value_type);

        // VARIADIC FIX: Add extra parameter for rest list
        if (is_variadic) {
            param_types.push_back(tagged_value_type);  // rest parameter (list of remaining args)
        }

        FunctionType* func_type = FunctionType::get(
            tagged_value_type, // return tagged_value
            param_types,
            false // not varargs - we handle variadics by passing a list
        );

        Function* function = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // Set parameter names
        auto arg_it = function->arg_begin();
        if (ast->operation.define_op.parameters) {
            for (uint64_t i = 0; i < num_params && arg_it != function->arg_end(); ++i, ++arg_it) {
                if (ast->operation.define_op.parameters[i].type == ESHKOL_VAR &&
                    ast->operation.define_op.parameters[i].variable.id) {
                    arg_it->setName(ast->operation.define_op.parameters[i].variable.id);
                }
            }
        }
        // Set name for rest parameter
        if (is_variadic && arg_it != function->arg_end()) {
            arg_it->setName(ast->operation.define_op.rest_param);
        }

        // VARIADIC FIX: Register variadic function info
        if (is_variadic) {
            variadic_function_info[func_name] = std::make_pair(num_params, true);
            eshkol_debug("Registered variadic function %s with %llu fixed params",
                        func_name, (unsigned long long)num_params);
        }

        // FUNCTION-AS-VALUE FIX: Record arity for closure wrapping when function is used as value
        function_arity_table[func_name] = num_params;

        registerContextFunction(func_name, function);
        eshkol_debug("Created polymorphic function declaration: %s with %llu tagged_value parameters%s",
                    func_name, (unsigned long long)num_params, is_variadic ? " (variadic)" : "");
    }

    // Recursively traverse AST to find nested function definitions
    // Pre-generate top-level lambdas so user-defined main can reference them
    // This is needed because user's main is compiled in Step 2, before Step 3 processes global defines
    void preGenerateTopLevelLambdas(const eshkol_ast_t* asts, size_t num_asts) {
        // Create a temporary init function to use as insertion point for any capture loads
        FunctionType* init_type = FunctionType::get(void_type, false);
        Function* init_func = Function::Create(init_type, Function::InternalLinkage,
                                                "__lambda_init__", module.get());
        BasicBlock* init_entry = BasicBlock::Create(*context, "entry", init_func);

        IRBuilderBase::InsertPoint saved_point = builder->saveIP();
        Function* saved_function = current_function;

        builder->SetInsertPoint(init_entry);
        current_function = init_func;

        for (size_t i = 0; i < num_asts; i++) {
            // Look for (define var (lambda ...)) patterns
            if (asts[i].type == ESHKOL_OP &&
                asts[i].operation.op == ESHKOL_DEFINE_OP &&
                !asts[i].operation.define_op.is_function) {

                const char* var_name = asts[i].operation.define_op.name;
                const eshkol_ast_t* value = asts[i].operation.define_op.value;

                // Check if value is a lambda expression
                if (value && value->type == ESHKOL_OP &&
                    value->operation.op == ESHKOL_LAMBDA_OP) {

                    eshkol_debug("Pre-generating lambda for top-level define: %s", var_name);

                    // Generate the lambda function
                    Value* lambda_func = codegenLambda(&value->operation);

                    if (lambda_func && isa<Function>(lambda_func)) {
                        Function* actual_func = cast<Function>(lambda_func);
                        // Store the function reference for gradient/derivative resolution
                        symbol_table[std::string(var_name) + "_func"] = actual_func;
                        global_symbol_table[std::string(var_name) + "_func"] = actual_func;
                        eshkol_debug("Pre-generated lambda stored as %s_func", var_name);

                        // HOMOICONIC FIX: Pre-create the var_sexpr global so display code can find it
                        // The actual S-expression value will be copied later during variable definition
                        std::string lambda_name = actual_func->getName().str();
                        std::string lambda_sexpr_key = lambda_name + "_sexpr";
                        std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                        GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                        if (lambda_sexpr_global && !module->getNamedGlobal(var_sexpr_key)) {
                            // Create var_sexpr global (initial value will be set later)
                            new GlobalVariable(
                                *module, int64_type, false,
                                GlobalValue::ExternalLinkage,
                                ConstantInt::get(int64_type, 0),
                                var_sexpr_key
                            );
                            eshkol_debug("Pre-created S-expression alias global: %s for %s",
                                        var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                        }
                    }
                }
            }
        }

        // Clean up: add return to init function (even though we won't call it)
        builder->CreateRetVoid();

        // Restore state
        builder->restoreIP(saved_point);
        current_function = saved_function;

        // Note: We keep the init function in the module but it's internal linkage
        // and will be removed by dead code elimination
    }

    // Note: We don't pre-declare nested functions anymore - they're generated at codegen time
    // with proper closure support (like lambdas)
    void declareNestedFunctions(const eshkol_ast_t* ast) {
        if (!ast) return;

        // Check if this is a function definition - just recurse, don't declare
        // (nested functions are handled at codegen time by codegenNestedFunctionDefinition)
        if (ast->type == ESHKOL_OP && ast->operation.op == ESHKOL_DEFINE_OP &&
            ast->operation.define_op.is_function) {
            // Recurse into the function body to find deeper nested functions
            if (ast->operation.define_op.value) {
                declareNestedFunctions(ast->operation.define_op.value);
            }
        }

        // Recurse into operation operands
        if (ast->type == ESHKOL_OP) {
            switch (ast->operation.op) {
                case ESHKOL_DEFINE_OP:
                    if (ast->operation.define_op.value) {
                        declareNestedFunctions(ast->operation.define_op.value);
                    }
                    break;
                case ESHKOL_SEQUENCE_OP:
                    for (uint64_t i = 0; i < ast->operation.sequence_op.num_expressions; i++) {
                        declareNestedFunctions(&ast->operation.sequence_op.expressions[i]);
                    }
                    break;
                case ESHKOL_LET_OP:
                case ESHKOL_LET_STAR_OP:
                case ESHKOL_LETREC_OP:
                    // Check bindings for function definitions (bindings are cons cells: (var . value))
                    for (uint64_t i = 0; i < ast->operation.let_op.num_bindings; i++) {
                        const eshkol_ast_t* binding = &ast->operation.let_op.bindings[i];
                        if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                            declareNestedFunctions(binding->cons_cell.cdr);
                        }
                    }
                    // Check body
                    if (ast->operation.let_op.body) {
                        declareNestedFunctions(ast->operation.let_op.body);
                    }
                    break;
                case ESHKOL_CALL_OP:
                    if (ast->operation.call_op.func) {
                        declareNestedFunctions(ast->operation.call_op.func);
                    }
                    for (uint64_t i = 0; i < ast->operation.call_op.num_vars; i++) {
                        declareNestedFunctions(&ast->operation.call_op.variables[i]);
                    }
                    break;
                case ESHKOL_LAMBDA_OP:
                    if (ast->operation.lambda_op.body) {
                        declareNestedFunctions(ast->operation.lambda_op.body);
                    }
                    break;
                default:
                    break;
            }
        }
        // Also handle cons cells (for list structures)
        else if (ast->type == ESHKOL_CONS) {
            if (ast->cons_cell.car) declareNestedFunctions(ast->cons_cell.car);
            if (ast->cons_cell.cdr) declareNestedFunctions(ast->cons_cell.cdr);
        }
    }

    // LIBRARY MODE: Create initialization function instead of main
    // This function initializes global state but doesn't create an entry point
    void createLibraryInitFunction(const eshkol_ast_t* asts, size_t num_asts) {
        // Create library init function: void __eshkol_lib_init__(void* arena)
        // Takes an arena pointer as parameter so caller can manage memory
        std::vector<Type*> init_args = { PointerType::getUnqual(*context) }; // arena pointer
        FunctionType* init_type = FunctionType::get(void_type, init_args, false);
        Function* init_func = Function::Create(init_type, Function::ExternalLinkage,
                                               "__eshkol_lib_init__", module.get());

        BasicBlock* entry = BasicBlock::Create(*context, "entry", init_func);
        builder->SetInsertPoint(entry);
        current_function = init_func;

        // Get arena parameter and store in global
        Value* arena_param = init_func->arg_begin();
        arena_param->setName("arena");
        builder->CreateStore(arena_param, global_arena);

        // Process global variable definitions (non-function defines) and set! statements
        for (size_t i = 0; i < num_asts; i++) {
            if (asts[i].type == ESHKOL_OP &&
                asts[i].operation.op == ESHKOL_DEFINE_OP &&
                !asts[i].operation.define_op.is_function) {
                codegenAST(&asts[i]);
                eshkol_debug("Library init: initialized global variable: %s",
                            asts[i].operation.define_op.name);
            }
            // Also process top-level set! statements (for forward declaration patterns)
            else if (asts[i].type == ESHKOL_OP &&
                     asts[i].operation.op == ESHKOL_SET_OP) {
                codegenAST(&asts[i]);
                eshkol_debug("Library init: executed set! for: %s",
                            asts[i].operation.set_op.name ? asts[i].operation.set_op.name : "(unknown)");
            }
        }

        // Call __lambda_init__ to initialize lambda captures
        Function* lambda_init_func = module->getFunction("__lambda_init__");
        if (lambda_init_func) {
            builder->CreateCall(lambda_init_func);
            eshkol_debug("Library init: called __lambda_init__ for lambda captures");
        }

        // Initialize lambda registry (caller may not have done it yet)
        builder->CreateCall(eshkol_lambda_registry_init_func);
        eshkol_debug("Library init: initialized lambda registry");

        // Generate S-expressions for lambdas and register them
        if (!pending_lambda_sexprs.empty()) {
            // Create a continuation block for after S-expression generation
            BasicBlock* sexpr_continue = BasicBlock::Create(*context, "sexpr_continue", init_func);

            for (const auto& meta : pending_lambda_sexprs) {
                Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);
                std::string sexpr_key = meta.lambda_name + "_sexpr";
                GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                if (!sexpr_global) {
                    sexpr_global = new GlobalVariable(
                        *module, int64_type, false,
                        GlobalValue::ExternalLinkage,
                        ConstantInt::get(int64_type, 0),
                        sexpr_key
                    );
                }
                builder->CreateStore(sexpr_ptr, sexpr_global);
                global_symbol_table[sexpr_key] = sexpr_global;

                // Register this lambda in the registry for homoiconic display
                Function* lambda_func = module->getFunction(meta.lambda_name);
                if (lambda_func) {
                    Value* func_ptr_int = builder->CreatePtrToInt(lambda_func, int64_type);
                    // sexpr_ptr is already i64 from codegenLambdaToSExpr, use directly
                    Value* name_str = builder->CreateGlobalString(meta.lambda_name);
                    builder->CreateCall(eshkol_lambda_registry_add_func,
                        {func_ptr_int, sexpr_ptr, name_str});
                    eshkol_debug("Library init: registered lambda '%s' in homoiconic registry", meta.lambda_name.c_str());
                }
            }

            // Branch to continuation
            builder->CreateBr(sexpr_continue);
            builder->SetInsertPoint(sexpr_continue);

            pending_lambda_sexprs.clear();
        }

        // Return void
        builder->CreateRetVoid();

        // Make named functions external linkage for library export
        // Keep lambda functions as internal to avoid conflicts with user code
        for (auto& pair : function_table) {
            if (pair.second && pair.first != "__lambda_init__") {
                // Skip runtime functions that need external linkage (they're declarations, not definitions)
                if (pair.first.find("eshkol_") == 0 || pair.first.find("arena_") == 0) {
                    // Keep external linkage for runtime function declarations
                    continue;
                }
                // Only export user-defined named functions, not lambdas
                if (!isLambdaName(pair.first)) {
                    pair.second->setLinkage(GlobalValue::ExternalLinkage);
                } else {
                    pair.second->setLinkage(GlobalValue::InternalLinkage);
                }
            }
        }
        // Also make lambda sexpr globals internal
        for (auto& G : module->globals()) {
            std::string name = G.getName().str();
            if (isLambdaName(name) && name.find("_sexpr") != std::string::npos) {
                G.setLinkage(GlobalValue::InternalLinkage);
            }
        }

        eshkol_info("Created library init function: __eshkol_lib_init__");
    }

    void createMainWrapper() {
        // Check if main function exists
        Function* main_func = function_table["main"];
        if (main_func) {
            // Rename the Scheme main function first to avoid name conflict
            main_func->setName("scheme_main");

            // Create C-style main function with argc, argv
            std::vector<Type*> main_args = {int32_type, PointerType::getUnqual(*context)};
            FunctionType* c_main_type = FunctionType::get(int32_type, main_args, false);
            Function* c_main = Function::Create(c_main_type, Function::ExternalLinkage, "main", module.get());

            // Name the arguments
            auto arg_it = c_main->arg_begin();
            Value* argc_val = arg_it++;
            argc_val->setName("argc");
            Value* argv_val = arg_it;
            argv_val->setName("argv");

            main_entry = BasicBlock::Create(*context, "entry", c_main);
            builder->SetInsertPoint(main_entry);

            // Store argc and argv to globals for (command-line)
            GlobalVariable* g_argc = module->getGlobalVariable("__eshkol_argc");
            GlobalVariable* g_argv = module->getGlobalVariable("__eshkol_argv");
            if (g_argc && g_argv) {
                builder->CreateStore(argc_val, g_argc);
                builder->CreateStore(argv_val, g_argv);
            }

            // OPTION 3: Generate S-expressions for all lambdas BEFORE any code runs
            // This ensures S-expressions are available when lambdas are displayed
            if (!pending_lambda_sexprs.empty()) {
                // Start at entry block, initialize arena
                builder->SetInsertPoint(main_entry);

                // REPL MODE FIX: Use shared arena instead of creating new one
                Value* arena_ptr;
                if (g_repl_mode_enabled) {
                    // Load the shared arena pointer from external symbol (single load)
                    GlobalVariable* shared_arena_ref = new GlobalVariable(
                        *module,
                        PointerType::getUnqual(*context),
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer (external)
                        "__repl_shared_arena"
                    );
                    arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                    eshkol_debug("Loaded shared REPL arena");
                } else {
                    // Normal mode: create new arena
                    Value* arena_size = ConstantInt::get(int64_type, 8192);
                    arena_ptr = builder->CreateCall(getArenaCreateFunc(), {arena_size});
                    eshkol_debug("Created new arena in main wrapper");
                }
                builder->CreateStore(arena_ptr, global_arena);

                // Initialize lambda registry for homoiconic display
                builder->CreateCall(eshkol_lambda_registry_init_func);
                eshkol_debug("Initialized lambda registry for homoiconic display");

                // Generate S-expressions now that arena is ready

                for (size_t i = 0; i < pending_lambda_sexprs.size(); i++) {
                    const auto& meta = pending_lambda_sexprs[i];
                    
                    Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);
                    
                    // Create or get global variable for this lambda's S-expression
                    // Use ExternalLinkage for runtime resolution by display code
                    std::string sexpr_key = meta.lambda_name + "_sexpr";
                    GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                    if (!sexpr_global) {
                        sexpr_global = new GlobalVariable(
                            *module, int64_type, false,
                            GlobalValue::ExternalLinkage,  // CRITICAL: External linkage for runtime lookup
                            ConstantInt::get(int64_type, 0),
                            sexpr_key
                        );
                    }
                    builder->CreateStore(sexpr_ptr, sexpr_global);

                    // Add to global symbol table for display lookup
                    global_symbol_table[sexpr_key] = sexpr_global;
                    eshkol_debug("Generated S-expression for lambda %s", meta.lambda_name.c_str());

                    // Register this lambda in the registry for homoiconic display
                    Function* lambda_func = module->getFunction(meta.lambda_name);
                    if (lambda_func) {
                        Value* func_ptr_int = builder->CreatePtrToInt(lambda_func, int64_type);
                        // sexpr_ptr is already i64 from codegenLambdaToSExpr, use directly
                        Value* name_str = builder->CreateGlobalString(meta.lambda_name);
                        builder->CreateCall(eshkol_lambda_registry_add_func,
                            {func_ptr_int, sexpr_ptr, name_str});
                        eshkol_debug("Registered lambda '%s' in homoiconic registry", meta.lambda_name.c_str());
                    }
                }

                // Clear pending list after generation
                pending_lambda_sexprs.clear();

                // CRITICAL: Create S-expression aliases for variable-bound lambdas
                // Scan symbol_table for lambda function references (var_func) and create var_sexpr aliases
                eshkol_debug("Checking for S-expression aliases, global_symbol_table has %zu entries",
                            global_symbol_table.size());
                for (const auto& entry : global_symbol_table) {
                    if (entry.first.length() > 5 &&
                        entry.first.substr(entry.first.length() - 5) == "_func") {
                        eshkol_debug("  Found _func entry: %s, value=%p, isFunction=%d",
                                    entry.first.c_str(), (void*)entry.second,
                                    entry.second ? isa<Function>(entry.second) : 0);
                    }
                    if (entry.first.length() > 5 &&
                        entry.first.substr(entry.first.length() - 5) == "_func" &&
                        entry.second && isa<Function>(entry.second)) {

                        Function* func = cast<Function>(entry.second);
                        std::string func_name = func->getName().str();

                        // Extract variable name from "varname_func"
                        std::string var_name = entry.first.substr(0, entry.first.length() - 5);

                        // Look for lambda S-expression: lambda_N_sexpr
                        std::string lambda_sexpr_key = func_name + "_sexpr";
                        eshkol_debug("  Looking for %s in global_symbol_table", lambda_sexpr_key.c_str());
                        auto lambda_sexpr_it = global_symbol_table.find(lambda_sexpr_key);
                        
                        if (lambda_sexpr_it != global_symbol_table.end()) {
                            // Create or get alias global variable
                            std::string var_sexpr_key = var_name + "_sexpr";
                            GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                            if (!var_sexpr_global) {
                                var_sexpr_global = new GlobalVariable(
                                    *module, int64_type, false,
                                    GlobalValue::ExternalLinkage,
                                    ConstantInt::get(int64_type, 0),
                                    var_sexpr_key
                                );
                            }
                            
                            // CRITICAL: Initialize alias with lambda S-expression value AT RUNTIME
                            Value* lambda_sexpr_val = builder->CreateLoad(int64_type,
                                                                          lambda_sexpr_it->second);
                            builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                            
                            global_symbol_table[var_sexpr_key] = var_sexpr_global;
                            eshkol_debug("Initialized S-expression alias: %s = value from %s",
                                        var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                        }
                    }
                }
            } else {
                // No lambdas - just initialize arena at entry
                builder->SetInsertPoint(main_entry);

                // REPL MODE FIX: Use shared arena instead of creating new one
                Value* arena_ptr;
                if (g_repl_mode_enabled) {
                    // Load the shared arena pointer from external symbol (single load)
                    GlobalVariable* shared_arena_ref = new GlobalVariable(
                        *module,
                        PointerType::getUnqual(*context),
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer (external)
                        "__repl_shared_arena"
                    );
                    arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                    eshkol_debug("Loaded shared REPL arena (no lambdas case)");
                } else {
                    // Normal mode: create new arena
                    Value* arena_size = ConstantInt::get(int64_type, 8192);
                    arena_ptr = builder->CreateCall(getArenaCreateFunc(), {arena_size});
                    eshkol_debug("Created new arena in main wrapper");
                }
                builder->CreateStore(arena_ptr, global_arena);

                // Initialize lambda registry for homoiconic display
                builder->CreateCall(eshkol_lambda_registry_init_func);
                eshkol_debug("Initialized lambda registry (no lambdas case)");
            }

            // Call scheme_main
            Value* result = builder->CreateCall(main_func);
            
            // CRITICAL FIX: scheme_main returns tagged_value, need to unpack to int64 first
            Value* result_int64 = unpackInt64FromTaggedValue(result);

            // GLOBAL ARENA FIX: Cleanup arena before return (SKIP IN REPL MODE)
            // In REPL mode, s-expressions need to persist across evaluations
            if (!g_repl_mode_enabled) {
                Value* arena_to_destroy = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                builder->CreateCall(getArenaDestroyFunc(), {arena_to_destroy});
                eshkol_debug("Added global arena cleanup before main return");
            } else {
                eshkol_debug("Skipped arena cleanup in REPL mode to preserve s-expressions");
            }
            
            // Convert result to int32 and return
            Value* int32_result = builder->CreateTrunc(result_int64, int32_type);
            builder->CreateRet(int32_result);
            
            function_table["main"] = c_main;
        } else {
            eshkol_debug("No main function found, creating main for top-level expressions");
            // Create main function for top-level expressions with argc, argv
            std::vector<Type*> main_args = {int32_type, PointerType::getUnqual(*context)};
            FunctionType* main_type = FunctionType::get(int32_type, main_args, false);
            main_func = Function::Create(main_type, Function::ExternalLinkage, "main", module.get());

            // Name the arguments
            auto arg_it = main_func->arg_begin();
            Value* argc_val = arg_it++;
            argc_val->setName("argc");
            Value* argv_val = arg_it;
            argv_val->setName("argv");

            main_entry = BasicBlock::Create(*context, "entry", main_func);
            // Don't set terminator yet - we'll add expressions and then terminate

            function_table["main"] = main_func;

            // REPL MODE FIX: Use shared arena instead of creating new one
            builder->SetInsertPoint(main_entry);

            // Store argc and argv to globals for (command-line)
            GlobalVariable* g_argc = module->getGlobalVariable("__eshkol_argc");
            GlobalVariable* g_argv = module->getGlobalVariable("__eshkol_argv");
            if (g_argc && g_argv) {
                builder->CreateStore(argc_val, g_argc);
                builder->CreateStore(argv_val, g_argv);
            }
            Value* arena_ptr;
            if (g_repl_mode_enabled) {
                // Load the shared arena pointer from external symbol (single load)
                GlobalVariable* shared_arena_ref = new GlobalVariable(
                    *module,
                    PointerType::getUnqual(*context),
                    false,  // not constant
                    GlobalValue::ExternalLinkage,
                    nullptr,  // no initializer (external)
                    "__repl_shared_arena"
                );
                arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), shared_arena_ref);
                eshkol_debug("Loaded shared REPL arena (top-level expressions case)");
            } else {
                // Normal mode: create new arena
                Value* arena_size = ConstantInt::get(int64_type, 8192);
                arena_ptr = builder->CreateCall(getArenaCreateFunc(), {arena_size});
                eshkol_debug("Created new arena in main (top-level expressions case)");
            }
            builder->CreateStore(arena_ptr, global_arena);

            // Initialize lambda registry for homoiconic display
            builder->CreateCall(eshkol_lambda_registry_init_func);
            eshkol_debug("Initialized lambda registry (top-level expressions case)");

            // Call library init function if program uses stdlib (linked with stdlib.o)
            // This registers library functions in the lambda registry for homoiconic display
            if (g_uses_stdlib) {
                // Declare and call __eshkol_lib_init__ - will be linked from stdlib.o
                Function* lib_init_func = module->getFunction("__eshkol_lib_init__");
                if (!lib_init_func) {
                    std::vector<Type*> lib_init_args = { PointerType::getUnqual(*context) };
                    FunctionType* lib_init_type = FunctionType::get(void_type, lib_init_args, false);
                    lib_init_func = Function::Create(lib_init_type, Function::ExternalLinkage,
                                                     "__eshkol_lib_init__", module.get());
                }
                Value* arena_for_lib = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                builder->CreateCall(lib_init_func, {arena_for_lib});
                eshkol_debug("Called library init function for stdlib");
            }

            // Generate S-expressions for pending lambdas (function definitions compiled in Step 2)
            // NOTE: codegenLambdaToSExpr creates basic blocks, so we need a continuation block
            if (!pending_lambda_sexprs.empty()) {
                // Create a continuation block for after all S-expression generation
                BasicBlock* sexpr_continue = BasicBlock::Create(*context, "sexpr_continue", main_func);

                for (size_t i = 0; i < pending_lambda_sexprs.size(); i++) {
                    const auto& meta = pending_lambda_sexprs[i];

                    Value* sexpr_ptr = codegenLambdaToSExpr(meta.lambda_ast);

                    // Create or get global variable for this lambda's S-expression
                    std::string sexpr_key = meta.lambda_name + "_sexpr";
                    GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                    if (!sexpr_global) {
                        sexpr_global = new GlobalVariable(
                            *module, int64_type, false,
                            GlobalValue::ExternalLinkage,
                            ConstantInt::get(int64_type, 0),
                            sexpr_key
                        );
                    }
                    builder->CreateStore(sexpr_ptr, sexpr_global);

                    // Add to global symbol table for display lookup
                    global_symbol_table[sexpr_key] = sexpr_global;
                    eshkol_debug("Generated S-expression for lambda %s (top-level case)", meta.lambda_name.c_str());

                    // Register this lambda in the registry for homoiconic display
                    Function* lambda_func = module->getFunction(meta.lambda_name);
                    if (lambda_func) {
                        Value* func_ptr_int = builder->CreatePtrToInt(lambda_func, int64_type);
                        // sexpr_ptr is already i64 from codegenLambdaToSExpr, use directly
                        Value* name_str = builder->CreateGlobalString(meta.lambda_name);
                        builder->CreateCall(eshkol_lambda_registry_add_func,
                            {func_ptr_int, sexpr_ptr, name_str});
                        eshkol_debug("Registered lambda '%s' in homoiconic registry (top-level case)", meta.lambda_name.c_str());
                    }
                }

                // Branch to continuation and set it as the new insertion point
                builder->CreateBr(sexpr_continue);
                builder->SetInsertPoint(sexpr_continue);

                // Update main_entry to point to the continuation block for generateIR
                main_entry = sexpr_continue;

                pending_lambda_sexprs.clear();
            }
        }
    }

    void initializeArena() {
        // DEPRECATED: Arena initialization is now handled globally in createMainWrapper()
        // This function is kept for compatibility but does nothing
        // All functions now share the global arena automatically
        eshkol_debug("initializeArena() called but using global arena (no-op)");
    }
    
    Value* getArenaPtr() {
        // GLOBAL ARENA FIX: Load arena pointer from global variable
        // This allows all functions and scopes to share the same arena
        if (!global_arena) {
            eshkol_error("Global arena not initialized!");
            return nullptr;
        }
        return builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
    }
    
    // Production-grade arena scope tracking helpers
    void arenaTrackedPushScope() {
        Value* arena_ptr = getArenaPtr();
        if (arena_ptr) {
            builder->CreateCall(getArenaPushScopeFunc(), {arena_ptr});
            arena_scope_depth++;
            eshkol_debug("Arena scope pushed (depth: %zu)", arena_scope_depth);
        }
    }
    
    void arenaTrackedPopScope() {
        if (arena_scope_depth > 0) {
            Value* arena_ptr = getArenaPtr();
            if (arena_ptr) {
                builder->CreateCall(getArenaPopScopeFunc(), {arena_ptr});
                arena_scope_depth--;
                eshkol_debug("Arena scope popped (depth: %zu)", arena_scope_depth);
            }
        } else {
            eshkol_warn("Attempted to pop arena scope with depth 0");
        }
    }
    
    void arenaForceCleanup() {
        if (arena_scope_depth > 0) {
            eshkol_debug("Force cleaning %zu arena scopes", arena_scope_depth);
            Value* arena_ptr = getArenaPtr();
            if (arena_ptr) {
                while (arena_scope_depth > 0) {
                    builder->CreateCall(getArenaPopScopeFunc(), {arena_ptr});
                    arena_scope_depth--;
                }
            }
            eshkol_debug("Arena scope cleanup complete (depth: %zu)", arena_scope_depth);
        }
    }
    
    // Mixed type arithmetic helper functions
    TypedValue promoteInt64ToDouble(const TypedValue& int64_val) {
        if (!int64_val.isInt64()) return int64_val;
        
        Value* double_val = builder->CreateSIToFP(int64_val.llvm_value, double_type);
        return TypedValue(double_val, ESHKOL_VALUE_DOUBLE, false); // Promoted values are inexact
    }
    
    std::pair<TypedValue, TypedValue> promoteToCommonType(const TypedValue& left, const TypedValue& right) {
        // Handle NULL types - treat as int64(0)
        if (left.isNull() && right.isNull()) {
            TypedValue zero_left(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_INT64, true);
            TypedValue zero_right(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_INT64, true);
            return {zero_left, zero_right};
        }
        if (left.isNull()) {
            TypedValue zero_left(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_INT64, true);
            return {zero_left, right};
        }
        if (right.isNull()) {
            TypedValue zero_right(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_INT64, true);
            return {left, zero_right};
        }
        
        // Both int64: no promotion needed
        if (left.isInt64() && right.isInt64()) {
            return {left, right};
        }
        
        // Both double: no promotion needed
        if (left.isDouble() && right.isDouble()) {
            return {left, right};
        }
        
        // Mixed types: promote to double
        if (left.isInt64() && right.isDouble()) {
            return {promoteInt64ToDouble(left), right};
        }
        
        if (left.isDouble() && right.isInt64()) {
            return {left, promoteInt64ToDouble(right)};
        }
        
        // Error case: unsupported type combination
        eshkol_error("Unsupported type combination in arithmetic: %d and %d", left.type, right.type);
        return {left, right};
    }
    
    TypedValue generateMixedArithmetic(const std::string& operation, const TypedValue& left, const TypedValue& right) {
        auto [promoted_left, promoted_right] = promoteToCommonType(left, right);
        
        Value* result_val = nullptr;
        bool result_exact = promoted_left.is_exact && promoted_right.is_exact;
        
        if (promoted_left.isInt64() && promoted_right.isInt64()) {
            // Pure integer arithmetic
            if (operation == "add") {
                result_val = builder->CreateAdd(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "sub") {
                result_val = builder->CreateSub(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "mul") {
                result_val = builder->CreateMul(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "div") {
                // Division always promotes to double in Scheme
                auto double_left = promoteInt64ToDouble(promoted_left);
                auto double_right = promoteInt64ToDouble(promoted_right);
                result_val = builder->CreateFDiv(double_left.llvm_value, double_right.llvm_value);
                return TypedValue(result_val, ESHKOL_VALUE_DOUBLE, false); // Division is inexact
            }
            return TypedValue(result_val, ESHKOL_VALUE_INT64, result_exact);
        } else {
            // Floating-point arithmetic (both operands are now double)
            if (operation == "add") {
                result_val = builder->CreateFAdd(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "sub") {
                result_val = builder->CreateFSub(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "mul") {
                result_val = builder->CreateFMul(promoted_left.llvm_value, promoted_right.llvm_value);
            } else if (operation == "div") {
                result_val = builder->CreateFDiv(promoted_left.llvm_value, promoted_right.llvm_value);
            }
            return TypedValue(result_val, ESHKOL_VALUE_DOUBLE, false); // Mixed arithmetic is inexact
        }
    }
    
    // Convert TypedValue back to raw Value* for compatibility
    Value* typedValueToLLVM(const TypedValue& typed_val) {
        return typed_val.llvm_value;
    }
    
    // Create TypedValue from AST node
    TypedValue codegenTypedAST(const eshkol_ast_t* ast) {
        if (!ast) return TypedValue();
        
        switch (ast->type) {
            case ESHKOL_INT64:
                return TypedValue(
                    ConstantInt::get(int64_type, ast->int64_val),
                    ESHKOL_VALUE_INT64,
                    eshkol::hott::BuiltinTypes::Int64,  // HoTT type
                    true  // Integer literals are exact
                );

            case ESHKOL_DOUBLE:
                return TypedValue(
                    ConstantFP::get(double_type, ast->double_val),
                    ESHKOL_VALUE_DOUBLE,
                    eshkol::hott::BuiltinTypes::Float64,  // HoTT type
                    false  // Double literals are inexact
                );

            case ESHKOL_CHAR:
                return TypedValue(
                    ConstantInt::get(int64_type, ast->int64_val),
                    ESHKOL_VALUE_CHAR,
                    eshkol::hott::BuiltinTypes::Char,  // HoTT type
                    true  // Character literals are exact
                );

            case ESHKOL_BOOL:
                // Boolean literals #t and #f - return as i1 boolean with ESHKOL_VALUE_BOOL type
                // The i1 value will be extended to int64 when packed into a tagged_value
                return TypedValue(
                    ast->int64_val ? ConstantInt::getTrue(*context) : ConstantInt::getFalse(*context),
                    ESHKOL_VALUE_BOOL,
                    eshkol::hott::BuiltinTypes::Boolean,  // HoTT type
                    true  // Boolean literals are exact
                );

            case ESHKOL_OP: {
                // OALR FIX: Handle ownership operations by propagating type from inner expression
                if (ast->operation.op == ESHKOL_OWNED_OP && ast->operation.owned_op.value) {
                    // (owned expr) - propagate type from inner expression
                    TypedValue inner = codegenTypedAST(ast->operation.owned_op.value);
                    // Generate the owned wrapper (which just returns the value)
                    Value* val = codegenAST(ast);
                    if (!val) return TypedValue();
                    return TypedValue(val, inner.type, inner.is_exact);
                }
                if (ast->operation.op == ESHKOL_MOVE_OP && ast->operation.move_op.value) {
                    // (move expr) - get type from inner expression, then generate move
                    // Use codegenTypedAST on inner to get proper type, but with VAR guard
                    const eshkol_ast_t* inner = ast->operation.move_op.value;

                    // For variables, check if they're stored in a tagged_value GlobalVariable
                    if (inner->type == ESHKOL_VAR && inner->variable.id) {
                        std::string var_name = inner->variable.id;
                        // Look up the variable
                        auto it = symbol_table.find(var_name);
                        if (it == symbol_table.end()) {
                            it = global_symbol_table.find(var_name);
                        }
                        if (it != global_symbol_table.end() || it != symbol_table.end()) {
                            Value* var_ptr = it->second;
                            if (GlobalVariable* gv = dyn_cast<GlobalVariable>(var_ptr)) {
                                // If stored as tagged_value, load it and return with preserved type
                                if (gv->getValueType() == tagged_value_type) {
                                    Value* val = codegenAST(ast);
                                    if (!val) return TypedValue();
                                    // Return the tagged_value directly - type info is inside
                                    // Use CONS_PTR so codegenVariableDefinition stores properly
                                    return TypedValue(val, ESHKOL_VALUE_CONS_PTR, true);
                                }
                            }
                        }
                    }

                    // For non-variable expressions or non-tagged storage, use inner type
                    TypedValue inner_typed = codegenTypedAST(inner);
                    Value* val = codegenAST(ast);
                    if (!val) return TypedValue();
                    return TypedValue(val, inner_typed.type, inner_typed.is_exact);
                }
                if (ast->operation.op == ESHKOL_BORROW_OP && ast->operation.borrow_op.body) {
                    // (borrow val body...) - type is from last body expression
                    Value* val = codegenAST(ast);
                    if (!val) return TypedValue();
                    // Detect type from result
                    return detectValueType(val);
                }
                if (ast->operation.op == ESHKOL_SHARED_OP && ast->operation.shared_op.value) {
                    // (shared expr) - propagate type from inner expression
                    TypedValue inner = codegenTypedAST(ast->operation.shared_op.value);
                    Value* val = codegenAST(ast);
                    if (!val) return TypedValue();
                    return TypedValue(val, inner.type, inner.is_exact);
                }

                // GRADIENT FIX: Handle LAMBDA_OP specially to preserve CLOSURE_PTR type
                // This is critical for (define f (lambda ...)) inside functions to work with gradient
                if (ast->operation.op == ESHKOL_LAMBDA_OP) {
                    Value* val = codegenAST(ast);
                    if (!val) return TypedValue();
                    // Lambda returns a closure (even with 0 captures for S-expression support)
                    return TypedValue(val, ESHKOL_VALUE_CLOSURE_PTR, true);
                }

                // Check if this is an operation that returns a typed pointer
                if (ast->operation.op == ESHKOL_CALL_OP && ast->operation.call_op.func &&
                    ast->operation.call_op.func->type == ESHKOL_VAR && ast->operation.call_op.func->variable.id) {
                    std::string func_name = ast->operation.call_op.func->variable.id;

                    // HoTT TYPE TRACKING: Look up return type for builtin functions
                    eshkol::hott::TypeId return_hott_type = eshkol::hott::BuiltinTypes::Value;
                    auto return_type_it = function_return_types.find(func_name);
                    if (return_type_it != function_return_types.end()) {
                        return_hott_type = return_type_it->second;
                    }

                    // Operations that return cons pointers (or null for empty list)
                    // HoTT PARAMETERIZED TYPES: Track element types for List<T>
                    if (func_name == "list") {
                        // Infer element type from list arguments
                        std::vector<eshkol::hott::TypeId> element_types;
                        for (uint64_t i = 0; i < ast->operation.call_op.num_vars; i++) {
                            TypedValue arg_typed = codegenTypedAST(&ast->operation.call_op.variables[i]);
                            element_types.push_back(arg_typed.hott_type);
                        }
                        eshkol::hott::TypeId elem_type = ctx_->hottTypes().inferListElementType(element_types);
                        auto list_type = ctx_->hottTypes().makeListType(elem_type);

                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        if (ConstantInt* ci = dyn_cast<ConstantInt>(val)) {
                            if (ci->isZero()) {
                                return TypedValue(val, ESHKOL_VALUE_NULL,
                                                 eshkol::hott::BuiltinTypes::Null, true);
                            }
                        }
                        return TypedValue(val, ESHKOL_VALUE_CONS_PTR,
                                         eshkol::hott::BuiltinTypes::List, list_type, true);
                    }

                    if (func_name == "cons") {
                        // For cons, first arg determines element type
                        eshkol::hott::TypeId elem_type = eshkol::hott::BuiltinTypes::Value;
                        if (ast->operation.call_op.num_vars > 0) {
                            TypedValue first_arg = codegenTypedAST(&ast->operation.call_op.variables[0]);
                            elem_type = first_arg.hott_type;
                        }
                        auto list_type = ctx_->hottTypes().makeListType(elem_type);

                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        if (ConstantInt* ci = dyn_cast<ConstantInt>(val)) {
                            if (ci->isZero()) {
                                return TypedValue(val, ESHKOL_VALUE_NULL,
                                                 eshkol::hott::BuiltinTypes::Null, true);
                            }
                        }
                        return TypedValue(val, ESHKOL_VALUE_CONS_PTR,
                                         eshkol::hott::BuiltinTypes::List, list_type, true);
                    }

                    if (func_name == "cdr") {
                        // Preserve element type from the input list
                        eshkol::hott::TypeId elem_type = eshkol::hott::BuiltinTypes::Value;
                        if (ast->operation.call_op.num_vars > 0) {
                            TypedValue list_arg = codegenTypedAST(&ast->operation.call_op.variables[0]);
                            if (list_arg.hasParameterizedType()) {
                                elem_type = list_arg.elementType();
                            }
                        }
                        auto list_type = ctx_->hottTypes().makeListType(elem_type);

                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        if (ConstantInt* ci = dyn_cast<ConstantInt>(val)) {
                            if (ci->isZero()) {
                                return TypedValue(val, ESHKOL_VALUE_NULL,
                                                 eshkol::hott::BuiltinTypes::Null, true);
                            }
                        }
                        return TypedValue(val, ESHKOL_VALUE_CONS_PTR,
                                         eshkol::hott::BuiltinTypes::List, list_type, true);
                    }

                    if (func_name == "car") {
                        // car returns the element type from the list
                        eshkol::hott::TypeId elem_type = eshkol::hott::BuiltinTypes::Value;
                        if (ast->operation.call_op.num_vars > 0) {
                            TypedValue list_arg = codegenTypedAST(&ast->operation.call_op.variables[0]);
                            if (list_arg.hasParameterizedType()) {
                                elem_type = list_arg.elementType();
                            }
                        }
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        // Return the element type (could be any type)
                        // For unknown element type, default to tagged_value type
                        eshkol_value_type_t runtime_type = static_cast<eshkol_value_type_t>(ctx_->hottTypes().toRuntimeType(elem_type));
                        return TypedValue(val, runtime_type, elem_type, true);
                    }

                    // Operations that return scheme vector pointers
                    // HoTT PARAMETERIZED TYPES: Track element types for Vector<T>
                    if (func_name == "vector") {
                        // Infer element type from vector arguments
                        std::vector<eshkol::hott::TypeId> element_types;
                        for (uint64_t i = 0; i < ast->operation.call_op.num_vars; i++) {
                            TypedValue arg_typed = codegenTypedAST(&ast->operation.call_op.variables[i]);
                            element_types.push_back(arg_typed.hott_type);
                        }
                        eshkol::hott::TypeId elem_type = ctx_->hottTypes().inferListElementType(element_types);
                        auto vec_type = ctx_->hottTypes().makeVectorType(elem_type);

                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_VECTOR_PTR,
                                         eshkol::hott::BuiltinTypes::Vector, vec_type, true);
                    }

                    if (func_name == "make-vector") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_VECTOR_PTR,
                                         eshkol::hott::BuiltinTypes::Vector, true);
                    }

                    if (func_name == "vector-ref") {
                        // vector-ref returns the element type from the vector
                        eshkol::hott::TypeId elem_type = eshkol::hott::BuiltinTypes::Value;
                        if (ast->operation.call_op.num_vars > 0) {
                            TypedValue vec_arg = codegenTypedAST(&ast->operation.call_op.variables[0]);
                            if (vec_arg.hasParameterizedType()) {
                                elem_type = vec_arg.elementType();
                            }
                        }
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        eshkol_value_type_t runtime_type = static_cast<eshkol_value_type_t>(ctx_->hottTypes().toRuntimeType(elem_type));
                        return TypedValue(val, runtime_type, elem_type, true);
                    }

                    // Operations that return tensor pointers
                    if (func_name == "gradient" || func_name == "jacobian") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_TENSOR_PTR,
                                         eshkol::hott::BuiltinTypes::Tensor, true);
                    }

                    // Comparison functions return Boolean
                    if (func_name == "<" || func_name == ">" || func_name == "<=" ||
                        func_name == ">=" || func_name == "=" || func_name == "null?" ||
                        func_name == "pair?" || func_name == "list?" || func_name == "number?" ||
                        func_name == "zero?" || func_name == "positive?" || func_name == "negative?" ||
                        func_name == "even?" || func_name == "odd?" || func_name == "eq?" || func_name == "equal?") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_BOOL,
                                         eshkol::hott::BuiltinTypes::Boolean, true);
                    }

                    // Math functions return Float64
                    if (func_name == "sin" || func_name == "cos" || func_name == "tan" ||
                        func_name == "exp" || func_name == "log" || func_name == "sqrt" ||
                        func_name == "fabs") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_DOUBLE,
                                         eshkol::hott::BuiltinTypes::Float64, false);
                    }

                    // Length returns Int64
                    if (func_name == "length" || func_name == "vector-length") {
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();
                        return TypedValue(val, ESHKOL_VALUE_INT64,
                                         eshkol::hott::BuiltinTypes::Int64, true);
                    }

                    // CLOSURE FIX: Check if callee returns a lambda
                    // Case 1: Lambda calling lambda (make-adder pattern)
                    auto callee_it = global_symbol_table.find(func_name + "_func");
                    if (callee_it != global_symbol_table.end() && callee_it->second &&
                        isa<Function>(callee_it->second)) {
                        Function* callee_func = cast<Function>(callee_it->second);
                        if (callee_func) {
                            std::string callee_lambda_name = callee_func->getName().str();
                            if (isLambdaName(callee_lambda_name)) {
                                // This callee is a lambda - check if it returns another lambda
                                // by looking for lambda_N+1 in function_table
                                std::string num_str = callee_lambda_name.substr(7);
                                try {
                                    int callee_num = std::stoi(num_str);
                                    std::string inner_lambda_name = "lambda_" + std::to_string(callee_num + 1);
                                    if (function_table.find(inner_lambda_name) != function_table.end()) {
                                        // Callee returns a lambda - mark the result appropriately
                                        Value* val = codegenAST(ast);
                                        if (!val) return TypedValue();
                                        return TypedValue(val, ESHKOL_VALUE_LAMBDA_SEXPR, true);
                                    }
                                } catch (...) {}
                            }
                        }
                    }

                    // Case 2: Named function that is registered as returning a lambda
                    auto lambda_it = functions_returning_lambda.find(func_name);
                    if (lambda_it != functions_returning_lambda.end()) {
                        std::string lambda_name = lambda_it->second;
                        // Check if the lambda has captures (making it a closure)
                        auto captures_it = nested_function_captures.find(lambda_name);
                        bool has_captures = (captures_it != nested_function_captures.end() && !captures_it->second.empty());

                        eshkol_debug("Function %s returns lambda %s (has_captures=%d)",
                                    func_name.c_str(), lambda_name.c_str(), has_captures);
                        Value* val = codegenAST(ast);
                        if (!val) return TypedValue();

                        // Return CLOSURE_PTR if the lambda has captures, LAMBDA_SEXPR otherwise
                        return TypedValue(val, has_captures ? ESHKOL_VALUE_CLOSURE_PTR : ESHKOL_VALUE_LAMBDA_SEXPR, true);
                    }

                    // Case 3: Named function that contains a nested lambda (e.g., make-adder)
                    // Check if any lambda was created inside this function
                    auto func_it = function_table.find(func_name);
                    if (func_it != function_table.end()) {
                        // Look for lambdas or nested functions associated with this function
                        for (auto& entry : function_table) {
                            // Check for nested functions: func_name_nested_N
                            if (entry.first.find(func_name + "_nested_") == 0) {
                                Value* val = codegenAST(ast);
                                if (!val) return TypedValue();
                                return TypedValue(val, ESHKOL_VALUE_LAMBDA_SEXPR, true);
                            }
                        }
                    }
                }

                // Fall through to default handling for other operations
                [[fallthrough]];
            }

            case ESHKOL_VAR:
            default: {
                // For variables and operations, generate LLVM value and detect type
                Value* val = codegenAST(ast);
                if (!val) return TypedValue();

                // HoTT TYPE TRACKING: Look up compile-time type for variables
                eshkol::hott::TypeId hott_type = eshkol::hott::BuiltinTypes::Value;  // Default to unknown
                std::optional<eshkol::hott::ParameterizedType> param_type = std::nullopt;
                if (ast->type == ESHKOL_VAR && ast->variable.id) {
                    std::string var_name = ast->variable.id;

                    // Look up HoTT type from symbol tables
                    auto hott_it = symbol_hott_types.find(var_name);
                    if (hott_it != symbol_hott_types.end()) {
                        hott_type = hott_it->second;
                    } else {
                        auto global_hott_it = global_symbol_hott_types.find(var_name);
                        if (global_hott_it != global_symbol_hott_types.end()) {
                            hott_type = global_hott_it->second;
                        }
                    }

                    // Look up parameterized type (List<T>, Vector<T>) from symbol tables
                    auto param_it = symbol_param_types.find(var_name);
                    if (param_it != symbol_param_types.end()) {
                        param_type = param_it->second;
                    } else {
                        auto global_param_it = global_symbol_param_types.find(var_name);
                        if (global_param_it != global_symbol_param_types.end()) {
                            param_type = global_param_it->second;
                        }
                    }

                    // HOMOICONIC FIX: Check if this is a lambda variable by looking for _func entry
                    std::string func_key = var_name + "_func";
                    bool found_in_symbol_table = (symbol_table.find(func_key) != symbol_table.end());
                    bool found_in_global = (global_symbol_table.find(func_key) != global_symbol_table.end());
                    if (found_in_symbol_table || found_in_global) {
                        // This variable is a lambda - return with LAMBDA_SEXPR type
                        return TypedValue(val, ESHKOL_VALUE_LAMBDA_SEXPR,
                                         eshkol::hott::BuiltinTypes::Function, true);
                    }
                }

                // Detect type from LLVM Value type
                Type* llvm_type = val->getType();

                // Special handling for tagged_value: extract raw value based on HoTT type
                // This is critical for operations like string-ref that need raw integer indices
                if (llvm_type == tagged_value_type) {
                    // Use HoTT type from symbol table to determine how to extract value
                    using namespace eshkol::hott;

                    // For Int64 types (including Char), extract raw integer
                    if (hott_type == BuiltinTypes::Int64 ||
                        hott_type == BuiltinTypes::Char ||
                        hott_type == BuiltinTypes::Natural) {
                        // Extract raw int64 from tagged value
                        Value* raw_int = unpackInt64FromTaggedValue(val);
                        if (param_type.has_value()) {
                            return TypedValue(raw_int, ESHKOL_VALUE_INT64, hott_type, *param_type, true);
                        }
                        return TypedValue(raw_int, ESHKOL_VALUE_INT64, hott_type, true);
                    }

                    // For Float64 types, extract raw double
                    if (hott_type == BuiltinTypes::Float64 || hott_type == BuiltinTypes::Real) {
                        Value* raw_double = unpackDoubleFromTaggedValue(val);
                        return TypedValue(raw_double, ESHKOL_VALUE_DOUBLE, hott_type, false);
                    }

                    // For Boolean types, extract raw boolean
                    if (hott_type == BuiltinTypes::Boolean) {
                        Value* raw_int = unpackInt64FromTaggedValue(val);
                        Value* raw_bool = builder->CreateTrunc(raw_int, int1_type);
                        return TypedValue(raw_bool, ESHKOL_VALUE_BOOL, hott_type, true);
                    }

                    // For unknown types, return tagged value as-is
                    // Callers that need raw values must handle extraction themselves
                    if (param_type.has_value()) {
                        return TypedValue(val, ESHKOL_VALUE_INT64, hott_type, *param_type, true);
                    }
                    return TypedValue(val, ESHKOL_VALUE_INT64, hott_type, true);
                } else if (llvm_type->isIntegerTy(64)) {
                    // Use tracked HoTT type if known, otherwise Int64
                    if (hott_type == eshkol::hott::BuiltinTypes::Value) {
                        hott_type = eshkol::hott::BuiltinTypes::Int64;
                    }
                    if (param_type.has_value()) {
                        return TypedValue(val, ESHKOL_VALUE_INT64, hott_type, *param_type, true);
                    }
                    return TypedValue(val, ESHKOL_VALUE_INT64, hott_type, true);
                } else if (llvm_type->isDoubleTy()) {
                    if (hott_type == eshkol::hott::BuiltinTypes::Value) {
                        hott_type = eshkol::hott::BuiltinTypes::Float64;
                    }
                    return TypedValue(val, ESHKOL_VALUE_DOUBLE, hott_type, false);
                } else if (llvm_type->isPointerTy()) {
                    // HOMOICONIC FIX: Handle Function* (lambdas) properly
                    if (isa<Function>(val)) {
                        Value* as_int = builder->CreatePtrToInt(val, int64_type);
                        return TypedValue(as_int, ESHKOL_VALUE_LAMBDA_SEXPR,
                                         eshkol::hott::BuiltinTypes::Function, true);
                    }
                    // Other pointer types - convert to CONS_PTR
                    Value* as_int = builder->CreatePtrToInt(val, int64_type);
                    if (hott_type == eshkol::hott::BuiltinTypes::Value) {
                        hott_type = eshkol::hott::BuiltinTypes::List;
                    }
                    // Include parameterized type if available
                    if (param_type.has_value()) {
                        return TypedValue(as_int, ESHKOL_VALUE_CONS_PTR, hott_type, *param_type, true);
                    }
                    return TypedValue(as_int, ESHKOL_VALUE_CONS_PTR, hott_type, true);
                } else {
                    // Non-numeric type (unknown)
                    return TypedValue(val, ESHKOL_VALUE_NULL, hott_type, true);
                }
            }
        }
    }
    
private:
    // Function context management for isolation
    struct FunctionContext {
        std::unordered_map<std::string, Function*> local_functions;
        std::vector<std::string> created_functions;  // Track functions created in this context
    };
    
    std::stack<FunctionContext> function_contexts;
    
    void pushFunctionContext() {
        FunctionContext ctx;
        function_contexts.push(ctx);
        eshkol_debug("Pushed function context (depth: %zu)", function_contexts.size());
    }
    
    void popFunctionContext() {
        if (function_contexts.empty()) {
            eshkol_warn("Attempted to pop function context with no active context");
            return;
        }
        
        FunctionContext& ctx = function_contexts.top();
        
        // Clean up functions created in this context if needed
        for (const std::string& func_name : ctx.created_functions) {
            eshkol_debug("Context cleanup: function %s", func_name.c_str());
            // Note: Don't actually erase from function_table as functions may be reused
            // Just track for debugging purposes
        }
        
        function_contexts.pop();
        eshkol_debug("Popped function context (depth: %zu)", function_contexts.size());
    }
    
    void registerContextFunction(const std::string& name, Function* func) {
        if (!function_contexts.empty()) {
            function_contexts.top().created_functions.push_back(name);
        }
        function_table[name] = func;
    }

    // REPL MODE: Check if a function exists in the global REPL context and create external declaration
    Function* tryResolveReplFunction(const std::string& func_name) {
        // Only check REPL symbols if REPL mode is enabled
        if (!g_repl_mode_enabled) {
            return nullptr;
        }

        std::lock_guard<std::mutex> lock(g_repl_mutex);

        // Check multiple name variations and track which one matched
        std::string actual_func_name;

        // 1. Exact name
        auto it = g_repl_function_addresses.find(func_name);
        if (it != g_repl_function_addresses.end()) {
            actual_func_name = func_name;
        } else {
            // 2. With "_func" suffix for lambda variables
            std::string func_key = func_name + "_func";
            it = g_repl_function_addresses.find(func_key);
            if (it != g_repl_function_addresses.end()) {
                actual_func_name = func_key;
            } else if (func_name.ends_with("_func")) {
                // 3. Try removing "_func" suffix if present
                std::string base_name = func_name.substr(0, func_name.length() - 5);
                it = g_repl_function_addresses.find(base_name);
                if (it != g_repl_function_addresses.end()) {
                    actual_func_name = base_name;
                }
            }
        }

        if (it == g_repl_function_addresses.end()) {
            return nullptr;
        }

        // CRITICAL: If this is a lambda variable (like "square"), resolve to the actual lambda name
        // The JIT only has the lambda function (e.g., "lambda_0"), not the alias (e.g., "square_func")
        std::string jit_symbol_name = actual_func_name;
        auto lambda_it = g_repl_lambda_names.find(func_name);
        if (lambda_it != g_repl_lambda_names.end()) {
            // Found lambda mapping: use the actual lambda name that exists in JIT
            jit_symbol_name = lambda_it->second;
        }

        // Get the function's arity using the actual matched name
        size_t arity = 0;
        auto arity_it = g_repl_function_arities.find(actual_func_name);
        if (arity_it != g_repl_function_arities.end()) {
            arity = arity_it->second;
        }

        // Check if we already have this function in the current module
        Function* extern_func = module->getFunction(jit_symbol_name);
        if (!extern_func) {
            // Function doesn't exist yet - create external declaration
            // All Eshkol functions return eshkol_tagged_value and take tagged_value parameters
            std::vector<Type*> param_types(arity, tagged_value_type);
            FunctionType* func_type = FunctionType::get(
                tagged_value_type,
                param_types,
                false  // NOT varargs - use exact arity
            );

            // CRITICAL: Use the actual JIT symbol name that exists in the JIT, not the requested name
            extern_func = Function::Create(
                func_type,
                Function::ExternalLinkage,
                jit_symbol_name,  // Use the actual JIT symbol name (e.g., "lambda_0")!
                module.get()
            );
        }

        // Register in function table so subsequent lookups find it
        // Register under BOTH the requested name and JIT symbol name for flexibility
        function_table[func_name] = extern_func;
        if (jit_symbol_name != func_name) {
            function_table[jit_symbol_name] = extern_func;
        }
        if (actual_func_name != func_name && actual_func_name != jit_symbol_name) {
            function_table[actual_func_name] = extern_func;
        }

        return extern_func;
    }

    Value* codegenArenaConsCell(Value* car_val, Value* cdr_val) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for cons cell allocation");
            return nullptr;
        }
        
        // Allocate cons cell using arena
        Value* cons_ptr = builder->CreateCall(getArenaAllocateConsCellFunc(), {arena_ptr});
        
        // Store car value - arena_cons_cell_t has car at offset 0
        Value* car_ptr = builder->CreateStructGEP(
            StructType::get(int64_type, int64_type), 
            cons_ptr, 0
        );
        builder->CreateStore(car_val, car_ptr);
        
        // Store cdr value - arena_cons_cell_t has cdr at offset 1
        Value* cdr_ptr = builder->CreateStructGEP(
            StructType::get(int64_type, int64_type), 
            cons_ptr, 1
        );
        builder->CreateStore(cdr_val, cdr_ptr);
        
        // Return pointer to cons cell as int64
        return builder->CreatePtrToInt(cons_ptr, int64_type);
    }
    // Phase 3B: Simplified tagged cons cell allocation - direct tagged_value storage!
    Value* codegenTaggedArenaConsCell(const TypedValue& car_val, const TypedValue& cdr_val) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for tagged cons cell allocation");
            return nullptr;
        }
        
        // Allocate tagged cons cell (32 bytes in Phase 3B) using arena
        Value* cons_ptr = builder->CreateCall(getArenaAllocateTaggedConsCellFunc(), {arena_ptr});
        
        // Convert TypedValue to tagged_value
        Value* car_tagged = typedValueToTaggedValue(car_val);
        Value* cdr_tagged = typedValueToTaggedValue(cdr_val);
        
        // Store COMPLETE tagged_value structs directly using Phase 3B helpers!
        Value* is_car = ConstantInt::get(int1_type, 0);
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        
        // Phase 3B FIX: Create allocas at function entry to ensure dominance
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }
        
        // Create pointers to tagged values for passing by reference
        Value* car_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "car_tagged_ptr");
        Value* cdr_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "cdr_tagged_ptr");
        
        // Restore insertion point for stores and calls
        builder->restoreIP(saved_ip);
        
        builder->CreateStore(car_tagged, car_ptr);
        builder->CreateStore(cdr_tagged, cdr_ptr);
        
        // Direct struct copy - this is the key optimization of Phase 3B!
        builder->CreateCall(getTaggedConsSetTaggedValueFunc(), {cons_ptr, is_car, car_ptr});
        builder->CreateCall(getTaggedConsSetTaggedValueFunc(), {cons_ptr, is_cdr, cdr_ptr});

        eshkol_debug("Created tagged cons cell (Phase 3B): car_type=%d, cdr_type=%d", car_val.type, cdr_val.type);

        // Return pointer to cons cell as int64
        return builder->CreatePtrToInt(cons_ptr, int64_type);
    }
    
    // ROBUST SOLUTION: Create cons cell directly from tagged_value with type preservation
    // This stores the VALUE from tagged_value into the cons cell car, preserving the type
    Value* codegenTaggedArenaConsCellFromTaggedValue(Value* car_tagged, Value* cdr_tagged) {
        Value* arena_ptr = getArenaPtr();
        if (!arena_ptr) {
            eshkol_error("Arena not initialized for tagged cons cell allocation");
            return nullptr;
        }
        
        // Allocate tagged cons cell
        Value* cons_ptr = builder->CreateCall(getArenaAllocateTaggedConsCellFunc(), {arena_ptr});
        
        // Extract type from car_tagged
        Value* car_type = getTaggedValueType(car_tagged);
        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(int8_type, 0x0F));
        
        // SYMBOLIC DIFF FIX: Check for NULL, DOUBLE, all pointer types (CONS_PTR, STRING_PTR, etc.), and INT64
        Value* car_is_null = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        // Check all pointer types that should use set_ptr
        Value* car_is_cons = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* car_is_string = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* car_is_vector = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
        Value* car_is_tensor = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* car_is_ad = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* car_is_lambda = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        // CLOSURE_PTR FIX: Also handle closure pointers in cons cells
        Value* car_is_closure = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        Value* car_is_ptr = builder->CreateOr(car_is_cons,
            builder->CreateOr(car_is_string,
            builder->CreateOr(car_is_vector,
            builder->CreateOr(car_is_tensor,
            builder->CreateOr(car_is_ad,
            builder->CreateOr(car_is_lambda, car_is_closure))))));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* car_null = BasicBlock::Create(*context, "cons_car_null", current_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "cons_car_check_double", current_func);
        BasicBlock* car_double = BasicBlock::Create(*context, "cons_car_double", current_func);
        BasicBlock* check_ptr = BasicBlock::Create(*context, "cons_car_check_ptr", current_func);
        BasicBlock* car_ptr = BasicBlock::Create(*context, "cons_car_ptr", current_func);
        BasicBlock* car_int = BasicBlock::Create(*context, "cons_car_int", current_func);
        BasicBlock* car_done = BasicBlock::Create(*context, "cons_car_done", current_func);

        Value* is_car = ConstantInt::get(int1_type, 0);

        // Check NULL first
        builder->CreateCondBr(car_is_null, car_null, check_double);

        // Store car as null
        builder->SetInsertPoint(car_null);
        builder->CreateCall(getTaggedConsSetNullFunc(), {cons_ptr, is_car});
        builder->CreateBr(car_done);

        // Check double
        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(car_is_double, car_double, check_ptr);

        // Store car as double
        builder->SetInsertPoint(car_double);
        Value* car_double_val = unpackDoubleFromTaggedValue(car_tagged);
        builder->CreateCall(getTaggedConsSetDoubleFunc(),
            {cons_ptr, is_car, car_double_val, car_type});
        builder->CreateBr(car_done);

        // Check if CONS_PTR
        builder->SetInsertPoint(check_ptr);
        builder->CreateCondBr(car_is_ptr, car_ptr, car_int);

        // Store car as pointer (string symbols, nested lists, etc.)
        builder->SetInsertPoint(car_ptr);
        Value* car_ptr_val = unpackInt64FromTaggedValue(car_tagged);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {cons_ptr, is_car, car_ptr_val, car_type});
        builder->CreateBr(car_done);

        // Store car as int64
        builder->SetInsertPoint(car_int);
        Value* car_int_val = unpackInt64FromTaggedValue(car_tagged);
        builder->CreateCall(getTaggedConsSetInt64Func(),
            {cons_ptr, is_car, car_int_val, car_type});
        builder->CreateBr(car_done);
        
        // Store cdr - SYMBOLIC DIFF FIX: check for NULL, DOUBLE, CONS_PTR, INT64
        builder->SetInsertPoint(car_done);
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        
        // Get cdr type
        Value* cdr_type = getTaggedValueType(cdr_tagged);
        Value* cdr_base_type = builder->CreateAnd(cdr_type,
            ConstantInt::get(int8_type, 0x0F));
        
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        // Check all pointer types that should use set_ptr
        Value* cdr_is_cons = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_string = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* cdr_is_vector = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
        Value* cdr_is_tensor = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* cdr_is_ad = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* cdr_is_lambda = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        // CLOSURE_PTR FIX: Also handle closure pointers in cons cells
        Value* cdr_is_closure = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        Value* cdr_is_ptr = builder->CreateOr(cdr_is_cons,
            builder->CreateOr(cdr_is_string,
            builder->CreateOr(cdr_is_vector,
            builder->CreateOr(cdr_is_tensor,
            builder->CreateOr(cdr_is_ad,
            builder->CreateOr(cdr_is_lambda, cdr_is_closure))))));
        
        BasicBlock* cdr_null_block = BasicBlock::Create(*context, "cons_cdr_null", current_func);
        BasicBlock* cdr_check_double = BasicBlock::Create(*context, "cons_cdr_check_double", current_func);
        BasicBlock* cdr_double_block = BasicBlock::Create(*context, "cons_cdr_double", current_func);
        BasicBlock* cdr_check_ptr = BasicBlock::Create(*context, "cons_cdr_check_ptr", current_func);
        BasicBlock* cdr_ptr_block = BasicBlock::Create(*context, "cons_cdr_ptr", current_func);
        BasicBlock* cdr_int_block = BasicBlock::Create(*context, "cons_cdr_int", current_func);
        BasicBlock* cdr_done_block = BasicBlock::Create(*context, "cons_cdr_done", current_func);
        
        builder->CreateCondBr(cdr_is_null, cdr_null_block, cdr_check_double);
        
        // Cdr is null - use set_null
        builder->SetInsertPoint(cdr_null_block);
        builder->CreateCall(getTaggedConsSetNullFunc(), {cons_ptr, is_cdr});
        builder->CreateBr(cdr_done_block);
        
        // Check if cdr is double
        builder->SetInsertPoint(cdr_check_double);
        builder->CreateCondBr(cdr_is_double, cdr_double_block, cdr_check_ptr);
        
        // Cdr is double - use set_double
        builder->SetInsertPoint(cdr_double_block);
        Value* cdr_double_val = unpackDoubleFromTaggedValue(cdr_tagged);
        builder->CreateCall(getTaggedConsSetDoubleFunc(),
            {cons_ptr, is_cdr, cdr_double_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        // Check if CONS_PTR
        builder->SetInsertPoint(cdr_check_ptr);
        builder->CreateCondBr(cdr_is_ptr, cdr_ptr_block, cdr_int_block);
        
        // Cdr is CONS_PTR - use set_ptr (for nested lists in S-expressions!)
        builder->SetInsertPoint(cdr_ptr_block);
        Value* cdr_ptr_val = unpackInt64FromTaggedValue(cdr_tagged);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {cons_ptr, is_cdr, cdr_ptr_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        // Cdr is int64 - use set_int64
        builder->SetInsertPoint(cdr_int_block);
        Value* cdr_int_val = unpackInt64FromTaggedValue(cdr_tagged);
        builder->CreateCall(getTaggedConsSetInt64Func(),
            {cons_ptr, is_cdr, cdr_int_val, cdr_type});
        builder->CreateBr(cdr_done_block);
        
        builder->SetInsertPoint(cdr_done_block);
        
        // Return cons cell pointer as int64
        return builder->CreatePtrToInt(cons_ptr, int64_type);
    }
    
    // ===== TAGGED VALUE HELPER FUNCTIONS =====
    // Pack/unpack values to/from eshkol_tagged_value_t structs
    
    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packInt64ToTaggedValue(Value* int64_val, bool is_exact = true) {
        return tagged_->packInt64(int64_val, is_exact);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packBoolToTaggedValue(Value* bool_val) {
        return tagged_->packBool(bool_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packInt64ToTaggedValueWithTypeAndFlags(Value* int64_val, Value* type_val, Value* flags_val) {
        return tagged_->packInt64WithTypeAndFlags(int64_val, type_val, flags_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packDoubleToTaggedValue(Value* double_val) {
        return tagged_->packDouble(double_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packPtrToTaggedValue(Value* ptr_val, eshkol_value_type_t type, uint8_t flags = 0) {
        return tagged_->packPtr(ptr_val, type, flags);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packPtrToTaggedValueWithFlags(Value* ptr_val, Value* type_val, Value* flags_val) {
        return tagged_->packPtrWithFlags(ptr_val, type_val, flags_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* packNullToTaggedValue() {
        return tagged_->packNull();
    }

    // Runtime closure call dispatcher - supports variadic closures with up to 16 captures
    // This is essential for N-dimensional lambda calculus and AD operations
    Value* codegenClosureCall(Value* func_result, const std::vector<Value*>& call_args, const char* caller_info = "unknown") {
        (void)caller_info;  // Used for debugging
        // Check if the result is a CLOSURE_PTR or a direct function pointer
        Value* type_tag = getTaggedValueType(func_result);
        Value* base_type = builder->CreateAnd(type_tag,
            ConstantInt::get(int8_type, 0x0F));
        Value* is_closure = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* closure_bb = BasicBlock::Create(*context, "call_closure", current_func);
        BasicBlock* direct_bb = BasicBlock::Create(*context, "call_direct", current_func);
        BasicBlock* merge_bb = BasicBlock::Create(*context, "call_merge", current_func);

        builder->CreateCondBr(is_closure, closure_bb, direct_bb);

        // CLOSURE PATH: Extract func_ptr and captures, dispatch by capture count
        builder->SetInsertPoint(closure_bb);

        Value* closure_ptr_i64 = unpackInt64FromTaggedValue(func_result);
        Value* closure_ptr = builder->CreateIntToPtr(closure_ptr_i64, PointerType::getUnqual(*context));

        // Load func_ptr from closure (offset 0)
        Value* func_ptr_from_closure = builder->CreateLoad(int64_type, closure_ptr);
        Value* actual_func_ptr = builder->CreateIntToPtr(func_ptr_from_closure, PointerType::getUnqual(*context));

        // Load env pointer from closure (offset 8)
        Value* env_ptr_addr = builder->CreateGEP(int8_type, closure_ptr,
            ConstantInt::get(int64_type, 8));
        Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_addr);

        // HOMOICONICITY FIX: Check if env_ptr is null (0 captures case)
        Value* env_is_null = builder->CreateICmpEQ(env_ptr,
            ConstantPointerNull::get(PointerType::getUnqual(*context)));
        BasicBlock* env_valid = BasicBlock::Create(*context, "env_valid", current_func);
        BasicBlock* env_null = BasicBlock::Create(*context, "env_null", current_func);
        BasicBlock* env_checked = BasicBlock::Create(*context, "env_checked", current_func);

        builder->CreateCondBr(env_is_null, env_null, env_valid);

        // Null env path - 0 captures, but need to get arity from closure->input_arity
        builder->SetInsertPoint(env_null);
        // Closure structure: func_ptr(8) + env(8) + sexpr_ptr(8) + return_type(1) + input_arity(1)
        // So input_arity is at offset 25 from closure_ptr
        Value* input_arity_ptr = builder->CreateGEP(int8_type, closure_ptr,
            ConstantInt::get(int64_type, 25));
        Value* input_arity_byte = builder->CreateLoad(int8_type, input_arity_ptr);
        Value* input_arity_i64 = builder->CreateZExt(input_arity_byte, int64_type);
        // Pack: 0 captures (bits 0-15), input_arity in bits 16-31
        Value* null_env_packed = builder->CreateShl(input_arity_i64, ConstantInt::get(int64_type, 16));
        builder->CreateBr(env_checked);

        // Valid env path - load packed_info from env (offset 0)
        // Packed format: bits 0-15 = num_captures, bits 16-31 = fixed_params, bit 63 = is_variadic
        builder->SetInsertPoint(env_valid);
        Value* packed_info = builder->CreateLoad(int64_type, env_ptr);
        builder->CreateBr(env_checked);

        // Merge paths with phi node
        builder->SetInsertPoint(env_checked);
        PHINode* packed_phi = builder->CreatePHI(int64_type, 2, "packed_info");
        packed_phi->addIncoming(null_env_packed, env_null);
        packed_phi->addIncoming(packed_info, env_valid);

        // Unpack the fields
        Value* num_captures = builder->CreateAnd(packed_phi,
            ConstantInt::get(int64_type, 0xFFFF), "num_captures");
        Value* fixed_params = builder->CreateAnd(
            builder->CreateLShr(packed_phi, ConstantInt::get(int64_type, 16)),
            ConstantInt::get(int64_type, 0xFFFF), "fixed_params");
        Value* is_variadic = builder->CreateAnd(
            builder->CreateLShr(packed_phi, ConstantInt::get(int64_type, 63)),
            ConstantInt::get(int64_type, 1), "is_variadic");

        // Load captures base (at offset 8 in env, after packed_info field)
        Value* captures_base = builder->CreateGEP(int8_type, env_ptr,
            ConstantInt::get(int64_type, 8));
        Value* captures_typed = builder->CreateBitCast(captures_base,
            PointerType::getUnqual(*context));

        // VARIADIC CLOSURE FIX: Check if this is a variadic closure
        Value* is_variadic_cond = builder->CreateICmpNE(is_variadic,
            ConstantInt::get(int64_type, 0));
        BasicBlock* variadic_bb = BasicBlock::Create(*context, "variadic_closure", current_func);
        BasicBlock* non_variadic_bb = BasicBlock::Create(*context, "non_variadic_closure", current_func);
        builder->CreateCondBr(is_variadic_cond, variadic_bb, non_variadic_bb);

        // ===== VARIADIC PATH: Package extra args into rest list =====

        // Pre-allocate allocas at function entry to ensure dominance
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
        BasicBlock& entry_block = current_func->getEntryBlock();
        builder->SetInsertPoint(&entry_block, entry_block.begin());

        // Create allocas for each arg's car and cdr storage
        std::vector<Value*> arg_ptrs;
        std::vector<Value*> rest_ptrs;
        for (size_t i = 0; i < call_args.size(); i++) {
            arg_ptrs.push_back(builder->CreateAlloca(tagged_value_type, nullptr, "var_arg_ptr"));
            rest_ptrs.push_back(builder->CreateAlloca(tagged_value_type, nullptr, "var_rest_ptr"));
        }

        // Restore insertion point
        builder->restoreIP(saved_ip);
        builder->SetInsertPoint(variadic_bb);

        // Build rest list from call_args starting after fixed_params
        // We need to iterate and cons each arg. Start with null, then cons each from right to left
        Value* rest_list = packPtrToTaggedValue(
            ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);

        // For now, we build the list by consing all args (no fixed params handling yet)
        // This is a simplification - full implementation would handle fixed params
        for (int64_t i = call_args.size() - 1; i >= 0; i--) {
            // Allocate cons cell
            Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
            Value* cons_cell = builder->CreateCall(getArenaAllocateTaggedConsCellFunc(), {arena_ptr});

            // Set car to arg, cdr to rest_list using pre-allocated allocas
            Value* arg_val = call_args[i];
            builder->CreateStore(arg_val, arg_ptrs[i]);
            builder->CreateCall(getTaggedConsSetTaggedValueFunc(),
                {cons_cell, ConstantInt::get(int1_type, 0), arg_ptrs[i]}); // car

            builder->CreateStore(rest_list, rest_ptrs[i]);
            builder->CreateCall(getTaggedConsSetTaggedValueFunc(),
                {cons_cell, ConstantInt::get(int1_type, 1), rest_ptrs[i]}); // cdr

            // Update rest_list to point to new cons cell
            Value* cons_int = builder->CreatePtrToInt(cons_cell, int64_type);
            rest_list = packPtrToTaggedValue(cons_int, ESHKOL_VALUE_CONS_PTR);
        }

        // Now generate switch for variadic closure call (with captures)
        const int MAX_CAPTURES = 32;
        BasicBlock* variadic_switch_default = BasicBlock::Create(*context, "var_cap_default", current_func);
        SwitchInst* var_sw = builder->CreateSwitch(num_captures, variadic_switch_default, MAX_CAPTURES + 1);
        std::vector<std::pair<BasicBlock*, Value*>> variadic_results;

        for (int cap_count = 0; cap_count <= MAX_CAPTURES; cap_count++) {
            BasicBlock* case_bb = BasicBlock::Create(*context,
                "var_cap_" + std::to_string(cap_count), current_func);
            var_sw->addCase(ConstantInt::get(int64_type, cap_count), case_bb);
            builder->SetInsertPoint(case_bb);

            // For variadic: args are (rest_list, captures...)
            std::vector<Value*> full_args;
            full_args.push_back(rest_list);  // The packaged rest list
            for (int i = 0; i < cap_count; i++) {
                Value* cap_ptr = builder->CreateGEP(tagged_value_type, captures_typed,
                    ConstantInt::get(int64_type, i));
                full_args.push_back(cap_ptr);
            }

            // Function type: (tagged_value, pointer...) -> tagged_value
            std::vector<Type*> param_types;
            param_types.push_back(tagged_value_type);  // rest list
            for (int i = 0; i < cap_count; i++) {
                param_types.push_back(PointerType::getUnqual(*context));
            }
            FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);

            Value* result = builder->CreateCall(func_type, actual_func_ptr, full_args);
            builder->CreateBr(merge_bb);
            variadic_results.push_back({builder->GetInsertBlock(), result});
        }

        builder->SetInsertPoint(variadic_switch_default);
        Value* var_default_result = packNullToTaggedValue();
        builder->CreateBr(merge_bb);
        variadic_results.push_back({variadic_switch_default, var_default_result});

        // ===== NON-VARIADIC PATH: Call as before =====
        builder->SetInsertPoint(non_variadic_bb);

        BasicBlock* nonvar_switch_default = BasicBlock::Create(*context, "cap_default", current_func);
        SwitchInst* sw = builder->CreateSwitch(num_captures, nonvar_switch_default, MAX_CAPTURES + 1);

        std::vector<std::pair<BasicBlock*, Value*>> results;

        // Generate a case for each capture count
        for (int cap_count = 0; cap_count <= MAX_CAPTURES; cap_count++) {
            BasicBlock* case_bb = BasicBlock::Create(*context,
                "cap_" + std::to_string(cap_count), current_func);
            sw->addCase(ConstantInt::get(int64_type, cap_count), case_bb);

            builder->SetInsertPoint(case_bb);

            // MUTABLE CAPTURE FIX: Pass capture pointers instead of values
            // Build args with this many captures (as pointers to closure env slots)
            std::vector<Value*> full_args = call_args;
            for (int i = 0; i < cap_count; i++) {
                Value* cap_ptr = builder->CreateGEP(tagged_value_type, captures_typed,
                    ConstantInt::get(int64_type, i));
                // Pass pointer to capture slot, not the loaded value
                full_args.push_back(cap_ptr);
            }

            // Build function type for this capture count
            // Regular args are tagged_value, captures are pointer
            std::vector<Type*> param_types;
            for (size_t i = 0; i < call_args.size(); i++) {
                param_types.push_back(tagged_value_type);
            }
            for (int i = 0; i < cap_count; i++) {
                param_types.push_back(PointerType::getUnqual(*context));
            }
            FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);

            Value* result = builder->CreateCall(func_type, actual_func_ptr, full_args);

            builder->CreateBr(merge_bb);
            results.push_back({builder->GetInsertBlock(), result});
        }

        // Default case (more than MAX_CAPTURES - shouldn't happen but handle gracefully)
        builder->SetInsertPoint(nonvar_switch_default);
        Value* default_result = packNullToTaggedValue();
        builder->CreateBr(merge_bb);
        results.push_back({nonvar_switch_default, default_result});

        // Combine variadic_results with results for the merge
        for (auto& p : variadic_results) {
            results.push_back(p);
        }

        // DIRECT PATH: Check if callable, otherwise return value as-is
        // This handles Y combinator patterns where non-functions may be "called"
        builder->SetInsertPoint(direct_bb);

        // NON-CALLABLE FIX: Check if this is actually a callable type
        // Only INT64 (function pointer) and LAMBDA_SEXPR should be called directly
        // CONS_PTR, STRING_PTR, NULL, BOOL, DOUBLE etc. should be returned as-is
        Value* is_lambda_sexpr = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        Value* is_int64 = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_callable = builder->CreateOr(is_lambda_sexpr, is_int64);

        BasicBlock* do_direct_call = BasicBlock::Create(*context, "do_direct_call", current_func);
        BasicBlock* return_as_is = BasicBlock::Create(*context, "return_as_is", current_func);
        builder->CreateCondBr(is_callable, do_direct_call, return_as_is);

        // Return non-callable value as-is (e.g., cons pair from Y combinator)
        builder->SetInsertPoint(return_as_is);
        Value* as_is_result = func_result;
        builder->CreateBr(merge_bb);
        BasicBlock* as_is_exit_bb = builder->GetInsertBlock();

        // Actually call the function pointer
        builder->SetInsertPoint(do_direct_call);
        Value* direct_func_ptr_i64 = unpackInt64FromTaggedValue(func_result);
        Value* direct_func_ptr = builder->CreateIntToPtr(direct_func_ptr_i64, PointerType::getUnqual(*context));

        std::vector<Type*> direct_param_types(call_args.size(), tagged_value_type);
        FunctionType* direct_func_type = FunctionType::get(tagged_value_type, direct_param_types, false);

        Value* direct_result = builder->CreateCall(direct_func_type, direct_func_ptr, call_args);
        builder->CreateBr(merge_bb);
        BasicBlock* direct_exit_bb = builder->GetInsertBlock();

        // MERGE: PHI node to select result from all paths
        builder->SetInsertPoint(merge_bb);
        PHINode* phi = builder->CreatePHI(tagged_value_type, results.size() + 2, "call_result");
        for (auto& [bb, val] : results) {
            phi->addIncoming(val, bb);
        }
        phi->addIncoming(direct_result, direct_exit_bb);
        phi->addIncoming(as_is_result, as_is_exit_bb);

        return phi;
    }


    // MIGRATED: Delegates to TaggedValueCodegen
    Value* getTaggedValueType(Value* tagged_val) {
        return tagged_->getType(tagged_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* getTaggedValueFlags(Value* tagged_val) {
        return tagged_->getFlags(tagged_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* unpackInt64FromTaggedValue(Value* tagged_val) {
        return tagged_->unpackInt64(tagged_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* unpackDoubleFromTaggedValue(Value* tagged_val) {
        return tagged_->unpackDouble(tagged_val);
    }

    // MIGRATED: Delegates to TaggedValueCodegen
    Value* unpackPtrFromTaggedValue(Value* tagged_val) {
        return tagged_->unpackPtr(tagged_val);
    }

    Value* extractCarAsTaggedValue(Value* cons_ptr_int) {
        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        cons_ptr_int = safeExtractInt64(cons_ptr_int);

        Value* cons_ptr = builder->CreateIntToPtr(cons_ptr_int, builder->getPtrTy());

        Value* is_car = ConstantInt::get(int1_type, 0);
        Value* car_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car});

        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(int8_type, 0x0F));

        // HOMOICONIC FIX: Check for NULL, DOUBLE, CONS_PTR, STRING_PTR, LAMBDA_SEXPR, CLOSURE_PTR, INT64
        Value* car_is_null = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* car_is_cons_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* car_is_string_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* car_is_lambda_sexpr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        // CLOSURE_PTR FIX: Handle closure pointers when extracting from cons cells
        Value* car_is_closure_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        // BOOL FIX: Handle boolean values when extracting from cons cells
        Value* car_is_bool = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL));
        // HASH_PTR FIX: Handle hash table pointers when extracting from cons cells
        Value* car_is_hash_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_HASH_PTR));
        // VECTOR_PTR FIX: Handle vector pointers when extracting from cons cells
        Value* car_is_vector_ptr = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* null_car = BasicBlock::Create(*context, "car_extract_null", current_func);
        BasicBlock* double_car = BasicBlock::Create(*context, "car_extract_double", current_func);
        BasicBlock* check_cons_ptr = BasicBlock::Create(*context, "car_check_cons_ptr", current_func);
        BasicBlock* cons_ptr_car = BasicBlock::Create(*context, "car_extract_cons_ptr", current_func);
        BasicBlock* check_string_ptr = BasicBlock::Create(*context, "car_check_string_ptr", current_func);
        BasicBlock* string_ptr_car = BasicBlock::Create(*context, "car_extract_string_ptr", current_func);
        BasicBlock* check_lambda_sexpr = BasicBlock::Create(*context, "car_check_lambda_sexpr", current_func);
        BasicBlock* lambda_sexpr_car = BasicBlock::Create(*context, "car_extract_lambda_sexpr", current_func);
        BasicBlock* check_closure_ptr = BasicBlock::Create(*context, "car_check_closure_ptr", current_func);
        BasicBlock* closure_ptr_car = BasicBlock::Create(*context, "car_extract_closure_ptr", current_func);
        BasicBlock* check_bool = BasicBlock::Create(*context, "car_check_bool", current_func);
        BasicBlock* bool_car = BasicBlock::Create(*context, "car_extract_bool", current_func);
        BasicBlock* check_hash_ptr = BasicBlock::Create(*context, "car_check_hash_ptr", current_func);
        BasicBlock* hash_ptr_car = BasicBlock::Create(*context, "car_extract_hash_ptr", current_func);
        BasicBlock* check_vector_ptr = BasicBlock::Create(*context, "car_check_vector_ptr", current_func);
        BasicBlock* vector_ptr_car = BasicBlock::Create(*context, "car_extract_vector_ptr", current_func);
        BasicBlock* int_car = BasicBlock::Create(*context, "car_extract_int", current_func);
        BasicBlock* merge_car = BasicBlock::Create(*context, "car_merge", current_func);

        BasicBlock* check_double = BasicBlock::Create(*context, "car_check_double", current_func);

        builder->CreateCondBr(car_is_null, null_car, check_double);

        builder->SetInsertPoint(null_car);
        Value* tagged_null = packNullToTaggedValue();
        builder->CreateBr(merge_car);
        BasicBlock* null_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(car_is_double, double_car, check_cons_ptr);

        builder->SetInsertPoint(double_car);
        Value* car_double = builder->CreateCall(getTaggedConsGetDoubleFunc(), {cons_ptr, is_car});
        Value* tagged_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(merge_car);
        BasicBlock* double_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_cons_ptr);
        builder->CreateCondBr(car_is_cons_ptr, cons_ptr_car, check_string_ptr);

        builder->SetInsertPoint(cons_ptr_car);
        Value* car_cons_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});
        Value* tagged_cons_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_cons_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* cons_ptr_exit = builder->GetInsertBlock();

        // HOMOICONIC FIX: Handle STRING_PTR for symbol names (x, y, +, *, etc.)
        builder->SetInsertPoint(check_string_ptr);
        builder->CreateCondBr(car_is_string_ptr, string_ptr_car, check_lambda_sexpr);

        builder->SetInsertPoint(string_ptr_car);
        Value* car_string_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});
        Value* tagged_string_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_string_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_STRING_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* string_ptr_exit = builder->GetInsertBlock();

        // HOMOICONIC FIX: Handle LAMBDA_SEXPR for lambdas stored in lists
        builder->SetInsertPoint(check_lambda_sexpr);
        builder->CreateCondBr(car_is_lambda_sexpr, lambda_sexpr_car, check_closure_ptr);

        builder->SetInsertPoint(lambda_sexpr_car);
        // CRITICAL FIX: Read type, flags, and ptr separately to avoid struct-return ABI issues
        // This is essential for homoiconic lambda display - flags determine if we need to dereference
        Value* lambda_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car});
        Value* lambda_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car});
        Value* lambda_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});

        // Manually build the tagged_value struct with correct type, flags, and ptr
        Value* tagged_lambda_ptr = packPtrToTaggedValueWithFlags(
            builder->CreateIntToPtr(lambda_ptr, builder->getPtrTy()),
            lambda_type, lambda_flags);
        builder->CreateBr(merge_car);
        BasicBlock* lambda_sexpr_exit = builder->GetInsertBlock();

        // CLOSURE_PTR FIX: Handle closure pointers when extracting from cons cells
        builder->SetInsertPoint(check_closure_ptr);
        builder->CreateCondBr(car_is_closure_ptr, closure_ptr_car, check_bool);

        builder->SetInsertPoint(closure_ptr_car);
        // Extract closure pointer from cons cell and rebuild as CLOSURE_PTR tagged value
        Value* closure_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car});
        Value* closure_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car});
        Value* closure_ptr_val = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});
        Value* tagged_closure_ptr = packPtrToTaggedValueWithFlags(
            builder->CreateIntToPtr(closure_ptr_val, builder->getPtrTy()),
            closure_type, closure_flags);
        builder->CreateBr(merge_car);
        BasicBlock* closure_ptr_exit = builder->GetInsertBlock();

        // BOOL FIX: Handle boolean values when extracting from cons cells
        builder->SetInsertPoint(check_bool);
        builder->CreateCondBr(car_is_bool, bool_car, check_hash_ptr);

        builder->SetInsertPoint(bool_car);
        // Extract boolean value and pack as BOOL type
        Value* car_bool_int = builder->CreateCall(getTaggedConsGetInt64Func(), {cons_ptr, is_car});
        Value* car_bool_i1 = builder->CreateICmpNE(car_bool_int, ConstantInt::get(int64_type, 0));
        Value* tagged_bool = packBoolToTaggedValue(car_bool_i1);
        builder->CreateBr(merge_car);
        BasicBlock* bool_exit = builder->GetInsertBlock();

        // HASH_PTR FIX: Handle hash table pointers when extracting from cons cells
        builder->SetInsertPoint(check_hash_ptr);
        builder->CreateCondBr(car_is_hash_ptr, hash_ptr_car, check_vector_ptr);

        builder->SetInsertPoint(hash_ptr_car);
        Value* car_hash_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});
        Value* tagged_hash_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_hash_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_HASH_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* hash_ptr_exit = builder->GetInsertBlock();

        // VECTOR_PTR FIX: Handle vector pointers when extracting from cons cells
        builder->SetInsertPoint(check_vector_ptr);
        builder->CreateCondBr(car_is_vector_ptr, vector_ptr_car, int_car);

        builder->SetInsertPoint(vector_ptr_car);
        Value* car_vector_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car});
        Value* tagged_vector_ptr = packPtrToTaggedValue(
            builder->CreateIntToPtr(car_vector_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_VECTOR_PTR);
        builder->CreateBr(merge_car);
        BasicBlock* vector_ptr_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(int_car);
        Value* car_int64 = builder->CreateCall(getTaggedConsGetInt64Func(), {cons_ptr, is_car});
        Value* tagged_int64 = packInt64ToTaggedValue(car_int64, true);
        builder->CreateBr(merge_car);
        BasicBlock* int_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(merge_car);
        PHINode* car_tagged_phi = builder->CreatePHI(tagged_value_type, 10);
        car_tagged_phi->addIncoming(tagged_null, null_exit);
        car_tagged_phi->addIncoming(tagged_double, double_exit);
        car_tagged_phi->addIncoming(tagged_cons_ptr, cons_ptr_exit);
        car_tagged_phi->addIncoming(tagged_string_ptr, string_ptr_exit);
        car_tagged_phi->addIncoming(tagged_lambda_ptr, lambda_sexpr_exit);
        car_tagged_phi->addIncoming(tagged_closure_ptr, closure_ptr_exit);
        car_tagged_phi->addIncoming(tagged_bool, bool_exit);
        car_tagged_phi->addIncoming(tagged_hash_ptr, hash_ptr_exit);
        car_tagged_phi->addIncoming(tagged_vector_ptr, vector_ptr_exit);
        car_tagged_phi->addIncoming(tagged_int64, int_exit);

        return car_tagged_phi;
    }
    
    Value* extractCdrAsTaggedValue(Value* cons_ptr_int) {
        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        cons_ptr_int = safeExtractInt64(cons_ptr_int);

        Value* cons_ptr = builder->CreateIntToPtr(cons_ptr_int, builder->getPtrTy());
        
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        Value* cdr_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_cdr});
        
        Value* cdr_base_type = builder->CreateAnd(cdr_type,
            ConstantInt::get(int8_type, 0x0F));
        
        // SYMBOLIC DIFF FIX: Check for NULL, DOUBLE, CONS_PTR, BOOL, INT64
        Value* cdr_is_double = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* cdr_is_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        // BOOL FIX: Handle boolean values in cdr
        Value* cdr_is_bool = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL));
        // HASH_PTR FIX: Handle hash table pointers in cdr
        Value* cdr_is_hash_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_HASH_PTR));
        // VECTOR_PTR FIX: Handle vector pointers in cdr
        Value* cdr_is_vector_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
        // STRING_PTR FIX: Handle string pointers in cdr
        Value* cdr_is_string_ptr = builder->CreateICmpEQ(cdr_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* double_cdr = BasicBlock::Create(*context, "cdr_extract_double", current_func);
        BasicBlock* check_ptr_cdr = BasicBlock::Create(*context, "cdr_check_ptr", current_func);
        BasicBlock* ptr_cdr = BasicBlock::Create(*context, "cdr_extract_ptr", current_func);
        BasicBlock* check_null_cdr = BasicBlock::Create(*context, "cdr_check_null", current_func);
        BasicBlock* null_cdr = BasicBlock::Create(*context, "cdr_extract_null", current_func);
        BasicBlock* check_bool_cdr = BasicBlock::Create(*context, "cdr_check_bool", current_func);
        BasicBlock* bool_cdr = BasicBlock::Create(*context, "cdr_extract_bool", current_func);
        BasicBlock* check_hash_ptr_cdr = BasicBlock::Create(*context, "cdr_check_hash_ptr", current_func);
        BasicBlock* hash_ptr_cdr = BasicBlock::Create(*context, "cdr_extract_hash_ptr", current_func);
        BasicBlock* check_vector_ptr_cdr = BasicBlock::Create(*context, "cdr_check_vector_ptr", current_func);
        BasicBlock* vector_ptr_cdr = BasicBlock::Create(*context, "cdr_extract_vector_ptr", current_func);
        BasicBlock* check_string_ptr_cdr = BasicBlock::Create(*context, "cdr_check_string_ptr", current_func);
        BasicBlock* string_ptr_cdr = BasicBlock::Create(*context, "cdr_extract_string_ptr", current_func);
        BasicBlock* int_cdr = BasicBlock::Create(*context, "cdr_extract_int", current_func);
        BasicBlock* merge_cdr = BasicBlock::Create(*context, "cdr_merge", current_func);

        builder->CreateCondBr(cdr_is_double, double_cdr, check_ptr_cdr);

        builder->SetInsertPoint(double_cdr);
        Value* cdr_double = builder->CreateCall(getTaggedConsGetDoubleFunc(), {cons_ptr, is_cdr});
        Value* tagged_double_cdr = packDoubleToTaggedValue(cdr_double);
        builder->CreateBr(merge_cdr);
        BasicBlock* double_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_ptr_cdr);
        builder->CreateCondBr(cdr_is_ptr, ptr_cdr, check_null_cdr);

        builder->SetInsertPoint(ptr_cdr);
        Value* cdr_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        // SYMBOLIC DIFF FIX: Preserve CONS_PTR type for nested lists!
        Value* tagged_ptr_cdr = packPtrToTaggedValue(
            builder->CreateIntToPtr(cdr_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* ptr_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_null_cdr);
        builder->CreateCondBr(cdr_is_null, null_cdr, check_bool_cdr);

        builder->SetInsertPoint(null_cdr);
        Value* tagged_null_cdr = packNullToTaggedValue();
        builder->CreateBr(merge_cdr);
        BasicBlock* null_exit = builder->GetInsertBlock();

        // BOOL FIX: Handle boolean values when extracting cdr from cons cells
        builder->SetInsertPoint(check_bool_cdr);
        builder->CreateCondBr(cdr_is_bool, bool_cdr, check_hash_ptr_cdr);

        builder->SetInsertPoint(bool_cdr);
        Value* cdr_bool_int = builder->CreateCall(getTaggedConsGetInt64Func(), {cons_ptr, is_cdr});
        Value* cdr_bool_i1 = builder->CreateICmpNE(cdr_bool_int, ConstantInt::get(int64_type, 0));
        Value* tagged_bool_cdr = packBoolToTaggedValue(cdr_bool_i1);
        builder->CreateBr(merge_cdr);
        BasicBlock* bool_exit = builder->GetInsertBlock();

        // HASH_PTR FIX: Handle hash table pointers when extracting cdr from cons cells
        builder->SetInsertPoint(check_hash_ptr_cdr);
        builder->CreateCondBr(cdr_is_hash_ptr, hash_ptr_cdr, check_vector_ptr_cdr);

        builder->SetInsertPoint(hash_ptr_cdr);
        Value* cdr_hash_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        Value* tagged_hash_ptr_cdr = packPtrToTaggedValue(
            builder->CreateIntToPtr(cdr_hash_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_HASH_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* hash_ptr_exit = builder->GetInsertBlock();

        // VECTOR_PTR FIX: Handle vector pointers when extracting cdr from cons cells
        builder->SetInsertPoint(check_vector_ptr_cdr);
        builder->CreateCondBr(cdr_is_vector_ptr, vector_ptr_cdr, check_string_ptr_cdr);

        builder->SetInsertPoint(vector_ptr_cdr);
        Value* cdr_vector_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        Value* tagged_vector_ptr_cdr = packPtrToTaggedValue(
            builder->CreateIntToPtr(cdr_vector_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_VECTOR_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* vector_ptr_exit = builder->GetInsertBlock();

        // STRING_PTR FIX: Handle string pointers when extracting cdr from cons cells
        builder->SetInsertPoint(check_string_ptr_cdr);
        builder->CreateCondBr(cdr_is_string_ptr, string_ptr_cdr, int_cdr);

        builder->SetInsertPoint(string_ptr_cdr);
        Value* cdr_string_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        Value* tagged_string_ptr_cdr = packPtrToTaggedValue(
            builder->CreateIntToPtr(cdr_string_ptr, builder->getPtrTy()),
            ESHKOL_VALUE_STRING_PTR);
        builder->CreateBr(merge_cdr);
        BasicBlock* string_ptr_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(int_cdr);
        Value* cdr_int64 = builder->CreateCall(getTaggedConsGetInt64Func(), {cons_ptr, is_cdr});
        Value* tagged_int64_cdr = packInt64ToTaggedValue(cdr_int64, true);
        builder->CreateBr(merge_cdr);
        BasicBlock* int_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(merge_cdr);
        PHINode* cdr_tagged_phi = builder->CreatePHI(tagged_value_type, 8);
        cdr_tagged_phi->addIncoming(tagged_double_cdr, double_exit);
        cdr_tagged_phi->addIncoming(tagged_ptr_cdr, ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_null_cdr, null_exit);
        cdr_tagged_phi->addIncoming(tagged_bool_cdr, bool_exit);
        cdr_tagged_phi->addIncoming(tagged_hash_ptr_cdr, hash_ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_vector_ptr_cdr, vector_ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_string_ptr_cdr, string_ptr_exit);
        cdr_tagged_phi->addIncoming(tagged_int64_cdr, int_exit);

        return cdr_tagged_phi;
    }
    
    // MIGRATED: Delegates to TaggedValueCodegen
    // Helper to safely extract i64 from possibly-tagged values for ICmp operations
    // CRITICAL: This prevents ICmp type mismatch assertions
    Value* safeExtractInt64(Value* val) {
        return tagged_->safeExtractInt64(val);
    }

    // Helper: Extract car element from cons cell as tagged value (type-safe approach)
    // This avoids ABI issues with returning 16-byte structs from C functions
    Value* extractConsCarAsTaggedValue(Value* cons_ptr) {
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Get car type using arena_tagged_cons_get_type(cell, false)
        Value* is_car_flag = ConstantInt::get(int1_type, 0); // false = car
        Value* car_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_flag});

        // Mask out flags to get base type (type & 0x0F)
        Value* car_base_type = builder->CreateAnd(car_type,
            ConstantInt::get(int8_type, 0x0F));

        // NULL FIX: Check for NULL values stored in cons cells
        Value* car_is_null = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        // Check for all types: DOUBLE, CONS_PTR, STRING_PTR, LAMBDA_SEXPR, CLOSURE_PTR, INT64
        Value* car_is_double = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* car_is_cons = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        // SYMBOL FIX: Check for STRING_PTR, LAMBDA_SEXPR, CLOSURE_PTR
        Value* car_is_string = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* car_is_lambda = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        Value* car_is_closure = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        // HASH_PTR FIX: Check for HASH_PTR, VECTOR_PTR
        Value* car_is_hash = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_HASH_PTR));
        Value* car_is_vector = builder->CreateICmpEQ(car_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        // NULL FIX: Add null_block for NULL values
        BasicBlock* null_block = BasicBlock::Create(*context, "extract_null", current_func);
        BasicBlock* check_double = BasicBlock::Create(*context, "extract_check_double", current_func);
        BasicBlock* double_block = BasicBlock::Create(*context, "extract_double", current_func);
        BasicBlock* check_cons = BasicBlock::Create(*context, "extract_check_cons", current_func);
        BasicBlock* cons_block = BasicBlock::Create(*context, "extract_cons", current_func);
        BasicBlock* check_string = BasicBlock::Create(*context, "extract_check_string", current_func);
        BasicBlock* string_block = BasicBlock::Create(*context, "extract_string", current_func);
        BasicBlock* check_lambda = BasicBlock::Create(*context, "extract_check_lambda", current_func);
        BasicBlock* lambda_block = BasicBlock::Create(*context, "extract_lambda", current_func);
        BasicBlock* check_closure = BasicBlock::Create(*context, "extract_check_closure", current_func);
        BasicBlock* closure_block = BasicBlock::Create(*context, "extract_closure", current_func);
        BasicBlock* check_hash = BasicBlock::Create(*context, "extract_check_hash", current_func);
        BasicBlock* hash_block = BasicBlock::Create(*context, "extract_hash", current_func);
        BasicBlock* check_vector = BasicBlock::Create(*context, "extract_check_vector", current_func);
        BasicBlock* vector_block = BasicBlock::Create(*context, "extract_vector", current_func);
        BasicBlock* int_block = BasicBlock::Create(*context, "extract_int", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "extract_merge", current_func);

        // NULL FIX: Check for NULL first
        builder->CreateCondBr(car_is_null, null_block, check_double);

        // NULL FIX: Extract NULL car and return proper NULL tagged value
        builder->SetInsertPoint(null_block);
        Value* tagged_null = packNullToTaggedValue();
        builder->CreateBr(merge_block);
        BasicBlock* null_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_double);
        builder->CreateCondBr(car_is_double, double_block, check_cons);

        // Extract double car and pack into tagged value
        builder->SetInsertPoint(double_block);
        Value* car_double = builder->CreateCall(getTaggedConsGetDoubleFunc(), {cons_ptr, is_car_flag});
        Value* tagged_double = packDoubleToTaggedValue(car_double);
        builder->CreateBr(merge_block);
        BasicBlock* double_exit = builder->GetInsertBlock();

        builder->SetInsertPoint(check_cons);
        builder->CreateCondBr(car_is_cons, cons_block, check_string);

        builder->SetInsertPoint(cons_block);
        Value* car_cons = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_cons = packPtrToTaggedValue(builder->CreateIntToPtr(car_cons, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        builder->CreateBr(merge_block);
        BasicBlock* cons_exit = builder->GetInsertBlock();

        // SYMBOL FIX: Handle STRING_PTR
        builder->SetInsertPoint(check_string);
        builder->CreateCondBr(car_is_string, string_block, check_lambda);

        builder->SetInsertPoint(string_block);
        Value* car_string = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_string = packPtrToTaggedValue(builder->CreateIntToPtr(car_string, builder->getPtrTy()), ESHKOL_VALUE_STRING_PTR);
        builder->CreateBr(merge_block);
        BasicBlock* string_exit = builder->GetInsertBlock();

        // Handle LAMBDA_SEXPR
        builder->SetInsertPoint(check_lambda);
        builder->CreateCondBr(car_is_lambda, lambda_block, check_closure);

        builder->SetInsertPoint(lambda_block);
        Value* lambda_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_flag});
        Value* lambda_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_flag});
        Value* lambda_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_lambda = packPtrToTaggedValueWithFlags(
            builder->CreateIntToPtr(lambda_ptr, builder->getPtrTy()),
            lambda_type, lambda_flags);
        builder->CreateBr(merge_block);
        BasicBlock* lambda_exit = builder->GetInsertBlock();

        // Handle CLOSURE_PTR
        builder->SetInsertPoint(check_closure);
        builder->CreateCondBr(car_is_closure, closure_block, check_hash);

        builder->SetInsertPoint(closure_block);
        Value* closure_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_flag});
        Value* closure_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_flag});
        Value* closure_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_closure = packPtrToTaggedValueWithFlags(
            builder->CreateIntToPtr(closure_ptr, builder->getPtrTy()),
            closure_type, closure_flags);
        builder->CreateBr(merge_block);
        BasicBlock* closure_exit = builder->GetInsertBlock();

        // HASH_PTR FIX: Handle hash table pointers
        builder->SetInsertPoint(check_hash);
        builder->CreateCondBr(car_is_hash, hash_block, check_vector);

        builder->SetInsertPoint(hash_block);
        Value* car_hash = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_hash = packPtrToTaggedValue(builder->CreateIntToPtr(car_hash, builder->getPtrTy()), ESHKOL_VALUE_HASH_PTR);
        builder->CreateBr(merge_block);
        BasicBlock* hash_exit = builder->GetInsertBlock();

        // VECTOR_PTR FIX: Handle vector pointers
        builder->SetInsertPoint(check_vector);
        builder->CreateCondBr(car_is_vector, vector_block, int_block);

        builder->SetInsertPoint(vector_block);
        Value* car_vector = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_flag});
        Value* tagged_vector = packPtrToTaggedValue(builder->CreateIntToPtr(car_vector, builder->getPtrTy()), ESHKOL_VALUE_VECTOR_PTR);
        builder->CreateBr(merge_block);
        BasicBlock* vector_exit = builder->GetInsertBlock();

        // Extract int64 car and pack into tagged value
        builder->SetInsertPoint(int_block);
        Value* car_int64 = builder->CreateCall(getTaggedConsGetInt64Func(), {cons_ptr, is_car_flag});
        Value* tagged_int64 = packInt64ToTaggedValue(car_int64, true);
        builder->CreateBr(merge_block);
        BasicBlock* int_exit = builder->GetInsertBlock();

        // Merge: return tagged value struct
        builder->SetInsertPoint(merge_block);
        PHINode* car_tagged_phi = builder->CreatePHI(tagged_value_type, 9);
        // NULL FIX: Add null_exit as incoming
        car_tagged_phi->addIncoming(tagged_null, null_exit);
        car_tagged_phi->addIncoming(tagged_double, double_exit);
        car_tagged_phi->addIncoming(tagged_cons, cons_exit);
        car_tagged_phi->addIncoming(tagged_string, string_exit);
        car_tagged_phi->addIncoming(tagged_lambda, lambda_exit);
        car_tagged_phi->addIncoming(tagged_closure, closure_exit);
        car_tagged_phi->addIncoming(tagged_hash, hash_exit);
        car_tagged_phi->addIncoming(tagged_vector, vector_exit);
        car_tagged_phi->addIncoming(tagged_int64, int_exit);

        return car_tagged_phi;
    }

    // ========== HoTT PROOF ERASURE HELPERS ==========
    // Check if a HoTT type should be erased at runtime (proof types have no runtime representation)
    bool shouldEraseType(eshkol::hott::TypeId type_id) {
        // Query the TypeEnvironment to check if this type has RuntimeRep::Erased
        auto rep = ctx_->hottTypes().getRuntimeRep(type_id);
        return rep == eshkol::hott::RuntimeRep::Erased;
    }

    // Create a unit value for erased types (when we need a valid LLVM value but the type is erased)
    // Returns null tagged_value which is our "unit" type
    Value* createErasedPlaceholder() {
        // Create a null tagged_value as a unit placeholder
        // This is for cases where the type system requires a value but the proof is erased
        return tagged_->packNull();
    }

    // Create TypedValue for an erased proof type
    TypedValue makeErasedTypedValue(eshkol::hott::TypeId proof_type) {
        Value* placeholder = createErasedPlaceholder();
        return TypedValue::makeErasedWithPlaceholder(placeholder, proof_type);
    }

    // Robust helper to convert tagged_value to TypedValue with proper runtime type detection
    // This preserves type information through PHI nodes
    TypedValue detectValueType(Value* llvm_val) {
        if (!llvm_val) return TypedValue();
        
        if (llvm_val->getType() == tagged_value_type) {
            // Extract type tag from tagged_value
            Value* type_tag = getTaggedValueType(llvm_val);
            Value* base_type = builder->CreateAnd(type_tag,
                ConstantInt::get(int8_type, 0x0F));
            
            // Check if it's a double
            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
            
            // Branch to unpack the correct type
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* double_block = BasicBlock::Create(*context, "detect_double", current_func);
            BasicBlock* int_block = BasicBlock::Create(*context, "detect_int", current_func);
            BasicBlock* merge_block = BasicBlock::Create(*context, "detect_merge", current_func);
            
            builder->CreateCondBr(is_double, double_block, int_block);
            
            // Unpack as double and create TypedValue
            builder->SetInsertPoint(double_block);
            Value* double_val = unpackDoubleFromTaggedValue(llvm_val);
            // Bitcast to int64 for storage BEFORE branching (must be in same block)
            Value* double_as_int = builder->CreateBitCast(double_val, int64_type);
            builder->CreateBr(merge_block);
            BasicBlock* double_exit = builder->GetInsertBlock();

            // Unpack as int64 and create TypedValue
            builder->SetInsertPoint(int_block);
            Value* int_val = unpackInt64FromTaggedValue(llvm_val);
            builder->CreateBr(merge_block);
            BasicBlock* int_exit = builder->GetInsertBlock();

            // Return TypedValue with int64 value
            // The type will be determined by the cons cell storage
            builder->SetInsertPoint(merge_block);
            // PHI nodes must be at the top of the basic block
            PHINode* value_phi = builder->CreatePHI(int64_type, 2);
            value_phi->addIncoming(double_as_int, double_exit);
            value_phi->addIncoming(int_val, int_exit);

            // Create type PHI to track whether it's int or double
            PHINode* type_phi = builder->CreatePHI(int8_type, 2);
            type_phi->addIncoming(ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE), double_exit);
            type_phi->addIncoming(ConstantInt::get(int8_type, ESHKOL_VALUE_INT64), int_exit);
            
            // Return TypedValue with runtime type - but we can't do this statically
            // For now, assume int64 and let the caller handle conversion
            return TypedValue(value_phi, ESHKOL_VALUE_INT64, true);
        }
        
        Type* val_type = llvm_val->getType();
        if (val_type->isIntegerTy(64)) {
            // CRITICAL FIX: Check if i64 came from PtrToInt (tensor/cons pointers)
            // Distinguish tensor pointers from cons cell pointers using name heuristics
            if (isa<PtrToIntInst>(llvm_val)) {
                PtrToIntInst* ptoi = dyn_cast<PtrToIntInst>(llvm_val);
                if (ptoi) {
                    // Heuristic: tensor operations have specific naming patterns
                    std::string name = ptoi->getName().str();
                    if (name.find("tensor") != std::string::npos ||
                        name.find("vector") != std::string::npos ||
                        name.find("gradient") != std::string::npos ||
                        name.find("jacobian") != std::string::npos ||
                        name.find("hessian") != std::string::npos) {
                        eshkol_debug("detectValueType: i64 from tensor PtrToInt (%s)", name.c_str());
                        return TypedValue(llvm_val, ESHKOL_VALUE_TENSOR_PTR, true);
                    }
                }
                eshkol_debug("detectValueType: i64 from PtrToInt, treating as CONS_PTR");
                return TypedValue(llvm_val, ESHKOL_VALUE_CONS_PTR, true);
            }
            return TypedValue(llvm_val, ESHKOL_VALUE_INT64, true);
        } else if (val_type->isDoubleTy()) {
            return TypedValue(llvm_val, ESHKOL_VALUE_DOUBLE, false);
        } else if (val_type->isPointerTy()) {
            Value* as_int = builder->CreatePtrToInt(llvm_val, int64_type);
            // HOMOICONIC FIX: Check if this is a Function* (lambda)
            if (isa<Function>(llvm_val)) {
                // Return FUNCTION POINTER (for execution) with LAMBDA_SEXPR type (for display lookup)
                // Display code will use var_sexpr alias to find the S-expression
                eshkol_debug("detectValueType: Function* detected, tagging as LAMBDA_SEXPR");
                return TypedValue(as_int, ESHKOL_VALUE_LAMBDA_SEXPR, true);
            }
            return TypedValue(as_int, ESHKOL_VALUE_CONS_PTR, true);
        }
        
        return TypedValue(
            ConstantInt::get(int64_type, 0),
            ESHKOL_VALUE_NULL,
            true
        );
    }
    // Convert TypedValue to tagged_value (AST→IR boundary crossing)
    Value* typedValueToTaggedValue(const TypedValue& tv) {
        // HoTT PROOF ERASURE: If this is a proof type, return null (proofs have no runtime representation)
        if (tv.shouldErase()) {
            eshkol_debug("typedValueToTaggedValue: erasing proof type (HoTT TypeId %u)", tv.hott_type.id);
            return packNullToTaggedValue();
        }

        if (!tv.llvm_value) {
            return packNullToTaggedValue();
        }

        Type* llvm_type = tv.llvm_value->getType();

        // CRITICAL: If already a tagged_value, return as-is (don't double-pack!)
        if (llvm_type == tagged_value_type) {
            return tv.llvm_value;
        }

        // CRITICAL FIX: Check LLVM type for doubles FIRST
        // This handles cases where TypedValue type is mismatched (e.g., loaded from variable)
        if (llvm_type->isDoubleTy()) {
            return packDoubleToTaggedValue(tv.llvm_value);
        }

        // For other types, use TypedValue semantic type
        if (tv.isInt64()) {
            return packInt64ToTaggedValue(tv.llvm_value, tv.is_exact);
        } else if (tv.isDouble()) {
            // Shouldn't reach here (caught above), but handle anyway
            return packDoubleToTaggedValue(tv.llvm_value);
        } else if (tv.type == ESHKOL_VALUE_CHAR) {
            return packCharToTaggedValue(tv.llvm_value);
        } else if (tv.type == ESHKOL_VALUE_CONS_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_CONS_PTR);
        } else if (tv.type == ESHKOL_VALUE_VECTOR_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_VECTOR_PTR);
        } else if (tv.type == ESHKOL_VALUE_TENSOR_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_TENSOR_PTR);
        } else if (tv.type == ESHKOL_VALUE_STRING_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_STRING_PTR);
        } else if (tv.type == ESHKOL_VALUE_AD_NODE_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_AD_NODE_PTR);
        } else if (tv.type == ESHKOL_VALUE_LAMBDA_SEXPR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_LAMBDA_SEXPR, tv.flags);
        } else if (tv.type == ESHKOL_VALUE_BOOL) {
            // BOOL FIX: Handle boolean values for list storage
            return packBoolToTaggedValue(tv.llvm_value);
        } else if (tv.type == ESHKOL_VALUE_CLOSURE_PTR) {
            return packPtrToTaggedValue(tv.llvm_value, ESHKOL_VALUE_CLOSURE_PTR);
        } else if (tv.isNull()) {
            return packNullToTaggedValue();
        }

        // Fallback: null tagged value
        return packNullToTaggedValue();
    }
    
    // Simple helper to wrap tagged_value in TypedValue (for cons cell creation)
    // This avoids complex control flow by just storing the tagged_value as-is
    TypedValue taggedValueToTypedValue(Value* tagged_val) {
        if (!tagged_val || tagged_val->getType() != tagged_value_type) {
            return TypedValue();
        }
        
        // Simply unpack the int64 data field - we'll let runtime type checking handle it
        // This avoids dominance issues from complex branching
        Value* data = unpackInt64FromTaggedValue(tagged_val);
        
        // For cons cell creation, we just need the raw data
        // The type is preserved in the tagged_value itself
        return TypedValue(data, ESHKOL_VALUE_INT64, true);
    }
    
    // ===== POLYMORPHIC ARITHMETIC FUNCTIONS (Phase 1.3 + Phase 2 Dual Number Support) =====
    // These operate on tagged_value parameters and handle mixed types + dual numbers
    
    // MIGRATED: Polymorphic addition - delegates to ArithmeticCodegen
    Value* polymorphicAdd(Value* left_tagged, Value* right_tagged) {
        return arith_->add(left_tagged, right_tagged);
    }
    
    // MIGRATED: Polymorphic subtraction - delegates to ArithmeticCodegen
    Value* polymorphicSub(Value* left_tagged, Value* right_tagged) {
        return arith_->sub(left_tagged, right_tagged);
    }

    // MIGRATED: Polymorphic multiplication - delegates to ArithmeticCodegen
    Value* polymorphicMul(Value* left_tagged, Value* right_tagged) {
        return arith_->mul(left_tagged, right_tagged);
    }

    // MIGRATED: Polymorphic division - delegates to ArithmeticCodegen
    Value* polymorphicDiv(Value* left_tagged, Value* right_tagged) {
        return arith_->div(left_tagged, right_tagged);
    }
    
    // MIGRATED: Polymorphic comparison - delegates to ArithmeticCodegen
    Value* polymorphicCompare(Value* left_tagged, Value* right_tagged,
                             const std::string& operation) {
        return arith_->compare(left_tagged, right_tagged, operation);
    }
    
    
    
    // ===== POLYMORPHIC FUNCTION WRAPPERS (Phase 2.4) =====
    // Create Function* objects that wrap polymorphic arithmetic for use in higher-order functions
    
    Function* polymorphicAdd() {
        std::string func_name = "polymorphic_add_2arg";
        
        // Check if already created
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        // Create function type: (tagged_value, tagged_value) -> tagged_value
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        // Call polymorphic add helper
        Value* result = polymorphicAdd(left, right);
        builder->CreateRet(result);
        
        // Restore insertion point
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicSub() {
        std::string func_name = "polymorphic_sub_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicSub(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicMul() {
        std::string func_name = "polymorphic_mul_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicMul(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    Function* polymorphicDiv() {
        std::string func_name = "polymorphic_div_2arg";
        
        auto it = function_table.find(func_name);
        if (it != function_table.end()) {
            return it->second;
        }
        
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(tagged_value_type, param_types, false);
        
        Function* func = Function::Create(func_type, Function::ExternalLinkage, func_name, module.get());
        
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        BasicBlock* entry = BasicBlock::Create(*context, "entry", func);
        builder->SetInsertPoint(entry);
        
        auto arg_it = func->arg_begin();
        Value* left = &*arg_it++;
        Value* right = &*arg_it;
        
        Value* result = polymorphicDiv(left, right);
        builder->CreateRet(result);
        
        builder->restoreIP(old_point);
        
        function_table[func_name] = func;
        return func;
    }
    
    
    Value* codegenAST(const eshkol_ast_t* ast) {
        if (!ast) return nullptr;

        switch (ast->type) {
            case ESHKOL_INVALID:
                // Invalid AST node - treat as null (empty list, etc.)
                eshkol_debug("codegenAST: ESHKOL_INVALID node, treating as null");
                return packNullToTaggedValue();

            case ESHKOL_UINT8:
            case ESHKOL_UINT16:
            case ESHKOL_UINT32:
            case ESHKOL_UINT64:
                // Handle unsigned integers - type 0 (UINT8) with value 0 often represents null
                if (ast->type == ESHKOL_UINT8 && ast->int64_val == 0) {
                    return packNullToTaggedValue();
                }
                return ConstantInt::get(int64_type, ast->int64_val);

            case ESHKOL_INT8:
            case ESHKOL_INT16:
            case ESHKOL_INT32:
            case ESHKOL_INT64:
                return ConstantInt::get(int64_type, ast->int64_val);
                
            case ESHKOL_DOUBLE:
                return ConstantFP::get(double_type, ast->double_val);
                
            case ESHKOL_STRING: {
                // String literals are packed as tagged values with STRING_PTR type
                Value* str_ptr = codegenString(ast->str_val.ptr);
                return packPtrToTaggedValue(str_ptr, ESHKOL_VALUE_STRING_PTR);
            }
                
            case ESHKOL_VAR:
                return codegenVariable(ast);
                
            case ESHKOL_OP:
                return codegenOperation(&ast->operation);
                
            case ESHKOL_CONS:
                return codegenConsCell(ast);
                
            case ESHKOL_TENSOR:
                return codegenTensor(ast);

            case ESHKOL_CHAR:
                return packCharToTaggedValue(
                    ConstantInt::get(int64_type, ast->int64_val));

            case ESHKOL_BOOL:
                // Boolean literals #t and #f - pack as ESHKOL_VALUE_BOOL
                return packBoolToTaggedValue(
                    ast->int64_val ? ConstantInt::getTrue(*context) : ConstantInt::getFalse(*context));

            case ESHKOL_NULL:
                return packNullToTaggedValue(); // null as properly tagged value

            default:
                eshkol_warn("Unhandled AST node type: %d", ast->type);
                return nullptr;
        }
    }
    
    // MIGRATED: Delegates to StringIOCodegen
    Value* codegenString(const char* str) {
        return strio_->createString(str);
    }

    Value* codegenVariable(const eshkol_ast_t* ast) {
        if (!ast->variable.id) return nullptr;

        std::string var_name = ast->variable.id;

        // TCO FIX: Check symbol_table FIRST for parameters that might be overridden with allocas
        // This is essential for TCO where we need to load from allocas, not use the original arguments
        auto sym_it = symbol_table.find(var_name);
        if (sym_it != symbol_table.end() && sym_it->second) {
            Value* sym_val = sym_it->second;
            // If it's an alloca (TCO parameter), load from it
            if (isa<AllocaInst>(sym_val)) {
                return builder->CreateLoad(tagged_value_type, sym_val, var_name + ".load");
            }
            // If it's a GlobalVariable, load from it
            if (isa<GlobalVariable>(sym_val)) {
                return builder->CreateLoad(tagged_value_type, sym_val, var_name + ".load");
            }
            // MUTABLE CAPTURE FIX: If it's an Argument with pointer type (closure capture storage),
            // load the value from the pointed-to storage
            if (isa<Argument>(sym_val) && sym_val->getType()->isPointerTy()) {
                return builder->CreateLoad(tagged_value_type, sym_val, var_name + ".load");
            }
            // MUTABLE CAPTURE FIX: If it's any other pointer (e.g., IntToPtr result from
            // unpacking an alloca pointer stored in closure env), load from it
            if (sym_val->getType()->isPointerTy()) {
                return builder->CreateLoad(tagged_value_type, sym_val, var_name + ".load");
            }
            // CROSS-FUNCTION ARGUMENT FIX: If sym_val is an Argument, verify it belongs to the current function
            // Stale symbol_table entries from previous function compilations could reference Arguments
            // from other functions, which causes LLVM verification errors
            if (isa<Argument>(sym_val)) {
                Argument* arg = cast<Argument>(sym_val);
                Function* arg_parent = arg->getParent();
                if (current_function && arg_parent != current_function) {
                    // Stale Argument from another function - skip it and fall through to other lookups
                    eshkol_debug("codegenVariable: skipping stale Argument %s from function %s (current: %s)",
                               var_name.c_str(), arg_parent->getName().str().c_str(), current_function->getName().str().c_str());
                    // Fall through to check current_function->args() instead
                } else {
                    // Argument belongs to current function - safe to return
                    return sym_val;
                }
            } else {
                // Otherwise return the value directly
                return sym_val;
            }
        }

        if (current_function) {
            for (auto& arg : current_function->args()) {
                if (arg.getName() == var_name) {
                    return &arg;
                }
            }
            // CLOSURE CAPTURE FIX: Check for captured arguments (prefixed with "captured_")
            // Nested lambdas receive captured variables as arguments with this naming convention
            std::string captured_name = "captured_" + var_name;
            for (auto& arg : current_function->args()) {
                if (arg.getName() == captured_name) {
                    // If it's a pointer type, load the value from the capture storage
                    if (arg.getType()->isPointerTy()) {
                        return builder->CreateLoad(tagged_value_type, &arg, var_name + ".captured");
                    }
                    return &arg;
                }
            }
        }

        // BUILTIN FIRST-CLASS FIX: Check math builtins FIRST before function_table lookup
        // This prevents returning raw C functions (double->double) which cause ABI mismatch
        // when called through closure dispatch (tagged_value->tagged_value)
        static const std::set<std::string> math_builtins = {
            // Exponential/Logarithmic
            "exp", "exp2", "log", "log2", "log10",
            // Trigonometric
            "sin", "cos", "tan", "asin", "acos", "atan",
            // Hyperbolic
            "sinh", "cosh", "tanh", "asinh", "acosh", "atanh",
            // Power/Root
            "sqrt", "cbrt",
            // Absolute/Rounding
            "abs", "fabs", "floor", "ceil", "round", "trunc",
            // Scheme-style names
            "ceiling", "truncate"
        };

        if (math_builtins.count(var_name)) {
            // Use createBuiltinUnaryMathFunction which creates a wrapper with proper ABI
            // (tagged_value -> tagged_value) that internally unpacks, calls C function, repacks
            Function* wrapper_func = createBuiltinUnaryMathFunction(var_name);
            if (wrapper_func) {
                // Create closure for the wrapper function
                Value* func_ptr_int = builder->CreatePtrToInt(wrapper_func, int64_type);
                Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                Value* packed_info = ConstantInt::get(int64_type, 0);  // No captures
                Value* sexpr_ptr = ConstantInt::get(int64_type, 0);
                Value* return_type_info = ConstantInt::get(int64_type, CLOSURE_RETURN_SCALAR);  // Math builtins return scalars
                Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                         {arena_ptr, func_ptr_int, packed_info, sexpr_ptr, return_type_info});
                Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
                return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
            }
        }

        // Check function_table for function names being used as values (first-class functions)
        // NOTE: Math builtins are handled above to avoid returning raw C functions
        auto func_it = function_table.find(var_name);
        if (func_it != function_table.end() && func_it->second) {
            Function* func = func_it->second;

            // FUNCTION-AS-VALUE FIX: Wrap user-defined functions in closures when referenced as values
            // This ensures they can be stored in variables (via set!) and called later
            auto arity_it = function_arity_table.find(var_name);
            if (arity_it != function_arity_table.end()) {
                // User-defined function with known arity - wrap in closure
                uint64_t num_params = arity_it->second;
                Value* func_ptr_int = builder->CreatePtrToInt(func, int64_type);
                Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

                // Pack closure info: no captures, arity in bits 16-31
                // Format: bits 0-15 = num_captures, bits 16-31 = fixed_params, bit 63 = is_variadic
                uint64_t packed_info = 0;  // No captures (bits 0-15 = 0)
                packed_info |= (num_params & 0xFFFF) << 16;  // Arity in bits 16-31
                Value* packed_info_val = ConstantInt::get(int64_type, packed_info);

                // No S-expression for now
                Value* sexpr_ptr = ConstantInt::get(int64_type, 0);

                // Return type unknown for general user functions
                // Pack: bits 0-7 = return_type, bits 8-15 = input_arity
                uint64_t return_type_info_val = CLOSURE_RETURN_UNKNOWN | (num_params << 8);
                Value* return_type_info = ConstantInt::get(int64_type, return_type_info_val);

                Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                         {arena_ptr, func_ptr_int, packed_info_val, sexpr_ptr, return_type_info});
                Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
                eshkol_debug("Wrapped user function '%s' (arity=%llu) in closure for first-class use",
                            var_name.c_str(), (unsigned long long)num_params);
                return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
            }

            // Fallback: return raw function pointer (for C functions, builtins, etc.)
            return func;
        }

        // Handle builtin operators as first-class functions
        // Comparison operators
        if (var_name == "<" || var_name == ">" || var_name == "<=" ||
            var_name == ">=" || var_name == "=") {
            Function* builtin_func = createBuiltinComparisonFunction(var_name);
            if (builtin_func) {
                return builtin_func;
            }
        }

        // Arithmetic operators
        if (var_name == "+" || var_name == "-" || var_name == "*" || var_name == "/") {
            Function* builtin_func = createBuiltinArithmeticFunction(var_name, 2);
            if (builtin_func) {
                return builtin_func;
            }
        }

        // Predicates as first-class functions
        if (var_name == "even?" || var_name == "odd?" || var_name == "zero?" ||
            var_name == "positive?" || var_name == "negative?" || var_name == "null?" ||
            var_name == "pair?") {
            Function* builtin_func = createBuiltinPredicateFunction(var_name);
            if (builtin_func) {
                return builtin_func;
            }
        }

        // NOTE: abs and other unary math functions are now handled at the top of this function
        // with proper closure wrapping (before function_table check)

        // List operations as first-class functions (for fold-right, map, etc.)
        // Note: cadr is handled by stdlib (lib/core/list/compound.esk), not as a builtin
        if (var_name == "cons" || var_name == "car" || var_name == "cdr") {
            // Use resolveLambdaFunction with appropriate arity
            eshkol_ast_t var_ast;
            var_ast.type = ESHKOL_VAR;
            var_ast.variable.id = strdup(var_name.c_str());
            size_t arity = (var_name == "cons") ? 2 : 1;
            Value* builtin_func = resolveLambdaFunction(&var_ast, arity);
            free((void*)var_ast.variable.id);
            if (builtin_func) {
                return builtin_func;
            }
        }

        // Check symbol table
        auto it = symbol_table.find(var_name);
        if (it != symbol_table.end()) {
            Value* var_ptr = it->second;

            // If it's an AllocaInst (local variable), load its value
            if (isa<AllocaInst>(var_ptr)) {
                AllocaInst* alloca = dyn_cast<AllocaInst>(var_ptr);
                return builder->CreateLoad(alloca->getAllocatedType(), var_ptr);
            }
            // If it's a GlobalVariable, load its value
            else if (isa<GlobalVariable>(var_ptr)) {
                GlobalVariable* global = dyn_cast<GlobalVariable>(var_ptr);
                return builder->CreateLoad(global->getValueType(), var_ptr);
            }
            // MUTABLE CAPTURE FIX: If it's an Argument with pointer type (closure capture storage),
            // load the value from the pointed-to storage
            else if (isa<Argument>(var_ptr) && var_ptr->getType()->isPointerTy()) {
                // CROSS-FUNCTION ARGUMENT FIX: Validate Argument belongs to current function
                Argument* arg = cast<Argument>(var_ptr);
                Function* arg_parent = arg->getParent();
                if (current_function && arg_parent != current_function) {
                    // Stale entry from another function - don't use it
                    // Fall through to error handling below
                } else {
                    // This is a closure capture pointer - load the tagged_value from it
                    return builder->CreateLoad(tagged_value_type, var_ptr);
                }
            }
            // Otherwise return as-is (for function arguments with value type, etc.)
            else if (isa<Argument>(var_ptr)) {
                // CROSS-FUNCTION ARGUMENT FIX: Validate Argument belongs to current function
                Argument* arg = cast<Argument>(var_ptr);
                Function* arg_parent = arg->getParent();
                if (current_function && arg_parent != current_function) {
                    // Stale entry from another function - don't use it
                    // Fall through to error handling below
                } else {
                    return var_ptr;
                }
            }
            else {
                return var_ptr;
            }
        }

        // REPL MODE: Check if variable exists in REPL registries
        // Variables from previous REPL evaluations are stored here
        if (g_repl_mode_enabled) {
            // First check if it's a lambda function (stored in g_repl_function_addresses)
            // Don't hold lock while calling tryResolveReplFunction (it acquires its own lock)
            Function* repl_func = tryResolveReplFunction(var_name);
            if (repl_func) {
                // Return the function pointer - display() will handle s-expression lookup
                return repl_func;
            }

            // Then check if it's a regular variable (stored in g_repl_symbol_addresses)
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            auto repl_it = g_repl_symbol_addresses.find(var_name);
            if (repl_it != g_repl_symbol_addresses.end()) {
                // Variable exists in REPL context - create external global declaration
                GlobalVariable* global_var = module->getGlobalVariable(var_name);
                if (!global_var) {
                    // Create external declaration for this global variable
                    // Use tagged_value type to preserve type information across modules
                    global_var = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer for external declaration
                        var_name
                    );
                }

                // Load and return the value
                return builder->CreateLoad(global_var->getValueType(), global_var);
            }
        }

        // NOTE: math_builtins are now handled at the top of this function
        // (before function_table check) with proper closure wrapping

        eshkol_warn("Undefined variable: %s (current_function: %s)", var_name.c_str(),
                   current_function ? current_function->getName().str().c_str() : "null");
        return nullptr;
    }

    Value* codegenOperation(const eshkol_operations_t* op) {
        switch (op->op) {
            case ESHKOL_INVALID_OP:
                // Invalid/empty operation - return null
                return packNullToTaggedValue();

            case ESHKOL_DEFINE_OP:
                return codegenDefine(op);
                
            case ESHKOL_CALL_OP:
                return codegenCall(op);
                
            case ESHKOL_SEQUENCE_OP:
                return codegenSequence(op);
                
            case ESHKOL_EXTERN_OP:
                return codegenExtern(op);

            case ESHKOL_EXTERN_VAR_OP:
                return codegenExternVar(op);

            case ESHKOL_LAMBDA_OP:
                return codegenLambda(op);
                
            case ESHKOL_LET_OP:
                // Handle named let: (let loop ((var init) ...) body)
                // Named let needs special handling that codegenNamedLet provides
                if (op->let_op.name != nullptr) {
                    return codegenNamedLet(op);
                }
                // REFACTOR: Delegate regular let to BindingCodegen
                return binding_->let(op);

            case ESHKOL_LET_STAR_OP:
                // REFACTOR: Delegate to BindingCodegen (let* has sequential semantics)
                return binding_->letStar(op);

            case ESHKOL_LETREC_OP:
                // REFACTOR: Delegate to BindingCodegen (letrec has recursive semantics)
                return binding_->letrec(op);

            case ESHKOL_AND_OP:
                return codegenAnd(op);

            case ESHKOL_OR_OP:
                return codegenOr(op);

            case ESHKOL_COND_OP:
                return codegenCond(op);

            case ESHKOL_CASE_OP:
                return codegenCase(op);

            case ESHKOL_DO_OP:
                return codegenDo(op);

            case ESHKOL_WHEN_OP:
                return codegenWhen(op);

            case ESHKOL_UNLESS_OP:
                return codegenUnless(op);

            case ESHKOL_GUARD_OP:
                return codegenGuard(op);

            case ESHKOL_RAISE_OP:
                return codegenRaise(op);

            case ESHKOL_QUOTE_OP:
                // Quote returns the AST as literal data
                if (op->call_op.num_vars > 0) {
                    return codegenQuotedAST(&op->call_op.variables[0]);
                }
                return packNullToTaggedValue();

            case ESHKOL_SET_OP:
                return codegenSet(op);

            case ESHKOL_DEFINE_TYPE_OP:
                // Type alias definition - compile-time only, no runtime code
                // The type alias is stored in the AST for use by the type checker
                return packNullToTaggedValue();

            case ESHKOL_TENSOR_OP:
                return tensor_->tensorOperation(op);
                
            case ESHKOL_DIFF_OP:
                return codegenDiff(op);
                
            case ESHKOL_DERIVATIVE_OP: {
                // Try autodiff first (handles 2-arg form)
                Value* result = autodiff_->derivative(op);
                if (result) return result;
                // Fall back to local codegen (handles higher-order 1-arg form)
                return codegenDerivative(op);
            }
                
            case ESHKOL_GRADIENT_OP:
                return codegenGradient(op);
                
            case ESHKOL_JACOBIAN_OP:
                return codegenJacobian(op);
                
            case ESHKOL_HESSIAN_OP:
                return codegenHessian(op);
                
            case ESHKOL_DIVERGENCE_OP:
                return codegenDivergence(op);
                
            case ESHKOL_CURL_OP:
                return codegenCurl(op);
                
            case ESHKOL_LAPLACIAN_OP:
                return codegenLaplacian(op);
                
            case ESHKOL_DIRECTIONAL_DERIV_OP:
                return codegenDirectionalDerivative(op);

            // Memory management operations (OALR)
            case ESHKOL_WITH_REGION_OP:
                return codegenWithRegion(op);

            case ESHKOL_OWNED_OP:
                return codegenOwned(op);

            case ESHKOL_MOVE_OP:
                return codegenMove(op);

            case ESHKOL_BORROW_OP:
                return codegenBorrow(op);

            case ESHKOL_SHARED_OP:
                return codegenShared(op);

            case ESHKOL_WEAK_REF_OP:
                return codegenWeakRef(op);

            // Module system operations (compile-time only, no runtime code)
            case ESHKOL_IMPORT_OP:
            case ESHKOL_REQUIRE_OP:
            case ESHKOL_PROVIDE_OP:
                // These are handled at parse/load time, return nil at runtime
                return packNullToTaggedValue();

            // HoTT Type System operations (compile-time only, no runtime code)
            case ESHKOL_TYPE_ANNOTATION_OP:
            case ESHKOL_FORALL_OP:
                // Type annotations are compile-time only - they affect type checking
                // but generate no runtime code (proof erasure)
                return packNullToTaggedValue();

            default:
                eshkol_warn("Unhandled operation type: %d", op->op);
                return nullptr;
        }
    }
    
    Value* codegenDefine(const eshkol_operations_t* op) {
        const char* name = op->define_op.name;
        if (!name) return nullptr;

        if (op->define_op.is_function) {
            return codegenFunctionDefinition(op);
        } else {
            // EXTERNAL VARIABLE FIX: For external variables from pre-compiled modules,
            // just create an external GlobalVariable declaration - don't evaluate/store
            if (op->define_op.is_external) {
                // Create external GlobalVariable declaration if it doesn't exist
                GlobalVariable* gv = module->getNamedGlobal(name);
                if (!gv) {
                    gv = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer (external)
                        name
                    );
                    gv->setAlignment(Align(16));
                    eshkol_debug("External variable declaration: %s", name);
                }
                // Register in symbol tables so lookups find it
                symbol_table[name] = gv;
                global_symbol_table[name] = gv;
                return packNullToTaggedValue();
            }
            // REFACTOR: Use new BindingCodegen for variable definitions
            // This fixes the issue with ports and other tagged values
            return binding_->define(op);
        }
    }

    Value* codegenFunctionDefinition(const eshkol_operations_t* op) {
        const char* func_name = op->define_op.name;
        Function* function = function_table[func_name];

        if (!function) {
            // This is a nested function definition - generate it like a lambda with closure support
            eshkol_debug("Generating nested function %s as closure", func_name);
            return codegenNestedFunctionDefinition(op);
        }

        // Check if this is an external function (body comes from linked .o file)
        if (op->define_op.is_external) {
            eshkol_debug("External function %s - body from linked library, skipping codegen", func_name);
            // The function declaration already exists from createFunctionDeclaration
            // The actual code will be provided by the linked .o file
            return nullptr;
        }

        // Create basic block for function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", function);
        builder->SetInsertPoint(entry);

        // Set current function
        Function* prev_function = current_function;
        current_function = function;
        
        // GLOBAL ARENA FIX: No per-function arena initialization needed
        // All functions share the global arena initialized in main
        
        // Add parameters to symbol table
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;
        auto arg_it = function->arg_begin();
        if (op->define_op.parameters) {
            for (uint64_t i = 0; i < op->define_op.num_params && arg_it != function->arg_end(); ++i, ++arg_it) {
                if (op->define_op.parameters[i].type == ESHKOL_VAR &&
                    op->define_op.parameters[i].variable.id) {
                    symbol_table[op->define_op.parameters[i].variable.id] = &(*arg_it);
                }
            }
        }

        // VARIADIC FIX: Add rest parameter to symbol table
        bool is_variadic = op->define_op.is_variadic && op->define_op.rest_param;
        if (is_variadic && arg_it != function->arg_end()) {
            symbol_table[op->define_op.rest_param] = &(*arg_it);
            eshkol_debug("Function %s uses rest parameter: %s", func_name, op->define_op.rest_param);
        }

        // TCO SETUP: Check if this function is self-tail-recursive
        bool use_tco = false;
        BasicBlock* tco_loop_bb = nullptr;

        bool is_tail_rec = op->define_op.value && isSelfTailRecursive(op, func_name);
        if (is_tail_rec) {
            use_tco = true;
            eshkol_debug("TCO: Enabling tail call optimization for define %s", func_name);

            // Set up TCO context in binding module
            auto& tco_ctx = binding_->getTCOContext();
            tco_ctx.func_name = func_name;
            tco_ctx.enabled = true;
            tco_ctx.param_allocas.clear();
            tco_ctx.param_names.clear();

            // Convert parameters to allocas for mutability
            arg_it = function->arg_begin();
            if (op->define_op.parameters) {
                for (uint64_t i = 0; i < op->define_op.num_params && arg_it != function->arg_end(); ++i, ++arg_it) {
                    if (op->define_op.parameters[i].type == ESHKOL_VAR &&
                        op->define_op.parameters[i].variable.id) {
                        std::string param_name = op->define_op.parameters[i].variable.id;

                        // Create alloca for this parameter
                        AllocaInst* param_alloca = builder->CreateAlloca(
                            tagged_value_type, nullptr, param_name + "_tco");

                        // Store initial argument value
                        builder->CreateStore(&(*arg_it), param_alloca);

                        tco_ctx.param_allocas.push_back(param_alloca);
                        tco_ctx.param_names.push_back(param_name);
                        symbol_table[param_name] = param_alloca;  // Override with alloca
                    }
                }
            }

            // Create loop header block
            tco_loop_bb = BasicBlock::Create(*context, "tco_loop", function);
            tco_ctx.loop_header = tco_loop_bb;

            // Branch to loop header
            builder->CreateBr(tco_loop_bb);
            builder->SetInsertPoint(tco_loop_bb);
        }

        // Generate function body
        Value* body_result = nullptr;
        if (op->define_op.value) {
            body_result = codegenAST(op->define_op.value);
        }

        // Clear TCO context after body generation
        if (use_tco) {
            binding_->getTCOContext().enabled = false;
            binding_->getTCOContext().func_name = "";
            binding_->getTCOContext().loop_header = nullptr;
        }
        eshkol_debug("Function %s body_result: %p", func_name, body_result);

        // TCO FIX: Check if block is already terminated (tail call path)
        BasicBlock* current_bb = builder->GetInsertBlock();
        if (!current_bb) {
            eshkol_error("No insertion block in function %s", func_name);
            return nullptr;
        }

        // If block is already terminated (TCO tail call), skip return generation
        if (current_bb->getTerminator()) {
            // Block was terminated by a tail call jump - this is expected for TCO
            eshkol_debug("Function %s: block already terminated (TCO path)", func_name);
            symbol_table = prev_symbols;
            current_function = prev_function;
            return function;
        }

        // Return the result - pack to tagged_value since functions now return tagged_value
        if (body_result) {
            // If body_result is already a tagged_value, return it directly
            if (body_result->getType() == tagged_value_type) {
                // CLOSURE FIX: Check if this is a closure/lambda and register it
                // The most recently created lambda is the one being returned
                if (!last_generated_lambda_name.empty()) {
                    functions_returning_lambda[func_name] = last_generated_lambda_name;
                    eshkol_debug("Function %s returns closure/lambda %s (tagged value)",
                                func_name, last_generated_lambda_name.c_str());
                }
                builder->CreateRet(body_result);
            }
            // If body_result is a function (lambda), pack as function pointer
            // CRITICAL FIX: Check for null before isa<Function>
            else if (body_result && isa<Function>(body_result)) {
                Function* lambda_func = dyn_cast<Function>(body_result);
                eshkol_debug("Function %s returns lambda %s", func_name, lambda_func->getName().str().c_str());

                // CLOSURE FIX: Register that this function returns a lambda
                functions_returning_lambda[func_name] = lambda_func->getName().str();
                eshkol_debug("Registered %s as returning lambda %s", func_name, lambda_func->getName().str().c_str());

                // Pack function pointer to tagged_value
                Value* func_addr = builder->CreatePtrToInt(lambda_func, int64_type);
                Value* func_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(func_addr, builder->getPtrTy()),
                    ESHKOL_VALUE_LAMBDA_SEXPR);  // CRITICAL: Mark as LAMBDA_SEXPR, not CONS_PTR
                builder->CreateRet(func_tagged);
            }
            // Otherwise, detect type and pack to tagged_value
            else {
                TypedValue typed = detectValueType(body_result);
                Value* tagged = typedValueToTaggedValue(typed);
                builder->CreateRet(tagged);
            }
        } else {
            // Return null tagged value as default
            eshkol_debug("Function %s has no body result, returning null tagged value", func_name);
            Value* null_tagged = packInt64ToTaggedValue(
                ConstantInt::get(int64_type, 0), true);
            builder->CreateRet(null_tagged);
        }

        // CRITICAL FIX (Bug #2): Register function reference for autodiff resolution FIRST
        // Must happen BEFORE symbol_table restoration to ensure it persists
        global_symbol_table[std::string(func_name) + "_func"] = function;
        eshkol_debug("Registered function reference for autodiff in global_symbol_table: %s_func", func_name);

        // Restore previous state - but preserve TOP-LEVEL _func entries added during body execution
        // NESTED FUNCTION SCOPING FIX: Do NOT preserve nested function references (like "helper_func")
        // because they should be local to the outer function. Only preserve:
        // 1. Scoped keys (containing "." like "foo.helper_func") - these are properly scoped
        // 2. Top-level function keys (whose base name is in function_table)
        std::unordered_map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            // Check if this is a _func entry
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {

                // Check if this is a scoped key (contains ".")
                bool is_scoped = entry.first.find('.') != std::string::npos;

                // Check if this is a top-level function (base name in function_table)
                std::string base_name = entry.first.substr(0, entry.first.length() - 5);
                bool is_top_level = function_table.find(base_name) != function_table.end();

                // Only preserve scoped keys or top-level function keys
                if (is_scoped || is_top_level) {
                    func_refs_to_preserve[entry.first] = entry.second;
                    eshkol_debug("Preserving function reference across scope restore: %s (scoped=%d, top_level=%d)",
                                entry.first.c_str(), is_scoped, is_top_level);
                } else {
                    eshkol_debug("NOT preserving nested function reference: %s (would break scoping)",
                                entry.first.c_str());
                }
            }
        }

        symbol_table = prev_symbols;

        // Re-add preserved function references
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
            global_symbol_table[entry.first] = entry.second;  // Also ensure in global
        }
        
        // Add this function's reference as well
        symbol_table[std::string(func_name) + "_func"] = function;
        
        current_function = prev_function;

        // Add named function to pending_lambda_sexprs for S-expression generation and registry
        // This enables homoiconic display: (display double) shows (lambda (x) (* x 2))
        pending_lambda_sexprs.push_back({op, std::string(func_name)});
        lambda_ast_to_name[op] = std::string(func_name);  // MEMOIZATION FIX
        eshkol_debug("Added named function %s to pending_lambda_sexprs for homoiconic display", func_name);

        eshkol_debug("Generated function: %s", func_name);

        return function;
    }

    // Generate a nested function definition as a closure (like a lambda)
    Value* codegenNestedFunctionDefinition(const eshkol_operations_t* op) {
        // Generate unique name for this instance of the nested function
        static int nested_counter = 0;
        std::string orig_name = op->define_op.name;
        std::string func_name = orig_name + "_nested_" + std::to_string(nested_counter++);
        const char* orig_name_cstr = op->define_op.name;

        // Find free variables in the function body
        std::vector<std::string> free_vars;
        findFreeVariables(op->define_op.value, symbol_table,
                          op->define_op.parameters, op->define_op.num_params, free_vars);

        // RECURSIVE FUNCTION FIX: Remove the function's own name from free_vars
        // Recursive calls to the function should not be captured as free variables -
        // the function will be directly called, not passed as a closure capture.
        auto self_it = std::find(free_vars.begin(), free_vars.end(), orig_name);
        if (self_it != free_vars.end()) {
            free_vars.erase(self_it);
        }

        eshkol_debug("Nested function %s found %zu free variables", func_name.c_str(), free_vars.size());
        for (const std::string& var : free_vars) {
            eshkol_debug("  Free variable: %s", var.c_str());
        }

        // Store captured values in global variables (same as lambdas)
        for (const std::string& var_name : free_vars) {
            Value* var_value = nullptr;
            Value* captured_val = nullptr;

            // Try local symbol table first
            auto var_it = symbol_table.find(var_name);
            if (var_it != symbol_table.end() && var_it->second) {
                var_value = var_it->second;

                // Load actual value from storage location
                captured_val = var_value;
                if (isa<AllocaInst>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<AllocaInst>(var_value)->getAllocatedType(), var_value);
                } else if (isa<GlobalVariable>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<GlobalVariable>(var_value)->getValueType(), var_value);
                } else if (isa<Argument>(var_value)) {
                    // NESTED FUNCTION FIX: Check if the Argument belongs to the current function
                    Argument* arg = cast<Argument>(var_value);
                    Function* arg_parent = arg->getParent();
                    Function* current_func = builder->GetInsertBlock()->getParent();

                    if (arg_parent != current_func) {
                        // The Argument is from a different function (e.g., grandparent function)
                        // We need to find it in our function's capture parameters
                        bool found_in_captures = false;
                        for (auto& curr_arg : current_func->args()) {
                            std::string arg_name = curr_arg.getName().str();
                            if (arg_name == "captured_" + var_name) {
                                // Found the capture parameter in current function
                                if (curr_arg.getType()->isPointerTy()) {
                                    captured_val = builder->CreateLoad(tagged_value_type, &curr_arg);
                                } else {
                                    captured_val = &curr_arg;
                                }
                                found_in_captures = true;
                                eshkol_debug("Using current function's capture for %s (instead of outer arg)", var_name.c_str());
                                break;
                            }
                        }
                        if (!found_in_captures) {
                            // Check GlobalVariable captures
                            std::string capture_key = current_func->getName().str() + "_capture_" + var_name;
                            auto cap_it = global_symbol_table.find(capture_key);
                            if (cap_it != global_symbol_table.end() && isa<GlobalVariable>(cap_it->second)) {
                                captured_val = builder->CreateLoad(tagged_value_type, cap_it->second);
                                eshkol_debug("Using GlobalVariable capture for %s", var_name.c_str());
                            } else {
                                eshkol_warn("Cannot capture %s from outer function - not found in current function", var_name.c_str());
                                captured_val = nullptr;
                            }
                        }
                    } else if (var_value->getType()->isPointerTy()) {
                        // This is a pointer to a captured variable
                        captured_val = builder->CreateLoad(tagged_value_type, var_value);
                    } else {
                        // Function parameters are already loaded
                        captured_val = var_value;
                        eshkol_debug("Capturing function parameter: %s", var_name.c_str());
                    }
                }
            }

            if (!captured_val) {
                eshkol_warn("Could not capture variable %s for nested function %s", var_name.c_str(), func_name.c_str());
                continue;
            }

            // NESTED CAPTURE FIX: If the captured variable is already stored in a GlobalVariable
            // (from an outer function's capture), reuse that GlobalVariable instead of creating a new one.
            // This ensures that set! on the inner function modifies the same storage as the outer function.
            GlobalVariable* storage = nullptr;
            if (var_value && isa<GlobalVariable>(var_value)) {
                // The variable is already a GlobalVariable - reuse it directly
                storage = dyn_cast<GlobalVariable>(var_value);
                eshkol_debug("Reusing existing GlobalVariable for capture: %s -> %s",
                            var_name.c_str(), storage->getName().str().c_str());
                // Register in symbol tables under the capture key for lookup
                std::string capture_key = std::string(func_name) + "_capture_" + var_name;
                symbol_table[capture_key] = storage;
                global_symbol_table[capture_key] = storage;
            } else {
                // Ensure value is tagged_value
                if (captured_val->getType() != tagged_value_type) {
                    if (captured_val->getType()->isIntegerTy(64)) {
                        captured_val = packInt64ToTaggedValue(captured_val, true);
                    } else if (captured_val->getType()->isDoubleTy()) {
                        captured_val = packDoubleToTaggedValue(captured_val);
                    } else if (isa<Function>(captured_val)) {
                        Value* func_addr = builder->CreatePtrToInt(captured_val, int64_type);
                        captured_val = packInt64ToTaggedValue(func_addr, true);
                    } else {
                        TypedValue tv = detectValueType(captured_val);
                        captured_val = typedValueToTaggedValue(tv);
                    }
                }

                // Create GlobalVariable for persistent storage
                std::string capture_key = std::string(func_name) + "_capture_" + var_name;
                GlobalValue::LinkageTypes linkage = g_repl_mode_enabled ?
                    GlobalValue::ExternalLinkage : GlobalValue::InternalLinkage;
                storage = new GlobalVariable(
                    *module,
                    tagged_value_type,
                    false, // not constant
                    linkage,
                    UndefValue::get(tagged_value_type),
                    capture_key
                );

                // Store captured value in global variable
                builder->CreateStore(captured_val, storage);

                // Register in symbol tables
                symbol_table[capture_key] = storage;
                global_symbol_table[capture_key] = storage;

                // SIBLING CAPTURE FIX: Also update the original variable name to point to this GlobalVariable
                // This ensures that sibling nested functions (defined later) will see and share
                // the same capture storage, rather than creating their own separate storage.
                symbol_table[var_name] = storage;
                eshkol_debug("Stored capture: %s -> %s", var_name.c_str(), capture_key.c_str());
            }
        }

        // Store capture names for later use
        nested_function_captures[func_name] = free_vars;

        // Create polymorphic function type with extra params for captures
        // MUTABLE CAPTURE FIX: Use pointer type for captures (same as codegenLambda)
        std::vector<Type*> param_types;
        for (uint64_t i = 0; i < op->define_op.num_params; i++) {
            param_types.push_back(tagged_value_type);
        }
        for (size_t i = 0; i < free_vars.size(); i++) {
            param_types.push_back(PointerType::getUnqual(*context));  // Pointer to tagged_value
        }

        FunctionType* func_type = FunctionType::get(
            tagged_value_type,
            param_types,
            false
        );

        Function* nested_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // CRITICAL: Register the function BEFORE compiling body to support recursion
        function_table[func_name] = nested_func;
        nested_function_captures[func_name] = free_vars;

        // NESTED FUNCTION SCOPING FIX: Register under original name with proper scoping
        // to prevent name collisions between nested functions with the same name in
        // different outer functions (e.g., multiple functions with (define (helper ...)))
        std::string orig_func_key = std::string(orig_name) + "_func";

        // Add to local symbol_table for direct calls within this function
        symbol_table[orig_name] = nested_func;
        symbol_table[orig_func_key] = nested_func;

        // Add scoped version to allow lookup from nested lambda bodies
        if (current_function) {
            std::string scoped_key = current_function->getName().str() + "." + orig_func_key;
            symbol_table[scoped_key] = nested_func;
            // Only add scoped key to global, not unscoped (prevents collision)
            global_symbol_table[scoped_key] = nested_func;
            eshkol_debug("Pre-registered nested function %s (scoped: %s) for recursion support",
                        func_name.c_str(), scoped_key.c_str());
        } else {
            // Top-level nested function (shouldn't happen normally, but handle it)
            global_symbol_table[orig_func_key] = nested_func;
            eshkol_debug("Pre-registered top-level nested function %s (original: %s) for recursion support",
                        func_name.c_str(), orig_name.c_str());
        }

        // Set parameter names
        auto arg_it = nested_func->arg_begin();

        // Set names for original parameters
        if (op->define_op.parameters) {
            for (uint64_t i = 0; i < op->define_op.num_params && arg_it != nested_func->arg_end(); ++i, ++arg_it) {
                if (op->define_op.parameters[i].type == ESHKOL_VAR &&
                    op->define_op.parameters[i].variable.id) {
                    arg_it->setName(op->define_op.parameters[i].variable.id);
                }
            }
        }

        // Set names for captured parameters
        for (size_t i = 0; i < free_vars.size() && arg_it != nested_func->arg_end(); ++i, ++arg_it) {
            arg_it->setName("captured_" + free_vars[i]);
        }

        // Create basic block for function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", nested_func);
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        builder->SetInsertPoint(entry);

        // Save and set current function
        Function* prev_function = current_function;
        current_function = nested_func;
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;

        // CRITICAL: Clear symbol table to prevent referencing outer function's arguments
        // We only want the nested function's parameters and captures in scope
        symbol_table.clear();

        // Add global functions back (they should be accessible)
        for (auto& entry : function_table) {
            symbol_table[entry.first] = entry.second;
        }
        // Add global variables back
        for (auto& entry : global_symbol_table) {
            if (isa<GlobalVariable>(entry.second)) {
                symbol_table[entry.first] = entry.second;
            }
        }

        // RECURSIVE NESTED FIX: Re-register the nested function under its original name
        // This was cleared above but is needed for recursive calls to find the function
        symbol_table[orig_name] = nested_func;
        symbol_table[orig_name + "_func"] = nested_func;
        eshkol_debug("RECURSIVE FIX: Re-registered %s and %s_func in symbol_table",
                    orig_name.c_str(), orig_name.c_str());

        // Add parameters to symbol table
        arg_it = nested_func->arg_begin();
        if (op->define_op.parameters) {
            for (uint64_t i = 0; i < op->define_op.num_params && arg_it != nested_func->arg_end(); ++i, ++arg_it) {
                if (op->define_op.parameters[i].type == ESHKOL_VAR &&
                    op->define_op.parameters[i].variable.id) {
                    symbol_table[op->define_op.parameters[i].variable.id] = &(*arg_it);
                }
            }
        }

        // Add captured variables to symbol table
        // CLOSURE MUTATION FIX: Use the GlobalVariable storage directly so set! changes persist
        for (size_t i = 0; i < free_vars.size() && arg_it != nested_func->arg_end(); ++i, ++arg_it) {
            arg_it->setName("captured_" + free_vars[i]);

            // Look up the GlobalVariable storage that was created earlier
            std::string capture_key = std::string(func_name) + "_capture_" + free_vars[i];
            eshkol_debug("Looking for GlobalVariable: %s", capture_key.c_str());

            // Try direct lookup first
            GlobalVariable* capture_storage = module->getGlobalVariable(capture_key);

            // If not found, search by iterating (handles name mangling edge cases)
            if (!capture_storage) {
                for (GlobalVariable& gv : module->globals()) {
                    if (gv.getName().str() == capture_key) {
                        capture_storage = &gv;
                        eshkol_debug("Found global via iteration: %s", capture_key.c_str());
                        break;
                    }
                }
            }

            if (capture_storage) {
                // Use the GlobalVariable directly - this allows set! to modify the shared storage
                symbol_table[free_vars[i]] = capture_storage;
                eshkol_debug("Using global capture storage for %s: %s", free_vars[i].c_str(), capture_key.c_str());
            } else {
                // MUTABLE CAPTURE FIX: Use the passed pointer directly (same as codegenLambda)
                // The argument is a pointer to the capture storage, use it directly
                symbol_table[free_vars[i]] = &(*arg_it);
                eshkol_debug("Using passed pointer for capture %s (global not found)", free_vars[i].c_str());
            }
        }

        // CRITICAL: Add self-reference for recursive calls using original name
        symbol_table[orig_name] = nested_func;
        symbol_table[orig_name + "_func"] = nested_func;

        // Generate function body
        Value* body_result = nullptr;
        if (op->define_op.value) {
            body_result = codegenAST(op->define_op.value);
        }

        // Handle return
        if (body_result) {
            if (body_result->getType() == tagged_value_type) {
                builder->CreateRet(body_result);
            } else if (body_result->getType()->isIntegerTy(64)) {
                builder->CreateRet(packInt64ToTaggedValue(body_result, true));
            } else if (body_result->getType()->isDoubleTy()) {
                builder->CreateRet(packDoubleToTaggedValue(body_result));
            } else if (isa<Function>(body_result)) {
                Value* func_ptr = builder->CreatePtrToInt(body_result, int64_type);
                builder->CreateRet(packInt64ToTaggedValue(func_ptr, true));
            } else {
                TypedValue tv = detectValueType(body_result);
                builder->CreateRet(typedValueToTaggedValue(tv));
            }
        } else {
            builder->CreateRet(packNullToTaggedValue());
        }

        // Restore state
        symbol_table = prev_symbols;
        current_function = prev_function;
        builder->restoreIP(old_point);

        // CLOSURE MUTATION FIX: Update outer scope to use GlobalVariables for captured variables
        // This ensures that both the nested function and outer scope share the same storage
        for (const std::string& var_name : free_vars) {
            std::string capture_key = std::string(func_name) + "_capture_" + var_name;

            // Try direct lookup first
            GlobalVariable* capture_storage = module->getGlobalVariable(capture_key);

            // If not found, search by iterating (handles name mangling edge cases)
            if (!capture_storage) {
                for (GlobalVariable& gv : module->globals()) {
                    if (gv.getName().str() == capture_key) {
                        capture_storage = &gv;
                        break;
                    }
                }
            }

            if (capture_storage) {
                // Update outer scope to use the shared GlobalVariable
                symbol_table[var_name] = capture_storage;
                eshkol_debug("Updated outer scope %s to use global storage %s", var_name.c_str(), capture_key.c_str());
            }
        }

        // Register the function in function_table under the unique name (for closure handling)
        function_table[func_name] = nested_func;
        nested_function_captures[func_name] = free_vars;

        // Also register under original name so it can be referenced in code
        // Note: We register the Function* in symbol_table, not function_table
        // This way each call to the outer function creates a new instance
        symbol_table[orig_name] = nested_func;
        symbol_table[orig_name + "_func"] = nested_func;

        eshkol_debug("Generated nested function: %s (original: %s) with %zu captures",
                    func_name.c_str(), orig_name.c_str(), free_vars.size());

        return nested_func;
    }

    Value* codegenVariableDefinition(const eshkol_operations_t* op) {
        const char* var_name = op->define_op.name;
        Value* value = nullptr;
        eshkol_value_type_t value_type = ESHKOL_VALUE_INT64;  // Default type
        eshkol::hott::TypeId hott_type = eshkol::hott::BuiltinTypes::Value;  // HoTT type tracking
        std::optional<eshkol::hott::ParameterizedType> param_type = std::nullopt;  // HoTT parameterized type

        if (op->define_op.value) {
            // HOMOICONIC FIX: Check if this is a lambda that was pre-generated
            // If so, reuse the pre-generated lambda instead of creating a new one
            // BUT: For lambdas with captures, we MUST regenerate to create the closure
            // SCOPED LAMBDA FIX: Only check pre-generation for TOP-LEVEL defines (current_function == nullptr)
            // For nested defines inside functions, we must always generate a new lambda to avoid
            // incorrectly reusing a lambda from a different function with the same local variable name
            bool use_pregenerated = false;
            if (!current_function &&  // CRITICAL: Only for top-level defines!
                op->define_op.value->type == ESHKOL_OP &&
                op->define_op.value->operation.op == ESHKOL_LAMBDA_OP) {
                std::string func_key = std::string(var_name) + "_func";
                auto it = global_symbol_table.find(func_key);
                if (it != global_symbol_table.end() && isa<Function>(it->second)) {
                    Function* pregenerated = dyn_cast<Function>(it->second);
                    std::string lambda_name = pregenerated->getName().str();
                    // Check if this lambda has captures - if so, we must regenerate to create the closure
                    auto captures_it = nested_function_captures.find(lambda_name);
                    bool has_captures = captures_it != nested_function_captures.end() && !captures_it->second.empty();
                    if (has_captures) {
                        eshkol_debug("Lambda %s has captures, will regenerate to create closure", lambda_name.c_str());
                        use_pregenerated = false;
                    } else {
                        value = builder->CreatePtrToInt(pregenerated, int64_type);
                        value_type = ESHKOL_VALUE_LAMBDA_SEXPR;
                        hott_type = eshkol::hott::BuiltinTypes::Function;  // Lambda is a function
                        use_pregenerated = true;
                        eshkol_debug("Reusing pre-generated lambda %s for %s (no captures)",
                                    lambda_name.c_str(), var_name);
                    }
                }
            }

            if (!use_pregenerated) {
                // CRITICAL FIX: Use codegenTypedAST to preserve type information for lists
                TypedValue typed = codegenTypedAST(op->define_op.value);
                value = typed.llvm_value;
                value_type = typed.type;
                hott_type = typed.hott_type;  // Capture HoTT type from expression
                param_type = typed.param_type;  // Capture parameterized type (List<T>, Vector<T>)
            }

            // DEFINE LIST FIX: Explicitly check if this is a list operation and force CONS_PTR type
            // This handles cases where codegenTypedAST doesn't correctly identify the type
            eshkol_debug("codegenVariableDefinition: var=%s, value_type=%d, ast_type=%d",
                        var_name, (int)value_type, (int)op->define_op.value->type);
            if (op->define_op.value->type == ESHKOL_OP) {
                eshkol_debug("  op_type=%d", (int)op->define_op.value->operation.op);
                if (op->define_op.value->operation.op == ESHKOL_CALL_OP &&
                    op->define_op.value->operation.call_op.func &&
                    op->define_op.value->operation.call_op.func->type == ESHKOL_VAR &&
                    op->define_op.value->operation.call_op.func->variable.id) {
                    std::string func_name = op->define_op.value->operation.call_op.func->variable.id;
                    eshkol_debug("  func_name=%s", func_name.c_str());
                    if (func_name == "list" || func_name == "cons" || func_name == "append" ||
                        func_name == "reverse" || func_name == "map" || func_name == "filter" ||
                        func_name == "take" || func_name == "drop" || func_name == "range" ||
                        func_name == "zip" || func_name == "cdr" || func_name == "make-list") {
                        // Force CONS_PTR type for list operations (unless result is null)
                        eshkol_debug("  FORCING CONS_PTR type");
                        if (value && !isa<ConstantInt>(value)) {
                            value_type = ESHKOL_VALUE_CONS_PTR;
                        } else if (auto* ci = dyn_cast<ConstantInt>(value)) {
                            if (ci->isZero()) {
                                value_type = ESHKOL_VALUE_NULL;
                            } else {
                                value_type = ESHKOL_VALUE_CONS_PTR;
                            }
                        }
                    }
                }
            }
        }

        if (!value) return nullptr;

        IRBuilderBase::InsertPoint old_point;
        bool had_insertion_point = builder->GetInsertBlock() != nullptr;
        if (had_insertion_point) {
            old_point = builder->saveIP();
        }

        if (current_function) {
            // CRITICAL FIX: Check if we're in __global_init temp function OR REPL mode
            // If so, use GlobalVariable instead of AllocaInst so definitions survive function execution!
            bool is_global_init = (current_function->getName() == "__global_init");
            bool is_repl_eval = g_repl_mode_enabled;  // In REPL mode, always use globals

            // For functions (lambdas), store as int64 pointer
            Type* storage_type = value->getType();
            // CRITICAL FIX: Check for null before isa<Function> to avoid assertion
            if (value && isa<Function>(value)) {
                Function* func = dyn_cast<Function>(value);
                storage_type = int64_type;

                // Store direct function reference for lambda resolution
                // NESTED FUNCTION SCOPING FIX: For nested defines (current_function set),
                // only add unscoped key to local symbol_table, NOT global_symbol_table.
                // Adding unscoped keys to global_symbol_table would cause name collisions
                // when multiple functions have same-named nested helpers (e.g., "helper").
                std::string func_key = std::string(var_name) + "_func";
                symbol_table[func_key] = func;

                if (current_function) {
                    // Nested define: add scoped key to both tables, but NOT unscoped to global
                    std::string scoped_key = current_function->getName().str() + "." + func_key;
                    symbol_table[scoped_key] = func;
                    global_symbol_table[scoped_key] = func;
                    eshkol_debug("Stored SCOPED lambda function reference: %s -> %s (nested)",
                                scoped_key.c_str(), func->getName().str().c_str());
                } else {
                    // Top-level define: add unscoped key to global_symbol_table
                    global_symbol_table[func_key] = func;
                    eshkol_debug("Stored lambda function reference: %s -> %s (top-level)",
                                func_key.c_str(), func->getName().str().c_str());
                }

                // OPTION 3: Create S-expression alias GlobalVariable for this variable
                // This allows display(square) to find S-expression via module->getNamedGlobal()
                std::string lambda_name = func->getName().str();
                std::string lambda_sexpr_key = lambda_name + "_sexpr";
                std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                // Check if lambda S-expression global exists
                GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                if (lambda_sexpr_global) {
                    // Create alias global that points to the same S-expression
                    GlobalVariable* var_sexpr_global = new GlobalVariable(
                        *module, int64_type, false,
                        GlobalValue::ExternalLinkage,
                        ConstantInt::get(int64_type, 0),  // Initialize to 0, will be set at runtime
                        var_sexpr_key
                    );

                    // Store a reference to lambda S-expression in the alias
                    // This must be done at runtime in main, not here
                    global_symbol_table[var_sexpr_key] = var_sexpr_global;
                    eshkol_debug("Created S-expression alias global: %s for %s",
                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                }

                value = builder->CreatePtrToInt(func, storage_type);
            }
            // HOMOICONIC FIX: Handle LAMBDA_SEXPR type (value is PtrToInt of Function*)
            // We need to find the corresponding lambda function to create the var_sexpr alias
            else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                Function* matching_lambda = nullptr;

                // Try to recover the original Function* from the PtrToInt instruction
                if (PtrToIntInst* ptoi = dyn_cast<PtrToIntInst>(value)) {
                    Value* ptr_operand = ptoi->getPointerOperand();
                    if (Function* func = dyn_cast<Function>(ptr_operand)) {
                        matching_lambda = func;
                        eshkol_debug("Recovered Function* %s from PtrToIntInst", func->getName().str().c_str());
                    }
                }
                // Handle CallInst (function call results that return lambdas)
                if (!matching_lambda) {
                    if (CallInst* call = dyn_cast<CallInst>(value)) {
                        Function* called_func = call->getCalledFunction();
                        if (called_func) {
                            std::string called_name = called_func->getName().str();
                            if (isLambdaName(called_name)) {
                                // Find the inner lambda this function returns
                                std::string num_str = called_name.substr(7);
                                try {
                                    int called_num = std::stoi(num_str);
                                    std::string inner_name = "lambda_" + std::to_string(called_num + 1);
                                    auto inner_it = function_table.find(inner_name);
                                    if (inner_it != function_table.end()) {
                                        matching_lambda = inner_it->second;
                                        eshkol_debug("Found inner lambda %s for CallInst to %s",
                                                    inner_name.c_str(), called_name.c_str());
                                    }
                                } catch (...) {}
                            }
                        }
                    }
                }
                // Also handle ConstantExpr (used for global function pointers)
                if (!matching_lambda) {
                    if (ConstantExpr* ce = dyn_cast<ConstantExpr>(value)) {
                        if (ce->getOpcode() == Instruction::PtrToInt) {
                            Value* ptr_operand = ce->getOperand(0);
                            if (Function* func = dyn_cast<Function>(ptr_operand)) {
                                matching_lambda = func;
                                eshkol_debug("Recovered Function* %s from ConstantExpr", func->getName().str().c_str());
                            }
                        }
                    }
                }

                // Fallback: find the most recent lambda or nested function (for returned functions)
                if (!matching_lambda) {
                    int highest_lambda_num = -1;
                    int highest_nested_num = -1;
                    Function* highest_nested_func = nullptr;
                    for (auto& func_entry : function_table) {
                        if (isLambdaName(func_entry.first)) {
                            std::string num_str = func_entry.first.substr(7);
                            try {
                                int lambda_num = std::stoi(num_str);
                                if (lambda_num > highest_lambda_num) {
                                    highest_lambda_num = lambda_num;
                                    matching_lambda = func_entry.second;
                                }
                            } catch (...) {}
                        }
                        // Also check for nested functions (format: name_nested_N)
                        size_t nested_pos = func_entry.first.find("_nested_");
                        if (nested_pos != std::string::npos) {
                            std::string num_str = func_entry.first.substr(nested_pos + 8);
                            try {
                                int nested_num = std::stoi(num_str);
                                if (nested_num > highest_nested_num) {
                                    highest_nested_num = nested_num;
                                    highest_nested_func = func_entry.second;
                                }
                            } catch (...) {}
                        }
                    }
                    // Prefer most recent nested function if its number is higher
                    if (highest_nested_func && highest_nested_num > highest_lambda_num) {
                        matching_lambda = highest_nested_func;
                        eshkol_debug("Using nested function as matching lambda: %s",
                                    highest_nested_func->getName().str().c_str());
                    }
                }

                if (matching_lambda) {
                    std::string lambda_name = matching_lambda->getName().str();
                    std::string lambda_sexpr_key = lambda_name + "_sexpr";
                    std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                    // Store function reference for lambda resolution
                    // NESTED FUNCTION SCOPING FIX: Same fix as above - only add unscoped
                    // to global_symbol_table for top-level defines
                    std::string func_key = std::string(var_name) + "_func";
                    symbol_table[func_key] = matching_lambda;

                    if (current_function) {
                        // Nested define: add scoped key to both tables, but NOT unscoped to global
                        std::string scoped_key = current_function->getName().str() + "." + func_key;
                        symbol_table[scoped_key] = matching_lambda;
                        global_symbol_table[scoped_key] = matching_lambda;
                        eshkol_debug("Stored SCOPED lambda function reference: %s -> %s (nested, LAMBDA_SEXPR)",
                                    scoped_key.c_str(), lambda_name.c_str());
                    } else {
                        // Top-level define: add unscoped key to global_symbol_table
                        global_symbol_table[func_key] = matching_lambda;
                        eshkol_debug("Stored lambda function reference: %s -> %s (top-level, LAMBDA_SEXPR)",
                                    func_key.c_str(), lambda_name.c_str());
                    }

                    // Create S-expression alias and copy the value at runtime
                    GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                    if (lambda_sexpr_global) {
                        // NOTE: getNamedGlobal returns GlobalVariable* directly, no dyn_cast needed
                        GlobalVariable* var_sexpr_global = module->getNamedGlobal(var_sexpr_key);
                        if (!var_sexpr_global) {
                            var_sexpr_global = new GlobalVariable(
                                *module, int64_type, false,
                                GlobalValue::ExternalLinkage,
                                ConstantInt::get(int64_type, 0),
                                var_sexpr_key
                            );
                            global_symbol_table[var_sexpr_key] = var_sexpr_global;
                        }
                        // Generate code to copy lambda_sexpr to var_sexpr at runtime
                        Value* sexpr_value = builder->CreateLoad(int64_type, lambda_sexpr_global);
                        builder->CreateStore(sexpr_value, var_sexpr_global);
                        eshkol_debug("Created S-expression alias (from LAMBDA_SEXPR): %s -> %s",
                                    var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                    }
                }
            }
            // CLOSURE_PTR FIX: Handle CLOSURE_PTR type (value is a closure from a function call)
            // We need to find the underlying lambda function to register var_name_func
            else if (value_type == ESHKOL_VALUE_CLOSURE_PTR) {
                Function* matching_lambda = nullptr;

                // Handle CallInst (function call results that return closures)
                if (CallInst* call = dyn_cast<CallInst>(value)) {
                    Function* called_func = call->getCalledFunction();
                    if (called_func) {
                        std::string called_name = called_func->getName().str();
                        // Check if this function is registered as returning a lambda
                        auto ret_it = functions_returning_lambda.find(called_name);
                        if (ret_it != functions_returning_lambda.end()) {
                            std::string lambda_name = ret_it->second;
                            auto func_it = function_table.find(lambda_name);
                            if (func_it != function_table.end()) {
                                matching_lambda = func_it->second;
                                eshkol_debug("Found returned lambda %s for closure from %s",
                                            lambda_name.c_str(), called_name.c_str());
                            }
                        }
                    }
                }

                // GRADIENT FIX: Use last_generated_lambda_name for inline lambdas
                // This handles (define f (lambda ...)) inside a function where
                // the lambda was just generated and is tracked via last_generated_lambda_name
                if (!matching_lambda && !last_generated_lambda_name.empty()) {
                    auto func_it = function_table.find(last_generated_lambda_name);
                    if (func_it != function_table.end()) {
                        matching_lambda = func_it->second;
                        eshkol_debug("CLOSURE_PTR: matched %s_func to %s via last_generated_lambda_name",
                                   var_name, last_generated_lambda_name.c_str());
                    }
                }

                // Fallback: find the most recent lambda with captures
                if (!matching_lambda) {
                    int highest_lambda_num = -1;
                    for (auto& func_entry : function_table) {
                        if (isLambdaName(func_entry.first)) {
                            // Check if this lambda has captures
                            auto capture_it = nested_function_captures.find(func_entry.first);
                            if (capture_it != nested_function_captures.end() && !capture_it->second.empty()) {
                                std::string num_str = func_entry.first.substr(7);
                                try {
                                    int lambda_num = std::stoi(num_str);
                                    if (lambda_num > highest_lambda_num) {
                                        highest_lambda_num = lambda_num;
                                        matching_lambda = func_entry.second;
                                    }
                                } catch (...) {}
                            }
                        }
                    }
                }

                if (matching_lambda) {
                    std::string lambda_name = matching_lambda->getName().str();
                    // Store function reference for closure resolution
                    // NESTED FUNCTION SCOPING FIX: Same fix as above
                    std::string func_key = std::string(var_name) + "_func";
                    symbol_table[func_key] = matching_lambda;

                    if (current_function) {
                        // Nested define: add scoped key to both tables, but NOT unscoped to global
                        std::string scoped_key = current_function->getName().str() + "." + func_key;
                        symbol_table[scoped_key] = matching_lambda;
                        global_symbol_table[scoped_key] = matching_lambda;
                        eshkol_debug("Stored SCOPED closure function reference: %s -> %s (nested, CLOSURE_PTR)",
                                    scoped_key.c_str(), lambda_name.c_str());
                    } else {
                        // Top-level define: add unscoped key to global_symbol_table
                        global_symbol_table[func_key] = matching_lambda;
                        eshkol_debug("Stored closure function reference: %s -> %s (top-level, CLOSURE_PTR)",
                                    func_key.c_str(), lambda_name.c_str());
                    }
                }
            }
            if (is_global_init || is_repl_eval) {
                // In __global_init or REPL eval: create GlobalVariable so it survives function execution

                // REPL MODE FIX: Always use tagged_value type for cross-module compatibility
                // This ensures external declarations in other modules can load the correct type
                Value* store_value = value;
                Type* actual_storage_type = storage_type;
                Constant* const_init = nullptr;

                // Pack to tagged_value when:
                // 1. REPL mode (always), OR
                // 2. Global init mode with CONS_PTR, LAMBDA_SEXPR, TENSOR_PTR, or BOOL types
                bool needs_tagged_packing = is_repl_eval ||
                    (is_global_init && (value_type == ESHKOL_VALUE_CONS_PTR ||
                                        value_type == ESHKOL_VALUE_LAMBDA_SEXPR ||
                                        value_type == ESHKOL_VALUE_TENSOR_PTR ||
                                        value_type == ESHKOL_VALUE_BOOL));
                if (needs_tagged_packing && storage_type != tagged_value_type) {
                    actual_storage_type = tagged_value_type;

                    // Try to create constant tagged_value for constant inputs
                    // Struct layout: {i8 type, i8 flags, i16 reserved, i64 data}
                    if (auto* const_fp = dyn_cast<ConstantFP>(value)) {
                        // Create constant tagged_value struct for double
                        double dval = const_fp->getValueAPF().convertToDouble();
                        uint64_t bits;
                        memcpy(&bits, &dval, sizeof(double));
                        Constant* type_const = ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE);
                        Constant* flags_const = ConstantInt::get(int8_type, 0);
                        Constant* reserved_const = ConstantInt::get(int16_type, 0);
                        Constant* data_const = ConstantInt::get(int64_type, bits);
                        const_init = ConstantStruct::get(
                            dyn_cast<StructType>(tagged_value_type),
                            {type_const, flags_const, reserved_const, data_const});
                        store_value = const_init;
                    } else if (auto* const_int = dyn_cast<ConstantInt>(value)) {
                        // BOOL FIX: Check value_type to properly pack booleans
                        Constant* type_const;
                        Constant* flags_const;
                        int64_t ival;
                        if (value_type == ESHKOL_VALUE_BOOL) {
                            // Create constant tagged_value struct for bool
                            // Use getZExtValue() for booleans to get 0 or 1 (not -1 from sign extension)
                            ival = const_int->getZExtValue();
                            type_const = ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL);
                            flags_const = ConstantInt::get(int8_type, 0);
                        } else {
                            // Create constant tagged_value struct for int64
                            ival = const_int->getSExtValue();
                            type_const = ConstantInt::get(int8_type, ESHKOL_VALUE_INT64);
                            flags_const = ConstantInt::get(int8_type, ESHKOL_VALUE_EXACT_FLAG);
                        }
                        Constant* reserved_const = ConstantInt::get(int16_type, 0);
                        Constant* data_const = ConstantInt::get(int64_type, ival);
                        const_init = ConstantStruct::get(
                            dyn_cast<StructType>(tagged_value_type),
                            {type_const, flags_const, reserved_const, data_const});
                        store_value = const_init;
                    } else {
                        // Non-constant: pack at runtime with correct type
                        if (storage_type->isDoubleTy()) {
                            store_value = packDoubleToTaggedValue(value);
                        } else if (storage_type->isIntegerTy(1) && value_type == ESHKOL_VALUE_BOOL) {
                            // BOOL FIX: Handle boolean i1 values
                            store_value = packBoolToTaggedValue(value);
                        } else if (storage_type->isIntegerTy(64)) {
                            // CRITICAL FIX: Check value_type to properly tag list/cons pointers
                            if (value_type == ESHKOL_VALUE_CONS_PTR) {
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_CONS_PTR);
                            } else if (value_type == ESHKOL_VALUE_TENSOR_PTR) {
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_TENSOR_PTR);
                            } else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                                // HOMOICONIC FIX: Preserve lambda S-expression type
                                store_value = packPtrToTaggedValue(
                                    builder->CreateIntToPtr(value, builder->getPtrTy()),
                                    ESHKOL_VALUE_LAMBDA_SEXPR);
                            } else {
                                store_value = packInt64ToTaggedValue(value, true);
                            }
                        }
                    }
                }

                Constant* init_value = dyn_cast<Constant>(store_value);

                // FIX: For non-constant values, use UndefValue as initializer and store at runtime
                // This works for both __global_init and REPL mode because GlobalVariable persists
                // beyond function scope, unlike AllocaInst which is destroyed when function returns
                {
                    if (!init_value) {
                        // REPL mode: Use UndefValue, will store at runtime
                        init_value = UndefValue::get(actual_storage_type);
                    }

                    // Check if GlobalVariable was pre-declared (for forward references from functions)
                    GlobalVariable* global_var = module->getNamedGlobal(var_name);
                    if (global_var) {
                        // Use existing pre-declared global variable
                        eshkol_debug("Using pre-declared GlobalVariable for %s", var_name);
                    } else {
                        // Use WeakAnyLinkage for REPL variables to allow cross-module access
                        GlobalValue::LinkageTypes linkage = is_repl_eval
                            ? GlobalValue::WeakAnyLinkage
                            : GlobalValue::InternalLinkage;

                        global_var = new GlobalVariable(
                            *module,
                            actual_storage_type,
                            false, // not constant
                            linkage,
                            init_value,
                            var_name
                        );
                        eshkol_debug("Created new GlobalVariable for %s in %s", var_name,
                                    is_repl_eval ? "REPL mode" : "__global_init");
                    }

                    // Store actual value (always do this to initialize the global)
                    builder->CreateStore(store_value, global_var);

                    symbol_table[var_name] = global_var;
                    global_symbol_table[var_name] = global_var;
                    // HoTT TYPE TRACKING: Store the compile-time type
                    symbol_hott_types[var_name] = hott_type;
                    global_symbol_hott_types[var_name] = hott_type;
                    // HoTT PARAMETERIZED TYPE: Store element type for List<T>, Vector<T>
                    if (param_type.has_value()) {
                        symbol_param_types[var_name] = *param_type;
                        global_symbol_param_types[var_name] = *param_type;
                    }

                    // HOMOICONIC FIX: Handle returned lambdas (value is tagged_value or not a Function*)
                    // Find the most recently created lambda or nested function and create S-expression alias
                    // This allows (display add5) to work after (define add5 (make-adder 5))
                    eshkol_debug("Checking returned lambda handling for %s: value_type=%d, is_tagged=%d, is_i64=%d",
                                var_name, value_type, value->getType() == tagged_value_type, storage_type->isIntegerTy(64));
                    if (value_type != ESHKOL_VALUE_LAMBDA_SEXPR &&
                        (value->getType() == tagged_value_type || storage_type->isIntegerTy(64))) {
                        Function* matching_lambda = nullptr;
                        int highest_lambda_num = -1;
                        int highest_nested_num = -1;
                        Function* highest_nested_func = nullptr;

                        for (auto& func_entry : function_table) {
                            if (isLambdaName(func_entry.first)) {
                                std::string num_str = func_entry.first.substr(7);
                                try {
                                    int lambda_num = std::stoi(num_str);
                                    if (lambda_num > highest_lambda_num) {
                                        highest_lambda_num = lambda_num;
                                        matching_lambda = func_entry.second;
                                    }
                                } catch (...) {}
                            }
                            // Also check for nested functions (format: name_nested_N)
                            size_t nested_pos = func_entry.first.find("_nested_");
                            if (nested_pos != std::string::npos) {
                                std::string num_str = func_entry.first.substr(nested_pos + 8);
                                try {
                                    int nested_num = std::stoi(num_str);
                                    if (nested_num > highest_nested_num) {
                                        highest_nested_num = nested_num;
                                        highest_nested_func = func_entry.second;
                                    }
                                } catch (...) {}
                            }
                        }

                        // Prefer most recent nested function if its number is higher
                        if (highest_nested_func && highest_nested_num > highest_lambda_num) {
                            matching_lambda = highest_nested_func;
                        }

                        if (matching_lambda) {
                            std::string lambda_name = matching_lambda->getName().str();
                            std::string lambda_sexpr_key = lambda_name + "_sexpr";
                            std::string var_sexpr_key = std::string(var_name) + "_sexpr";

                            // Store function reference
                            // NOTE: This is in global init, so adding to global_symbol_table is OK
                            std::string func_key_v = std::string(var_name) + "_func";
                            symbol_table[func_key_v] = matching_lambda;
                            global_symbol_table[func_key_v] = matching_lambda;

                            // Create S-expression alias if not already exists
                            if (!module->getNamedGlobal(var_sexpr_key)) {
                                GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                                if (lambda_sexpr_global) {
                                    GlobalVariable* var_sexpr_global = new GlobalVariable(
                                        *module, int64_type, false,
                                        GlobalValue::ExternalLinkage,
                                        ConstantInt::get(int64_type, 0),
                                        var_sexpr_key
                                    );
                                    global_symbol_table[var_sexpr_key] = var_sexpr_global;
                                    eshkol_debug("Created S-expression alias for returned lambda: %s -> %s",
                                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                                }
                            }
                        }
                    }
                }
            } else {
                // Normal function context
                // CRITICAL FIX: Check if there's a pre-declared GlobalVariable for this name
                // If so, store to that instead of creating an AllocaInst
                GlobalVariable* pre_declared_global = module->getNamedGlobal(var_name);
                if (pre_declared_global) {
                    // Store to the pre-declared global variable
                    Value* store_value = value;
                    if (store_value->getType() != tagged_value_type) {
                        // Pack value into tagged_value format
                        // CRITICAL FIX: Check value_type FIRST before raw LLVM type checks!
                        // List pointers are i64, so we must check CONS_PTR before isIntegerTy
                        if (value_type == ESHKOL_VALUE_CONS_PTR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_CONS_PTR);
                        } else if (value_type == ESHKOL_VALUE_TENSOR_PTR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_TENSOR_PTR);
                        } else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_LAMBDA_SEXPR);
                        } else if (value_type == ESHKOL_VALUE_BOOL) {
                            // BOOL FIX: Handle boolean values
                            store_value = packBoolToTaggedValue(value);
                        } else if (value->getType()->isIntegerTy(64)) {
                            store_value = packInt64ToTaggedValue(value, true);
                        } else if (value->getType()->isDoubleTy()) {
                            store_value = packDoubleToTaggedValue(value);
                        } else {
                            // For other types, try to pack as pointer (fallback)
                            TypedValue tv = detectValueType(value);
                            store_value = typedValueToTaggedValue(tv);
                        }
                    }
                    builder->CreateStore(store_value, pre_declared_global);
                    symbol_table[var_name] = pre_declared_global;
                    global_symbol_table[var_name] = pre_declared_global;
                    eshkol_debug("Stored value to pre-declared global: %s", var_name);
                } else {
                    // No pre-declared global, use AllocaInst
                    // HOMOICONIC FIX: Pack CONS_PTR, LAMBDA_SEXPR, TENSOR_PTR in tagged_value to preserve type
                    Value* store_value = value;
                    Type* actual_storage_type = storage_type;
                    if ((value_type == ESHKOL_VALUE_CONS_PTR ||
                         value_type == ESHKOL_VALUE_LAMBDA_SEXPR ||
                         value_type == ESHKOL_VALUE_TENSOR_PTR) &&
                        storage_type != tagged_value_type) {
                        actual_storage_type = tagged_value_type;
                        if (value_type == ESHKOL_VALUE_CONS_PTR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_CONS_PTR);
                        } else if (value_type == ESHKOL_VALUE_TENSOR_PTR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_TENSOR_PTR);
                        } else if (value_type == ESHKOL_VALUE_LAMBDA_SEXPR) {
                            store_value = packPtrToTaggedValue(
                                builder->CreateIntToPtr(value, builder->getPtrTy()),
                                ESHKOL_VALUE_LAMBDA_SEXPR);
                        }
                    }
                    AllocaInst* variable = builder->CreateAlloca(
                        actual_storage_type,
                        nullptr,
                        var_name
                    );
                    // Fix alignment mismatch: explicitly set proper alignment for i64
                    if (actual_storage_type->isIntegerTy(64)) {
                        variable->setAlignment(Align(8)); // Explicit 8-byte alignment for i64
                    }
                    builder->CreateStore(store_value, variable);
                    symbol_table[var_name] = variable;
                    // HoTT TYPE TRACKING: Store the compile-time type
                    symbol_hott_types[var_name] = hott_type;
                    // HoTT PARAMETERIZED TYPE: Store element type for List<T>, Vector<T>
                    if (param_type.has_value()) {
                        symbol_param_types[var_name] = *param_type;
                    }
                }

                // HOMOICONIC FIX: For returned lambdas/closures in function context, find the matching lambda
                // and create var_func reference so the alias code in main can find it
                // BUT ONLY if _func isn't already set (don't overwrite correct values from LAMBDA_SEXPR branch)
                // CRITICAL: Handle both LAMBDA_SEXPR and CLOSURE_PTR types
                if ((value_type == ESHKOL_VALUE_LAMBDA_SEXPR || value_type == ESHKOL_VALUE_CLOSURE_PTR) &&
                    symbol_table.find(std::string(var_name) + "_func") == symbol_table.end()) {
                    // Find the most recently created lambda or nested function (heuristic for returned functions)
                    Function* matching_lambda = nullptr;
                    int highest_lambda_num = -1;
                    int highest_nested_num = -1;
                    Function* highest_nested_func = nullptr;
                    for (auto& func_entry : function_table) {
                        if (isLambdaName(func_entry.first)) {
                            std::string num_str = func_entry.first.substr(7);
                            try {
                                int lambda_num = std::stoi(num_str);
                                if (lambda_num > highest_lambda_num) {
                                    highest_lambda_num = lambda_num;
                                    matching_lambda = func_entry.second;
                                }
                            } catch (...) {}
                        }
                        // Also check for nested functions (format: name_nested_N)
                        size_t nested_pos = func_entry.first.find("_nested_");
                        if (nested_pos != std::string::npos) {
                            std::string num_str = func_entry.first.substr(nested_pos + 8);
                            try {
                                int nested_num = std::stoi(num_str);
                                if (nested_num > highest_nested_num) {
                                    highest_nested_num = nested_num;
                                    highest_nested_func = func_entry.second;
                                }
                            } catch (...) {}
                        }
                    }
                    // Prefer most recent nested function if its number is higher
                    if (highest_nested_func && highest_nested_num > highest_lambda_num) {
                        matching_lambda = highest_nested_func;
                    }
                    if (matching_lambda) {
                        // NESTED FUNCTION SCOPING FIX: Same fix for function context
                        std::string func_key_fc = std::string(var_name) + "_func";
                        symbol_table[func_key_fc] = matching_lambda;
                        if (current_function) {
                            std::string scoped_key = current_function->getName().str() + "." + func_key_fc;
                            symbol_table[scoped_key] = matching_lambda;
                            global_symbol_table[scoped_key] = matching_lambda;
                            eshkol_debug("Created SCOPED _func reference for %s -> %s in function context",
                                        scoped_key.c_str(), matching_lambda->getName().str().c_str());
                        } else {
                            global_symbol_table[func_key_fc] = matching_lambda;
                            eshkol_debug("Created _func reference for %s -> %s (top-level, function context)",
                                        func_key_fc.c_str(), matching_lambda->getName().str().c_str());
                        }
                    }
                }
            }
        } else {
            // For global variables, handle function pointers specially
            // CRITICAL FIX: Check for null before isa<Function> to avoid assertion
            if (value && isa<Function>(value)) {
                Function* func = dyn_cast<Function>(value);

                // This is for top-level (no current_function), so add to both tables
                symbol_table[std::string(var_name) + "_func"] = func;
                global_symbol_table[std::string(var_name) + "_func"] = func;
                eshkol_debug("Stored GLOBAL lambda function reference: %s_func -> %s (top-level)",
                            var_name, func->getName().str().c_str());
                
                // OPTION 3: Use same GlobalVariable pointer for alias (no need to create new one)
                std::string lambda_name = func->getName().str();
                std::string lambda_sexpr_key = lambda_name + "_sexpr";
                std::string var_sexpr_key = std::string(var_name) + "_sexpr";
                
                // Check if lambda S-expression GlobalVariable exists
                auto lambda_sexpr_it = global_symbol_table.find(lambda_sexpr_key);
                if (lambda_sexpr_it != global_symbol_table.end()) {
                    // Alias: Both keys point to SAME GlobalVariable instance
                    // This works because global_symbol_table stores Value* pointers
                    global_symbol_table[var_sexpr_key] = lambda_sexpr_it->second;
                    eshkol_debug("Aliased GLOBAL S-expression: %s -> %s (same GlobalVariable ptr)",
                                var_sexpr_key.c_str(), lambda_sexpr_key.c_str());
                }
                
                // Store function pointer as a global variable with proper initialization
                Constant* func_ptr = ConstantExpr::getPtrToInt(func, int64_type);
                GlobalVariable *variable = new GlobalVariable(
                    *module,
                    int64_type, // Store as int64 function pointer
                    false,
                    GlobalValue::WeakAnyLinkage,
                    func_ptr, // Initialize with actual function address
                    var_name
                );
                symbol_table[var_name] = variable;
                global_symbol_table[var_name] = variable; // Also store in global table
                // HoTT TYPE TRACKING: Functions have Function type
                symbol_hott_types[var_name] = eshkol::hott::BuiltinTypes::Function;
                global_symbol_hott_types[var_name] = eshkol::hott::BuiltinTypes::Function;

                eshkol_debug("Created global lambda variable: %s", var_name);
            } else {
                // CRITICAL FIX: GlobalVariable requires Constant initializer
                // For non-constant values, use UndefValue and mark for runtime init
                Constant* init_value = dyn_cast<Constant>(value);
                if (!init_value) {
                    // Non-constant value - use UndefValue as placeholder
                    init_value = UndefValue::get(value->getType());
                    eshkol_debug("Global variable %s has non-constant initializer, will init at runtime", var_name);
                }

                GlobalVariable *variable = new GlobalVariable(
                    *module,
                    value->getType(),
                    false,
                    GlobalValue::WeakAnyLinkage,
                    init_value,  // Always valid Constant now
                    var_name
                );
                symbol_table[var_name] = variable;
                global_symbol_table[var_name] = variable; // Also store in global table
                // HoTT TYPE TRACKING: Store the compile-time type
                symbol_hott_types[var_name] = hott_type;
                global_symbol_hott_types[var_name] = hott_type;
                // HoTT PARAMETERIZED TYPE: Store element type for List<T>, Vector<T>
                if (param_type.has_value()) {
                    symbol_param_types[var_name] = *param_type;
                    global_symbol_param_types[var_name] = *param_type;
                }

                // CRITICAL FIX: Handle returned lambdas stored in global variables
                // When (define curried-add (curry2 add)) is evaluated, we need to track
                // which lambda function curried-add points to so closure calls work correctly
                if (value && value->getType() == tagged_value_type) {
                    Function* matching_lambda = nullptr;

                    // FIRST: Check if this is a call to a function that returns a lambda
                    // Use functions_returning_lambda to find the CORRECT lambda
                    if (op->define_op.value && op->define_op.value->type == ESHKOL_OP &&
                        op->define_op.value->operation.op == ESHKOL_CALL_OP &&
                        op->define_op.value->operation.call_op.func &&
                        op->define_op.value->operation.call_op.func->type == ESHKOL_VAR) {

                        std::string callee_name = op->define_op.value->operation.call_op.func->variable.id;
                        auto lambda_it = functions_returning_lambda.find(callee_name);
                        if (lambda_it != functions_returning_lambda.end()) {
                            std::string lambda_name = lambda_it->second;
                            auto func_it = function_table.find(lambda_name);
                            if (func_it != function_table.end()) {
                                matching_lambda = func_it->second;
                                eshkol_debug("Global define: matched %s_func to %s via functions_returning_lambda",
                                           var_name, lambda_name.c_str());
                            }
                        }
                    }

                    // FALLBACK: If not found via functions_returning_lambda, use last_generated_lambda_name
                    // This handles inline lambdas and other cases
                    if (!matching_lambda && !last_generated_lambda_name.empty()) {
                        auto func_it = function_table.find(last_generated_lambda_name);
                        if (func_it != function_table.end()) {
                            matching_lambda = func_it->second;
                            eshkol_debug("Global define: matched %s_func to %s via last_generated_lambda_name",
                                       var_name, last_generated_lambda_name.c_str());
                        }
                    }

                    if (matching_lambda) {
                        std::string lambda_name = matching_lambda->getName().str();
                        symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        global_symbol_table[std::string(var_name) + "_func"] = matching_lambda;
                        eshkol_debug("Global define: stored returned lambda reference %s_func -> %s",
                                   var_name, lambda_name.c_str());

                        // REPL MODE: Register lambda name mapping for cross-evaluation calls
                        if (g_repl_mode_enabled) {
                            eshkol_repl_register_lambda_name(var_name, lambda_name.c_str());
                        }
                    }
                }
            }
        }

        if (had_insertion_point) {
            builder->restoreIP(old_point);
        }

        eshkol_debug("Defined variable: %s", var_name);

        return value;
    }

    // set! - mutate an existing variable
    Value* codegenSet(const eshkol_operations_t* op) {
        const char* var_name = op->set_op.name;
        if (!var_name) {
            eshkol_error("set! requires a variable name");
            return packNullToTaggedValue();
        }

        // Generate code for the new value
        if (!op->set_op.value) {
            eshkol_error("set! requires a value");
            return packNullToTaggedValue();
        }

        TypedValue typed = codegenTypedAST(op->set_op.value);
        Value* new_value = typed.llvm_value;
        if (!new_value) {
            eshkol_error("set!: failed to evaluate value");
            return packNullToTaggedValue();
        }

        // Look up the variable in symbol tables
        Value* var_ptr = nullptr;

        // LIBRARY MODE FIX: In library init, prefer global variables over local allocas
        // This fixes the forward declaration pattern where set! should store to the global,
        // not a local alloca created during the define processing
        if (library_mode) {
            // Check global symbol table first in library mode
            auto git = global_symbol_table.find(var_name);
            if (git != global_symbol_table.end()) {
                if (isa<GlobalVariable>(git->second)) {
                    var_ptr = git->second;
                }
            }
        }

        // Check local symbol table
        if (!var_ptr) {
            auto it = symbol_table.find(var_name);
            if (it != symbol_table.end()) {
                var_ptr = it->second;
            }
        }

        // Check global symbol table (fallback for non-library mode or if not found locally)
        if (!var_ptr) {
            auto git = global_symbol_table.find(var_name);
            if (git != global_symbol_table.end()) {
                var_ptr = git->second;
            }
        }

        // REPL MODE: Check if variable exists in REPL registries
        if (!var_ptr && g_repl_mode_enabled) {
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            auto repl_it = g_repl_symbol_addresses.find(var_name);
            if (repl_it != g_repl_symbol_addresses.end()) {
                // Variable exists in REPL context - create external global declaration
                GlobalVariable* global_var = module->getGlobalVariable(var_name);
                if (!global_var) {
                    // Create external declaration for this global variable
                    global_var = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,  // not constant
                        GlobalValue::ExternalLinkage,
                        nullptr,  // no initializer for external declaration
                        var_name
                    );
                }
                var_ptr = global_var;
            }
        }

        if (!var_ptr) {
            eshkol_error("set!: undefined variable '%s'", var_name);
            return packNullToTaggedValue();
        }

        // Determine if var_ptr is a pointer we can store to
        // MUTABLE CAPTURE FIX: Also accept any pointer type (for closure capture storage)
        // Valid storage types: GlobalVariable, AllocaInst, Argument pointer, or any pointer value
        // (e.g., IntToPtr result from unpacking an alloca pointer stored in closure env)
        bool is_valid_storage = isa<GlobalVariable>(var_ptr) || isa<AllocaInst>(var_ptr) ||
                                var_ptr->getType()->isPointerTy();

        if (is_valid_storage) {
            // Get the storage type
            Type* store_type = tagged_value_type;  // Default for Argument pointers
            if (GlobalVariable* gv = dyn_cast<GlobalVariable>(var_ptr)) {
                store_type = gv->getValueType();
            } else if (AllocaInst* ai = dyn_cast<AllocaInst>(var_ptr)) {
                store_type = ai->getAllocatedType();
            }
            // For Argument pointers (closure captures), assume tagged_value_type

            // Pack value to tagged_value if storage is tagged_value type
            Value* store_value = new_value;
            if (store_type == tagged_value_type && new_value->getType() != tagged_value_type) {
                // Pack to tagged value
                TypedValue tv = detectValueType(new_value);
                store_value = typedValueToTaggedValue(tv);
            } else if (store_type == int64_type && new_value->getType() != int64_type) {
                // Handle i64 storage (for function pointers, etc.)
                if (new_value->getType() == tagged_value_type) {
                    store_value = unpackInt64FromTaggedValue(new_value);
                } else if (new_value->getType()->isDoubleTy()) {
                    store_value = builder->CreateBitCast(new_value, int64_type);
                } else {
                    store_value = builder->CreateBitCast(new_value, int64_type);
                }
            }

            builder->CreateStore(store_value, var_ptr);
            eshkol_debug("set! updated variable: %s", var_name);

            // Return the new value (set! returns an unspecified value, but we return the stored value)
            return new_value->getType() == tagged_value_type ? new_value : typedValueToTaggedValue(typed);
        } else {
            // Variable is not mutable (might be a function argument passed by value)
            eshkol_error("set!: variable '%s' is not mutable (not an alloca, global, or capture pointer)", var_name);
            return packNullToTaggedValue();
        }
    }

    Value* codegenCall(const eshkol_operations_t* op) {
        if (!op->call_op.func) {
            return nullptr;
        }
        
        // CRITICAL FIX: Handle inline lambda expressions: ((lambda (x) body) arg)
        // This pattern appears in nested lambda calls and must be supported
        if (op->call_op.func->type == ESHKOL_OP &&
            op->call_op.func->operation.op == ESHKOL_LAMBDA_OP) {

            // Generate the inline lambda
            Value* lambda = codegenLambda(&op->call_op.func->operation);
            if (!lambda) {
                eshkol_error("Failed to generate inline lambda in call expression");
                return nullptr;
            }

            // Generate arguments
            std::vector<Value*> call_args;
            for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                Value* arg = codegenAST(&op->call_op.variables[i]);
                if (!arg) continue;

                // Pack to tagged_value if needed (lambdas expect tagged_value)
                if (arg->getType() != tagged_value_type) {
                    if (arg->getType()->isIntegerTy(64)) {
                        arg = packInt64ToTaggedValue(arg, true);
                    } else if (arg->getType()->isDoubleTy()) {
                        arg = packDoubleToTaggedValue(arg);
                    } else {
                        TypedValue tv = detectValueType(arg);
                        arg = typedValueToTaggedValue(tv);
                    }
                }
                call_args.push_back(arg);
            }

            // CAPTURE FIX: Use codegenClosureCall to properly handle lambdas with captures.
            // codegenLambda returns a closure (tagged_value) that contains both the function
            // pointer and captured values. codegenClosureCall extracts these and builds
            // the correct argument list including captures.
            return codegenClosureCall(lambda, call_args, "inline-lambda");
        }
        
        // Handle call-result-as-function: ((f x) y) where (f x) returns a function
        // This is a common pattern for curried functions and compose
        if (op->call_op.func->type == ESHKOL_OP && op->call_op.func->operation.op == ESHKOL_CALL_OP) {
            // Evaluate the inner call to get the function value
            Value* func_result = codegenAST(op->call_op.func);
            if (!func_result) {
                eshkol_error("Failed to evaluate function expression");
                return nullptr;
            }

            // Generate all normal arguments first
            std::vector<Value*> call_args;
            for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                Value* arg = codegenAST(&op->call_op.variables[i]);
                if (!arg) continue;

                // Pack to tagged_value if needed
                if (arg->getType() != tagged_value_type) {
                    if (arg->getType()->isIntegerTy(64)) {
                        arg = packInt64ToTaggedValue(arg, true);
                    } else if (arg->getType()->isDoubleTy()) {
                        arg = packDoubleToTaggedValue(arg);
                    } else {
                        TypedValue tv = detectValueType(arg);
                        arg = typedValueToTaggedValue(tv);
                    }
                }
                call_args.push_back(arg);
            }

            // Call runtime closure dispatch helper
            return codegenClosureCall(func_result, call_args, "call-result-as-func");
        }

        // Handle operation-result-as-function: ((derivative f) x), ((gradient f) p), ((lambda ...) x), etc.
        // Operations like derivative/gradient/lambda return closures that can be called
        if (op->call_op.func->type == ESHKOL_OP) {
            eshkol_op_t inner_op = op->call_op.func->operation.op;
            // Check if this is an operation that returns a callable closure
            if (inner_op == ESHKOL_DERIVATIVE_OP || inner_op == ESHKOL_GRADIENT_OP ||
                inner_op == ESHKOL_LAMBDA_OP || inner_op == ESHKOL_JACOBIAN_OP) {
                // Evaluate the operation to get the closure value
                Value* func_result = codegenAST(op->call_op.func);
                if (!func_result) {
                    eshkol_error("Failed to evaluate function-returning operation");
                    return nullptr;
                }

                // Generate all arguments
                std::vector<Value*> call_args;
                for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                    Value* arg = codegenAST(&op->call_op.variables[i]);
                    if (!arg) continue;

                    // Pack to tagged_value if needed
                    if (arg->getType() != tagged_value_type) {
                        if (arg->getType()->isIntegerTy(64)) {
                            arg = packInt64ToTaggedValue(arg, true);
                        } else if (arg->getType()->isDoubleTy()) {
                            arg = packDoubleToTaggedValue(arg);
                        } else {
                            TypedValue tv = detectValueType(arg);
                            arg = typedValueToTaggedValue(tv);
                        }
                    }
                    call_args.push_back(arg);
                }

                // Call the returned closure with the arguments
                return codegenClosureCall(func_result, call_args, "op-result-as-func");
            }
        }

        // Handle variable function references (existing code)
        if (op->call_op.func->type != ESHKOL_VAR || !op->call_op.func->variable.id) {
            eshkol_error("Call expression requires variable or inline lambda");
            return nullptr;
        }
        
        std::string func_name = op->call_op.func->variable.id;

        // TCO CHECK: If TCO is active and this is a self-recursive call, use tail call jump
        // Check the binding module's TCO context (set by letrec during lambda generation)
        if (binding_ && binding_->isTCOActive(func_name)) {
            auto& tco_ctx = binding_->getTCOContext();
            Value* tco_result = codegenTailCallFromContext(op, tco_ctx);
            if (tco_result) {
                return tco_result;  // Tail call generated as jump
            }
            // If codegenTailCall returns nullptr, fall through to normal call
        }

        // USER-DEFINED FUNCTION SHADOWING: Check if this function name is user-defined
        // before checking builtins. User-defined functions should shadow builtins.
        // Check: symbol_table (for _func entries), function_table (for direct definitions)
        {
            std::string func_key = func_name + "_func";
            bool is_user_defined = false;

            // Check scoped key first (for nested functions)
            if (current_function) {
                std::string scoped_key = current_function->getName().str() + "." + func_key;
                if (symbol_table.find(scoped_key) != symbol_table.end()) {
                    is_user_defined = true;
                }
            }

            // Check unscoped _func key
            if (!is_user_defined && symbol_table.find(func_key) != symbol_table.end()) {
                is_user_defined = true;
            }

            // NOTE: Do NOT check function_table here! function_table contains both
            // user-defined functions AND C library functions (sin, cos, exp, etc.).
            // Checking function_table would incorrectly treat math functions as user-defined,
            // bypassing polymorphic dispatch (e.g., dual number support for autodiff).
            // Only check _func keys which are exclusively for user-defined functions.

            // Check global symbol table
            if (!is_user_defined && global_symbol_table.find(func_key) != global_symbol_table.end()) {
                is_user_defined = true;
            }

            // If user-defined, skip all builtin checks and go directly to user function handling
            if (is_user_defined) {
                goto user_defined_function_call;
            }
        }

        // Handle arithmetic operations
        if (func_name == "+") return codegenArithmetic(op, "add");
        if (func_name == "-") return codegenArithmetic(op, "sub");
        if (func_name == "*") return codegenArithmetic(op, "mul");
        if (func_name == "/") return codegenArithmetic(op, "div");

        // Handle comparison operations
        if (func_name == "<") return codegenComparison(op, "lt");
        if (func_name == ">") return codegenComparison(op, "gt");
        if (func_name == "=") return codegenComparison(op, "eq");
        if (func_name == "<=") return codegenComparison(op, "le");
        if (func_name == ">=") return codegenComparison(op, "ge");
        
        // Handle math functions with dual number support (Phase 2)
        if (func_name == "sin") return codegenMathFunction(op, "sin");
        if (func_name == "cos") return codegenMathFunction(op, "cos");
        if (func_name == "exp") return codegenMathFunction(op, "exp");
        if (func_name == "exp2") return codegenMathFunction(op, "exp2");
        if (func_name == "log") return codegenMathFunction(op, "log");

        // Additional trigonometric functions
        if (func_name == "tan") return codegenMathFunction(op, "tan");
        if (func_name == "asin") return codegenMathFunction(op, "asin");
        if (func_name == "acos") return codegenMathFunction(op, "acos");
        if (func_name == "atan") return codegenMathFunction(op, "atan");
        if (func_name == "atan2") return codegenBinaryMathFunction(op, "atan2");

        // Hyperbolic functions
        if (func_name == "sinh") return codegenMathFunction(op, "sinh");
        if (func_name == "cosh") return codegenMathFunction(op, "cosh");
        if (func_name == "tanh") return codegenMathFunction(op, "tanh");
        if (func_name == "asinh") return codegenMathFunction(op, "asinh");
        if (func_name == "acosh") return codegenMathFunction(op, "acosh");
        if (func_name == "atanh") return codegenMathFunction(op, "atanh");

        // Logarithmic functions
        if (func_name == "log10") return codegenMathFunction(op, "log10");
        if (func_name == "log2") return codegenMathFunction(op, "log2");

        // Root functions (also need dual number support for autodiff)
        if (func_name == "sqrt") return codegenMathFunction(op, "sqrt");

        // Numeric/rounding functions
        if (func_name == "abs") return codegenAbs(op);  // Polymorphic abs preserves int type
        if (func_name == "fabs") return codegenMathFunction(op, "fabs");
        if (func_name == "floor") return codegenMathFunction(op, "floor");
        if (func_name == "ceiling") return codegenMathFunction(op, "ceil");
        if (func_name == "ceil") return codegenMathFunction(op, "ceil");
        if (func_name == "round") return codegenMathFunction(op, "round");
        if (func_name == "truncate") return codegenMathFunction(op, "trunc");
        if (func_name == "trunc") return codegenMathFunction(op, "trunc");
        if (func_name == "cbrt") return codegenMathFunction(op, "cbrt");

        // Modulo and remainder
        if (func_name == "modulo" || func_name == "mod" || func_name == "%")
            return codegenModulo(op);
        if (func_name == "remainder") return codegenRemainder(op);
        if (func_name == "quotient") return codegenQuotient(op);
        if (func_name == "gcd") return codegenGCD(op);
        if (func_name == "lcm") return codegenLCM(op);

        // Min/max
        if (func_name == "min") return codegenMinMax(op, true);
        if (func_name == "max") return codegenMinMax(op, false);

        // Power function with dual number support for autodiff
        if (func_name == "pow" || func_name == "expt") {
            if (op->call_op.num_vars != 2) {
                eshkol_warn("pow/expt requires exactly 2 arguments");
                return nullptr;
            }
            // Use codegenTypedAST and convert to tagged_value like other arithmetic ops
            TypedValue tv_base = codegenTypedAST(&op->call_op.variables[0]);
            TypedValue tv_exp = codegenTypedAST(&op->call_op.variables[1]);
            if (!tv_base.llvm_value || !tv_exp.llvm_value) return nullptr;
            Value* base = typedValueToTaggedValue(tv_base);
            Value* exp = typedValueToTaggedValue(tv_exp);
            return arith_->pow(base, exp);
        }

        // Logical operators (short-circuit)
        if (func_name == "and") return codegenAnd(op);
        if (func_name == "or") return codegenOr(op);
        if (func_name == "not") return codegenNot(op);

        // One-armed conditionals
        if (func_name == "when") return codegenWhen(op);
        if (func_name == "unless") return codegenUnless(op);

        // Type predicates
        if (func_name == "number?") {
            // Number is either int64 or double
            // Use codegenTypedAST for proper handling of raw values
            TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
            if (!tv.llvm_value) return nullptr;
            Value* arg = typedValueToTaggedValue(tv);
            Value* type = getTaggedValueType(arg);
            Value* base_type = builder->CreateAnd(type, ConstantInt::get(int8_type, 0x0F));
            Value* is_int = builder->CreateICmpEQ(base_type, ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
            Value* is_double = builder->CreateICmpEQ(base_type, ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
            return packBoolToTaggedValue(builder->CreateOr(is_int, is_double));
        }
        if (func_name == "integer?") return codegenTypePredicate(op, ESHKOL_VALUE_INT64);
        if (func_name == "real?") return codegenTypePredicate(op, ESHKOL_VALUE_DOUBLE);
        if (func_name == "list?") return codegenTypePredicate(op, ESHKOL_VALUE_CONS_PTR);
        if (func_name == "string?") return codegenTypePredicate(op, ESHKOL_VALUE_STRING_PTR);
        if (func_name == "boolean?") return codegenBooleanPredicate(op);
        if (func_name == "symbol?") return codegenTypePredicate(op, ESHKOL_VALUE_SYMBOL);
        if (func_name == "procedure?") return codegenProcedurePredicate(op);

        // HoTT TYPE INTROSPECTION: type-of returns the type tag as an integer
        if (func_name == "type-of") {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
            if (!tv.llvm_value) return nullptr;
            Value* arg = typedValueToTaggedValue(tv);
            return tagged_->typeOf(arg);
        }

        // String functions (dispatched to StringIOCodegen)
        if (func_name == "string-length") return strio_->stringLength(op);
        if (func_name == "string-ref") return strio_->stringRef(op);
        if (func_name == "string-append") return strio_->stringAppend(op);
        if (func_name == "substring") return strio_->substring(op);
        if (func_name == "string=?") return strio_->stringCompare(op, "eq");
        if (func_name == "string<?") return strio_->stringCompare(op, "lt");
        if (func_name == "string>?") return strio_->stringCompare(op, "gt");
        if (func_name == "string<=?") return strio_->stringCompare(op, "le");
        if (func_name == "string>=?") return strio_->stringCompare(op, "ge");
        if (func_name == "number->string") return strio_->numberToString(op);
        if (func_name == "string->number") return strio_->stringToNumber(op);
        if (func_name == "make-string") return strio_->makeString(op);
        if (func_name == "string-set!") return strio_->stringSet(op);
        if (func_name == "string->list") return strio_->stringToList(op);
        if (func_name == "list->string") return strio_->listToString(op);
        // Extended string functions (dispatched to StringIOCodegen)
        if (func_name == "string-split") return strio_->stringSplit(op);
        if (func_name == "string-contains?") return strio_->stringContains(op);
        if (func_name == "string-index") return strio_->stringIndex(op);
        if (func_name == "string-upcase") return strio_->stringUpcase(op);
        if (func_name == "string-downcase") return strio_->stringDowncase(op);

        // Character functions
        if (func_name == "char?") return codegenTypePredicate(op, ESHKOL_VALUE_CHAR);
        if (func_name == "char->integer") return strio_->charToInteger(op);
        if (func_name == "integer->char") return strio_->integerToChar(op);
        if (func_name == "char=?") return strio_->charCompare(op, "eq");
        if (func_name == "char<?") return strio_->charCompare(op, "lt");
        if (func_name == "char>?") return strio_->charCompare(op, "gt");
        if (func_name == "char<=?") return strio_->charCompare(op, "le");
        if (func_name == "char>=?") return strio_->charCompare(op, "ge");

        // Numeric predicates
        if (func_name == "positive?") return codegenNumericPredicate(op, "positive?");
        if (func_name == "negative?") return codegenNumericPredicate(op, "negative?");
        if (func_name == "zero?") return codegenNumericPredicate(op, "zero?");
        if (func_name == "even?") return codegenNumericPredicate(op, "even?");
        if (func_name == "odd?") return codegenNumericPredicate(op, "odd?");

        // Equivalence predicates
        if (func_name == "eq?") return codegenEq(op);
        if (func_name == "eqv?") return codegenEqv(op);
        if (func_name == "equal?") return codegenEqual(op);

        // Handle display/newline/error operations (delegated to StringIOCodegen)
        if (func_name == "display") return strio_->display(op);
        if (func_name == "newline") return strio_->newline(op);
        if (func_name == "error") return codegenError(op);

        // Handle file I/O operations
        if (func_name == "open-input-file") return strio_->openInputFile(op);
        if (func_name == "read-line") return strio_->readLine(op);
        if (func_name == "close-port") return strio_->closePort(op);
        if (func_name == "eof-object?") return strio_->eofObject(op);
        if (func_name == "open-output-file") return strio_->openOutputFile(op);
        if (func_name == "write-string") return strio_->writeString(op);
        if (func_name == "write-line") return strio_->writeLine(op);
        if (func_name == "write-char") return strio_->writeChar(op);
        if (func_name == "flush-output-port") return strio_->flushOutputPort(op);

        // =========================================================================
        // SYSTEM & ENVIRONMENT OPERATIONS (delegated to SystemCodegen)
        // =========================================================================
        if (func_name == "getenv") return system_->getenv(op);
        if (func_name == "setenv") return system_->setenv(op);
        if (func_name == "unsetenv") return system_->unsetenv(op);
        if (func_name == "system") return system_->systemCall(op);
        if (func_name == "sleep") return system_->sleep(op);
        if (func_name == "current-seconds") return system_->currentSeconds(op);
        if (func_name == "exit") return system_->exitProgram(op);
        if (func_name == "command-line") return system_->commandLine(op);

        // =========================================================================
        // FILE SYSTEM OPERATIONS (delegated to SystemCodegen)
        // =========================================================================
        if (func_name == "file-exists?") return system_->fileExists(op);
        if (func_name == "file-readable?") return system_->fileReadable(op);
        if (func_name == "file-writable?") return system_->fileWritable(op);
        if (func_name == "file-delete") return system_->fileDelete(op);
        if (func_name == "file-rename") return system_->fileRename(op);
        if (func_name == "file-size") return system_->fileSize(op);
        if (func_name == "directory-exists?") return system_->directoryExists(op);
        if (func_name == "make-directory") return system_->makeDirectory(op);
        if (func_name == "delete-directory") return system_->deleteDirectory(op);
        if (func_name == "directory-list") return system_->directoryList(op);
        if (func_name == "current-directory") return system_->currentDirectory(op);
        if (func_name == "set-current-directory!") return system_->setCurrentDirectory(op);
        if (func_name == "read-file") return system_->readFile(op);
        if (func_name == "write-file") return system_->writeFile(op);
        if (func_name == "append-file") return system_->appendFile(op);

        // =========================================================================
        // HASH TABLE OPERATIONS (delegated to HashCodegen)
        // =========================================================================
        if (func_name == "make-hash-table") return hash_->makeHashTable(op);
        if (func_name == "hash-table?") return codegenTypePredicate(op, ESHKOL_VALUE_HASH_PTR);
        if (func_name == "hash-ref") return hash_->hashRef(op);
        if (func_name == "hash-set!") return hash_->hashSet(op);
        if (func_name == "hash-has-key?") return hash_->hashHasKey(op);
        if (func_name == "hash-remove!") return hash_->hashRemove(op);
        if (func_name == "hash-keys") return hash_->hashKeys(op);
        if (func_name == "hash-values") return hash_->hashValues(op);
        if (func_name == "hash-count") return hash_->hashCount(op);
        if (func_name == "hash-clear!") return hash_->hashClear(op);

        // Handle if conditional
        if (func_name == "if") return codegenIfCall(op);
        
        // Handle begin sequence
        if (func_name == "begin") return codegenBegin(op);
        
        // Handle basic list operations
        if (func_name == "cons") return coll_->cons(op);
        if (func_name == "car") return coll_->car(op);
        if (func_name == "cdr") return coll_->cdr(op);
        if (func_name == "list") return coll_->list(op);
        if (func_name == "null?") return coll_->isNull(op);
        if (func_name == "pair?") return coll_->isPair(op);

        // Compound car/cdr operations - use builtin codegen for AD-aware vector/tensor access
        // These are also defined in stdlib (core/list/compound.esk), but the builtin version
        // is needed for gradient computation since stdlib functions are pre-compiled without AD instrumentation
        if (func_name == "cadr") return codegenCompoundCarCdr(op, "ad");
        if (func_name == "caddr") return codegenCompoundCarCdr(op, "add");
        if (func_name == "cadddr") return codegenCompoundCarCdr(op, "addd");
        if (func_name == "caar") return codegenCompoundCarCdr(op, "aa");
        if (func_name == "cdar") return codegenCompoundCarCdr(op, "da");
        if (func_name == "cddr") return codegenCompoundCarCdr(op, "dd");
        if (func_name == "caaar") return codegenCompoundCarCdr(op, "aaa");
        if (func_name == "caadr") return codegenCompoundCarCdr(op, "aad");
        if (func_name == "cadar") return codegenCompoundCarCdr(op, "ada");
        if (func_name == "cdaar") return codegenCompoundCarCdr(op, "daa");
        if (func_name == "cdadr") return codegenCompoundCarCdr(op, "dad");
        if (func_name == "cddar") return codegenCompoundCarCdr(op, "dda");
        if (func_name == "cdddr") return codegenCompoundCarCdr(op, "ddd");
        
        // Handle essential list utilities
        // length is now in stdlib.esk (core/list/query.esk)
        // append is now in stdlib.esk (core/list/transform.esk)
        // reverse is now in stdlib.esk (core/list/transform.esk)
        // list-ref is now in stdlib.esk (core/list/search.esk)
        // list-tail is now in stdlib.esk (core/list/search.esk)
        
        // Handle mutable list operations
        if (func_name == "set-car!") return codegenSetCar(op);
        if (func_name == "set-cdr!") return codegenSetCdr(op);
        
        // Handle higher-order list functions
        // map kept as builtin for performance (iterative LLVM IR vs recursive stdlib)
        if (func_name == "map") return codegenMap(op);
        // filter is now in stdlib.esk (core/list/transform.esk)
        // fold is now in stdlib.esk (core/list/higher_order.esk)
        // fold-right is now in stdlib.esk (core/list/higher_order.esk)
        // for-each is now in stdlib.esk (core/list/higher_order.esk)
        // any is now in stdlib.esk (core/list/higher_order.esk)
        // every is now in stdlib.esk (core/list/higher_order.esk)
        if (func_name == "apply") return codegenApply(op);

        // Handle member/association functions
        // member is now in stdlib.esk (core/list/search.esk)
        // memq is now in stdlib.esk (core/list/search.esk)
        // memv is now in stdlib.esk (core/list/search.esk)
        // assoc is now in stdlib.esk (core/list/search.esk)
        // assq is now in stdlib.esk (core/list/search.esk)
        // assv is now in stdlib.esk (core/list/search.esk)

        // Handle advanced list constructors
        // make-list is now in stdlib.esk (core/list/generate.esk)
        if (func_name == "list*") return codegenListStar(op);
        if (func_name == "acons") return codegenAcons(op);

        // Handle list processing utilities
        // take is now in stdlib.esk (core/list/transform.esk)
        // drop is now in stdlib.esk (core/list/transform.esk)
        // find is now in stdlib.esk (core/list/query.esk)
        // partition is now in stdlib.esk
        if (func_name == "split-at") return codegenSplitAt(op);
        // range is now in stdlib.esk (core/list/generate.esk)
        // zip is now in stdlib.esk (core/list/generate.esk)
        // unzip is now in stdlib.esk
        // sort is now in stdlib.esk
        // iota is now in stdlib.esk
        if (func_name == "reduce") return codegenReduce(op);

        // Handle random number generation
        if (func_name == "random") return codegenRandom(op);

        // Handle quantum random number generation
        if (func_name == "quantum-random") return codegenQuantumRandom(op);
        if (func_name == "quantum-random-int") return codegenQuantumRandomInt(op);
        if (func_name == "quantum-random-range") return codegenQuantumRandomRange(op);

        // Handle list removal operations
        // remove kept as builtin for performance (iterative LLVM IR vs recursive stdlib)
        if (func_name == "remove") return codegenRemove(op, "equal");
        if (func_name == "remq") return codegenRemove(op, "eq");
        if (func_name == "remv") return codegenRemove(op, "eqv");

        // Handle list boundary operations
        // last/last-pair kept as builtin for performance (iterative LLVM IR vs recursive stdlib)
        if (func_name == "last") return codegenLast(op);
        if (func_name == "last-pair") return codegenLastPair(op);
        
        // Handle tensor operations (numerical arrays) - MIGRATED to TensorCodegen
        if (func_name == "tensor-get") return tensor_->tensorGet(op);
        if (func_name == "vref") return codegenTensorVectorRef(op);  // Tensor 1D access (AD-aware, stays here)
        if (func_name == "tensor-set") return tensor_->tensorSet(op);

        // Scheme vectors (heterogeneous - can hold any type) - MIGRATED to CollectionCodegen
        if (func_name == "vector?") return codegenTypePredicate(op, ESHKOL_VALUE_VECTOR_PTR);
        if (func_name == "make-vector") return coll_->makeVector(op);
        if (func_name == "vector") return coll_->vector(op);
        if (func_name == "vector-ref") return coll_->vectorRef(op);
        if (func_name == "vector-set!") return coll_->vectorSet(op);
        if (func_name == "vector-length") return coll_->vectorLength(op);
        // MIGRATED: Tensor arithmetic - now delegated to TensorCodegen
        if (func_name == "tensor-add") return tensor_->tensorArithmetic(op, "add");
        if (func_name == "tensor-sub") return tensor_->tensorArithmetic(op, "sub");
        if (func_name == "tensor-mul") return tensor_->tensorArithmetic(op, "mul");
        if (func_name == "tensor-div") return tensor_->tensorArithmetic(op, "div");
        if (func_name == "tensor-dot") return tensor_->tensorDot(op);
        // MIGRATED: tensor-shape - now delegated to TensorCodegen
        if (func_name == "tensor-shape") return tensor_->tensorShape(op);
        // MIGRATED: tensor-apply and tensor-reduce - now delegated to TensorCodegen
        if (func_name == "tensor-apply") return tensor_->tensorApply(op);
        if (func_name == "tensor-reduce") {
            // Support both 3-arg (reduce all) and 4-arg (reduce with dimension) versions
            if (op->call_op.num_vars == 3) {
                return tensor_->tensorReduceAll(op);
            } else {
                return tensor_->tensorReduceWithDim(op);
            }
        }
        if (func_name == "tensor-reduce-all") return tensor_->tensorReduceAll(op);

        // MIGRATED: ML tensor creation functions - now delegated to TensorCodegen
        if (func_name == "zeros") return tensor_->zeros(op);
        if (func_name == "ones") return tensor_->ones(op);
        if (func_name == "eye") return tensor_->eye(op);
        if (func_name == "arange") return tensor_->arange(op);
        if (func_name == "linspace") return tensor_->linspace(op);

        // MIGRATED: ML tensor manipulation functions - reshape now delegated to TensorCodegen
        if (func_name == "reshape") return tensor_->reshape(op);
        // MIGRATED: transpose - now delegated to TensorCodegen
        if (func_name == "transpose") return tensor_->transpose(op);
        if (func_name == "flatten") return codegenFlatten(op);

        // ML linear algebra
        if (func_name == "matmul") return codegenMatmul(op);
        if (func_name == "trace") return codegenTrace(op);
        // det is now implemented in lib/math.esk library
        // if (func_name == "det") return codegenDeterminant(op);
        if (func_name == "norm") return codegenNorm(op);
        if (func_name == "outer") return codegenOuterProduct(op);

        // MIGRATED: ML statistics - now delegated to TensorCodegen
        if (func_name == "tensor-sum") return tensor_->tensorSum(op);
        if (func_name == "tensor-mean") return tensor_->tensorMean(op);

        // Handle tensor-to-string conversions
        if (func_name == "vector-to-string") return codegenVectorToString(op);
        if (func_name == "matrix-to-string") return codegenMatrixToString(op);

    user_defined_function_call:
        // Handle function calls - check local bindings FIRST for proper shadowing
        // LOCAL SHADOWING FIX: Check local symbol_table before function_table
        // This ensures letrec/let bindings shadow global functions (e.g., local 'partition'
        // shadows global 'partition' from stdlib)
        Function* callee = nullptr;

        // Step 1: Check LOCAL symbol table first (for letrec/let bindings with _func)
        // SCOPED LOOKUP FIX: First try scoped version (current_func.name_func) to handle
        // nested functions with the same name in different outer functions.
        std::string func_key = func_name + "_func";
        if (current_function) {
            std::string scoped_key = current_function->getName().str() + "." + func_key;
            auto scoped_it = symbol_table.find(scoped_key);
            if (scoped_it != symbol_table.end() && scoped_it->second && isa<Function>(scoped_it->second)) {
                callee = cast<Function>(scoped_it->second);
                eshkol_debug("Resolved %s using scoped key %s from symbol_table", func_name.c_str(), scoped_key.c_str());
            }
        }

        // If not found with scoped key, try unscoped
        if (!callee) {
            auto func_it = symbol_table.find(func_key);
            eshkol_debug("Looking for %s in symbol_table: %s",
                        func_key.c_str(),
                        func_it != symbol_table.end() ? "found" : "not found");
            if (func_it != symbol_table.end() && func_it->second && isa<Function>(func_it->second)) {
                callee = cast<Function>(func_it->second);
                eshkol_debug("Resolved %s to Function* from local symbol_table (shadows globals)", func_name.c_str());
            }
        }

        // Step 1b: LETREC SHADOWING FIX: If no _func entry but there IS a letrec
        // GlobalVariable binding, we need to use closure call to shadow any global
        // function with the same name. This handles the case where letrec creates
        // the GlobalVariable in Phase 1, but _func isn't registered until Phase 3.
        // IMPORTANT: Only apply to letrec GlobalVariables (with InternalLinkage).
        // Don't apply to AllocaInst (let bindings) or regular GlobalVariables - those
        // should have _func entries already registered.
        if (!callee) {
            auto var_it = symbol_table.find(func_name);
            if (var_it != symbol_table.end() && var_it->second) {
                Value* var_value = var_it->second;

                // Check for letrec GlobalVariable (identified by InternalLinkage and
                // name starting with "letrec_")
                if (GlobalVariable* gv = dyn_cast<GlobalVariable>(var_value)) {
                    if (gv->hasInternalLinkage() &&
                        gv->getName().str().find("letrec_") == 0) {
                        eshkol_debug("Found letrec GlobalVariable binding for %s - using closure call to shadow globals", func_name.c_str());

                        // Load the closure value
                        Value* closure_val = builder->CreateLoad(tagged_value_type, var_value, func_name + ".closure");

                        // Generate all arguments
                        std::vector<Value*> call_args;
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            Value* arg = codegenAST(&op->call_op.variables[i]);
                            if (!arg) continue;

                            if (arg->getType() != tagged_value_type) {
                                if (arg->getType()->isIntegerTy(64)) {
                                    arg = packInt64ToTaggedValue(arg, true);
                                } else if (arg->getType()->isDoubleTy()) {
                                    arg = packDoubleToTaggedValue(arg);
                                } else {
                                    TypedValue tv = detectValueType(arg);
                                    arg = typedValueToTaggedValue(tv);
                                }
                            }
                            call_args.push_back(arg);
                        }

                        // Use closure call which properly handles the function pointer extraction
                        return codegenClosureCall(closure_val, call_args, "alloca-lookup");
                    }
                }
            }
        }

        // Step 2: Check global function_table if not found locally
        if (!callee) {
            callee = function_table[func_name];
        }

        // Step 3: Check global symbol table and REPL context if still not found
        if (!callee) {
            auto global_func_it = global_symbol_table.find(func_key);
            if (global_func_it != global_symbol_table.end() && global_func_it->second && isa<Function>(global_func_it->second)) {
                callee = cast<Function>(global_func_it->second);
            }

            // REPL MODE: Try resolving from global REPL context
            if (!callee) {
                callee = tryResolveReplFunction(func_name);
            }
            if (!callee) {
                callee = tryResolveReplFunction(func_key);

                // CRITICAL FIX: Only do variable fallback if we STILL haven't found the function
                if (!callee) {
                    // Fall back to the variable lookup
                    auto var_it = symbol_table.find(func_name);
                    if (var_it != symbol_table.end()) {
                        Value* lambda_ptr = var_it->second;
                        
                        // Check if it's a local variable containing function pointer
                        if (isa<AllocaInst>(lambda_ptr)) {
                            Type* stored_type = dyn_cast<AllocaInst>(lambda_ptr)->getAllocatedType();
                            if (stored_type && stored_type->isIntegerTy(64)) {
                                // Load the function pointer address
                                Value* func_addr = builder->CreateLoad(stored_type, lambda_ptr);
                                
                                // Find the corresponding lambda function by searching function table
                                for (auto& func_pair : function_table) {
                                    if (isLambdaName(func_pair.first)) {
                                        Function* lambda_func = func_pair.second;
                                        
                                        // Check if this lambda matches the expected signature
                                        if (lambda_func->arg_size() == op->call_op.num_vars) {
                                            callee = lambda_func;
                                            eshkol_debug("Resolved lambda function %s for variable %s",
                                                       func_pair.first.c_str(), func_name.c_str());
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if (!callee) {
            // If we can't find the function directly, check if it's a variable containing a function pointer
            // Check local symbols first, then global symbols
            Value* var_value = nullptr;
            auto local_it = symbol_table.find(func_name);
            if (local_it != symbol_table.end()) {
                var_value = local_it->second;
            } else {
                auto global_it = global_symbol_table.find(func_name);
                if (global_it != global_symbol_table.end()) {
                    var_value = global_it->second;
                }
            }

            // FIRST-CLASS FUNCTION FIX: Check if this is a captured function parameter FIRST
            // Before trying to match lambdas by arity, check if we need an indirect call
            if (var_value) {
                Value* func_val = var_value;

                // CLOSURE FIX: Handle LoadInst - this is a loaded captured value from closure environment
                // The captured value is a CLOSURE_PTR tagged_value, so use codegenClosureCall to handle it properly
                if (isa<LoadInst>(func_val) && func_val->getType() == tagged_value_type) {

                    // Generate all arguments first
                    std::vector<Value*> call_args;
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        Value* arg = codegenAST(&op->call_op.variables[i]);
                        if (!arg) continue;

                        // Pack to tagged_value if needed
                        if (arg->getType() != tagged_value_type) {
                            if (arg->getType()->isIntegerTy(64)) {
                                arg = packInt64ToTaggedValue(arg, true);
                            } else if (arg->getType()->isDoubleTy()) {
                                arg = packDoubleToTaggedValue(arg);
                            } else {
                                TypedValue tv = detectValueType(arg);
                                arg = typedValueToTaggedValue(tv);
                            }
                        }
                        call_args.push_back(arg);
                    }

                    // CAPTURED FUNCTION FIX: Use codegenClosureCall which properly handles
                    // loading and passing captured values from the closure's environment
                    return codegenClosureCall(func_val, call_args, "LoadInst-captured");
                }
                // For closures, the captured variable might be stored in an alloca, not passed as argument
                // In this case, we need to load the function pointer from the alloca
                if (isa<AllocaInst>(func_val) && func_val->getType() == PointerType::getUnqual(*context)) {
                    AllocaInst* alloca = cast<AllocaInst>(func_val);
                    if (alloca->getAllocatedType() == tagged_value_type) {
                        // Load the closure from the alloca
                        Value* loaded_val = builder->CreateLoad(tagged_value_type, func_val);

                        // Generate all arguments first
                        std::vector<Value*> call_args;
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            Value* arg = codegenAST(&op->call_op.variables[i]);
                            if (!arg) continue;

                            // Pack to tagged_value if needed
                            if (arg->getType() != tagged_value_type) {
                                if (arg->getType()->isIntegerTy(64)) {
                                    arg = packInt64ToTaggedValue(arg, true);
                                } else if (arg->getType()->isDoubleTy()) {
                                    arg = packDoubleToTaggedValue(arg);
                                } else {
                                    TypedValue tv = detectValueType(arg);
                                    arg = typedValueToTaggedValue(tv);
                                }
                            }
                            call_args.push_back(arg);
                        }

                        // CAPTURED FUNCTION FIX: Use codegenClosureCall which properly handles
                        // loading and passing captured values from the closure's environment
                        return codegenClosureCall(loaded_val, call_args, "AllocaInst-load");
                    }
                }
                // CAPTURED FUNCTION FIX: Handle function parameter (Argument) which is a closure
                if (isa<Argument>(func_val) && func_val->getType() == tagged_value_type) {
                    // Generate all arguments first
                    std::vector<Value*> call_args;
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        Value* arg = codegenAST(&op->call_op.variables[i]);
                        if (!arg) continue;

                        // Pack to tagged_value if needed
                        if (arg->getType() != tagged_value_type) {
                            if (arg->getType()->isIntegerTy(64)) {
                                arg = packInt64ToTaggedValue(arg, true);
                            } else if (arg->getType()->isDoubleTy()) {
                                arg = packDoubleToTaggedValue(arg);
                            } else {
                                TypedValue tv = detectValueType(arg);
                                arg = typedValueToTaggedValue(tv);
                            }
                        }
                        call_args.push_back(arg);
                    }

                    // Use codegenClosureCall which properly handles captured values
                    return codegenClosureCall(func_val, call_args, "Argument-tagged");
                }
                // MUTABLE CAPTURE FIX: Handle function parameter (Argument) which is a pointer to closure
                // This happens when a function is captured in a closure using the pointer-passing scheme
                if (isa<Argument>(func_val) && func_val->getType()->isPointerTy()) {
                    // Load the closure value from the pointer
                    Value* loaded_val = builder->CreateLoad(tagged_value_type, func_val);

                    // Generate all arguments first
                    std::vector<Value*> call_args;
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        Value* arg = codegenAST(&op->call_op.variables[i]);
                        if (!arg) continue;

                        // Pack to tagged_value if needed
                        if (arg->getType() != tagged_value_type) {
                            if (arg->getType()->isIntegerTy(64)) {
                                arg = packInt64ToTaggedValue(arg, true);
                            } else if (arg->getType()->isDoubleTy()) {
                                arg = packDoubleToTaggedValue(arg);
                            } else {
                                TypedValue tv = detectValueType(arg);
                                arg = typedValueToTaggedValue(tv);
                            }
                        }
                        call_args.push_back(arg);
                    }

                    // Use codegenClosureCall which properly handles captured values
                    return codegenClosureCall(loaded_val, call_args, "Argument-ptr");
                }
                // LETREC CAPTURE FIX: Handle GlobalVariable containing a captured function
                // This is used when a letrec lambda captures a function from outer scope
                // (e.g., merge capturing less? in sort's internal define)
                if (isa<GlobalVariable>(func_val)) {
                    GlobalVariable* global = dyn_cast<GlobalVariable>(func_val);
                    // Load the closure from the GlobalVariable
                    Value* loaded_val = builder->CreateLoad(global->getValueType(), func_val);

                    // Generate all arguments first
                    std::vector<Value*> call_args;
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        Value* arg = codegenAST(&op->call_op.variables[i]);
                        if (!arg) continue;

                        // Pack to tagged_value if needed
                        if (arg->getType() != tagged_value_type) {
                            if (arg->getType()->isIntegerTy(64)) {
                                arg = packInt64ToTaggedValue(arg, true);
                            } else if (arg->getType()->isDoubleTy()) {
                                arg = packDoubleToTaggedValue(arg);
                            } else {
                                TypedValue tv = detectValueType(arg);
                                arg = typedValueToTaggedValue(tv);
                            }
                        }
                        call_args.push_back(arg);
                    }

                    // Use codegenClosureCall which properly handles captured values
                    return codegenClosureCall(loaded_val, call_args, "GlobalVariable");
                }
                // MUTABLE CAPTURE FIX: Handle IntToPtrInst - this is a pointer to the outer scope's alloca
                // Created by the pointer-passing scheme for captured let-bound variables
                // The pointer points to an alloca containing a tagged_value (closure)
                if (isa<IntToPtrInst>(func_val) ||
                    (func_val->getType()->isPointerTy() && !isa<AllocaInst>(func_val) &&
                     !isa<GlobalVariable>(func_val) && !isa<Argument>(func_val))) {
                    // Load the closure from the pointed-to location
                    Value* loaded_val = builder->CreateLoad(tagged_value_type, func_val, "load_captured_func");

                    // Generate all arguments first
                    std::vector<Value*> call_args;
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        Value* arg = codegenAST(&op->call_op.variables[i]);
                        if (!arg) continue;

                        // Pack to tagged_value if needed
                        if (arg->getType() != tagged_value_type) {
                            if (arg->getType()->isIntegerTy(64)) {
                                arg = packInt64ToTaggedValue(arg, true);
                            } else if (arg->getType()->isDoubleTy()) {
                                arg = packDoubleToTaggedValue(arg);
                            } else {
                                TypedValue tv = detectValueType(arg);
                                arg = typedValueToTaggedValue(tv);
                            }
                        }
                        call_args.push_back(arg);
                    }

                    eshkol_debug("Calling captured function from pointer (IntToPtrInst): %s", func_name.c_str());
                    // Use codegenClosureCall which properly handles captured values
                    return codegenClosureCall(loaded_val, call_args, "IntToPtrInst");
                }
            }

            if (var_value) {
                eshkol_debug("Found variable %s, attempting dynamic function call", func_name.c_str());

                // Try to find associated lambda function
                // FIX: Avoid iterator comparison UB by using separate variables
                Value* func_entry = nullptr;
                auto func_local_it = symbol_table.find(std::string(func_name) + "_func");
                if (func_local_it != symbol_table.end()) {
                    func_entry = func_local_it->second;
                } else {
                    auto func_global_it = global_symbol_table.find(std::string(func_name) + "_func");
                    if (func_global_it != global_symbol_table.end()) {
                        func_entry = func_global_it->second;
                    }
                }

                if (func_entry && isa<Function>(func_entry)) {
                    callee = dyn_cast<Function>(func_entry);
                    eshkol_debug("Resolved closure function for %s", func_name.c_str());
                } else {
                    // Try to find lambda by inspecting function table for matching signatures
                    // CRITICAL FIX: Only match lambdas that actually have captured parameters
                    // (parameter names starting with "captured_"), not just any lambda with the right arg count
                    for (auto& func_pair : function_table) {
                        if (isLambdaName(func_pair.first)) {
                            Function* lambda_func = func_pair.second;
                            // For closures, the lambda has original params + captured params
                            if (lambda_func->arg_size() == op->call_op.num_vars + 1) {
                                // Verify this lambda actually has captured parameters
                                bool has_captures = false;
                                for (auto& arg : lambda_func->args()) {
                                    if (arg.getName().str().find("captured_") == 0) {
                                        has_captures = true;
                                        break;
                                    }
                                }
                                if (has_captures) {
                                    callee = lambda_func;
                                    eshkol_debug("Matched closure lambda %s for %s (args: %zu + 1 captured)",
                                               func_pair.first.c_str(), func_name.c_str(), op->call_op.num_vars);
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Also try matching lambdas without captures (plain functions)
                if (!callee) {
                    for (auto& func_pair : function_table) {
                        if (isLambdaName(func_pair.first)) {
                            Function* lambda_func = func_pair.second;
                            // Match lambda with exact argument count (no captures)
                            if (lambda_func->arg_size() == op->call_op.num_vars) {
                                // Verify this lambda has NO captured parameters
                                bool has_captures = false;
                                for (auto& arg : lambda_func->args()) {
                                    if (arg.getName().str().find("captured_") == 0) {
                                        has_captures = true;
                                        break;
                                    }
                                }
                                if (!has_captures) {
                                    callee = lambda_func;
                                    eshkol_debug("Matched plain lambda %s for %s (args: %zu)",
                                               func_pair.first.c_str(), func_name.c_str(), op->call_op.num_vars);
                                    break;
                                }
                            }
                        }
                    }
                }

                if (!callee) {
                    // Could not resolve closure - generate runtime error
                    eshkol_error("Could not resolve closure function for: %s", func_name.c_str());

                    Function* printf_func = function_table["printf"];
                    Function* exit_func = function_table["exit"];
                    if (printf_func && exit_func) {
                        std::string error_msg = "Error: Could not resolve function '" + func_name + "'\n";
                        Value* error_str = builder->CreateGlobalStringPtr(error_msg, "unresolved_func_error");
                        builder->CreateCall(printf_func, {error_str});
                        builder->CreateCall(exit_func, {ConstantInt::get(Type::getInt32Ty(*context), 1)});
                        builder->CreateUnreachable();
                        // Create a new block for any code that might follow (won't be reached)
                        Function* current_func = builder->GetInsertBlock()->getParent();
                        BasicBlock* dead_block = BasicBlock::Create(*context, "unreachable_continue", current_func);
                        builder->SetInsertPoint(dead_block);
                    }
                    return packNullToTaggedValue();
                }
            } else {
                // REPL FIX: Check if symbol exists in REPL registry (from previous evaluation)
                if (g_repl_mode_enabled) {
                    auto repl_it = g_repl_symbol_addresses.find(func_name);
                    if (repl_it != g_repl_symbol_addresses.end()) {
                        // Symbol exists in JIT from previous evaluation
                        // Create an external GlobalVariable reference and load the closure
                        GlobalVariable* ext_var = module->getNamedGlobal(func_name);
                        if (!ext_var) {
                            ext_var = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false, // not constant
                                GlobalValue::ExternalLinkage,
                                nullptr, // external - no initializer
                                func_name
                            );
                            eshkol_debug("REPL: Created external reference for %s", func_name.c_str());
                        }

                        // Load the closure value from the external global
                        Value* loaded_val = builder->CreateLoad(tagged_value_type, ext_var);

                        // Generate all arguments
                        std::vector<Value*> call_args;
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            Value* arg = codegenAST(&op->call_op.variables[i]);
                            if (!arg) continue;

                            // Pack to tagged_value if needed
                            if (arg->getType() != tagged_value_type) {
                                if (arg->getType()->isIntegerTy(64)) {
                                    arg = packInt64ToTaggedValue(arg, true);
                                } else if (arg->getType()->isDoubleTy()) {
                                    arg = packDoubleToTaggedValue(arg);
                                } else {
                                    TypedValue tv = detectValueType(arg);
                                    arg = typedValueToTaggedValue(tv);
                                }
                            }
                            call_args.push_back(arg);
                        }

                        eshkol_debug("REPL: Calling closure from external variable: %s", func_name.c_str());
                        return codegenClosureCall(loaded_val, call_args, "REPL-external");
                    }
                }

                // Not in symbol_table at all - truly unknown function
                // Generate runtime error instead of silently returning null
                eshkol_error("Unknown function: %s", func_name.c_str());

                // Generate code to print error and exit at runtime
                Function* printf_func = function_table["printf"];
                Function* exit_func = function_table["exit"];
                if (printf_func && exit_func) {
                    // Create error message string
                    std::string error_msg = "Error: Unknown function '" + func_name + "'\n";
                    Value* error_str = builder->CreateGlobalStringPtr(error_msg, "unknown_func_error");
                    builder->CreateCall(printf_func, {error_str});
                    builder->CreateCall(exit_func, {ConstantInt::get(Type::getInt32Ty(*context), 1)});
                    // Create unreachable and continue block for LLVM
                    builder->CreateUnreachable();
                    // Create a new block for any code that might follow (won't be reached)
                    Function* current_func = builder->GetInsertBlock()->getParent();
                    BasicBlock* dead_block = BasicBlock::Create(*context, "unreachable_continue", current_func);
                    builder->SetInsertPoint(dead_block);
                }
                return packNullToTaggedValue();
            }
        }

        // VARIADIC FUNCTION HANDLING: Check if this is a variadic function call
        std::string callee_name = callee->getName().str();
        auto variadic_it = variadic_function_info.find(callee_name);
        if (variadic_it != variadic_function_info.end() && variadic_it->second.second) {
            // This is a variadic function call
            uint64_t fixed_params = variadic_it->second.first;

            eshkol_debug("Variadic call to %s with %zu fixed params, %zu args provided",
                        callee_name.c_str(), fixed_params, op->call_op.num_vars);

            std::vector<Value*> call_args;
            FunctionType* func_type = callee->getFunctionType();

            // Process fixed parameters first
            for (uint64_t i = 0; i < fixed_params && i < op->call_op.num_vars; i++) {
                Value* arg = codegenAST(&op->call_op.variables[i]);
                if (!arg) continue;

                // Pack to tagged_value if needed
                if (arg->getType() != tagged_value_type) {
                    if (arg->getType()->isIntegerTy(64)) {
                        // CRITICAL FIX: Use detectValueType to correctly identify CONS_PTR from PtrToInt
                        TypedValue tv = detectValueType(arg);
                        arg = typedValueToTaggedValue(tv);
                    } else if (arg->getType()->isDoubleTy()) {
                        arg = packDoubleToTaggedValue(arg);
                    } else if (arg->getType()->isPointerTy()) {
                        // Check if this is a Function* (first-class function being passed)
                        if (isa<Function>(arg)) {
                            arg = packPtrToTaggedValue(arg, ESHKOL_VALUE_LAMBDA_SEXPR);
                        } else {
                            arg = packPtrToTaggedValue(arg, ESHKOL_VALUE_CONS_PTR);
                        }
                    } else {
                        TypedValue tv = detectValueType(arg);
                        arg = typedValueToTaggedValue(tv);
                    }
                }
                call_args.push_back(arg);
            }

            // Build rest parameter list from remaining arguments (in reverse order)
            // List is built from last element to first: (1 . (2 . (3 . null))) for args 1 2 3
            // Start with null (empty list) as a tagged_value
            Value* rest_list_tagged = packPtrToTaggedValue(
                ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);

            // Build list from right to left (last arg first)
            for (int64_t i = op->call_op.num_vars - 1; i >= (int64_t)fixed_params; i--) {
                Value* arg = codegenAST(&op->call_op.variables[i]);
                if (!arg) continue;

                // Pack to tagged_value if needed
                Value* arg_tagged;
                if (arg->getType() == tagged_value_type) {
                    arg_tagged = arg;
                } else if (arg->getType()->isIntegerTy(64)) {
                    // CRITICAL FIX: Use detectValueType to correctly identify CONS_PTR from PtrToInt
                    TypedValue tv = detectValueType(arg);
                    arg_tagged = typedValueToTaggedValue(tv);
                } else if (arg->getType()->isDoubleTy()) {
                    arg_tagged = packDoubleToTaggedValue(arg);
                } else if (arg->getType()->isPointerTy()) {
                    // Check if this is a Function* (first-class function being passed)
                    if (isa<Function>(arg)) {
                        arg_tagged = packPtrToTaggedValue(arg, ESHKOL_VALUE_LAMBDA_SEXPR);
                    } else {
                        arg_tagged = packPtrToTaggedValue(arg, ESHKOL_VALUE_CONS_PTR);
                    }
                } else {
                    TypedValue tv = detectValueType(arg);
                    arg_tagged = typedValueToTaggedValue(tv);
                }

                // Create cons cell: (arg . rest_list) - returns i64 pointer
                Value* cons_ptr_i64 = codegenTaggedArenaConsCellFromTaggedValue(arg_tagged, rest_list_tagged);
                // Pack as CONS_PTR tagged_value for next iteration
                rest_list_tagged = packPtrToTaggedValue(cons_ptr_i64, ESHKOL_VALUE_CONS_PTR);
            }

            // Add rest list as the final parameter (already a tagged_value)
            call_args.push_back(rest_list_tagged);

            eshkol_debug("Variadic call: %zu fixed args + rest list", call_args.size() - 1);

            // VARIADIC CLOSURE FIX: Check if this function has captures
            // For variadic functions, the signature is (fixed_params..., rest_list, captures...)
            // If func has more params than fixed_params + 1 (rest list), it has captures
            size_t expected_params_without_captures = fixed_params + 1;  // fixed params + rest list
            FunctionType* vfunc_type = callee->getFunctionType();
            if (vfunc_type->getNumParams() > expected_params_without_captures) {
                // This is a variadic closure - need to go through codegenClosureCall
                // First, find the closure value for this function
                std::string func_name = op->call_op.func->variable.id;
                Value* closure_val = nullptr;

                // Try symbol_table first
                auto sit = symbol_table.find(func_name);
                if (sit != symbol_table.end()) {
                    Value* val = sit->second;
                    if (isa<AllocaInst>(val)) {
                        closure_val = builder->CreateLoad(tagged_value_type, val);
                    } else if (val->getType() == tagged_value_type) {
                        closure_val = val;
                    }
                }

                // Try global_symbol_table
                if (!closure_val) {
                    auto git = global_symbol_table.find(func_name);
                    if (git != global_symbol_table.end()) {
                        Value* val = git->second;
                        if (isa<GlobalVariable>(val)) {
                            closure_val = builder->CreateLoad(tagged_value_type, val);
                        } else if (val->getType() == tagged_value_type) {
                            closure_val = val;
                        }
                    }
                }

                if (closure_val) {
                    eshkol_debug("Variadic closure call to %s - routing through codegenClosureCall",
                                callee_name.c_str());
                    return codegenClosureCall(closure_val, call_args, "variadic-closure");
                }
            }

            // Make the call (no captures)
            return builder->CreateCall(callee, call_args);
        }

        // Generate arguments with type conversion
        std::vector<Value*> args;
        FunctionType* func_type = callee->getFunctionType();

        // Check if this is a closure call (more parameters expected than provided)
        bool is_closure_call = (func_type->getNumParams() > op->call_op.num_vars);

        // Add explicit arguments first
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&op->call_op.variables[i]);
            if (arg && i < func_type->getNumParams()) {
                Type* expected_type = func_type->getParamType(i);
                Type* actual_type = arg->getType();

                // If function expects tagged_value, pack the argument
                if (expected_type == tagged_value_type) {
                    if (actual_type == tagged_value_type) {
                        // Already tagged - use as-is
                        // Do nothing, arg is already correct type
                    } else if (actual_type->isIntegerTy(64)) {
                        // CRITICAL FIX: Use detectValueType to correctly identify CONS_PTR from PtrToInt
                        TypedValue tv = detectValueType(arg);
                        arg = typedValueToTaggedValue(tv);
                    } else if (actual_type->isDoubleTy()) {
                        arg = packDoubleToTaggedValue(arg);
                    } else if (actual_type->isPointerTy()) {
                        // Check if this is a Function* (first-class function being passed)
                        if (isa<Function>(arg)) {
                            // Pack function pointers as LAMBDA_SEXPR for homoiconic display
                            arg = packPtrToTaggedValue(arg, ESHKOL_VALUE_LAMBDA_SEXPR);
                        } else {
                            arg = packPtrToTaggedValue(arg, ESHKOL_VALUE_CONS_PTR);
                        }
                    } else if (actual_type->isIntegerTy()) {
                        // Convert other integer types to i64 first
                        Value* as_i64 = builder->CreateSExtOrTrunc(arg, int64_type);
                        arg = packInt64ToTaggedValue(as_i64, true);
                    } else {
                        // Fallback: pack as null
                        arg = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
                    }
                }
                // If we have a tagged_value but function expects a C type, unpack it
                else if (actual_type == tagged_value_type && expected_type != tagged_value_type) {
                    // Extract raw data from tagged value and convert to expected type
                    Value* original_tagged = arg;
                    Value* data_i64 = unpackInt64FromTaggedValue(original_tagged);
                    if (expected_type->isPointerTy()) {
                        arg = builder->CreateIntToPtr(data_i64, expected_type);
                    } else if (expected_type->isIntegerTy(64)) {
                        arg = data_i64;
                    } else if (expected_type->isIntegerTy()) {
                        arg = builder->CreateTrunc(data_i64, expected_type);
                    } else if (expected_type->isDoubleTy()) {
                        arg = unpackDoubleFromTaggedValue(original_tagged);
                    } else if (expected_type->isFloatTy()) {
                        Value* as_double = unpackDoubleFromTaggedValue(original_tagged);
                        arg = builder->CreateFPTrunc(as_double, expected_type);
                    }
                }
                // Perform type conversion if necessary
                else if (actual_type != expected_type) {
                    if (actual_type->isIntegerTy() && expected_type->isIntegerTy()) {
                        // Integer to integer conversion
                        if (actual_type->getIntegerBitWidth() > expected_type->getIntegerBitWidth()) {
                            arg = builder->CreateTrunc(arg, expected_type);
                        } else if (actual_type->getIntegerBitWidth() < expected_type->getIntegerBitWidth()) {
                            arg = builder->CreateSExt(arg, expected_type);
                        }
                    } else if (actual_type->isFloatingPointTy() && expected_type->isFloatingPointTy()) {
                        // Float to float conversion
                        if (actual_type->isDoubleTy() && expected_type->isFloatTy()) {
                            arg = builder->CreateFPTrunc(arg, expected_type);
                        } else if (actual_type->isFloatTy() && expected_type->isDoubleTy()) {
                            arg = builder->CreateFPExt(arg, expected_type);
                        }
                    } else if (actual_type->isIntegerTy() && expected_type->isFloatingPointTy()) {
                        // Integer to float conversion
                        arg = builder->CreateSIToFP(arg, expected_type);
                    } else if (actual_type->isFloatingPointTy() && expected_type->isIntegerTy()) {
                        // Float to integer conversion
                        arg = builder->CreateFPToSI(arg, expected_type);
                    } else if (auto* global_value = dyn_cast<GlobalValue>(arg)) {
                        arg = builder->CreateLoad(global_value->getValueType(), global_value);
                    }
                }

                args.push_back(arg);
            } else if (arg && func_type->isVarArg()) {
                // For varargs C functions (like printf), unpack tagged values to native types
                if (arg->getType() == tagged_value_type) {
                    // Get the type from the tagged value
                    Value* type_byte = getTaggedValueType(arg);
                    Value* base_type = builder->CreateAnd(type_byte,
                        ConstantInt::get(int8_type, 0x0F));

                    // Check type and unpack appropriately
                    Value* is_string = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
                    Value* is_double = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));

                    // Extract the raw data field
                    Value* data_i64 = unpackInt64FromTaggedValue(arg);

                    // For the first arg position (format string in printf-like calls)
                    // or if it's a string type, convert to pointer
                    if (i == 0) {
                        // First arg is format string - must be pointer
                        arg = builder->CreateIntToPtr(data_i64, PointerType::getUnqual(*context));
                    } else {
                        // For other args, we need to handle based on type
                        // Use select to choose between double and int64
                        Value* as_double = unpackDoubleFromTaggedValue(arg);
                        // For printf, double args are passed as double, int args as int64
                        // We'll let the C varargs mechanism handle this
                        // Push as int64 for ints, double for doubles
                        arg = builder->CreateSelect(is_double,
                            builder->CreateBitCast(as_double, int64_type),
                            data_i64);
                    }
                }
                args.push_back(arg);
            }
        }
        
        // Add captured arguments for closure calls
        if (is_closure_call) {
            // ARITY FIX: Use actual capture count from nested_function_captures, not the difference
            // The old code `func_type->getNumParams() - op->call_op.num_vars` is wrong when
            // a function is called with fewer arguments than expected (arity mismatch)
            size_t actual_captures = 0;
            auto captures_it = nested_function_captures.find(func_name);
            if (captures_it != nested_function_captures.end()) {
                actual_captures = captures_it->second.size();
            } else {
                // LETREC FIX: For letrec bindings, func_name is "process" but captures
                // are registered under the actual lambda name (callee->getName()).
                // Try looking up by the lambda function's actual name.
                std::string lambda_name = callee->getName().str();
                captures_it = nested_function_captures.find(lambda_name);
                if (captures_it != nested_function_captures.end()) {
                    actual_captures = captures_it->second.size();
                    eshkol_debug("Found captures for %s under lambda name %s",
                                func_name.c_str(), lambda_name.c_str());
                }
            }

            // Calculate expected regular parameters (total params - captures)
            size_t expected_params = func_type->getNumParams() - actual_captures;

            // Check for arity mismatch
            if (op->call_op.num_vars != expected_params) {
                eshkol_error("Arity mismatch: %s expects %zu arguments but got %llu",
                            func_name.c_str(), expected_params, (unsigned long long)op->call_op.num_vars);
                return nullptr;
            }

            size_t num_captures = actual_captures;

            eshkol_debug("Closure call to %s needs %zu captured arguments",
                        func_name.c_str(), num_captures);

            // CLOSURE FIX: Load captures from the closure object, not from globals
            // The closure is stored in the variable we're calling (func_name)
            Value* closure_var = nullptr;
            bool found_in_local = false;
            auto var_it = symbol_table.find(func_name);
            if (var_it != symbol_table.end()) {
                found_in_local = true;
                closure_var = var_it->second;
            } else {
                auto global_it = global_symbol_table.find(func_name);
                if (global_it != global_symbol_table.end()) {
                    closure_var = global_it->second;
                }
            }

            if (closure_var) {
                // Load the closure tagged value (or use directly if Argument)
                Value* closure_tagged = nullptr;
                if (isa<AllocaInst>(closure_var)) {
                    closure_tagged = builder->CreateLoad(
                        dyn_cast<AllocaInst>(closure_var)->getAllocatedType(), closure_var);
                } else if (isa<GlobalVariable>(closure_var)) {
                    closure_tagged = builder->CreateLoad(
                        dyn_cast<GlobalVariable>(closure_var)->getValueType(), closure_var);
                } else if (isa<Argument>(closure_var)) {
                    // MUTABLE CAPTURE FIX: Handle Argument which may be pointer to closure or direct value
                    if (closure_var->getType()->isPointerTy()) {
                        // This is a pointer to a captured closure (from mutable capture fix)
                        // Load the tagged value from the pointer
                        closure_tagged = builder->CreateLoad(tagged_value_type, closure_var);
                    } else {
                        // Function parameters (captures) are already loaded values
                        closure_tagged = closure_var;
                    }
                } else if (isa<Function>(closure_var)) {
                    // This is a nested function definition - load captures from global variables
                    // Captures are stored with naming convention: lambda_name + "_capture_" + var_name
                    std::string lambda_name = dyn_cast<Function>(closure_var)->getName().str();
                    auto captures_it = nested_function_captures.find(lambda_name);
                    if (captures_it != nested_function_captures.end()) {
                        const std::vector<std::string>& capture_names = captures_it->second;
                        // MUTABLE CAPTURE FIX: Pass pointers to capture storage instead of values
                        for (const std::string& cap_name : capture_names) {
                            std::string capture_key = lambda_name + "_capture_" + cap_name;
                            auto cap_it = global_symbol_table.find(capture_key);
                            if (cap_it != global_symbol_table.end() && cap_it->second) {
                                // Pass pointer to storage, not the loaded value
                                args.push_back(cap_it->second);
                                eshkol_debug("Passing nested function capture pointer %s from global %s",
                                           cap_name.c_str(), capture_key.c_str());
                            } else {
                                eshkol_warn("Missing capture global: %s", capture_key.c_str());
                                // Create a null pointer for the capture slot
                                args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                            }
                        }
                        // Successfully handled captures for nested function - skip all fallback paths
                        closure_tagged = (Value*)-1;  // Non-null sentinel to skip fallback
                    } else {
                        // No captures registered - this might be a no-capture nested function
                        // MUTABLE CAPTURE FIX: Push null pointers (function signature expects pointers)
                        for (size_t i = 0; i < num_captures; i++) {
                            args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                        }
                        closure_tagged = (Value*)-1;  // Non-null sentinel to skip fallback
                    }
                }

                if (closure_tagged && closure_tagged != (Value*)-1 && closure_tagged->getType() == tagged_value_type) {
                    // Check at compile time if this is a known closure variable
                    // by looking up the _func entry
                    std::string func_key = func_name + "_func";
                    bool has_func_entry = (symbol_table.find(func_key) != symbol_table.end() ||
                                          global_symbol_table.find(func_key) != global_symbol_table.end());

                    if (has_func_entry) {
                        // This is a closure - unpack captures
                        Value* closure_ptr_i64 = unpackInt64FromTaggedValue(closure_tagged);
                        Value* closure_ptr = builder->CreateIntToPtr(closure_ptr_i64, PointerType::getUnqual(*context));

                        // Get pointer to env (second field of closure, offset 8 bytes)
                        Value* env_ptr_ptr = builder->CreateGEP(
                            int8_type, closure_ptr,
                            ConstantInt::get(int64_type, 8));
                        Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_ptr);

                        // MUTABLE CAPTURE FIX: Pass pointers to capture slots instead of values
                        // This allows the lambda to modify captures via set!
                        for (size_t i = 0; i < num_captures; i++) {
                            // Calculate offset: 8 (header) + i * 16 (sizeof tagged_value)
                            size_t offset = 8 + i * 16;
                            Value* capture_slot = builder->CreateGEP(
                                int8_type, env_ptr,
                                ConstantInt::get(int64_type, offset));
                            Value* capture_slot_typed = builder->CreateBitCast(
                                capture_slot, PointerType::getUnqual(*context));
                            // Pass pointer to slot, not the value
                            args.push_back(capture_slot_typed);
                            eshkol_debug("Passing capture slot pointer %zu at offset %zu", i, offset);
                        }
                    } else {
                        // This is a plain function or parameter - no captures to load
                        // The caller function expects captures but the callee doesn't have them
                        // MUTABLE CAPTURE FIX: Push null pointers
                        eshkol_debug("Calling non-closure function %s, pushing null capture pointers", func_name.c_str());
                        for (size_t i = 0; i < num_captures; i++) {
                            args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                        }
                    }
                } else if (closure_tagged != (Value*)-1) {
                    // Fallback: push null pointers (only if not already handled by Function* path)
                    eshkol_warn("Could not unpack closure for %s, using null capture pointers", func_name.c_str());
                    for (size_t i = 0; i < num_captures; i++) {
                        args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                    }
                }
            } else {
                // Fallback to old behavior for non-closure calls
                // MUTABLE CAPTURE FIX: Pass storage pointers, not values
                std::string lambda_name = callee->getName().str();
                for (size_t i = 0; i < num_captures; i++) {
                    std::string capture_key = lambda_name + "_capture_" + std::to_string(i);
                    auto it = global_symbol_table.find(capture_key);
                    if (it != global_symbol_table.end() && it->second) {
                        // Pass pointer to storage
                        args.push_back(it->second);
                    } else {
                        eshkol_error("Missing capture: %s", capture_key.c_str());
                        args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                    }
                }
            }
        }

        // Dereference global variables before passing them
        // MUTABLE CAPTURE FIX: Skip capture arguments - they're already pointers that should be passed as-is
        // Regular args are the first op->call_op.num_vars arguments; captures (if any) come after
        size_t regular_arg_count = op->call_op.num_vars;
        for (size_t i = 0; i < regular_arg_count && i < args.size(); ++i) {
            if (args[i]->getType()->isPointerTy()) {
                Value *pointed_value = args[i];
                if (auto* global_value = dyn_cast<GlobalValue>(pointed_value)) {
                    if (global_value->getLinkage() == GlobalValue::ExternalLinkage ||
                        global_value->getLinkage() == GlobalValue::WeakAnyLinkage) {
                        args[i] = builder->CreateLoad(
                            global_value->getValueType(),
                            global_value
                        );
                    }
                } else if (auto* local_value = dyn_cast<AllocaInst>(pointed_value)) {
                    args[i] = builder->CreateLoad(
                        local_value->getAllocatedType(),
                        local_value
                    );
                }
            }
        }
        // Note: Capture arguments (last num_captures args) are NOT dereferenced - they're storage pointers

        return builder->CreateCall(callee, args);
    }
    
    // HoTT-optimized binary arithmetic: when both types are known, skip runtime dispatch
    // Returns nullptr if optimization not possible (fall back to polymorphic path)
    Value* hottOptimizedBinaryArith(const TypedValue& left, const TypedValue& right,
                                     const std::string& operation) {
        using namespace eshkol::hott;

        // Both operands must have known HoTT types
        if (!left.hasKnownType() || !right.hasKnownType()) {
            return nullptr;
        }

        // SAFETY CHECK: Don't optimize if values are tagged_value structs
        // These require runtime dispatch to extract the actual value
        if (left.llvm_value->getType() == tagged_value_type ||
            right.llvm_value->getType() == tagged_value_type) {
            return nullptr;  // Fall back to polymorphic
        }

        // Use HoTT type system for promotion
        TypeId result_type = ctx_->hottTypes().promoteForArithmetic(
            left.hott_type, right.hott_type);

        // Only optimize for known numeric types
        if (result_type != BuiltinTypes::Int64 &&
            result_type != BuiltinTypes::Float64) {
            return nullptr;
        }

        Value* left_val = left.llvm_value;
        Value* right_val = right.llvm_value;

        // Result is Int64: both operands are integers
        if (result_type == BuiltinTypes::Int64) {
            // Ensure we have i64 values (handle bool, char)
            if (left_val->getType() != int64_type) {
                left_val = builder->CreateSExt(left_val, int64_type, "sext_left");
            }
            if (right_val->getType() != int64_type) {
                right_val = builder->CreateSExt(right_val, int64_type, "sext_right");
            }

            Value* result;
            if (operation == "add") {
                result = builder->CreateAdd(left_val, right_val, "hott_iadd");
            } else if (operation == "sub") {
                result = builder->CreateSub(left_val, right_val, "hott_isub");
            } else if (operation == "mul") {
                result = builder->CreateMul(left_val, right_val, "hott_imul");
            } else if (operation == "div") {
                result = builder->CreateSDiv(left_val, right_val, "hott_idiv");
            } else {
                return nullptr;
            }
            return packInt64ToTaggedValue(result, true);
        }

        // Result is Float64: at least one operand is float, or mixed int/float
        if (result_type == BuiltinTypes::Float64) {
            // Convert operands to double if needed
            Value* left_d = left_val;
            Value* right_d = right_val;

            if (left.hott_type == BuiltinTypes::Int64 ||
                left.hott_type == BuiltinTypes::Integer) {
                if (left_val->getType() != int64_type) {
                    left_val = builder->CreateSExt(left_val, int64_type);
                }
                left_d = builder->CreateSIToFP(left_val, double_type, "hott_itof_l");
            } else if (left_val->getType() != double_type) {
                left_d = builder->CreateFPExt(left_val, double_type);
            }

            if (right.hott_type == BuiltinTypes::Int64 ||
                right.hott_type == BuiltinTypes::Integer) {
                if (right_val->getType() != int64_type) {
                    right_val = builder->CreateSExt(right_val, int64_type);
                }
                right_d = builder->CreateSIToFP(right_val, double_type, "hott_itof_r");
            } else if (right_val->getType() != double_type) {
                right_d = builder->CreateFPExt(right_val, double_type);
            }

            Value* result;
            if (operation == "add") {
                result = builder->CreateFAdd(left_d, right_d, "hott_fadd");
            } else if (operation == "sub") {
                result = builder->CreateFSub(left_d, right_d, "hott_fsub");
            } else if (operation == "mul") {
                result = builder->CreateFMul(left_d, right_d, "hott_fmul");
            } else if (operation == "div") {
                result = builder->CreateFDiv(left_d, right_d, "hott_fdiv");
            } else {
                return nullptr;
            }
            return packDoubleToTaggedValue(result);
        }

        return nullptr;
    }

    Value* codegenArithmetic(const eshkol_operations_t* op, const std::string& operation) {
        // Handle unary minus: (- x) => negation
        if (op->call_op.num_vars == 1 && operation == "sub") {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
            if (!tv.llvm_value) return nullptr;
            Value* tagged = typedValueToTaggedValue(tv);
            // Create zero tagged value
            Value* zero = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
            // Return 0 - x
            return polymorphicSub(zero, tagged);
        }

        // Handle unary plus: (+ x) => identity
        if (op->call_op.num_vars == 1 && operation == "add") {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
            if (!tv.llvm_value) return nullptr;
            return typedValueToTaggedValue(tv);
        }

        if (op->call_op.num_vars < 2) {
            eshkol_warn("Arithmetic operation requires at least 2 arguments");
            return nullptr;
        }

        // Collect all operands with their HoTT types
        std::vector<TypedValue> typed_operands;
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            TypedValue tv = codegenTypedAST(&op->call_op.variables[i]);
            if (!tv.llvm_value) continue;
            typed_operands.push_back(tv);
        }

        if (typed_operands.empty()) return nullptr;

        // Check if ALL operands have known HoTT types - if so, use optimized path
        bool all_known = true;
        for (const auto& tv : typed_operands) {
            if (!tv.hasKnownType()) {
                all_known = false;
                break;
            }
        }

        if (all_known && typed_operands.size() >= 2) {
            // HoTT-optimized path: all types known at compile time
            TypedValue result = typed_operands[0];
            for (size_t i = 1; i < typed_operands.size(); i++) {
                Value* opt_result = hottOptimizedBinaryArith(result, typed_operands[i], operation);
                if (opt_result) {
                    // Update result with new HoTT type
                    eshkol::hott::TypeId new_type = ctx_->hottTypes().promoteForArithmetic(
                        result.hott_type, typed_operands[i].hott_type);
                    eshkol_value_type_t rt = (new_type == eshkol::hott::BuiltinTypes::Int64)
                        ? ESHKOL_VALUE_INT64 : ESHKOL_VALUE_DOUBLE;
                    result = TypedValue(opt_result, rt, new_type,
                                        new_type == eshkol::hott::BuiltinTypes::Int64);
                } else {
                    // Fall back to polymorphic path for this pair
                    all_known = false;
                    break;
                }
            }
            if (all_known) {
                return result.llvm_value;
            }
        }

        // Polymorphic fallback: convert to tagged values and use runtime dispatch
        std::vector<Value*> tagged_operands;
        for (const auto& tv : typed_operands) {
            tagged_operands.push_back(typedValueToTaggedValue(tv));
        }

        Value* result = tagged_operands[0];
        for (size_t i = 1; i < tagged_operands.size(); i++) {
            if (operation == "add") {
                result = polymorphicAdd(result, tagged_operands[i]);
            } else if (operation == "sub") {
                result = polymorphicSub(result, tagged_operands[i]);
            } else if (operation == "mul") {
                result = polymorphicMul(result, tagged_operands[i]);
            } else if (operation == "div") {
                result = polymorphicDiv(result, tagged_operands[i]);
            }
        }

        // Phase 3B: Keep result as tagged_value to preserve type information!
        // Don't unpack - variables will store tagged_value directly
        return result;
    }

    Value* codegenComparison(const eshkol_operations_t* op, const std::string& operation) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("Comparison operation requires exactly 2 arguments");
            return nullptr;
        }

        // Generate operands with type information
        TypedValue left_tv = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue right_tv = codegenTypedAST(&op->call_op.variables[1]);

        if (!left_tv.llvm_value || !right_tv.llvm_value) return nullptr;

        // HoTT TYPE-DIRECTED OPTIMIZATION: If both operands have known types,
        // use direct LLVM compare instructions instead of runtime dispatch
        Value* hott_result = hottOptimizedComparison(left_tv, right_tv, operation);
        if (hott_result) {
            return hott_result;  // Optimized path succeeded
        }

        // Fallback: Convert to tagged_value for runtime polymorphism
        Value* left_tagged = typedValueToTaggedValue(left_tv);
        Value* right_tagged = typedValueToTaggedValue(right_tv);

        // Call polymorphic comparison that handles runtime type detection
        return polymorphicCompare(left_tagged, right_tagged, operation);
    }

    // HoTT type-directed comparison optimization
    // Returns optimized result if both types are known, nullptr to fall back to polymorphic
    Value* hottOptimizedComparison(const TypedValue& left, const TypedValue& right,
                                    const std::string& operation) {
        using namespace eshkol::hott;

        // Only optimize if both types are known
        if (!left.hasKnownType() || !right.hasKnownType()) {
            return nullptr;
        }

        // SAFETY CHECK: Don't optimize if values are tagged_value structs
        // These require runtime dispatch to extract the actual value
        if (left.llvm_value->getType() == tagged_value_type ||
            right.llvm_value->getType() == tagged_value_type) {
            return nullptr;  // Fall back to polymorphic
        }

        // Get promoted type for comparison
        TypeId result_type = ctx_->hottTypes().promoteForArithmetic(
            left.hott_type, right.hott_type);

        Value* left_val = left.llvm_value;
        Value* right_val = right.llvm_value;

        // Integer comparison path
        if (result_type == BuiltinTypes::Int64 || result_type == BuiltinTypes::Integer ||
            result_type == BuiltinTypes::Natural) {
            // Ensure both are i64
            if (!left_val->getType()->isIntegerTy(64)) {
                if (left_val->getType()->isDoubleTy()) {
                    left_val = builder->CreateFPToSI(left_val, int64_type, "hott_ftoi_l");
                } else {
                    return nullptr;  // Can't convert this type
                }
            }
            if (!right_val->getType()->isIntegerTy(64)) {
                if (right_val->getType()->isDoubleTy()) {
                    right_val = builder->CreateFPToSI(right_val, int64_type, "hott_ftoi_r");
                } else {
                    return nullptr;  // Can't convert this type
                }
            }

            Value* cmp_result = nullptr;
            if (operation == "lt") {
                cmp_result = builder->CreateICmpSLT(left_val, right_val, "hott_icmp_lt");
            } else if (operation == "gt") {
                cmp_result = builder->CreateICmpSGT(left_val, right_val, "hott_icmp_gt");
            } else if (operation == "le") {
                cmp_result = builder->CreateICmpSLE(left_val, right_val, "hott_icmp_le");
            } else if (operation == "ge") {
                cmp_result = builder->CreateICmpSGE(left_val, right_val, "hott_icmp_ge");
            } else if (operation == "eq") {
                cmp_result = builder->CreateICmpEQ(left_val, right_val, "hott_icmp_eq");
            }

            if (cmp_result) {
                // Pack boolean result into tagged_value
                return packBoolToTaggedValue(cmp_result);
            }
        }

        // Float comparison path
        if (result_type == BuiltinTypes::Float64 || result_type == BuiltinTypes::Real) {
            // Promote both to double
            Value* left_d = left_val;
            Value* right_d = right_val;
            if (left_d->getType()->isIntegerTy(64)) {
                left_d = builder->CreateSIToFP(left_d, double_type, "hott_itof_l");
            } else if (!left_d->getType()->isDoubleTy()) {
                return nullptr;  // Can't convert this type
            }
            if (right_d->getType()->isIntegerTy(64)) {
                right_d = builder->CreateSIToFP(right_d, double_type, "hott_itof_r");
            } else if (!right_d->getType()->isDoubleTy()) {
                return nullptr;  // Can't convert this type
            }

            Value* cmp_result = nullptr;
            if (operation == "lt") {
                cmp_result = builder->CreateFCmpOLT(left_d, right_d, "hott_fcmp_lt");
            } else if (operation == "gt") {
                cmp_result = builder->CreateFCmpOGT(left_d, right_d, "hott_fcmp_gt");
            } else if (operation == "le") {
                cmp_result = builder->CreateFCmpOLE(left_d, right_d, "hott_fcmp_le");
            } else if (operation == "ge") {
                cmp_result = builder->CreateFCmpOGE(left_d, right_d, "hott_fcmp_ge");
            } else if (operation == "eq") {
                cmp_result = builder->CreateFCmpOEQ(left_d, right_d, "hott_fcmp_eq");
            }

            if (cmp_result) {
                // Pack boolean result into tagged_value
                return packBoolToTaggedValue(cmp_result);
            }
        }

        // Unknown type combination, fall back to polymorphic
        return nullptr;
    }
    
    
    Value* codegenMathFunction(const eshkol_operations_t* op, const std::string& func_name) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("%s requires exactly 1 argument", func_name.c_str());
            return nullptr;
        }

        // Get argument with type information
        TypedValue arg_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!arg_tv.llvm_value) return nullptr;

        // Convert to tagged_value for runtime type detection
        Value* arg_tagged = typedValueToTaggedValue(arg_tv);

        // Extract type tag
        Value* arg_type = getTaggedValueType(arg_tagged);
        Value* arg_base_type = builder->CreateAnd(arg_type,
            ConstantInt::get(int8_type, 0x0F));

        // Check if argument is a dual number
        Value* arg_is_dual = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));

        // REVERSE-MODE AD FIX: Check if argument is an AD node (for gradient/jacobian)
        Value* arg_is_ad_node = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* dual_path = BasicBlock::Create(*context, (func_name + "_dual_path").c_str(), current_func);
        BasicBlock* ad_node_path = BasicBlock::Create(*context, (func_name + "_ad_node_path").c_str(), current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, (func_name + "_check_dual").c_str(), current_func);
        BasicBlock* regular_path = BasicBlock::Create(*context, (func_name + "_regular_path").c_str(), current_func);
        BasicBlock* merge = BasicBlock::Create(*context, (func_name + "_merge").c_str(), current_func);

        // First check for AD node (reverse-mode AD)
        builder->CreateCondBr(arg_is_ad_node, ad_node_path, check_dual);

        // AD NODE PATH: Create new AD node for the unary operation
        builder->SetInsertPoint(ad_node_path);
        Value* ad_node_ptr_int = unpackInt64FromTaggedValue(arg_tagged);
        Value* ad_node_ptr = builder->CreateIntToPtr(ad_node_ptr_int, PointerType::getUnqual(*context));

        // Get the AD node operation type for this function
        uint32_t ad_op_type = 0;  // Default to constant if unknown
        if (func_name == "sin") ad_op_type = 6;       // AD_NODE_SIN
        else if (func_name == "cos") ad_op_type = 7;  // AD_NODE_COS
        else if (func_name == "exp") ad_op_type = 8;  // AD_NODE_EXP
        else if (func_name == "log") ad_op_type = 9;  // AD_NODE_LOG
        else if (func_name == "fabs") ad_op_type = 11; // Use NEG logic for abs (special case)

        Value* ad_result_node = nullptr;
        if (ad_op_type != 0) {
            // Call recordADNodeUnary with the correct operation type
            ad_result_node = recordADNodeUnary(ad_op_type, ad_node_ptr);
        } else {
            // For unsupported functions in AD mode, just pass through the input
            // (treating as identity function - not ideal but prevents crashes)
            ad_result_node = ad_node_ptr;
        }
        Value* ad_result_int = builder->CreatePtrToInt(ad_result_node, int64_type);
        Value* tagged_ad_result = packPtrToTaggedValue(ad_result_int, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // Check for dual number path
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(arg_is_dual, dual_path, regular_path);
        
        // PHASE 2: Dual number path - use dual math functions
        builder->SetInsertPoint(dual_path);
        Value* arg_dual = unpackDualFromTaggedValue(arg_tagged);
        Value* dual_result = nullptr;
        if (func_name == "sin") {
            dual_result = dualSin(arg_dual);
        } else if (func_name == "cos") {
            dual_result = dualCos(arg_dual);
        } else if (func_name == "exp") {
            dual_result = dualExp(arg_dual);
        } else if (func_name == "log") {
            dual_result = dualLog(arg_dual);
        } else if (func_name == "tan") {
            dual_result = dualTan(arg_dual);
        } else if (func_name == "tanh") {
            dual_result = dualTanh(arg_dual);
        } else if (func_name == "sinh") {
            dual_result = dualSinh(arg_dual);
        } else if (func_name == "cosh") {
            dual_result = dualCosh(arg_dual);
        } else if (func_name == "fabs") {
            dual_result = dualAbs(arg_dual);
        } else if (func_name == "sqrt") {
            dual_result = dualSqrt(arg_dual);
        } else {
            // For functions without dual number support, just call the regular function
            // and set derivative to 0 (treat as constant)
            auto [a, a_prime] = unpackDualNumber(arg_dual);
            Value* value = builder->CreateCall(function_table[func_name], {a});
            dual_result = packDualNumber(value, ConstantFP::get(double_type, 0.0));
        }
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        
        // Regular path: unpack argument and call regular function
        builder->SetInsertPoint(regular_path);
        
        // Check if argument is double or int64
        Value* arg_is_double = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        
        // Convert to double for math functions
        Value* arg_double = builder->CreateSelect(arg_is_double,
            unpackDoubleFromTaggedValue(arg_tagged),
            builder->CreateSIToFP(unpackInt64FromTaggedValue(arg_tagged), double_type));
        
        // Call the math function
        Value* result_double = builder->CreateCall(function_table[func_name], {arg_double});
        Value* tagged_regular_result = packDoubleToTaggedValue(result_double);
        builder->CreateBr(merge);
        
        // Merge paths
        builder->SetInsertPoint(merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 3, (func_name + "_result").c_str());
        result_phi->addIncoming(tagged_ad_result, ad_node_exit);  // AD node path (reverse-mode AD)
        result_phi->addIncoming(tagged_dual_result, dual_path);   // Dual number path (forward-mode AD)
        result_phi->addIncoming(tagged_regular_result, regular_path);  // Regular computation

        return result_phi;
    }

    // Polymorphic abs - preserves integer type for integers, uses fabs for doubles
    // HoTT TYPE SYSTEM: abs(Int64) -> Int64, abs(Float64) -> Float64
    Value* codegenAbs(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("abs requires exactly 1 argument");
            return nullptr;
        }

        // Get argument with type information
        TypedValue arg_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!arg_tv.llvm_value) return nullptr;

        // Convert to tagged_value for runtime type detection
        Value* arg_tagged = typedValueToTaggedValue(arg_tv);

        // Extract type tag
        Value* arg_type = getTaggedValueType(arg_tagged);
        Value* arg_base_type = builder->CreateAnd(arg_type,
            ConstantInt::get(int8_type, 0x0F));

        // Check type conditions
        Value* arg_is_dual = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));
        Value* arg_is_ad_node = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* arg_is_int = builder->CreateICmpEQ(arg_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* ad_node_path = BasicBlock::Create(*context, "abs_ad_node", current_func);
        BasicBlock* check_dual = BasicBlock::Create(*context, "abs_check_dual", current_func);
        BasicBlock* dual_path = BasicBlock::Create(*context, "abs_dual", current_func);
        BasicBlock* check_int = BasicBlock::Create(*context, "abs_check_int", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "abs_int", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "abs_double", current_func);
        BasicBlock* merge = BasicBlock::Create(*context, "abs_merge", current_func);

        // First check for AD node
        builder->CreateCondBr(arg_is_ad_node, ad_node_path, check_dual);

        // AD NODE PATH
        builder->SetInsertPoint(ad_node_path);
        Value* ad_node_ptr_int = unpackInt64FromTaggedValue(arg_tagged);
        Value* ad_node_ptr = builder->CreateIntToPtr(ad_node_ptr_int, PointerType::getUnqual(*context));
        Value* new_ad_node = recordADNodeUnary(12, ad_node_ptr);  // 12 = AD_NODE_ABS
        Value* new_ad_node_int = builder->CreatePtrToInt(new_ad_node, int64_type);
        Value* ad_result = packPtrToTaggedValue(new_ad_node_int, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(merge);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // Check for dual number
        builder->SetInsertPoint(check_dual);
        builder->CreateCondBr(arg_is_dual, dual_path, check_int);

        // DUAL PATH
        builder->SetInsertPoint(dual_path);
        Value* arg_dual = unpackDualFromTaggedValue(arg_tagged);
        Value* dual_result = dualAbs(arg_dual);
        Value* tagged_dual_result = packDualToTaggedValue(dual_result);
        builder->CreateBr(merge);
        BasicBlock* dual_exit = builder->GetInsertBlock();

        // Check for integer
        builder->SetInsertPoint(check_int);
        builder->CreateCondBr(arg_is_int, int_path, double_path);

        // INT PATH - compute integer absolute value: x < 0 ? -x : x
        builder->SetInsertPoint(int_path);
        Value* int_val = unpackInt64FromTaggedValue(arg_tagged);
        Value* is_negative = builder->CreateICmpSLT(int_val, ConstantInt::get(int64_type, 0));
        Value* neg_val = builder->CreateNeg(int_val);
        Value* abs_int = builder->CreateSelect(is_negative, neg_val, int_val);
        Value* tagged_int_result = packInt64ToTaggedValue(abs_int, true);  // exact
        builder->CreateBr(merge);
        BasicBlock* int_exit = builder->GetInsertBlock();

        // DOUBLE PATH - use fabs
        builder->SetInsertPoint(double_path);
        Value* double_val = unpackDoubleFromTaggedValue(arg_tagged);
        Value* abs_double = builder->CreateCall(function_table["fabs"], {double_val});
        Value* tagged_double_result = packDoubleToTaggedValue(abs_double);
        builder->CreateBr(merge);
        BasicBlock* double_exit = builder->GetInsertBlock();

        // Merge paths
        builder->SetInsertPoint(merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 4, "abs_result");
        result_phi->addIncoming(ad_result, ad_node_exit);
        result_phi->addIncoming(tagged_dual_result, dual_exit);
        result_phi->addIncoming(tagged_int_result, int_exit);
        result_phi->addIncoming(tagged_double_result, double_exit);

        return result_phi;
    }

    // Binary math function codegen (for atan2, fmod, fmin, fmax, remainder, etc.)
    Value* codegenBinaryMathFunction(const eshkol_operations_t* op, const std::string& func_name) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("%s requires exactly 2 arguments", func_name.c_str());
            return nullptr;
        }

        // Get both arguments
        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // Convert to double
        Value* val1 = extractDoubleFromTagged(arg1);
        Value* val2 = extractDoubleFromTagged(arg2);

        // Call the function
        Value* result = builder->CreateCall(function_table[func_name], {val1, val2});
        return packDoubleToTaggedValue(result);
    }

    // Modulo operation - handles both integer and floating point
    Value* codegenModulo(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("modulo requires exactly 2 arguments");
            return nullptr;
        }

        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // SCHEME SEMANTICS: modulo is defined for integers only
        // Convert all values to integers (truncate floats) and return integer result
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);
        bool arg1_is_double = arg1->getType()->isDoubleTy();
        bool arg2_is_double = arg2->getType()->isDoubleTy();
        bool arg1_is_tagged = arg1->getType() == tagged_value_type;
        bool arg2_is_tagged = arg2->getType() == tagged_value_type;

        // Convert all values to int64 for integer modulo
        Value* int_val1 = nullptr;
        Value* int_val2 = nullptr;

        // Convert arg1 to int64
        if (arg1_is_int64) {
            int_val1 = arg1;
        } else if (arg1_is_double) {
            int_val1 = builder->CreateFPToSI(arg1, int64_type);
        } else if (arg1_is_tagged) {
            // Extract as double first, then truncate to int
            Value* dval = extractDoubleFromTagged(arg1);
            int_val1 = builder->CreateFPToSI(dval, int64_type);
        }

        // Convert arg2 to int64
        if (arg2_is_int64) {
            int_val2 = arg2;
        } else if (arg2_is_double) {
            int_val2 = builder->CreateFPToSI(arg2, int64_type);
        } else if (arg2_is_tagged) {
            // Extract as double first, then truncate to int
            Value* dval = extractDoubleFromTagged(arg2);
            int_val2 = builder->CreateFPToSI(dval, int64_type);
        }

        if (!int_val1 || !int_val2) {
            eshkol_warn("modulo: failed to convert arguments to integers");
            return nullptr;
        }

        // Use integer SRem for modulo (Scheme modulo follows sign of divisor)
        // First compute remainder
        Value* rem = builder->CreateSRem(int_val1, int_val2, "rem");

        // Scheme's modulo: result has same sign as divisor
        // If signs differ and remainder is non-zero, add divisor
        Value* zero = ConstantInt::get(int64_type, 0);
        Value* rem_neg = builder->CreateICmpSLT(rem, zero);
        Value* div_neg = builder->CreateICmpSLT(int_val2, zero);
        Value* signs_differ = builder->CreateXor(rem_neg, div_neg);
        Value* rem_nonzero = builder->CreateICmpNE(rem, zero);
        Value* need_adjust = builder->CreateAnd(signs_differ, rem_nonzero);
        Value* adjusted = builder->CreateAdd(rem, int_val2);
        Value* result = builder->CreateSelect(need_adjust, adjusted, rem);

        return result;  // Return raw int64
    }

    // Remainder operation - handles both integer and floating point
    // Uses truncated division semantics (sign of result matches dividend)
    Value* codegenRemainder(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("remainder requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = tv1.llvm_value;
        Value* arg2 = tv2.llvm_value;

        // Check LLVM types
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);
        bool arg1_is_double = arg1->getType()->isDoubleTy();
        bool arg2_is_double = arg2->getType()->isDoubleTy();
        bool arg1_is_tagged = arg1->getType() == tagged_value_type;
        bool arg2_is_tagged = arg2->getType() == tagged_value_type;

        // Both raw integers - use direct integer remainder (SRem)
        if (arg1_is_int64 && arg2_is_int64) {
            Value* result = builder->CreateSRem(arg1, arg2);
            return result;  // Return raw int64
        }

        // Both raw doubles - use C's remainder function
        if (arg1_is_double && arg2_is_double) {
            return builder->CreateCall(function_table["remainder"], {arg1, arg2});
        }

        // Mixed types or tagged values - extract as double, then convert to int64 for integer remainder
        Value* val1 = arg1;
        Value* val2 = arg2;

        if (arg1_is_int64) {
            // Already int64, use directly
        } else if (arg1_is_double) {
            val1 = builder->CreateFPToSI(arg1, int64_type);
        } else if (arg1_is_tagged) {
            Value* extracted = extractDoubleFromTagged(arg1);
            val1 = builder->CreateFPToSI(extracted, int64_type);
        }

        if (arg2_is_int64) {
            // Already int64, use directly
        } else if (arg2_is_double) {
            val2 = builder->CreateFPToSI(arg2, int64_type);
        } else if (arg2_is_tagged) {
            Value* extracted = extractDoubleFromTagged(arg2);
            val2 = builder->CreateFPToSI(extracted, int64_type);
        }

        // Use integer remainder (SRem) to return int64
        return builder->CreateSRem(val1, val2);
    }

    // Integer quotient (truncated division)
    Value* codegenQuotient(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("quotient requires exactly 2 arguments");
            return nullptr;
        }

        Value* arg1 = codegenAST(&op->call_op.variables[0]);
        Value* arg2 = codegenAST(&op->call_op.variables[1]);
        if (!arg1 || !arg2) return nullptr;

        // FIXED: Handle raw int64/double values correctly
        bool arg1_is_int64 = arg1->getType()->isIntegerTy(64);
        bool arg2_is_int64 = arg2->getType()->isIntegerTy(64);

        // Both raw integers - use direct integer division
        if (arg1_is_int64 && arg2_is_int64) {
            return builder->CreateSDiv(arg1, arg2);  // Truncates toward zero
        }

        // Convert to double, divide, truncate
        Value* val1 = arg1;
        Value* val2 = arg2;

        if (arg1_is_int64) {
            val1 = builder->CreateSIToFP(arg1, double_type);
        } else if (arg1->getType()->isDoubleTy()) {
            // Already double
        } else if (arg1->getType() == tagged_value_type) {
            val1 = extractDoubleFromTagged(arg1);
        }

        if (arg2_is_int64) {
            val2 = builder->CreateSIToFP(arg2, double_type);
        } else if (arg2->getType()->isDoubleTy()) {
            // Already double
        } else if (arg2->getType() == tagged_value_type) {
            val2 = extractDoubleFromTagged(arg2);
        }

        Value* div_result = builder->CreateFDiv(val1, val2);
        Value* truncated = builder->CreateCall(function_table["trunc"], {div_result});
        return builder->CreateFPToSI(truncated, int64_type);
    }

    // GCD (Greatest Common Divisor) using Euclidean algorithm
    Value* codegenGCD(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("gcd requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        // Convert to int64 for GCD computation
        Value* a = tv1.llvm_value;
        Value* b = tv2.llvm_value;

        if (a->getType()->isDoubleTy()) {
            a = builder->CreateFPToSI(a, int64_type);
        } else if (a->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(a);
            a = builder->CreateFPToSI(extracted, int64_type);
        }

        if (b->getType()->isDoubleTy()) {
            b = builder->CreateFPToSI(b, int64_type);
        } else if (b->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(b);
            b = builder->CreateFPToSI(extracted, int64_type);
        }

        // Take absolute values (gcd is always positive)
        Value* zero = ConstantInt::get(int64_type, 0);
        Value* a_neg = builder->CreateICmpSLT(a, zero);
        a = builder->CreateSelect(a_neg, builder->CreateNeg(a), a);
        Value* b_neg = builder->CreateICmpSLT(b, zero);
        b = builder->CreateSelect(b_neg, builder->CreateNeg(b), b);

        // Euclidean algorithm using loop
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_bb = builder->GetInsertBlock();  // Save entry block
        BasicBlock* loop_bb = BasicBlock::Create(*context, "gcd_loop", current_func);
        BasicBlock* exit_bb = BasicBlock::Create(*context, "gcd_exit", current_func);

        builder->CreateBr(loop_bb);
        builder->SetInsertPoint(loop_bb);

        PHINode* a_phi = builder->CreatePHI(int64_type, 2, "a");
        PHINode* b_phi = builder->CreatePHI(int64_type, 2, "b");
        a_phi->addIncoming(a, entry_bb);
        b_phi->addIncoming(b, entry_bb);

        Value* b_is_zero = builder->CreateICmpEQ(b_phi, zero);

        // If b is zero, we're done (result is a)
        BasicBlock* continue_bb = BasicBlock::Create(*context, "gcd_continue", current_func);
        builder->CreateCondBr(b_is_zero, exit_bb, continue_bb);

        builder->SetInsertPoint(continue_bb);
        Value* new_a = b_phi;
        Value* new_b = builder->CreateSRem(a_phi, b_phi);
        a_phi->addIncoming(new_a, continue_bb);
        b_phi->addIncoming(new_b, continue_bb);
        builder->CreateBr(loop_bb);

        builder->SetInsertPoint(exit_bb);
        return a_phi;  // Return raw int64
    }

    // LCM (Least Common Multiple) = |a * b| / gcd(a, b)
    Value* codegenLCM(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("lcm requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper type handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        // Convert to int64
        Value* a = tv1.llvm_value;
        Value* b = tv2.llvm_value;

        if (a->getType()->isDoubleTy()) {
            a = builder->CreateFPToSI(a, int64_type);
        } else if (a->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(a);
            a = builder->CreateFPToSI(extracted, int64_type);
        }

        if (b->getType()->isDoubleTy()) {
            b = builder->CreateFPToSI(b, int64_type);
        } else if (b->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(b);
            b = builder->CreateFPToSI(extracted, int64_type);
        }

        // lcm(a, b) = |a| * (|b| / gcd(a, b))
        // First compute gcd inline using Euclidean algorithm
        Value* zero = ConstantInt::get(int64_type, 0);

        // Take absolute values
        Value* a_neg = builder->CreateICmpSLT(a, zero);
        Value* abs_a = builder->CreateSelect(a_neg, builder->CreateNeg(a), a);
        Value* b_neg = builder->CreateICmpSLT(b, zero);
        Value* abs_b = builder->CreateSelect(b_neg, builder->CreateNeg(b), b);

        // Special case: if either is 0, lcm is 0
        Value* a_is_zero = builder->CreateICmpEQ(abs_a, zero);
        Value* b_is_zero = builder->CreateICmpEQ(abs_b, zero);
        Value* either_zero = builder->CreateOr(a_is_zero, b_is_zero);

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_bb = builder->GetInsertBlock();  // Save the entry block
        BasicBlock* compute_bb = BasicBlock::Create(*context, "lcm_compute", current_func);
        BasicBlock* done_bb = BasicBlock::Create(*context, "lcm_done", current_func);

        builder->CreateCondBr(either_zero, done_bb, compute_bb);

        builder->SetInsertPoint(compute_bb);

        // Compute gcd using loop
        BasicBlock* gcd_loop = BasicBlock::Create(*context, "lcm_gcd_loop", current_func);
        BasicBlock* gcd_exit = BasicBlock::Create(*context, "lcm_gcd_exit", current_func);

        builder->CreateBr(gcd_loop);
        builder->SetInsertPoint(gcd_loop);

        PHINode* gcd_a = builder->CreatePHI(int64_type, 2, "gcd_a");
        PHINode* gcd_b = builder->CreatePHI(int64_type, 2, "gcd_b");
        gcd_a->addIncoming(abs_a, compute_bb);
        gcd_b->addIncoming(abs_b, compute_bb);

        Value* gcd_b_zero = builder->CreateICmpEQ(gcd_b, zero);

        BasicBlock* gcd_continue = BasicBlock::Create(*context, "lcm_gcd_continue", current_func);
        builder->CreateCondBr(gcd_b_zero, gcd_exit, gcd_continue);

        builder->SetInsertPoint(gcd_continue);
        Value* new_gcd_a = gcd_b;
        Value* new_gcd_b = builder->CreateSRem(gcd_a, gcd_b);
        gcd_a->addIncoming(new_gcd_a, gcd_continue);
        gcd_b->addIncoming(new_gcd_b, gcd_continue);
        builder->CreateBr(gcd_loop);

        builder->SetInsertPoint(gcd_exit);
        Value* gcd_result = gcd_a;

        // lcm = |a| * (|b| / gcd)
        Value* b_div_gcd = builder->CreateSDiv(abs_b, gcd_result);
        Value* lcm_result = builder->CreateMul(abs_a, b_div_gcd);
        builder->CreateBr(done_bb);

        builder->SetInsertPoint(done_bb);
        PHINode* result = builder->CreatePHI(int64_type, 2, "lcm_result");
        result->addIncoming(zero, entry_bb);  // Use saved entry block
        result->addIncoming(lcm_result, gcd_exit);

        return result;  // Return raw int64
    }

    // MIGRATED: Delegates to ArithmeticCodegen
    // Helper to convert any value to double
    Value* toDouble(Value* val) {
        return arith_->extractAsDouble(val);
    }

    // Min/Max - variadic, handles mixed types
    Value* codegenMinMax(const eshkol_operations_t* op, bool is_min) {
        if (op->call_op.num_vars < 1) {
            eshkol_warn("%s requires at least 1 argument", is_min ? "min" : "max");
            return nullptr;
        }

        // Start with first argument
        Value* result = codegenAST(&op->call_op.variables[0]);
        if (!result) return nullptr;
        Value* result_val = toDouble(result);

        // Compare with each subsequent argument
        for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&op->call_op.variables[i]);
            if (!arg) return nullptr;
            Value* arg_val = toDouble(arg);

            if (is_min) {
                result_val = builder->CreateCall(function_table["fmin"], {result_val, arg_val});
            } else {
                result_val = builder->CreateCall(function_table["fmax"], {result_val, arg_val});
            }
        }

        return result_val;  // Return raw double
    }

    // Power function (for expt alias)
    Value* codegenPow(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("pow/expt requires exactly 2 arguments");
            return nullptr;
        }

        Value* base = codegenAST(&op->call_op.variables[0]);
        Value* exp = codegenAST(&op->call_op.variables[1]);
        if (!base || !exp) return nullptr;

        Value* base_val = toDouble(base);
        Value* exp_val = toDouble(exp);
        return builder->CreateCall(function_table["pow"], {base_val, exp_val});
    }

    // MIGRATED: Delegates to ArithmeticCodegen
    // Helper to extract double from tagged value (handles both int and double)
    Value* extractDoubleFromTagged(Value* tagged) {
        return arith_->extractAsDouble(tagged);
    }

    // Extract string pointer from tagged value
    // Returns i8* pointer to the string, or null if not a string
    Value* extractStringFromTagged(Value* tagged) {
        if (!tagged) return nullptr;

        // Check if it's a string pointer type
        Value* type_val = getTaggedValueType(tagged);
        Value* base_type = builder->CreateAnd(type_val, ConstantInt::get(int8_type, 0x0F));
        Value* is_string = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));

        // Create branches to handle string vs non-string
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* string_block = BasicBlock::Create(*context, "is_string", current_func);
        BasicBlock* not_string_block = BasicBlock::Create(*context, "not_string", current_func);
        BasicBlock* merge_block = BasicBlock::Create(*context, "merge_string_extract", current_func);

        builder->CreateCondBr(is_string, string_block, not_string_block);

        // String path: extract pointer
        builder->SetInsertPoint(string_block);
        Value* str_int = unpackInt64FromTaggedValue(tagged);
        Value* str_ptr = builder->CreateIntToPtr(str_int, builder->getPtrTy());
        builder->CreateBr(merge_block);
        BasicBlock* string_exit = builder->GetInsertBlock();

        // Not string path: return null
        builder->SetInsertPoint(not_string_block);
        Value* null_ptr = ConstantPointerNull::get(builder->getPtrTy());
        builder->CreateBr(merge_block);
        BasicBlock* not_string_exit = builder->GetInsertBlock();

        // Merge
        builder->SetInsertPoint(merge_block);
        PHINode* result = builder->CreatePHI(builder->getPtrTy(), 2, "str_result");
        result->addIncoming(str_ptr, string_exit);
        result->addIncoming(null_ptr, not_string_exit);

        return result;
    }

    // MIGRATED: Delegates to ControlFlowCodegen
    // Helper to check if a tagged value is "truthy" (non-false, non-null, non-zero)
    Value* isTruthy(Value* val) {
        return flow_->isTruthy(val);
    }
    // MIGRATED: Short-circuit AND - delegates to ControlFlowCodegen
    Value* codegenAnd(const eshkol_operations_t* op) {
        return flow_->codegenAnd(op);
    }

    // MIGRATED: Short-circuit OR - delegates to ControlFlowCodegen
    Value* codegenOr(const eshkol_operations_t* op) {
        return flow_->codegenOr(op);
    }

    // MIGRATED: Cond expression - delegates to ControlFlowCodegen
    Value* codegenCond(const eshkol_operations_t* op) {
        return flow_->codegenCond(op);
    }

    // Exception handling: guard expression
    // Syntax: (guard (var clause ...) body ...)
    // Sets up setjmp handler, evaluates body, handles exceptions via clauses
    Value* codegenGuard(const eshkol_operations_t* op) {
        // Get runtime functions
        Function* push_handler_func = module->getFunction("eshkol_push_exception_handler");
        Function* pop_handler_func = module->getFunction("eshkol_pop_exception_handler");
        Function* get_exception_func = module->getFunction("eshkol_get_current_exception");
        Function* clear_exception_func = module->getFunction("eshkol_clear_current_exception");
        Function* setjmp_func = module->getFunction("setjmp");

        // Declare functions if not already declared
        if (!push_handler_func) {
            FunctionType* push_type = FunctionType::get(builder->getVoidTy(), {builder->getPtrTy()}, false);
            push_handler_func = Function::Create(push_type, Function::ExternalLinkage, "eshkol_push_exception_handler", module.get());
        }
        if (!pop_handler_func) {
            FunctionType* pop_type = FunctionType::get(builder->getVoidTy(), {}, false);
            pop_handler_func = Function::Create(pop_type, Function::ExternalLinkage, "eshkol_pop_exception_handler", module.get());
        }
        if (!get_exception_func) {
            FunctionType* get_type = FunctionType::get(builder->getPtrTy(), {}, false);
            get_exception_func = Function::Create(get_type, Function::ExternalLinkage, "eshkol_get_current_exception", module.get());
        }
        if (!clear_exception_func) {
            FunctionType* clear_type = FunctionType::get(builder->getVoidTy(), {}, false);
            clear_exception_func = Function::Create(clear_type, Function::ExternalLinkage, "eshkol_clear_current_exception", module.get());
        }
        if (!setjmp_func) {
            // setjmp takes a jmp_buf pointer and returns int
            FunctionType* setjmp_type = FunctionType::get(builder->getInt32Ty(), {builder->getPtrTy()}, false);
            setjmp_func = Function::Create(setjmp_type, Function::ExternalLinkage, "setjmp", module.get());
        }

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* entry_block = builder->GetInsertBlock();

        // Create basic blocks - IMPORTANT: setup_block is separate to avoid
        // corrupting the caller's block when we're nested inside another expression
        BasicBlock* setup_block = BasicBlock::Create(*context, "guard_setup", current_func);
        BasicBlock* try_block = BasicBlock::Create(*context, "guard_try", current_func);
        BasicBlock* handler_block = BasicBlock::Create(*context, "guard_handler", current_func);
        BasicBlock* done_block = BasicBlock::Create(*context, "guard_done", current_func);

        // Branch from entry to setup
        builder->CreateBr(setup_block);

        // Setup block: allocate jmp_buf, push handler, call setjmp
        builder->SetInsertPoint(setup_block);

        // Allocate jmp_buf on stack (platform-specific size, use 200 bytes to be safe)
        Type* jmp_buf_type = ArrayType::get(builder->getInt8Ty(), 200);
        Value* jmp_buf_alloc = builder->CreateAlloca(jmp_buf_type, nullptr, "jmp_buf");

        // Push exception handler
        builder->CreateCall(push_handler_func, {jmp_buf_alloc});

        // Call setjmp - returns 0 on first call, non-zero when longjmp is called
        Value* setjmp_result = builder->CreateCall(setjmp_func, {jmp_buf_alloc}, "setjmp_result");
        Value* is_exception = builder->CreateICmpNE(setjmp_result, ConstantInt::get(builder->getInt32Ty(), 0));

        builder->CreateCondBr(is_exception, handler_block, try_block);

        // Try block - evaluate body
        builder->SetInsertPoint(try_block);
        Value* body_result = nullptr;
        if (op->guard_op.body && op->guard_op.num_body_exprs > 0) {
            TypedValue body_typed = codegenTypedAST(&op->guard_op.body[0]);
            // Convert to tagged value to ensure consistent type for PHI node
            body_result = typedValueToTaggedValue(body_typed);
        }
        if (!body_result) {
            body_result = packNullToTaggedValue();
        }

        // After evaluating the body, check where we ended up
        // The body might have changed the insert point (e.g., nested guard, error)
        BasicBlock* body_end_block = builder->GetInsertBlock();
        bool body_end_terminated = body_end_block->getTerminator() != nullptr;

        BasicBlock* try_exit_block = nullptr;
        if (!body_end_terminated) {
            // Current block is not terminated - body completed normally
            // Continue from wherever we are (might be try_block or inner guard's done_block)
            builder->CreateCall(pop_handler_func, {});
            try_exit_block = builder->GetInsertBlock();
            builder->CreateBr(done_block);
        }
        // If body_end_block is terminated (e.g., by unreachable after error/raise),
        // control already diverged and we don't need to add anything

        // Handler block - exception was raised
        builder->SetInsertPoint(handler_block);

        // Pop handler first
        builder->CreateCall(pop_handler_func, {});

        // Get current exception
        Value* exception_ptr = builder->CreateCall(get_exception_func, {}, "exception_ptr");

        // Bind exception to variable in scope
        const char* var_name = op->guard_op.var_name;
        if (var_name) {
            // Pack exception pointer as tagged value
            Value* exc_tagged = packPtrToTaggedValue(exception_ptr, ESHKOL_VALUE_EXCEPTION);
            symbol_table[var_name] = exc_tagged;
        }

        // Evaluate guard clauses (similar to cond)
        Value* handler_result = nullptr;
        BasicBlock* handler_exit_block = nullptr;

        if (op->guard_op.num_clauses > 0) {
            std::vector<std::pair<Value*, BasicBlock*>> phi_inputs;

            for (uint64_t i = 0; i < op->guard_op.num_clauses; i++) {
                const eshkol_ast_t* clause = &op->guard_op.clauses[i];

                if (clause->type != ESHKOL_OP || clause->operation.op != ESHKOL_CALL_OP) {
                    continue;
                }

                // Check if this is an 'else' clause
                bool is_else = false;
                if (clause->operation.call_op.func &&
                    clause->operation.call_op.func->type == ESHKOL_VAR &&
                    clause->operation.call_op.func->variable.id) {
                    is_else = (strcmp(clause->operation.call_op.func->variable.id, "else") == 0);
                }

                if (is_else) {
                    // Evaluate body expressions
                    Value* result = nullptr;
                    for (uint64_t j = 0; j < clause->operation.call_op.num_vars; j++) {
                        TypedValue typed = codegenTypedAST(&clause->operation.call_op.variables[j]);
                        // Convert to tagged value for consistent PHI node type
                        result = typedValueToTaggedValue(typed);
                    }
                    if (!result) result = packNullToTaggedValue();

                    // Clear exception after handling
                    builder->CreateCall(clear_exception_func, {});

                    handler_exit_block = builder->GetInsertBlock();
                    phi_inputs.push_back({result, handler_exit_block});
                    builder->CreateBr(done_block);
                    break;
                } else {
                    // Evaluate test
                    TypedValue test_typed = codegenTypedAST(clause->operation.call_op.func);
                    Value* test = test_typed.llvm_value;
                    if (!test) continue;

                    Value* is_true = flow_->isTruthy(test);
                    BasicBlock* then_block = BasicBlock::Create(*context, "guard_clause_then", current_func);
                    BasicBlock* next_block = BasicBlock::Create(*context, "guard_clause_next", current_func);

                    builder->CreateCondBr(is_true, then_block, next_block);

                    // Then block - evaluate body expressions
                    builder->SetInsertPoint(then_block);
                    Value* result = nullptr;
                    for (uint64_t j = 0; j < clause->operation.call_op.num_vars; j++) {
                        TypedValue typed = codegenTypedAST(&clause->operation.call_op.variables[j]);
                        // Convert to tagged value for consistent PHI node type
                        result = typedValueToTaggedValue(typed);
                    }
                    if (!result) result = packNullToTaggedValue();

                    // Clear exception after handling
                    builder->CreateCall(clear_exception_func, {});

                    handler_exit_block = builder->GetInsertBlock();
                    phi_inputs.push_back({result, handler_exit_block});
                    builder->CreateBr(done_block);

                    // Continue to next clause
                    builder->SetInsertPoint(next_block);
                }
            }

            // If we fall through (no clause matched), re-raise
            // For now, just return the exception as-is
            if (builder->GetInsertBlock()->getTerminator() == nullptr) {
                // Re-get exception pointer since we may be in a different block
                Value* fallthrough_exc = builder->CreateCall(get_exception_func, {}, "fallthrough_exception");
                Value* exc_tagged = packPtrToTaggedValue(fallthrough_exc, ESHKOL_VALUE_EXCEPTION);
                phi_inputs.push_back({exc_tagged, builder->GetInsertBlock()});
                builder->CreateBr(done_block);
            }

            // Done block - merge results
            builder->SetInsertPoint(done_block);
            if (phi_inputs.size() == 1 && try_exit_block) {
                PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "guard_result");
                phi->addIncoming(body_result, try_exit_block);
                phi->addIncoming(phi_inputs[0].first, phi_inputs[0].second);
                return phi;
            } else if (phi_inputs.size() > 0) {
                // Calculate the number of incoming edges (with or without try_exit)
                size_t num_inputs = phi_inputs.size() + (try_exit_block ? 1 : 0);
                PHINode* phi = builder->CreatePHI(tagged_value_type, num_inputs, "guard_result");
                if (try_exit_block) {
                    phi->addIncoming(body_result, try_exit_block);
                }
                for (auto& [val, block] : phi_inputs) {
                    phi->addIncoming(val, block);
                }
                return phi;
            } else if (try_exit_block) {
                // No handler inputs but we have a normal exit
                return body_result;
            }
        } else {
            // No clauses - just return exception
            builder->CreateCall(clear_exception_func, {});
            Value* exc_tagged = packPtrToTaggedValue(exception_ptr, ESHKOL_VALUE_EXCEPTION);
            BasicBlock* handler_exit = builder->GetInsertBlock();  // Capture current block
            builder->CreateBr(done_block);

            builder->SetInsertPoint(done_block);
            if (try_exit_block) {
                PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "guard_result");
                phi->addIncoming(body_result, try_exit_block);
                phi->addIncoming(exc_tagged, handler_exit);  // Use captured block
                return phi;
            } else {
                // Body always throws, just return exception value
                return exc_tagged;
            }
        }

        return packNullToTaggedValue();
    }

    // Exception handling: raise expression
    // Syntax: (raise exception)
    // Simplified: Always create a new exception from the given value
    Value* codegenRaise(const eshkol_operations_t* op) {
        // Get or declare eshkol_raise function
        Function* raise_func = module->getFunction("eshkol_raise");
        if (!raise_func) {
            FunctionType* raise_type = FunctionType::get(builder->getVoidTy(), {builder->getPtrTy()}, false);
            raise_func = Function::Create(raise_type, Function::ExternalLinkage, "eshkol_raise", module.get());
            raise_func->setDoesNotReturn();
        }

        // Get or declare eshkol_make_exception function
        Function* make_exc_func = module->getFunction("eshkol_make_exception");
        if (!make_exc_func) {
            FunctionType* make_type = FunctionType::get(builder->getPtrTy(),
                {builder->getInt32Ty(), builder->getPtrTy()}, false);
            make_exc_func = Function::Create(make_type, Function::ExternalLinkage, "eshkol_make_exception", module.get());
        }

        // Evaluate exception expression and create exception object
        Value* error_msg = nullptr;
        if (op->raise_op.exception) {
            // Check if it's a string literal at compile time - optimize common case
            if (op->raise_op.exception->type == ESHKOL_STRING) {
                error_msg = codegenString(op->raise_op.exception->str_val.ptr);
            } else {
                // For other expressions, extract string at runtime
                Value* expr_val = codegenAST(op->raise_op.exception);
                if (expr_val) {
                    // extractStringFromTagged returns string ptr or null
                    // We need to handle the null case with a fallback
                    Value* extracted = extractStringFromTagged(expr_val);
                    // Check if extracted is null and use fallback
                    Value* is_null = builder->CreateICmpEQ(extracted,
                        ConstantPointerNull::get(builder->getPtrTy()));
                    Value* fallback = codegenString("user exception");
                    error_msg = builder->CreateSelect(is_null, fallback, extracted, "error_msg");
                }
            }
        }
        if (!error_msg) {
            error_msg = codegenString("raised exception");
        }

        // Create the exception object
        Value* exc = builder->CreateCall(make_exc_func, {
            ConstantInt::get(builder->getInt32Ty(), ESHKOL_EXCEPTION_USER_DEFINED),
            error_msg
        }, "new_exception");

        // Call raise (which doesn't return)
        builder->CreateCall(raise_func, {exc});
        builder->CreateUnreachable();

        // Return undef - this code path is unreachable, so the value doesn't matter
        // IMPORTANT: Don't call packNullToTaggedValue() here as it creates instructions
        // after the unreachable terminator, which is invalid LLVM IR
        return UndefValue::get(tagged_value_type);
    }

    // Helper function to compare two tagged values using eqv? semantics
    // Returns an i1 (boolean) value
    Value* callBuiltinEqv(Value* arg1, Value* arg2) {
        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(int8_type, 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(int8_type, 0x0F));

        // For eqv?, we check if types are "numeric compatible"
        Value* is_int1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_int2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_double1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* is_double2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* is_char1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CHAR));
        Value* is_char2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CHAR));

        // Both are numbers?
        Value* is_num1 = builder->CreateOr(is_int1, is_double1);
        Value* is_num2 = builder->CreateOr(is_int2, is_double2);
        Value* both_numbers = builder->CreateAnd(is_num1, is_num2);

        // Both are chars?
        Value* both_chars = builder->CreateAnd(is_char1, is_char2);

        // For same type comparison
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // For integers/chars, compare int values
        Value* data1 = unpackInt64FromTaggedValue(arg1);
        Value* data2 = unpackInt64FromTaggedValue(arg2);
        Value* int_equal = builder->CreateICmpEQ(data1, data2);

        // For doubles, use numeric equality
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double_equal = builder->CreateFCmpOEQ(double1, double2);

        // Same-type number comparison
        Value* both_int = builder->CreateAnd(is_int1, is_int2);
        Value* both_double = builder->CreateAnd(is_double1, is_double2);
        Value* same_type_num_equal = builder->CreateSelect(both_double, double_equal, int_equal);

        // eqv? for numbers: same type and equal value
        Value* num_result = builder->CreateAnd(types_match, same_type_num_equal);

        // eqv? for chars: compare char codes
        Value* char_result = builder->CreateAnd(both_chars, int_equal);

        // For non-numbers, fall back to eq? semantics (type + pointer/value equality)
        Value* non_num_result = builder->CreateAnd(types_match, int_equal);

        // Select based on whether we're comparing numbers or chars
        Value* result = builder->CreateSelect(both_numbers, num_result,
            builder->CreateSelect(both_chars, char_result, non_num_result));

        return result;
    }

    // MIGRATED: Case expression - delegates to ControlFlowCodegen
    Value* codegenCase(const eshkol_operations_t* op) {
        return flow_->codegenCase(op);
    }

    // Do loop: (do ((var init step) ...) ((test) result ...) body ...)
    // Parser structure: call_op.func = CONS(bindings-list, test-clause)
    //                   call_op.variables = body expressions
    // Where bindings-list is CALL_OP with CONS bindings (var, CONS(init, step))
    // And test-clause is CONS(test, results-list)
    Value* codegenDo(const eshkol_operations_t* op) {
        if (!op->call_op.func || op->call_op.func->type != ESHKOL_CONS) {
            eshkol_warn("do requires properly formed structure");
            return nullptr;
        }

        const eshkol_ast_t* main_cons = op->call_op.func;
        const eshkol_ast_t* bindings_list = main_cons->cons_cell.car;
        const eshkol_ast_t* test_clause = main_cons->cons_cell.cdr;

        if (!bindings_list || !test_clause || test_clause->type != ESHKOL_CONS) {
            eshkol_warn("do: invalid bindings or test clause");
            return nullptr;
        }

        const eshkol_ast_t* test_ast = test_clause->cons_cell.car;
        const eshkol_ast_t* results_list = test_clause->cons_cell.cdr;

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Create basic blocks
        BasicBlock* init_block = builder->GetInsertBlock();  // We're already in the entry
        BasicBlock* loop_header = BasicBlock::Create(*context, "do_loop_header", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "do_loop_body", current_func);
        BasicBlock* loop_step = BasicBlock::Create(*context, "do_loop_step", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "do_loop_exit", current_func);

        // Collect binding information
        std::vector<std::string> var_names;
        std::vector<Value*> var_allocas;
        std::vector<const eshkol_ast_t*> step_exprs;

        // Initialize loop variables
        if (bindings_list->type == ESHKOL_OP && bindings_list->operation.op == ESHKOL_CALL_OP) {
            for (uint64_t i = 0; i < bindings_list->operation.call_op.num_vars; i++) {
                const eshkol_ast_t* binding = &bindings_list->operation.call_op.variables[i];
                if (binding->type != ESHKOL_CONS) continue;

                const eshkol_ast_t* var_ast = binding->cons_cell.car;
                const eshkol_ast_t* inner_cons = binding->cons_cell.cdr;
                if (!var_ast || !inner_cons || inner_cons->type != ESHKOL_CONS) continue;

                const eshkol_ast_t* init_ast = inner_cons->cons_cell.car;
                const eshkol_ast_t* step_ast = inner_cons->cons_cell.cdr;

                if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) continue;

                std::string var_name = var_ast->variable.id;
                var_names.push_back(var_name);
                step_exprs.push_back(step_ast);

                // Create alloca for loop variable
                Value* alloca = builder->CreateAlloca(tagged_value_type, nullptr, var_name + "_do");
                var_allocas.push_back(alloca);

                // Evaluate init expression and store
                TypedValue init_tv = codegenTypedAST(init_ast);
                if (!init_tv.llvm_value) {
                    eshkol_warn("do: failed to evaluate init expression");
                    continue;
                }
                Value* init_val = typedValueToTaggedValue(init_tv);
                builder->CreateStore(init_val, alloca);

                // Add to symbol table
                symbol_table[var_name] = alloca;
            }
        }

        // Branch to loop header
        builder->CreateBr(loop_header);

        // Loop header - test condition
        builder->SetInsertPoint(loop_header);

        TypedValue test_tv = codegenTypedAST(test_ast);
        if (!test_tv.llvm_value) {
            eshkol_warn("do: failed to evaluate test expression");
            return nullptr;
        }
        Value* test_val = typedValueToTaggedValue(test_tv);
        Value* is_done = isTruthy(test_val);

        builder->CreateCondBr(is_done, loop_exit, loop_body);

        // Loop body
        builder->SetInsertPoint(loop_body);

        // Execute body expressions
        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
            TypedValue body_tv = codegenTypedAST(&op->call_op.variables[i]);
            // Just evaluate, don't need the result
        }

        builder->CreateBr(loop_step);

        // Loop step - evaluate step expressions and update variables
        builder->SetInsertPoint(loop_step);

        // Evaluate all step expressions FIRST (before updating any variable)
        std::vector<Value*> new_values;
        for (size_t i = 0; i < var_names.size(); i++) {
            TypedValue step_tv = codegenTypedAST(step_exprs[i]);
            if (!step_tv.llvm_value) {
                eshkol_warn("do: failed to evaluate step expression");
                new_values.push_back(nullptr);
                continue;
            }
            Value* step_val = typedValueToTaggedValue(step_tv);
            new_values.push_back(step_val);
        }

        // Now update all variables simultaneously
        for (size_t i = 0; i < var_names.size(); i++) {
            if (new_values[i]) {
                builder->CreateStore(new_values[i], var_allocas[i]);
            }
        }

        builder->CreateBr(loop_header);

        // Loop exit - evaluate result expressions
        builder->SetInsertPoint(loop_exit);

        Value* result = packBoolToTaggedValue(ConstantInt::getFalse(*context));  // Default result

        if (results_list && results_list->type == ESHKOL_OP &&
            results_list->operation.op == ESHKOL_CALL_OP) {
            for (uint64_t i = 0; i < results_list->operation.call_op.num_vars; i++) {
                TypedValue result_tv = codegenTypedAST(&results_list->operation.call_op.variables[i]);
                if (result_tv.llvm_value) {
                    result = typedValueToTaggedValue(result_tv);
                }
            }
        }

        // Remove loop variables from symbol table
        for (const auto& var_name : var_names) {
            symbol_table.erase(var_name);
        }

        return result;
    }

    // MIGRATED: Logical NOT - delegates to ControlFlowCodegen
    Value* codegenNot(const eshkol_operations_t* op) {
        return flow_->codegenNot(op);
    }

    // MIGRATED: When conditional - delegates to ControlFlowCodegen
    Value* codegenWhen(const eshkol_operations_t* op) {
        return flow_->codegenWhen(op);
    }

    // MIGRATED: Unless conditional - delegates to ControlFlowCodegen
    Value* codegenUnless(const eshkol_operations_t* op) {
        return flow_->codegenUnless(op);
    }

    // Type predicates
    Value* codegenTypePredicate(const eshkol_operations_t* op, uint8_t expected_type) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("Type predicate requires exactly 1 argument");
            return nullptr;
        }

        // CRITICAL FIX: Use codegenTypedAST + typedValueToTaggedValue for proper type handling
        TypedValue tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!tv.llvm_value) return nullptr;
        Value* arg = typedValueToTaggedValue(tv);

        Value* type = getTaggedValueType(arg);
        Value* base_type = builder->CreateAnd(type, ConstantInt::get(int8_type, 0x0F));
        Value* matches = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, expected_type));

        return packBoolToTaggedValue(matches);
    }

    // ============================================================================
    // STRING FUNCTIONS
    // ============================================================================

    // Helper: Extract string pointer from tagged value
    Value* extractStringPtr(Value* tagged_val) {
        Value* ptr_int = unpackInt64FromTaggedValue(tagged_val);
        return builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
    }



    // ============================================================================
    // CHARACTER FUNCTIONS
    // ============================================================================

    // Helper: Pack a character (as integer codepoint) into tagged value
    Value* packCharToTaggedValue(Value* char_val) {
        // Save current insertion point
        IRBuilderBase::InsertPoint saved_ip = builder->saveIP();

        // Create alloca at function entry to ensure dominance
        Function* func = builder->GetInsertBlock()->getParent();
        if (func && !func->empty()) {
            BasicBlock& entry = func->getEntryBlock();
            builder->SetInsertPoint(&entry, entry.begin());
        }

        Value* tagged_val_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "char_tagged");

        // Restore insertion point for the actual stores
        builder->restoreIP(saved_ip);

        Value* type_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 0);
        builder->CreateStore(ConstantInt::get(int8_type, ESHKOL_VALUE_CHAR), type_ptr);
        Value* flags_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 1);
        builder->CreateStore(ConstantInt::get(int8_type, 0), flags_ptr);
        Value* reserved_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 2);
        builder->CreateStore(ConstantInt::get(int16_type, 0), reserved_ptr);
        Value* data_ptr = builder->CreateStructGEP(tagged_value_type, tagged_val_ptr, 4);

        // Ensure char_val is i64
        Value* char_as_i64;
        if (char_val->getType()->isIntegerTy(64)) {
            char_as_i64 = char_val;
        } else {
            char_as_i64 = builder->CreateZExt(char_val, int64_type);
        }
        builder->CreateStore(char_as_i64, data_ptr);
        return builder->CreateLoad(tagged_value_type, tagged_val_ptr);
    }

    // ============================================================================
    // SCHEME VECTOR FUNCTIONS (heterogeneous arrays)
    // ============================================================================

    // Vector structure: [i64 length][tagged_value_t elements...]
    // Each element size comes from LLVM's DataLayout for proper alignment

    // make-vector: Create a vector of given size, optionally filled with a value
    Value* codegenMakeVector(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 2) {
            eshkol_warn("make-vector requires 1 or 2 arguments");
            return nullptr;
        }

        TypedValue len_tv = codegenTypedAST(&op->call_op.variables[0]);
        if (!len_tv.llvm_value) return nullptr;

        Value* length = len_tv.llvm_value;

        // CRITICAL FIX: Convert to i64 if it's a tagged_value
        if (length->getType() == tagged_value_type) {
            length = unpackInt64FromTaggedValue(length);
        } else if (length->getType() != int64_type) {
            if (length->getType()->isIntegerTy()) {
                length = builder->CreateSExtOrTrunc(length, int64_type);
            } else if (length->getType()->isFloatingPointTy()) {
                length = builder->CreateFPToSI(length, int64_type);
            }
        }

        // Calculate allocation size: 8 (length) + sizeof(tagged_value) * length
        uint64_t tagged_value_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);
        Value* elem_size = ConstantInt::get(int64_type, tagged_value_size);
        Value* data_size = builder->CreateMul(length, elem_size);
        Value* total_size = builder->CreateAdd(data_size, ConstantInt::get(int64_type, 8));

        // Allocate from arena
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* vec_ptr = builder->CreateCall(getArenaAllocateFunc(), {arena_ptr, total_size});

        // Store length at beginning
        Value* len_ptr = builder->CreateBitCast(vec_ptr, PointerType::getUnqual(*context));
        builder->CreateStore(length, len_ptr);

        // Get fill value (default to #f/0 if not provided)
        Value* fill_val;
        if (op->call_op.num_vars == 2) {
            TypedValue fill_tv = codegenTypedAST(&op->call_op.variables[1]);
            fill_val = fill_tv.llvm_value;
            // MAKE-VECTOR FIX: Ensure fill value is a tagged_value
            if (fill_val && fill_val->getType() != tagged_value_type) {
                if (fill_val->getType()->isDoubleTy()) {
                    fill_val = packDoubleToTaggedValue(fill_val);
                } else if (fill_val->getType()->isIntegerTy(64)) {
                    fill_val = packInt64ToTaggedValue(fill_val, true);
                } else if (fill_val->getType()->isIntegerTy()) {
                    Value* ext = builder->CreateSExtOrTrunc(fill_val, int64_type);
                    fill_val = packInt64ToTaggedValue(ext, true);
                }
            }
        } else {
            fill_val = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
        }

        // Fill loop - store fill_val at each element position
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_header = BasicBlock::Create(*context, "vec_fill_header", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "vec_fill_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "vec_fill_exit", current_func);

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(int8_type, vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(*context));

        builder->CreateBr(loop_header);

        builder->SetInsertPoint(loop_header);
        PHINode* i = builder->CreatePHI(int64_type, 2, "fill_i");
        i->addIncoming(ConstantInt::get(int64_type, 0),
            loop_header->getSinglePredecessor());
        Value* done = builder->CreateICmpUGE(i, length);
        builder->CreateCondBr(done, loop_exit, loop_body);

        builder->SetInsertPoint(loop_body);
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, i);
        builder->CreateStore(fill_val, elem_ptr);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        i->addIncoming(next_i, loop_body);
        builder->CreateBr(loop_header);

        builder->SetInsertPoint(loop_exit);
        return packPtrToTaggedValue(vec_ptr, ESHKOL_VALUE_VECTOR_PTR);
    }

    // vector: Create a vector from given elements
    Value* codegenVector(const eshkol_operations_t* op) {
        uint64_t num_elems = op->call_op.num_vars;

        // Calculate allocation size: 8 (length) + sizeof(tagged_value) * num_elems
        uint64_t tagged_value_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);
        uint64_t total_size = 8 + tagged_value_size * num_elems;

        // Allocate from arena
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* vec_ptr = builder->CreateCall(getArenaAllocateFunc(),
            {arena_ptr, ConstantInt::get(int64_type, total_size)});

        // Store length at beginning
        Value* len_ptr = builder->CreateBitCast(vec_ptr, PointerType::getUnqual(*context));
        builder->CreateStore(ConstantInt::get(int64_type, num_elems), len_ptr);

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(int8_type, vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(*context));

        // Store each element - use codegenTypedAST to properly handle all types
        for (uint64_t i = 0; i < num_elems; i++) {
            TypedValue elem_tv = codegenTypedAST(&op->call_op.variables[i]);
            if (!elem_tv.llvm_value) return nullptr;

            // Convert TypedValue to tagged value for storage
            Value* tagged_elem = typedValueToTaggedValue(elem_tv);

            Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed,
                ConstantInt::get(int64_type, i));
            builder->CreateStore(tagged_elem, elem_ptr);
        }

        return packPtrToTaggedValue(vec_ptr, ESHKOL_VALUE_VECTOR_PTR);
    }

    // vector-ref: Get element at index
    Value* codegenSchemeVectorRef(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("vector-ref requires exactly 2 arguments");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        if (!vec_arg || !idx_tv.llvm_value) return nullptr;

        // Extract vector pointer
        Value* vec_ptr_int = unpackInt64FromTaggedValue(vec_arg);
        Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(int8_type, vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(*context));

        // Get element at index
        Value* idx = idx_tv.llvm_value;
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, idx);
        return builder->CreateLoad(tagged_value_type, elem_ptr);
    }

    // vector-set!: Set element at index
    Value* codegenSchemeVectorSet(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("vector-set! requires exactly 3 arguments");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        TypedValue idx_tv = codegenTypedAST(&op->call_op.variables[1]);
        TypedValue val_tv = codegenTypedAST(&op->call_op.variables[2]);
        if (!vec_arg || !idx_tv.llvm_value || !val_tv.llvm_value) return nullptr;

        // Extract vector pointer
        Value* vec_ptr_int = unpackInt64FromTaggedValue(vec_arg);
        Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());

        // Get pointer to elements (after length field)
        Value* elem_base = builder->CreateGEP(int8_type, vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* elem_base_typed = builder->CreateBitCast(elem_base, PointerType::getUnqual(*context));

        // Convert value to tagged value for storage
        Value* tagged_val = typedValueToTaggedValue(val_tv);

        // Set element at index - CRITICAL FIX: convert tagged_value to i64
        Value* idx = idx_tv.llvm_value;
        if (idx->getType() == tagged_value_type) {
            idx = unpackInt64FromTaggedValue(idx);
        } else if (idx->getType() != int64_type) {
            if (idx->getType()->isIntegerTy()) {
                idx = builder->CreateSExtOrTrunc(idx, int64_type);
            } else if (idx->getType()->isFloatingPointTy()) {
                idx = builder->CreateFPToSI(idx, int64_type);
            }
        }
        Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base_typed, idx);
        builder->CreateStore(tagged_val, elem_ptr);

        // Return unspecified (void) - return the vector
        return vec_arg;
    }

    // vector-length: Get length of vector or tensor
    Value* codegenVectorLength(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("vector-length requires exactly 1 argument");
            return nullptr;
        }

        Value* vec_arg = codegenAST(&op->call_op.variables[0]);
        if (!vec_arg) return nullptr;

        // Check if this is a tagged value or raw i64
        Value* length = nullptr;

        if (vec_arg->getType() == tagged_value_type) {
            // Get the type tag to distinguish vector vs tensor
            Value* type_tag = getTaggedValueType(vec_arg);
            Value* base_type = builder->CreateAnd(type_tag,
                ConstantInt::get(int8_type, 0x0F));

            // Check if it's a tensor (ESHKOL_VALUE_TENSOR_PTR = 6)
            Value* is_tensor = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));

            // Extract pointer
            Value* ptr_int = unpackInt64FromTaggedValue(vec_arg);
            Value* ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());

            // Create basic blocks for tensor vs vector paths
            Function* current_func = builder->GetInsertBlock()->getParent();
            BasicBlock* tensor_block = BasicBlock::Create(*context, "tensor_len", current_func);
            BasicBlock* vector_block = BasicBlock::Create(*context, "vector_len", current_func);
            BasicBlock* merge_block = BasicBlock::Create(*context, "len_merge", current_func);

            builder->CreateCondBr(is_tensor, tensor_block, vector_block);

            // Tensor path: load total_elements from field 3
            builder->SetInsertPoint(tensor_block);
            Value* total_elem_ptr = builder->CreateStructGEP(tensor_type, ptr, 3);
            Value* tensor_len = builder->CreateLoad(int64_type, total_elem_ptr);
            builder->CreateBr(merge_block);

            // Vector path: load length from beginning
            builder->SetInsertPoint(vector_block);
            Value* vec_len_ptr = builder->CreateBitCast(ptr, PointerType::getUnqual(*context));
            Value* vec_len = builder->CreateLoad(int64_type, vec_len_ptr);
            builder->CreateBr(merge_block);

            // Merge
            builder->SetInsertPoint(merge_block);
            PHINode* len_phi = builder->CreatePHI(int64_type, 2, "length");
            len_phi->addIncoming(tensor_len, tensor_block);
            len_phi->addIncoming(vec_len, vector_block);
            length = len_phi;
        } else if (vec_arg->getType()->isIntegerTy(64)) {
            // Raw i64 pointer (likely a tensor)
            Value* ptr = builder->CreateIntToPtr(vec_arg, builder->getPtrTy());
            // Assume tensor layout - read total_elements from field 3
            Value* total_elem_ptr = builder->CreateStructGEP(tensor_type, ptr, 3);
            length = builder->CreateLoad(int64_type, total_elem_ptr);
        } else {
            eshkol_warn("vector-length: unexpected argument type");
            return nullptr;
        }

        return packInt64ToTaggedValue(length, true);
    }

    // Numeric predicates
    Value* codegenNumericPredicate(const eshkol_operations_t* op, const std::string& pred) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("%s requires exactly 1 argument", pred.c_str());
            return nullptr;
        }

        // CRITICAL FIX: Use toDouble helper which handles raw int64/double/tagged_value
        Value* arg = codegenAST(&op->call_op.variables[0]);
        if (!arg) return nullptr;

        Value* val = toDouble(arg);
        Value* zero = ConstantFP::get(double_type, 0.0);
        Value* result;

        if (pred == "positive?") {
            result = builder->CreateFCmpOGT(val, zero);
        } else if (pred == "negative?") {
            result = builder->CreateFCmpOLT(val, zero);
        } else if (pred == "zero?") {
            result = builder->CreateFCmpOEQ(val, zero);
        } else if (pred == "even?") {
            Value* int_val = builder->CreateFPToSI(val, int64_type);
            Value* mod2 = builder->CreateSRem(int_val, ConstantInt::get(int64_type, 2));
            result = builder->CreateICmpEQ(mod2, ConstantInt::get(int64_type, 0));
        } else if (pred == "odd?") {
            Value* int_val = builder->CreateFPToSI(val, int64_type);
            Value* mod2 = builder->CreateSRem(int_val, ConstantInt::get(int64_type, 2));
            result = builder->CreateICmpNE(mod2, ConstantInt::get(int64_type, 0));
        } else {
            result = ConstantInt::getFalse(*context);
        }

        return packBoolToTaggedValue(result);
    }

    // eq? - Identity comparison (pointer equality for lists, value equality for primitives)
    Value* codegenEq(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("eq? requires exactly 2 arguments");
            return nullptr;
        }

        // Use codegenTypedAST for proper handling
        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(int8_type, 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(int8_type, 0x0F));

        // Types must be equal for eq?
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // SYMBOL FIX: Detect if we're comparing pointer types (STRING_PTR, CONS_PTR, etc.)
        Value* is_string_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* is_cons_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* is_closure_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        Value* is_ptr_type = builder->CreateOr(is_string_ptr, builder->CreateOr(is_cons_ptr, is_closure_ptr));

        // For pointer types, compare pointers; for integers, compare as int64
        Value* ptr1 = unpackPtrFromTaggedValue(arg1);
        Value* ptr2 = unpackPtrFromTaggedValue(arg2);
        Value* ptr_equal = builder->CreateICmpEQ(ptr1, ptr2);

        Value* int1 = unpackInt64FromTaggedValue(arg1);
        Value* int2 = unpackInt64FromTaggedValue(arg2);
        Value* int_equal = builder->CreateICmpEQ(int1, int2);

        Value* data_equal = builder->CreateSelect(is_ptr_type, ptr_equal, int_equal);

        // For doubles, use bitwise comparison (exact equality, not numeric)
        Value* is_double = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double1_bits = builder->CreateBitCast(double1, int64_type);
        Value* double2_bits = builder->CreateBitCast(double2, int64_type);
        Value* double_bits_equal = builder->CreateICmpEQ(double1_bits, double2_bits);

        // Select appropriate comparison based on type
        Value* value_equal = builder->CreateSelect(is_double, double_bits_equal, data_equal);

        // Both types and values must match
        Value* result = builder->CreateAnd(types_match, value_equal);

        return packBoolToTaggedValue(result);
    }

    // eqv? - Same as eq? in our implementation since we don't have characters
    // In Scheme, eqv? differs from eq? mainly for characters and some number cases
    Value* codegenEqv(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("eqv? requires exactly 2 arguments");
            return nullptr;
        }

        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        // Get types
        Value* type1 = getTaggedValueType(arg1);
        Value* type2 = getTaggedValueType(arg2);
        Value* base_type1 = builder->CreateAnd(type1, ConstantInt::get(int8_type, 0x0F));
        Value* base_type2 = builder->CreateAnd(type2, ConstantInt::get(int8_type, 0x0F));

        // For eqv?, we check if types are "numeric compatible"
        // Both must be numbers for numeric comparison, otherwise types must match exactly
        Value* is_int1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_int2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_double1 = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* is_double2 = builder->CreateICmpEQ(base_type2,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));

        // Both are numbers?
        Value* is_num1 = builder->CreateOr(is_int1, is_double1);
        Value* is_num2 = builder->CreateOr(is_int2, is_double2);
        Value* both_numbers = builder->CreateAnd(is_num1, is_num2);

        // For numbers with same type, compare values
        Value* types_match = builder->CreateICmpEQ(base_type1, base_type2);

        // For integers, compare int values
        Value* data1 = unpackInt64FromTaggedValue(arg1);
        Value* data2 = unpackInt64FromTaggedValue(arg2);
        Value* int_equal = builder->CreateICmpEQ(data1, data2);

        // For doubles, use numeric equality
        Value* double1 = unpackDoubleFromTaggedValue(arg1);
        Value* double2 = unpackDoubleFromTaggedValue(arg2);
        Value* double_equal = builder->CreateFCmpOEQ(double1, double2);

        // Same-type number comparison
        Value* both_int = builder->CreateAnd(is_int1, is_int2);
        Value* both_double = builder->CreateAnd(is_double1, is_double2);
        Value* same_type_num_equal = builder->CreateSelect(both_double, double_equal, int_equal);

        // eqv? for numbers: same type and equal value
        Value* num_result = builder->CreateAnd(types_match, same_type_num_equal);

        // For non-numbers, fall back to eq? semantics (type + pointer/value equality)
        // SYMBOL FIX: Use pointer comparison for pointer types
        Value* is_string_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
        Value* is_cons_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
        Value* is_closure_ptr = builder->CreateICmpEQ(base_type1,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        Value* is_ptr_type = builder->CreateOr(is_string_ptr, builder->CreateOr(is_cons_ptr, is_closure_ptr));

        Value* ptr1 = unpackPtrFromTaggedValue(arg1);
        Value* ptr2 = unpackPtrFromTaggedValue(arg2);
        Value* ptr_equal = builder->CreateICmpEQ(ptr1, ptr2);

        Value* non_num_data_equal = builder->CreateSelect(is_ptr_type, ptr_equal, int_equal);
        Value* non_num_result = builder->CreateAnd(types_match, non_num_data_equal);

        // Select based on whether we're comparing numbers
        Value* result = builder->CreateSelect(both_numbers, num_result, non_num_result);

        return packBoolToTaggedValue(result);
    }

    // equal? - Deep structural equality using runtime helper
    Value* codegenEqual(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("equal? requires exactly 2 arguments");
            return nullptr;
        }

        TypedValue tv1 = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv2 = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv1.llvm_value || !tv2.llvm_value) return nullptr;

        Value* arg1 = typedValueToTaggedValue(tv1);
        Value* arg2 = typedValueToTaggedValue(tv2);

        // Use the runtime deep equality function for all comparisons
        // This handles all edge cases: nested lists, empty lists (NULL vs CONS_PTR with null), etc.
        Value* arg1_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "equal_arg1");
        Value* arg2_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "equal_arg2");
        builder->CreateStore(arg1, arg1_ptr);
        builder->CreateStore(arg2, arg2_ptr);

        Value* result = builder->CreateCall(eshkol_deep_equal_func, {arg1_ptr, arg2_ptr});
        return packBoolToTaggedValue(result);
    }

    // NOTE: codegenNewline has been migrated to StringIOCodegen (strio_->newline)

    Value* codegenError(const eshkol_operations_t* op) {
        // Use exception system: create exception and raise it
        // This allows (error "msg" ...) to be caught by guard

        // Get or declare exception functions
        Function* make_exc_func = module->getFunction("eshkol_make_exception");
        if (!make_exc_func) {
            FunctionType* make_type = FunctionType::get(builder->getPtrTy(),
                {builder->getInt32Ty(), builder->getPtrTy()}, false);
            make_exc_func = Function::Create(make_type, Function::ExternalLinkage, "eshkol_make_exception", module.get());
        }

        Function* raise_func = module->getFunction("eshkol_raise");
        if (!raise_func) {
            FunctionType* raise_type = FunctionType::get(builder->getVoidTy(), {builder->getPtrTy()}, false);
            raise_func = Function::Create(raise_type, Function::ExternalLinkage, "eshkol_raise", module.get());
            raise_func->setDoesNotReturn();
        }

        // Build error message from first string argument (if any)
        Value* error_msg = codegenString("error");
        if (op->call_op.num_vars > 0) {
            TypedValue first_arg = codegenTypedAST(&op->call_op.variables[0]);
            if (first_arg.llvm_value) {
                Value* tagged_arg = typedValueToTaggedValue(first_arg);
                if (tagged_arg) {
                    Value* type_byte = builder->CreateExtractValue(tagged_arg, {0});
                    Value* data_i64 = builder->CreateExtractValue(tagged_arg, {4});

                    // Check if first arg is a string
                    Value* is_string = builder->CreateICmpEQ(type_byte,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));

                    Function* current_func = builder->GetInsertBlock()->getParent();
                    BasicBlock* check_block = builder->GetInsertBlock();
                    BasicBlock* string_block = BasicBlock::Create(*context, "error_str_msg", current_func);
                    BasicBlock* default_block = BasicBlock::Create(*context, "error_default_msg", current_func);
                    BasicBlock* continue_block = BasicBlock::Create(*context, "error_continue", current_func);

                    builder->CreateCondBr(is_string, string_block, default_block);

                    // String case: use as message
                    builder->SetInsertPoint(string_block);
                    Value* str_ptr = builder->CreateIntToPtr(data_i64, PointerType::get(*context, 0));
                    builder->CreateBr(continue_block);

                    // Default case: use "error"
                    builder->SetInsertPoint(default_block);
                    builder->CreateBr(continue_block);

                    // Merge
                    builder->SetInsertPoint(continue_block);
                    PHINode* msg_phi = builder->CreatePHI(builder->getPtrTy(), 2, "error_msg");
                    msg_phi->addIncoming(str_ptr, string_block);
                    msg_phi->addIncoming(error_msg, default_block);

                    error_msg = msg_phi;
                }
            }
        }

        // Create exception
        Value* exception = builder->CreateCall(make_exc_func, {
            ConstantInt::get(builder->getInt32Ty(), ESHKOL_EXCEPTION_ERROR),
            error_msg
        }, "error_exception");

        // Raise exception
        builder->CreateCall(raise_func, {exception});
        builder->CreateUnreachable();

        // Create a new block for any subsequent code (which would be dead code)
        // Don't terminate it yet - subsequent code might add instructions
        // It will be terminated later when we detect it's unreachable
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* dead_block = BasicBlock::Create(*context, "error_dead", current_func);
        builder->SetInsertPoint(dead_block);

        return packNullToTaggedValue();
    }

    // =========================================================================
    // SYSTEM & ENVIRONMENT / FILE SYSTEM FUNCTIONS
    // Moved to system_codegen.cpp - delegated via system_-> in dispatch
    // =========================================================================

    Value* codegenSequence(const eshkol_operations_t* op) {
        Value* last_value = nullptr;
        for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
            const eshkol_ast_t* expr = &op->sequence_op.expressions[i];
            last_value = codegenAST(expr);
        }
        return last_value;
    }

    Value* codegenExternVar(const eshkol_operations_t* op) {
        const char* var_name = op->extern_var_op.name;

        // Check if the variable is already in the symbol table
        auto it = symbol_table.find(var_name);
        if (it != symbol_table.end()) {
            return it->second;
        }

        // Map type strings to LLVM types
        auto mapStringToType = [this](const char* type_str) -> Type* {
            if (strcmp(type_str, "int") == 0) return int32_type;
            if (strcmp(type_str, "long") == 0) return int64_type;
            if (strcmp(type_str, "float") == 0) return Type::getFloatTy(*context);
            if (strcmp(type_str, "double") == 0) return double_type;
            if (strcmp(type_str, "char*") == 0 || strcmp(type_str, "string") == 0) {
                return PointerType::getUnqual(*context); // char*
            }
            // Default to int32 for unknown types
            eshkol_warn("Unknown type '%s', defaulting to int32", type_str);
            return int32_type;
        };

        // Get the LLVM type based on the operation's type string
        Type* var_type = mapStringToType(op->extern_var_op.type);

        // Create a global variable with external linkage
        GlobalVariable* externVar = new GlobalVariable(
            *module,
            var_type,
            false, // isConstant
            GlobalValue::ExternalLinkage,
            nullptr,
            var_name
        );

        // Add to symbol table so it can be used later
        symbol_table[var_name] = externVar;                                                                 
                                                                                                        
        eshkol_debug("Declared external variable: %s with type %s", var_name, op->extern_var_op.type);

        return externVar;
    }                        
    
    Value* codegenExtern(const eshkol_operations_t* op) {
        const char* return_type_str = op->extern_op.return_type;
        const char* func_name = op->extern_op.name;
        const char* real_func_name = op->extern_op.real_name ? op->extern_op.real_name : func_name;
        uint64_t num_params = op->extern_op.num_params;

        bool is_vaarg = false;
        
        eshkol_debug("Creating external function declaration: %s (real: %s)", func_name, real_func_name);
        
        // Map type strings to LLVM types
        auto mapStringToType = [this](const char* type_str) -> Type* {
            if (strcmp(type_str, "void") == 0) return void_type;
            if (strcmp(type_str, "int") == 0) return int32_type;
            if (strcmp(type_str, "long") == 0) return int64_type;
            if (strcmp(type_str, "float") == 0) return Type::getFloatTy(*context);
            if (strcmp(type_str, "double") == 0) return double_type;
            if (strcmp(type_str, "char*") == 0 || strcmp(type_str, "string") == 0) {
                return PointerType::getUnqual(*context);
            }
            if (strcmp(type_str, "...") == 0) return nullptr;
            // Default to int64 for unknown types
            eshkol_warn("Unknown type '%s', defaulting to int64", type_str);
            return int64_type;
        };
        
        // Get return type
        Type* return_type = mapStringToType(return_type_str);
        
        // Get parameter types
        std::vector<Type*> param_types;
        for (uint64_t i = 0; i < num_params; i++) {
            if (op->extern_op.parameters[i].type == ESHKOL_STRING) {
                Type* param_type = mapStringToType(op->extern_op.parameters[i].str_val.ptr);
                if (param_type != nullptr)
                    param_types.push_back(param_type);
                else
                    is_vaarg = true;
            } else {
                eshkol_warn("Parameter type must be a string, defaulting to int64");
                param_types.push_back(int64_type);
            }
        }
        
        // Create function type
        FunctionType* func_type = FunctionType::get(
            return_type, param_types, is_vaarg
        );
        
        // Create function declaration using the real function name
        Function* extern_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            real_func_name,
            module.get()
        );
        
        // Add to function table using the given name so it can be called by that name
        function_table[func_name] = extern_func;
        
        eshkol_info("Declared external function: %s (real: %s) with %llu parameters", 
                   func_name, real_func_name, (unsigned long long)num_params);
        
        // extern declarations don't return a value at runtime, just nullptr
        return nullptr;
    }
    
    // If expression - delegate to control flow module
    Value* codegenIfCall(const eshkol_operations_t* op) {
        return flow_->codegenIf(op);
    }

    // Begin sequence - delegate to control flow module
    Value* codegenBegin(const eshkol_operations_t* op) {
        return flow_->codegenBegin(op);
    }
    
    // NOTE: codegenCons, codegenCar, codegenCdr, codegenList, codegenNullCheck, codegenPairCheck
    // have been migrated to CollectionCodegen. See coll_->cons(), coll_->car(), etc.
    // ~1100 lines of old implementations removed (now in collection_codegen.cpp)

    Value* codegenConsCell(const eshkol_ast_t* ast) {
        // Generate code for a cons cell AST node using arena allocation
        if (!ast->cons_cell.car || !ast->cons_cell.cdr) {
            eshkol_error("Invalid cons cell structure");
            return nullptr;
        }
        
        // Production implementation: use arena allocation for cons cells
        Value* car_val = codegenAST(ast->cons_cell.car);
        Value* cdr_val = codegenAST(ast->cons_cell.cdr);
        
        if (!car_val || !cdr_val) return nullptr;
        
        // Use arena-based allocation for proper cons cell creation
        return codegenArenaConsCell(car_val, cdr_val);
    }

    // ===== TAIL CALL OPTIMIZATION SUPPORT =====
    // These functions detect and handle tail-recursive patterns to prevent stack overflow

    // State for tail call optimization during lambda codegen
    struct TailCallContext {
        std::string func_name = "";           // Name of function being compiled
        BasicBlock* loop_header = nullptr;    // Loop header for tail call transformation
        std::vector<AllocaInst*> param_allocas;  // Allocas for mutable parameters
        std::vector<std::string> param_names;    // Parameter names for lookup
        bool enabled = false;                 // Whether TCO is enabled for current lambda
    };
    TailCallContext tco_context = {};

    // Check if an AST node is in tail position within its parent
    // Note: IF_OP uses call_op structure with variables[0]=cond, [1]=then, [2]=else
    bool isInTailPosition(const eshkol_ast_t* expr, const eshkol_ast_t* body) {
        if (!expr || !body) return false;

        // Direct match - expr IS the body
        if (expr == body) return true;

        // Handle operations
        if (body->type == ESHKOL_OP) {
            const eshkol_operations_t* op = &body->operation;

            switch (op->op) {
                case ESHKOL_CALL_OP: {
                    // PARSER QUIRK: "if" is stored as CALL_OP with func name "if"
                    std::string call_name = (op->call_op.func && op->call_op.func->type == ESHKOL_VAR &&
                                            op->call_op.func->variable.id) ?
                                            op->call_op.func->variable.id : "";
                    if (call_name == "if") {
                        // IF is stored as CALL_OP: variables[0]=cond, [1]=then, [2]=else
                        // Both branches (then/else) are in tail position
                        if (op->call_op.num_vars >= 2 &&
                            isInTailPosition(expr, &op->call_op.variables[1])) {
                            return true;
                        }
                        if (op->call_op.num_vars >= 3 &&
                            isInTailPosition(expr, &op->call_op.variables[2])) {
                            return true;
                        }
                        return false;
                    }
                    // Regular call: check if expr IS this call
                    return (expr->type == ESHKOL_OP && &expr->operation == op);
                }

                case ESHKOL_IF_OP:
                    // IF_OP uses call_op: variables[0]=cond, [1]=then, [2]=else
                    // Both branches (then/else) are in tail position
                    if (op->call_op.num_vars >= 2 &&
                        isInTailPosition(expr, &op->call_op.variables[1])) {
                        return true;
                    }
                    if (op->call_op.num_vars >= 3 &&
                        isInTailPosition(expr, &op->call_op.variables[2])) {
                        return true;
                    }
                    return false;

                case ESHKOL_LET_OP:
                case ESHKOL_LET_STAR_OP:
                case ESHKOL_LETREC_OP:
                    // Body of let is in tail position
                    return isInTailPosition(expr, op->let_op.body);

                case ESHKOL_SEQUENCE_OP:
                    // Last expression in sequence is in tail position
                    if (op->sequence_op.num_expressions > 0) {
                        return isInTailPosition(expr,
                            &op->sequence_op.expressions[op->sequence_op.num_expressions - 1]);
                    }
                    return false;

                default:
                    return false;
            }
        }

        return false;
    }

    // Count ALL recursive calls (both tail and non-tail) to a specific function name
    size_t countAllRecursiveCalls(const eshkol_ast_t* ast, const std::string& func_name) {
        if (!ast) return 0;

        size_t count = 0;

        if (ast->type == ESHKOL_OP) {
            const eshkol_operations_t* op = &ast->operation;

            switch (op->op) {
                case ESHKOL_CALL_OP: {
                    std::string call_name = (op->call_op.func && op->call_op.func->type == ESHKOL_VAR &&
                                            op->call_op.func->variable.id) ?
                                            op->call_op.func->variable.id : "(unknown)";

                    // Handle "if" specially
                    if (call_name == "if") {
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            count += countAllRecursiveCalls(&op->call_op.variables[i], func_name);
                        }
                        break;
                    }

                    // Count if this is a recursive call
                    if (call_name == func_name) {
                        count++;
                    }
                    // Recurse into arguments
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        count += countAllRecursiveCalls(&op->call_op.variables[i], func_name);
                    }
                    break;
                }

                case ESHKOL_IF_OP:
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        count += countAllRecursiveCalls(&op->call_op.variables[i], func_name);
                    }
                    break;

                case ESHKOL_LET_OP:
                case ESHKOL_LET_STAR_OP:
                case ESHKOL_LETREC_OP:
                    for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                        const eshkol_ast_t* binding = &op->let_op.bindings[i];
                        if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                            count += countAllRecursiveCalls(binding->cons_cell.cdr, func_name);
                        }
                    }
                    count += countAllRecursiveCalls(op->let_op.body, func_name);
                    break;

                case ESHKOL_SEQUENCE_OP:
                    for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
                        count += countAllRecursiveCalls(&op->sequence_op.expressions[i], func_name);
                    }
                    break;

                case ESHKOL_LAMBDA_OP:
                    // Don't recurse into nested lambdas - they have their own scope
                    break;

                default:
                    break;
            }
        }
        return count;
    }

    // Find all tail calls to a specific function name in an AST
    // Note: IF_OP uses call_op structure with variables[0]=cond, [1]=then, [2]=else
    void findTailCalls(const eshkol_ast_t* ast, const eshkol_ast_t* body,
                       const std::string& func_name,
                       std::vector<const eshkol_operations_t*>& tail_calls) {
        if (!ast) return;

        if (ast->type == ESHKOL_OP) {
            const eshkol_operations_t* op = &ast->operation;

            switch (op->op) {
                case ESHKOL_CALL_OP: {
                    // Check if this is a call to the function we're looking for
                    std::string call_name = (op->call_op.func && op->call_op.func->type == ESHKOL_VAR &&
                                            op->call_op.func->variable.id) ?
                                            op->call_op.func->variable.id : "(unknown)";

                    // PARSER QUIRK: "if" is stored as CALL_OP with func name "if"
                    // Handle it specially as an if expression
                    if (call_name == "if") {
                        // IF is stored as CALL_OP: variables[0]=cond, [1]=then, [2]=else
                        // Both branches (then/else) are in tail position
                        if (op->call_op.num_vars >= 1) {
                            findTailCalls(&op->call_op.variables[0], body, func_name, tail_calls);
                        }
                        if (op->call_op.num_vars >= 2) {
                            findTailCalls(&op->call_op.variables[1], body, func_name, tail_calls);
                        }
                        if (op->call_op.num_vars >= 3) {
                            findTailCalls(&op->call_op.variables[2], body, func_name, tail_calls);
                        }
                        break;
                    }

                    if (op->call_op.func && op->call_op.func->type == ESHKOL_VAR &&
                        op->call_op.func->variable.id &&
                        std::string(op->call_op.func->variable.id) == func_name) {
                        // Check if this call is in tail position
                        bool in_tail = isInTailPosition(ast, body);
                        if (in_tail) {
                            tail_calls.push_back(op);
                        }
                    }
                    // Recurse into arguments
                    for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                        findTailCalls(&op->call_op.variables[i], body, func_name, tail_calls);
                    }
                    break;
                }

                case ESHKOL_IF_OP:
                    // IF_OP uses call_op: variables[0]=cond, [1]=then, [2]=else
                    // Search condition and both branches
                    if (op->call_op.num_vars >= 1) {
                        findTailCalls(&op->call_op.variables[0], body, func_name, tail_calls);
                    }
                    if (op->call_op.num_vars >= 2) {
                        findTailCalls(&op->call_op.variables[1], body, func_name, tail_calls);
                    }
                    if (op->call_op.num_vars >= 3) {
                        findTailCalls(&op->call_op.variables[2], body, func_name, tail_calls);
                    }
                    break;

                case ESHKOL_LET_OP:
                case ESHKOL_LET_STAR_OP:
                case ESHKOL_LETREC_OP:
                    // Search bindings
                    for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                        const eshkol_ast_t* binding = &op->let_op.bindings[i];
                        if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                            findTailCalls(binding->cons_cell.cdr, body, func_name, tail_calls);
                        }
                    }
                    findTailCalls(op->let_op.body, body, func_name, tail_calls);
                    break;

                case ESHKOL_SEQUENCE_OP:
                    for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
                        findTailCalls(&op->sequence_op.expressions[i], body, func_name, tail_calls);
                    }
                    break;

                case ESHKOL_LAMBDA_OP:
                    // Don't recurse into nested lambdas - they have their own scope
                    break;

                default:
                    break;
            }
        }
    }

    // Check if a lambda/function is self-tail-recursive (calls itself ONLY in tail position)
    // Returns true only if ALL recursive calls are in tail position
    bool isSelfTailRecursive(const eshkol_operations_t* op, const std::string& func_name) {
        if (!op) return false;

        // Get the body based on operation type
        const eshkol_ast_t* body = nullptr;
        if (op->op == ESHKOL_LAMBDA_OP) {
            body = op->lambda_op.body;
        } else if (op->op == ESHKOL_DEFINE_OP && op->define_op.is_function) {
            body = op->define_op.value;
        } else {
            return false;
        }

        if (!body) return false;

        // Count ALL recursive calls (both tail and non-tail)
        size_t total_recursive_calls = countAllRecursiveCalls(body, func_name);
        if (total_recursive_calls == 0) {
            return false;  // No recursive calls at all
        }

        // Find only the tail calls
        std::vector<const eshkol_operations_t*> tail_calls;
        findTailCalls(body, body, func_name, tail_calls);

        // TCO is only safe if ALL recursive calls are in tail position
        // If there are non-tail recursive calls, TCO would corrupt the block structure
        bool all_in_tail = (tail_calls.size() == total_recursive_calls);

        if (!all_in_tail) {
            eshkol_debug("TCO: %s has %zu recursive calls but only %zu in tail position - TCO disabled",
                        func_name.c_str(), total_recursive_calls, tail_calls.size());
        }

        return all_in_tail;
    }

    // Generate a tail call as a jump back to loop header (TCO transformation)
    // Uses the binding module's TCO context
    Value* codegenTailCallFromContext(const eshkol_operations_t* call_op,
                                       eshkol::BindingCodegen::TailCallContext& tco_ctx) {
        eshkol_debug("TCO: codegenTailCallFromContext called, enabled=%d, loop_header=%p",
                     tco_ctx.enabled, (void*)tco_ctx.loop_header);

        if (!tco_ctx.enabled || !tco_ctx.loop_header) {
            return nullptr;  // TCO not active, caller should use normal call
        }

        // Check arity matches
        if (call_op->call_op.num_vars != tco_ctx.param_allocas.size()) {
            eshkol_warn("TCO: arity mismatch in tail call to %s (expected %zu, got %llu)",
                       tco_ctx.func_name.c_str(), tco_ctx.param_allocas.size(),
                       (unsigned long long)call_op->call_op.num_vars);
            return nullptr;
        }

        eshkol_debug("TCO: Generating tail call jump for %s", tco_ctx.func_name.c_str());

        // Evaluate all arguments first (to temporaries)
        std::vector<Value*> new_values;
        for (uint64_t i = 0; i < call_op->call_op.num_vars; i++) {
            Value* arg = codegenAST(&call_op->call_op.variables[i]);
            if (!arg) {
                eshkol_error("TCO: Failed to evaluate argument %llu", (unsigned long long)i);
                return nullptr;
            }
            // Pack to tagged_value if needed
            if (arg->getType() != tagged_value_type) {
                if (arg->getType()->isIntegerTy(64)) {
                    arg = packInt64ToTaggedValue(arg, true);
                } else if (arg->getType()->isDoubleTy()) {
                    arg = packDoubleToTaggedValue(arg);
                } else {
                    TypedValue tv = detectValueType(arg);
                    arg = typedValueToTaggedValue(tv);
                }
            }
            new_values.push_back(arg);
        }

        // Store all new values to parameter allocas
        for (size_t i = 0; i < new_values.size(); i++) {
            builder->CreateStore(new_values[i], tco_ctx.param_allocas[i]);
        }

        // Create dummy value BEFORE the branch (can't add instructions after terminator)
        Value* dummy = packNullToTaggedValue();

        // Jump back to loop header
        builder->CreateBr(tco_ctx.loop_header);

        // Return the dummy value (this block is now terminated, caller won't use the value)
        return dummy;
    }
    // ===== END TAIL CALL OPTIMIZATION SUPPORT =====

    // Helper function to find free variables in a lambda body
    void findFreeVariables(const eshkol_ast_t* ast,
                          const std::unordered_map<std::string, Value*>& current_scope,
                          const eshkol_ast_t* parameters, uint64_t num_params,
                          std::vector<std::string>& free_vars) {
        if (!ast) return;

        switch (ast->type) {
            case ESHKOL_VAR: {
                std::string var_name = ast->variable.id;


                // Check if this variable is a parameter
                bool is_parameter = false;
                if (parameters) {
                    for (uint64_t i = 0; i < num_params; i++) {
                        if (parameters[i].type == ESHKOL_VAR &&
                            parameters[i].variable.id &&
                            var_name == parameters[i].variable.id) {
                            is_parameter = true;
                            break;
                        }
                    }
                }

                // If not a parameter and exists in current scope or REPL registry, it's a free variable
                if (!is_parameter) {
                    bool is_free_var = false;

                    // LETREC REFACTOR: Skip names that are letrec-bound (they're accessed via globals/allocas, not captures)
                    if (letrec_excluded_capture_names.find(var_name) != letrec_excluded_capture_names.end()) {
                        // This is a letrec-bound name - don't capture it
                        break;
                    }

                    // Check local symbol table first
                    if (current_scope.find(var_name) != current_scope.end()) {
                        Value* val = current_scope.at(var_name);
                        // Skip if it's a Function (built-ins, user-defined functions, etc.)
                        if (val && !isa<Function>(val)) {
                            is_free_var = true;
                        }
                    }
                    // REPL MODE: Also check REPL registry for cross-module variables
                    else if (g_repl_mode_enabled) {
                        std::lock_guard<std::mutex> lock(g_repl_mutex);
                        // Check if it's a variable in REPL registry
                        if (g_repl_symbol_addresses.find(var_name) != g_repl_symbol_addresses.end()) {
                            is_free_var = true;
                        }
                        // Also check if it's a lambda function that needs to be captured
                        else if (g_repl_function_addresses.find(var_name) != g_repl_function_addresses.end() ||
                                 g_repl_function_addresses.find(var_name + "_func") != g_repl_function_addresses.end()) {
                            is_free_var = true;
                        }
                    }

                    if (is_free_var) {
                        // Check if already in free_vars to avoid duplicates
                        if (std::find(free_vars.begin(), free_vars.end(), var_name) == free_vars.end()) {
                            free_vars.push_back(var_name);
                        }
                    }
                }
                break;
            }
            case ESHKOL_OP: {
                const eshkol_operations_t* op = &ast->operation;
                switch (op->op) {
                    case ESHKOL_CALL_OP: {
                        // CRITICAL: Also check the function expression - it could be a captured lambda!
                        if (op->call_op.func) {
                            findFreeVariables(op->call_op.func, current_scope, parameters, num_params, free_vars);
                        }
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            findFreeVariables(&op->call_op.variables[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    }
                    case ESHKOL_SEQUENCE_OP:
                        for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
                            findFreeVariables(&op->sequence_op.expressions[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_LET_OP: {
                        // CRITICAL: Handle let expressions to find free variables in bindings and body
                        // First, collect let-bound variable names (they shadow outer scope)
                        std::vector<std::string> let_bound_names;
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.car) {
                                const eshkol_ast_t* var_ast = binding->cons_cell.car;
                                if (var_ast->type == ESHKOL_VAR && var_ast->variable.id) {
                                    let_bound_names.push_back(var_ast->variable.id);
                                }
                            }
                        }

                        // Search binding VALUE expressions (they can reference outer scope)
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                                findFreeVariables(binding->cons_cell.cdr, current_scope, parameters, num_params, free_vars);
                            }
                        }

                        // Search let body - but let-bound variables should be treated as parameters
                        // Create extended parameter list including let-bound names
                        if (op->let_op.body) {
                            // We need to pass let-bound names as "virtual parameters" so they're not captured
                            // For simplicity, just search the body and filter out let-bound names after
                            findFreeVariables(op->let_op.body, current_scope, parameters, num_params, free_vars);

                            // Remove any let-bound names that were incorrectly added as free vars
                            for (const std::string& let_var : let_bound_names) {
                                free_vars.erase(std::remove(free_vars.begin(), free_vars.end(), let_var), free_vars.end());
                            }
                        }
                        break;
                    }
                    case ESHKOL_LET_STAR_OP:
                    case ESHKOL_LETREC_OP: {
                        // Handle let* and letrec expressions the same way as let
                        std::vector<std::string> let_bound_names;
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.car) {
                                const eshkol_ast_t* var_ast = binding->cons_cell.car;
                                if (var_ast->type == ESHKOL_VAR && var_ast->variable.id) {
                                    let_bound_names.push_back(var_ast->variable.id);
                                }
                            }
                        }

                        // Search binding VALUE expressions
                        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
                            const eshkol_ast_t* binding = &op->let_op.bindings[i];
                            if (binding->type == ESHKOL_CONS && binding->cons_cell.cdr) {
                                findFreeVariables(binding->cons_cell.cdr, current_scope, parameters, num_params, free_vars);
                            }
                        }

                        // Search let body
                        if (op->let_op.body) {
                            findFreeVariables(op->let_op.body, current_scope, parameters, num_params, free_vars);

                            // Remove let-bound names from free vars
                            for (const std::string& let_var : let_bound_names) {
                                free_vars.erase(std::remove(free_vars.begin(), free_vars.end(), let_var), free_vars.end());
                            }
                        }
                        break;
                    }
                    case ESHKOL_LAMBDA_OP:
                        // Nested lambda - search its body too (but its parameters are bound)
                        if (op->lambda_op.body) {
                            findFreeVariables(op->lambda_op.body, current_scope,
                                             op->lambda_op.parameters, op->lambda_op.num_params, free_vars);
                        }
                        break;
                    case ESHKOL_COND_OP:
                        // Handle cond expressions - search all clauses
                        // cond uses call_op structure where each variable is a clause
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            const eshkol_ast_t* clause = &op->call_op.variables[i];
                            // Each clause is a CALL_OP: (test expr...)
                            if (clause->type == ESHKOL_OP && clause->operation.op == ESHKOL_CALL_OP) {
                                // The func is the test expression
                                if (clause->operation.call_op.func) {
                                    findFreeVariables(clause->operation.call_op.func, current_scope, parameters, num_params, free_vars);
                                }
                                // The variables are the body expressions
                                for (uint64_t j = 0; j < clause->operation.call_op.num_vars; j++) {
                                    findFreeVariables(&clause->operation.call_op.variables[j], current_scope, parameters, num_params, free_vars);
                                }
                            }
                        }
                        break;
                    case ESHKOL_AND_OP:
                    case ESHKOL_OR_OP:
                        // Handle and/or expressions - search all arguments
                        // NOTE: AND_OP/OR_OP use sequence_op structure, NOT call_op!
                        for (uint64_t i = 0; i < op->sequence_op.num_expressions; i++) {
                            findFreeVariables(&op->sequence_op.expressions[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_IF_OP:
                        // IF_OP uses call_op: variables[0]=cond, [1]=then, [2]=else
                        for (uint64_t i = 0; i < op->call_op.num_vars; i++) {
                            findFreeVariables(&op->call_op.variables[i], current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_DEFINE_OP:
                        // Handle define expressions - search the value
                        if (op->define_op.value) {
                            findFreeVariables(op->define_op.value, current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_SET_OP: {
                        // Handle set! - the variable being mutated may be a free variable
                        std::string set_var_name = op->set_op.name;

                        // LETREC REFACTOR: Skip names that are letrec-bound (they're accessed via globals, not captures)
                        if (letrec_excluded_capture_names.find(set_var_name) != letrec_excluded_capture_names.end()) {
                            // This is a letrec-bound name - don't capture it, just process the value
                            if (op->set_op.value) {
                                findFreeVariables(op->set_op.value, current_scope, parameters, num_params, free_vars);
                            }
                            break;
                        }

                        // Check if the variable being set is from outer scope
                        bool is_parameter = false;
                        if (parameters) {
                            for (uint64_t i = 0; i < num_params; i++) {
                                if (parameters[i].type == ESHKOL_VAR &&
                                    parameters[i].variable.id &&
                                    set_var_name == parameters[i].variable.id) {
                                    is_parameter = true;
                                    break;
                                }
                            }
                        }

                        // If not a parameter, check if it's in outer scope (free variable)
                        if (!is_parameter && current_scope.find(set_var_name) != current_scope.end()) {
                            Value* val = current_scope.at(set_var_name);
                            if (val && !isa<Function>(val)) {
                                if (std::find(free_vars.begin(), free_vars.end(), set_var_name) == free_vars.end()) {
                                    free_vars.push_back(set_var_name);
                                }
                            }
                        }

                        // Also search the value expression for free variables
                        if (op->set_op.value) {
                            findFreeVariables(op->set_op.value, current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    }
                    case ESHKOL_GRADIENT_OP:
                        // GRADIENT FREE VARS FIX: Search both function and point expressions
                        if (op->gradient_op.function) {
                            findFreeVariables(op->gradient_op.function, current_scope, parameters, num_params, free_vars);
                        }
                        if (op->gradient_op.point) {
                            findFreeVariables(op->gradient_op.point, current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_DERIVATIVE_OP:
                        // DERIVATIVE FREE VARS FIX: Search both function and point expressions
                        if (op->derivative_op.function) {
                            findFreeVariables(op->derivative_op.function, current_scope, parameters, num_params, free_vars);
                        }
                        if (op->derivative_op.point) {
                            findFreeVariables(op->derivative_op.point, current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    case ESHKOL_DIRECTIONAL_DERIV_OP:
                        // DIRECTIONAL_DERIV FREE VARS FIX: Search function, point, and direction
                        if (op->directional_deriv_op.function) {
                            findFreeVariables(op->directional_deriv_op.function, current_scope, parameters, num_params, free_vars);
                        }
                        if (op->directional_deriv_op.point) {
                            findFreeVariables(op->directional_deriv_op.point, current_scope, parameters, num_params, free_vars);
                        }
                        if (op->directional_deriv_op.direction) {
                            findFreeVariables(op->directional_deriv_op.direction, current_scope, parameters, num_params, free_vars);
                        }
                        break;
                    default:
                        break;
                }
                break;
            }
            case ESHKOL_CONS:
                if (ast->cons_cell.car) {
                    findFreeVariables(ast->cons_cell.car, current_scope, parameters, num_params, free_vars);
                }
                if (ast->cons_cell.cdr) {
                    findFreeVariables(ast->cons_cell.cdr, current_scope, parameters, num_params, free_vars);
                }
                break;
            default:
                break;
        }
    }

    Value* codegenLambda(const eshkol_operations_t* op) {
        // Generate anonymous function for lambda expression
        static int lambda_counter = 0;
        // Use module prefix to prevent symbol collisions when linking with stdlib.o
        std::string lambda_name = module_prefix + "_lambda_" + std::to_string(lambda_counter++);
        eshkol_debug("codegenLambda called, creating %s, current_function=%s",
                lambda_name.c_str(), current_function ? current_function->getName().str().c_str() : "null");

        // Find free variables in the lambda body
        std::vector<std::string> free_vars;
        findFreeVariables(op->lambda_op.body, symbol_table, op->lambda_op.parameters, op->lambda_op.num_params, free_vars);

        // VARIADIC FIX: Remove rest_param from free_vars if present (it's a parameter, not free)
        if (op->lambda_op.is_variadic && op->lambda_op.rest_param) {
            std::string rest_param_name = op->lambda_op.rest_param;
            auto it = std::find(free_vars.begin(), free_vars.end(), rest_param_name);
            if (it != free_vars.end()) {
                free_vars.erase(it);
                eshkol_debug("Removed rest param '%s' from free variables", rest_param_name.c_str());
            }
        }

        eshkol_debug("Lambda %s found %zu free variables", lambda_name.c_str(), free_vars.size());
        for (const std::string& var : free_vars) {
            eshkol_debug("  Free variable: %s", var.c_str());
        }
        
        // ===== PHASE 1: STORE CAPTURED VALUES IN GLOBAL VARIABLES =====
        // ARCHITECTURE: Captures are stored in GlobalVariable at lambda creation time.
        // This allows closures to persist values across function boundaries and avoids
        // cross-function Value* references which cause LLVM verification errors.
        
        // REPL MODE: Store capture names for gradient lookup
        if (g_repl_mode_enabled && !free_vars.empty()) {
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            g_repl_lambda_captures[lambda_name] = free_vars;
        }

        for (const std::string& var_name : free_vars) {
            Value* var_value = nullptr;
            Value* captured_val = nullptr;
            bool was_alloca = false;  // Track if original was let-bound (alloca)

            // Try local symbol table first, then global symbol table
            auto var_it = symbol_table.find(var_name);
            if (var_it != symbol_table.end() && var_it->second) {
                var_value = var_it->second;
                // Check if this is a let-bound alloca (not a TCO parameter alloca)
                // TCO converts parameters to allocas with names ending in "_tco"
                // We only want to create GlobalVariables for true let-bound variables
                if (isa<AllocaInst>(var_value)) {
                    std::string alloca_name = var_value->getName().str();
                    was_alloca = (alloca_name.find("_tco") == std::string::npos);
                }
            } else {
                // GLOBAL CAPTURE FIX: Also check global_symbol_table for global variables
                auto global_it = global_symbol_table.find(var_name);
                if (global_it != global_symbol_table.end() && global_it->second) {
                    var_value = global_it->second;
                    eshkol_debug("Capturing global variable: %s", var_name.c_str());
                }
            }

            if (var_value) {
                // Load actual value from storage location
                captured_val = var_value;
                if (isa<AllocaInst>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<AllocaInst>(var_value)->getAllocatedType(), var_value);
                } else if (isa<GlobalVariable>(var_value)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<GlobalVariable>(var_value)->getValueType(), var_value);
                } else if (isa<CallInst>(var_value) && var_value->getType()->isPointerTy()) {
                    // ARENA CAPTURE FIX: Handle arena-allocated storage (CallInst from arena_allocate)
                    // When a variable has been moved to arena storage by a previous lambda creation,
                    // symbol_table points to the CallInst result (a pointer). We need to load from it.
                    captured_val = builder->CreateLoad(tagged_value_type, var_value, var_name + "_arena_load");
                    eshkol_debug("Loading capture %s from arena storage", var_name.c_str());
                } else if (isa<Argument>(var_value)) {
                    // NESTED FUNCTION FIX: Check if the Argument belongs to the current function
                    Argument* arg = cast<Argument>(var_value);
                    Function* arg_parent = arg->getParent();
                    Function* current_func = builder->GetInsertBlock()->getParent();

                    if (arg_parent != current_func) {
                        // The Argument is from a different function (e.g., grandparent function)
                        // We need to find it in our function's capture parameters
                        bool found_in_captures = false;
                        for (auto& curr_arg : current_func->args()) {
                            std::string arg_name = curr_arg.getName().str();
                            if (arg_name == "captured_" + var_name) {
                                // Found the capture parameter in current function
                                if (curr_arg.getType()->isPointerTy()) {
                                    captured_val = builder->CreateLoad(tagged_value_type, &curr_arg);
                                } else {
                                    captured_val = &curr_arg;
                                }
                                found_in_captures = true;
                                eshkol_debug("Using current function's capture for %s (instead of outer arg)", var_name.c_str());
                                break;
                            }
                        }
                        if (!found_in_captures) {
                            // Check GlobalVariable captures
                            std::string capture_key = current_func->getName().str() + "_capture_" + var_name;
                            auto cap_it = global_symbol_table.find(capture_key);
                            if (cap_it != global_symbol_table.end() && isa<GlobalVariable>(cap_it->second)) {
                                captured_val = builder->CreateLoad(tagged_value_type, cap_it->second);
                                eshkol_debug("Using GlobalVariable capture for %s", var_name.c_str());
                            } else {
                                eshkol_warn("Cannot capture %s from outer function - not found in current function", var_name.c_str());
                                captured_val = nullptr;
                            }
                        }
                    } else if (var_value->getType()->isPointerTy()) {
                        // This is a pointer to a captured variable
                        captured_val = builder->CreateLoad(tagged_value_type, var_value);
                    } else {
                        // Function parameters are already loaded
                        captured_val = var_value;
                        eshkol_debug("Capturing function parameter: %s", var_name.c_str());
                    }
                }
            }
            // REPL MODE: Check REPL registry for cross-module captures
            else if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);

                // First check if it's a lambda function
                auto func_it = g_repl_function_addresses.find(var_name);
                if (func_it == g_repl_function_addresses.end()) {
                    func_it = g_repl_function_addresses.find(var_name + "_func");
                }

                if (func_it != g_repl_function_addresses.end()) {
                    // Capture is a lambda function - store function pointer as tagged value
                    uint64_t func_addr = func_it->second;
                    captured_val = packInt64ToTaggedValue(
                        ConstantInt::get(int64_type, func_addr), true);
                } else {
                    // Check if it's a regular variable
                    auto sym_it = g_repl_symbol_addresses.find(var_name);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for the global
                        GlobalVariable* global_var = module->getGlobalVariable(var_name);
                        if (!global_var) {
                            global_var = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,  // external - no initializer
                                var_name
                            );
                        }
                        // Load the captured value
                        captured_val = builder->CreateLoad(tagged_value_type, global_var);
                    }
                }
            }

            if (!captured_val) {
                continue;  // Skip this capture
            }

            // Ensure value is tagged_value
            if (captured_val->getType() != tagged_value_type) {
                if (captured_val->getType()->isIntegerTy(64)) {
                    captured_val = packInt64ToTaggedValue(captured_val, true);
                } else if (captured_val->getType()->isDoubleTy()) {
                    captured_val = packDoubleToTaggedValue(captured_val);
                } else if (isa<Function>(captured_val)) {
                    Value* func_addr = builder->CreatePtrToInt(captured_val, int64_type);
                    captured_val = packInt64ToTaggedValue(func_addr, true);
                } else {
                    TypedValue tv = detectValueType(captured_val);
                    captured_val = typedValueToTaggedValue(tv);
                }
            }

            // CLOSURE FIX: Don't create GlobalVariables for captures in Phase 1.
            // All captures are stored in the closure environment (created in the
            // closure allocation code below). This ensures:
            // 1. Each closure instance has its own captured values
            // 2. Recursive functions work correctly (no value overwriting)
            // 3. Higher-order functions work correctly
            //
            // The lambda body will access captures via capture parameters that
            // point to slots in the closure environment. set! inside the lambda
            // will modify those slots, allowing mutations to persist across calls.
            //
            // Note: This means the outer scope won't see set! mutations made inside
            // the lambda (the outer scope uses its original alloca). This is a
            // trade-off to make recursive functions and higher-order functions work.

        }
        
        // ===== END PHASE 1 =====

        // Create polymorphic function type - all parameters and return type are tagged_value
        // CLOSURE FIX: Include captures as additional parameters after declared params
        // VARIADIC FIX: For variadic lambdas, add an extra parameter for the rest list
        std::vector<Type*> param_types;
        for (uint64_t i = 0; i < op->lambda_op.num_params; i++) {
            param_types.push_back(tagged_value_type);
        }
        // For variadic lambdas, add a parameter for the rest list
        bool is_variadic = op->lambda_op.is_variadic && op->lambda_op.rest_param;
        if (is_variadic) {
            param_types.push_back(tagged_value_type);  // rest parameter (list of remaining args)
            eshkol_debug("Lambda %s is variadic with rest param: %s",
                        lambda_name.c_str(), op->lambda_op.rest_param);
        }
        // Add capture parameters - MUTABLE CAPTURE FIX: Use pointer type for captures
        // so set! can modify the closure environment directly
        for (size_t i = 0; i < free_vars.size(); i++) {
            param_types.push_back(PointerType::getUnqual(*context));  // Pointer to tagged_value
        }

        FunctionType* func_type = FunctionType::get(
            tagged_value_type, // return tagged_value
            param_types,
            false // not varargs - we handle variadics by passing a list
        );

        Function* lambda_func = Function::Create(
            func_type,
            Function::ExternalLinkage, // Use external linkage so it can be called
            lambda_name,
            module.get()
        );

        // Set parameter names
        auto arg_it = lambda_func->arg_begin();

        // Set names for declared parameters
        if (op->lambda_op.parameters) {
            for (uint64_t i = 0; i < op->lambda_op.num_params && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
                if (op->lambda_op.parameters[i].type == ESHKOL_VAR &&
                    op->lambda_op.parameters[i].variable.id) {
                    arg_it->setName(op->lambda_op.parameters[i].variable.id);
                }
            }
        }
        // Set name for rest parameter (variadic)
        if (is_variadic && arg_it != lambda_func->arg_end()) {
            arg_it->setName(op->lambda_op.rest_param);
            ++arg_it;
        }
        // Set names for capture parameters
        for (const std::string& var_name : free_vars) {
            if (arg_it != lambda_func->arg_end()) {
                arg_it->setName("captured_" + var_name);
                ++arg_it;
            }
        }
        
        // Create basic block for lambda body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", lambda_func);
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        builder->SetInsertPoint(entry);
        
        // Set current function and save previous state
        Function* prev_function = current_function;
        current_function = lambda_func;
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;
        
        // GLOBAL ARENA FIX: No per-lambda arena initialization needed
        // All lambdas share the global arena initialized in main
        
        // Add declared parameters to symbol table
        arg_it = lambda_func->arg_begin();
        if (op->lambda_op.parameters) {
            for (uint64_t i = 0; i < op->lambda_op.num_params && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
                if (op->lambda_op.parameters[i].type == ESHKOL_VAR &&
                    op->lambda_op.parameters[i].variable.id) {
                    symbol_table[op->lambda_op.parameters[i].variable.id] = &(*arg_it);
                }
            }
        }

        // VARIADIC FIX: Add rest parameter to symbol table
        if (is_variadic && arg_it != lambda_func->arg_end()) {
            symbol_table[op->lambda_op.rest_param] = &(*arg_it);
            eshkol_debug("Lambda uses rest parameter: %s", op->lambda_op.rest_param);
            ++arg_it;
        }

        // MUTABLE CAPTURE FIX: Handle captured variables from closure environment
        // For let-bound variables (allocas), the closure env contains a POINTER to the
        // original alloca (packed as int64). We unpack it and use it directly, so both
        // the lambda and the outer scope access the same storage.
        // For other captures (function params, globals), the closure env contains the
        // VALUE directly, and we use the closure env slot for storage.
        // IMPORTANT: TCO allocas (named *_tco) are function parameters, not let-bound.
        // They get new stack frames on each call, so we can't use pointer-passing for them.
        for (const std::string& var_name : free_vars) {
            if (arg_it != lambda_func->arg_end()) {
                // Check if the outer scope had an alloca for this variable
                // We detect this by checking prev_symbols
                auto outer_it = prev_symbols.find(var_name);
                bool was_alloca_capture = false;
                if (outer_it != prev_symbols.end() && outer_it->second) {
                    if (isa<AllocaInst>(outer_it->second)) {
                        // Check if this is a TCO alloca (function parameter) - these should NOT use pointer-passing
                        AllocaInst* alloca = cast<AllocaInst>(outer_it->second);
                        std::string alloca_name = alloca->getName().str();
                        // TCO allocas end with "_tco" - treat them like regular parameters
                        if (alloca_name.length() < 4 || alloca_name.substr(alloca_name.length() - 4) != "_tco") {
                            was_alloca_capture = true;
                        }
                    } else if (isa<IntToPtrInst>(outer_it->second)) {
                        // NESTED MUTABLE CAPTURE: IntToPtrInst means the outer scope is itself
                        // a lambda that captured a mutable variable via pointer-passing.
                        // We need to continue the pointer-passing chain.
                        was_alloca_capture = true;
                        eshkol_debug("Nested mutable capture detected for %s (outer is IntToPtrInst)", var_name.c_str());
                    } else if (isa<CallInst>(outer_it->second) && outer_it->second->getType()->isPointerTy()) {
                        // ARENA CAPTURE FIX: CallInst pointer means the outer scope moved this
                        // variable to arena storage when a previous lambda captured it.
                        // The closure contains a pointer to this arena storage (packed as int64).
                        // We need to unpack and use it to continue the pointer-passing chain.
                        was_alloca_capture = true;
                        eshkol_debug("Arena storage capture detected for %s (outer is CallInst)", var_name.c_str());
                    }
                }

                if (was_alloca_capture) {
                    // The capture argument contains a pointer to the outer scope's alloca
                    // (packed as int64 in tagged_value). Unpack and use directly.
                    // This allows set! to modify the original alloca.
                    Value* tagged_ptr = &(*arg_it);
                    if (tagged_ptr->getType()->isPointerTy()) {
                        tagged_ptr = builder->CreateLoad(tagged_value_type, tagged_ptr, "load_cap");
                    }
                    Value* ptr_int = unpackInt64FromTaggedValue(tagged_ptr);
                    Value* alloca_ptr = builder->CreateIntToPtr(ptr_int, PointerType::getUnqual(*context), var_name + "_ptr");
                    symbol_table[var_name] = alloca_ptr;
                    eshkol_debug("Lambda using alloca pointer for mutable capture %s", var_name.c_str());
                } else {
                    // Non-alloca capture - use the closure env slot directly
                    symbol_table[var_name] = &(*arg_it);
                    eshkol_debug("Lambda using closure env pointer for capture %s", var_name.c_str());
                }
                ++arg_it;
            } else {
                eshkol_warn("Missing capture parameter for %s", var_name.c_str());
            }
        }

        // TCO SETUP: Determine whether to use TCO for this lambda
        // Key insight: When letrec sets up TCO for a lambda:
        //   - tco_context.enabled = true
        //   - tco_context.loop_header = nullptr (not yet created)
        // When we're INSIDE a function that has TCO active (generating nested lambdas):
        //   - tco_context.enabled = true
        //   - tco_context.loop_header != nullptr (already created for outer function)
        //
        // So: Use TCO if enabled AND loop_header is null (this is the primary lambda)
        //     Save/clear/restore if loop_header is already set (nested lambda inside TCO function)
        eshkol::BindingCodegen::TailCallContext saved_tco_context;
        bool had_tco_active = binding_ && binding_->getTCOContext().enabled;
        bool is_nested_in_tco_func = had_tco_active && binding_->getTCOContext().loop_header != nullptr;

        if (is_nested_in_tco_func) {
            // Nested lambda inside a TCO function - save/clear/restore to prevent interference
            saved_tco_context = binding_->getTCOContext();
            binding_->getTCOContext().enabled = false;
            binding_->getTCOContext().loop_header = nullptr;
            eshkol_debug("TCO: Saving and clearing TCO context while generating nested lambda %s", lambda_name.c_str());
        }

        // Use TCO if letrec set it up for THIS lambda (enabled=true, loop_header=null)
        bool use_binding_tco = had_tco_active && !is_nested_in_tco_func;
        BasicBlock* tco_loop_bb = nullptr;

        if (use_binding_tco) {
            auto& tco_ctx = binding_->getTCOContext();
            eshkol_debug("TCO: Setting up loop structure for lambda (binding func=%s)", tco_ctx.func_name.c_str());

            // Convert parameters from Argument* to AllocaInst* for mutability
            tco_ctx.param_allocas.clear();
            tco_ctx.param_names.clear();

            // Re-iterate through parameters, create allocas, and update symbol table
            arg_it = lambda_func->arg_begin();
            if (op->lambda_op.parameters) {
                for (uint64_t i = 0; i < op->lambda_op.num_params && arg_it != lambda_func->arg_end(); ++i, ++arg_it) {
                    if (op->lambda_op.parameters[i].type == ESHKOL_VAR &&
                        op->lambda_op.parameters[i].variable.id) {
                        std::string param_name = op->lambda_op.parameters[i].variable.id;

                        // Create alloca for this parameter
                        AllocaInst* param_alloca = builder->CreateAlloca(
                            tagged_value_type, nullptr, param_name + "_tco");

                        // Store initial argument value
                        builder->CreateStore(&(*arg_it), param_alloca);

                        tco_ctx.param_allocas.push_back(param_alloca);
                        tco_ctx.param_names.push_back(param_name);
                        symbol_table[param_name] = param_alloca;  // Override with alloca
                    }
                }
            }

            // Create loop header block for tail calls to jump to
            tco_loop_bb = BasicBlock::Create(*context, "tco_loop", lambda_func);
            tco_ctx.loop_header = tco_loop_bb;

            // Branch from entry to loop body
            builder->CreateBr(tco_loop_bb);
            builder->SetInsertPoint(tco_loop_bb);
        }

        // Generate lambda body
        Value* body_result = nullptr;
        if (op->lambda_op.body) {
            body_result = codegenAST(op->lambda_op.body);
        }

        // Handle return based on TCO mode
        if (use_binding_tco) {
            // TCO mode: current block might be terminated by a tail call jump
            BasicBlock* current_bb = builder->GetInsertBlock();
            if (!current_bb->getTerminator()) {
                // Body didn't end with tail call, needs a return
                if (body_result) {
                    if (body_result->getType() == tagged_value_type) {
                        builder->CreateRet(body_result);
                    } else {
                        TypedValue typed = detectValueType(body_result);
                        Value* tagged = typedValueToTaggedValue(typed);
                        builder->CreateRet(tagged);
                    }
                } else {
                    builder->CreateRet(packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true));
                }
            }
            // Clear TCO context after lambda generation
            binding_->getTCOContext().loop_header = nullptr;
        } else {
            // Non-TCO: normal return handling
            if (body_result) {
                if (body_result->getType() == tagged_value_type) {
                    builder->CreateRet(body_result);
                } else {
                    TypedValue typed = detectValueType(body_result);
                    Value* tagged = typedValueToTaggedValue(typed);
                    builder->CreateRet(tagged);
                }
            } else {
                Value* null_tagged = packInt64ToTaggedValue(
                    ConstantInt::get(int64_type, 0), true);
                builder->CreateRet(null_tagged);
            }
        }
        
        // Restore previous state
        symbol_table = prev_symbols;
        current_function = prev_function;

        // TCO RESTORE: Restore the saved TCO context if we cleared it (for nested lambdas)
        if (is_nested_in_tco_func) {
            binding_->getTCOContext() = saved_tco_context;
            eshkol_debug("TCO: Restored TCO context after nested lambda %s", lambda_name.c_str());
        }

        // Add lambda function to function table so it can be called
        registerContextFunction(lambda_name, lambda_func);
        
        // CRITICAL FIX: Also add to global_symbol_table immediately for gradient/jacobian resolution
        // This allows autodiff operators to find lambdas WITHOUT changing evaluation order
        global_symbol_table[lambda_name] = lambda_func;
        eshkol_debug("Added lambda %s to global_symbol_table for autodiff resolution", lambda_name.c_str());
        
        // OPTION 3: Store lambda metadata for deferred S-expression generation
        // S-expressions will be generated in createMainWrapper() after all lambdas are compiled
        // This prevents basic block corruption from generating IR during lambda compilation
        pending_lambda_sexprs.push_back({op, lambda_name});
        lambda_ast_to_name[op] = lambda_name;  // MEMOIZATION FIX

        // Track last generated lambda name for codegenList to use
        last_generated_lambda_name = lambda_name;

        // CLOSURE FIX: Register lambda's captures so we can detect closures later
        if (!free_vars.empty()) {
            nested_function_captures[lambda_name] = free_vars;
            eshkol_debug("Registered %zu captures for lambda %s", free_vars.size(), lambda_name.c_str());
        }

        // VARIADIC FIX: Register variadic function info for call-site handling
        if (is_variadic) {
            variadic_function_info[lambda_name] = std::make_pair(op->lambda_op.num_params, true);
            eshkol_debug("Registered variadic function %s with %llu fixed params",
                        lambda_name.c_str(), (unsigned long long)op->lambda_op.num_params);
        }

        // FUNCTION-AS-VALUE FIX: Record arity for closure wrapping when lambda is used as value
        function_arity_table[lambda_name] = op->lambda_op.num_params;

        // HOMOICONIC FIX: Map lambda function to its S-expression global name
        // This allows codegenList to find the correct S-expression for inline lambdas
        lambda_sexpr_map[lambda_func] = lambda_name;

        // HOMOICONIC FIX: Create S-expression global variable IMMEDIATELY so detectValueType can find it
        std::string sexpr_key = lambda_name + "_sexpr";
        GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
        if (!sexpr_global) {
            sexpr_global = new GlobalVariable(
                *module, int64_type, false,
                GlobalValue::ExternalLinkage,
                ConstantInt::get(int64_type, 0),
                sexpr_key
            );
            global_symbol_table[sexpr_key] = sexpr_global;
            eshkol_debug("Pre-created S-expression global %s for lambda", sexpr_key.c_str());
        }

        eshkol_debug("Generated lambda function: %s with %llu parameters + %zu captured",
                    lambda_name.c_str(), (unsigned long long)op->lambda_op.num_params, free_vars.size());

        builder->restoreIP(old_point);

        // NOTE: Inline S-expression generation for lambdas inside functions was disabled
        // because codegenLambdaToSExpr creates branching control flow (via codegenTaggedArenaConsCellFromTaggedValue)
        // which terminates the current basic block and disrupts the outer function's code sequence.
        // S-expressions for nested lambdas will be generated at closure allocation time instead,
        // which happens after restoreIP but the disruption is acceptable at that point since
        // the lambda return value is the closure, not continuation of the outer body.
        eshkol_debug("Lambda function %s created, restored insertion point", lambda_name.c_str());

        // PRE-GENERATION FIX: Don't create closures during pre-generation phase
        // During __lambda_init__, captured variables haven't been initialized yet.
        // The closure will be created when the actual define is processed in main.
        bool is_pregeneration = current_function && current_function->getName() == "__lambda_init__";
        if (is_pregeneration) {
            eshkol_debug("Skipping closure creation during pre-generation for %s", lambda_name.c_str());
            // Return the function directly - closure will be created later
            return lambda_func;
        }

        // CLOSURE FIX: If there are captures, allocate a closure at runtime
        if (!free_vars.empty()) {
            // Get function pointer as i64
            Value* func_ptr = builder->CreatePtrToInt(lambda_func, int64_type);

            // HOMOICONICITY FIX: Generate S-expression at closure creation time
            // We're past restoreIP so control flow disruption is acceptable - we'll end up
            // in the merge block and continue from there
            Value* sexpr_ptr = codegenLambdaToSExpr(op);

            // Store to global variable so display code can also find it
            std::string closure_sexpr_key = lambda_name + "_sexpr";
            GlobalVariable* closure_sexpr_global = module->getNamedGlobal(closure_sexpr_key);
            if (closure_sexpr_global) {
                builder->CreateStore(sexpr_ptr, closure_sexpr_global);
            }

            // Allocate closure: arena_allocate_closure(arena, func_ptr, packed_info, sexpr_ptr, return_type_info)
            // Pack variadic info into the num_captures field:
            //   - Bits 0-15:  num_captures
            //   - Bits 16-31: fixed_param_count
            //   - Bit 63:     is_variadic flag
            Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
            uint64_t packed_info = free_vars.size() & 0xFFFF;
            packed_info |= ((uint64_t)op->lambda_op.num_params & 0xFFFF) << 16;
            if (is_variadic) {
                packed_info |= (1ULL << 63);
            }
            Value* packed_captures = ConstantInt::get(int64_type, packed_info);

            // Compute return type info for closure metadata:
            //   - Bits 0-7:   return_type (CLOSURE_RETURN_*)
            //   - Bits 8-15:  input_arity (num_params)
            //   - Bits 16-47: hott_type_id
            uint8_t return_type_category = CLOSURE_RETURN_UNKNOWN;
            uint32_t hott_type_id = eshkol::hott::BuiltinTypes::Value.id;  // Default to Value (top type)
            if (op->lambda_op.return_type) {
                hott_type_kind_t kind = op->lambda_op.return_type->kind;
                switch (kind) {
                    case HOTT_TYPE_INTEGER:
                        return_type_category = CLOSURE_RETURN_SCALAR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Integer.id;
                        break;
                    case HOTT_TYPE_REAL:
                        return_type_category = CLOSURE_RETURN_SCALAR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Real.id;
                        break;
                    case HOTT_TYPE_NUMBER:
                        return_type_category = CLOSURE_RETURN_SCALAR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Number.id;
                        break;
                    case HOTT_TYPE_VECTOR:
                        return_type_category = CLOSURE_RETURN_VECTOR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Vector.id;
                        break;
                    case HOTT_TYPE_TENSOR:
                        return_type_category = CLOSURE_RETURN_VECTOR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Tensor.id;
                        break;
                    case HOTT_TYPE_LIST:
                        return_type_category = CLOSURE_RETURN_LIST;
                        hott_type_id = eshkol::hott::BuiltinTypes::List.id;
                        break;
                    case HOTT_TYPE_PAIR:
                        return_type_category = CLOSURE_RETURN_LIST;
                        hott_type_id = eshkol::hott::BuiltinTypes::Pair.id;
                        break;
                    case HOTT_TYPE_ARROW:
                        return_type_category = CLOSURE_RETURN_FUNCTION;
                        hott_type_id = eshkol::hott::BuiltinTypes::Function.id;
                        break;
                    case HOTT_TYPE_BOOLEAN:
                        return_type_category = CLOSURE_RETURN_BOOL;
                        hott_type_id = eshkol::hott::BuiltinTypes::Boolean.id;
                        break;
                    case HOTT_TYPE_STRING:
                        return_type_category = CLOSURE_RETURN_STRING;
                        hott_type_id = eshkol::hott::BuiltinTypes::String.id;
                        break;
                    case HOTT_TYPE_CHAR:
                        return_type_category = CLOSURE_RETURN_SCALAR;
                        hott_type_id = eshkol::hott::BuiltinTypes::Char.id;
                        break;
                    case HOTT_TYPE_SYMBOL:
                        return_type_category = CLOSURE_RETURN_UNKNOWN;
                        hott_type_id = eshkol::hott::BuiltinTypes::Symbol.id;
                        break;
                    case HOTT_TYPE_NULL:
                        return_type_category = CLOSURE_RETURN_VOID;
                        hott_type_id = eshkol::hott::BuiltinTypes::Null.id;
                        break;
                    case HOTT_TYPE_NOTHING:
                        return_type_category = CLOSURE_RETURN_VOID;
                        hott_type_id = eshkol::hott::BuiltinTypes::Invalid.id;
                        break;
                    case HOTT_TYPE_ANY:
                        return_type_category = CLOSURE_RETURN_UNKNOWN;
                        hott_type_id = eshkol::hott::BuiltinTypes::Value.id;
                        break;
                    default:
                        return_type_category = CLOSURE_RETURN_UNKNOWN;
                        hott_type_id = eshkol::hott::BuiltinTypes::Value.id;
                        break;
                }
            }
            uint64_t return_type_info = (uint64_t)return_type_category;
            return_type_info |= ((uint64_t)(op->lambda_op.num_params & 0xFF)) << 8;
            return_type_info |= ((uint64_t)hott_type_id) << 16;  // Pack HoTT type ID into bits 16-47
            Value* return_type_val = ConstantInt::get(int64_type, return_type_info);

            eshkol_debug("Closure %s: packed_info=0x%llx (captures=%zu, fixed_params=%llu, variadic=%d), return_type=%d",
                        lambda_name.c_str(), (unsigned long long)packed_info,
                        free_vars.size(), (unsigned long long)op->lambda_op.num_params, is_variadic ? 1 : 0,
                        return_type_category);
            Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                     {arena_ptr, func_ptr, packed_captures, sexpr_ptr, return_type_val});

            // Store captured values into closure environment
            // The closure struct is: { uint64_t func_ptr, eshkol_closure_env_t* env }
            // The env struct is: { size_t num_captures, eshkol_tagged_value_t captures[] }

            // Get pointer to env (second field of closure, offset 8 bytes)
            Value* env_ptr_ptr = builder->CreateGEP(
                int8_type, closure_ptr,
                ConstantInt::get(int64_type, 8));
            Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_ptr);

            // Store each captured value into the environment's captures array
            // captures are at offset sizeof(size_t) = 8 bytes from env start
            size_t capture_idx = 0;
            for (const std::string& var_name : free_vars) {
                // Get the captured value from the current scope
                Value* captured_val = nullptr;
                Value* var_value = nullptr;

                // Check prev_symbols (local scope) first, then global_symbol_table
                auto var_it = prev_symbols.find(var_name);
                if (var_it != prev_symbols.end() && var_it->second) {
                    var_value = var_it->second;
                } else {
                    // GLOBAL CAPTURE FIX: Also check global_symbol_table for global variables
                    auto global_it = global_symbol_table.find(var_name);
                    if (global_it != global_symbol_table.end() && global_it->second) {
                        var_value = global_it->second;
                        eshkol_debug("Storing global capture for closure: %s", var_name.c_str());
                    }
                }

                if (var_value) {
                    // MUTABLE CAPTURE FIX: For let-bound variables (allocas), store a POINTER
                    // to the alloca in the closure environment instead of the VALUE.
                    // This ensures both the lambda and the outer scope access the same storage,
                    // making set! mutations visible to both.
                    // For other capture types (Arguments, GlobalVariables), store the value.
                    // IMPORTANT: TCO allocas (named *_tco) are function parameters, not let-bound.
                    // They get new stack frames on each call, so store the value, not pointer.
                    bool is_let_alloca = false;
                    if (isa<AllocaInst>(var_value)) {
                        AllocaInst* alloca = cast<AllocaInst>(var_value);
                        std::string alloca_name = alloca->getName().str();
                        // TCO allocas end with "_tco" - treat them like regular parameters
                        is_let_alloca = alloca_name.length() < 4 || alloca_name.substr(alloca_name.length() - 4) != "_tco";
                    }
                    if (is_let_alloca) {
                        // CLOSURE ESCAPE FIX: The stack alloca will be deallocated when
                        // the outer function returns, but the closure may outlive that.
                        // Solution: Allocate storage on the arena (heap) and use that.
                        // Both the outer scope and the closure will share this arena storage.

                        // 1. Allocate space for tagged_value on the arena (16 bytes)
                        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
                        Value* alloc_size = ConstantInt::get(int64_type, 16);  // sizeof(eshkol_tagged_value_t)
                        Value* arena_storage = builder->CreateCall(getArenaAllocateFunc(), {arena_ptr, alloc_size});

                        // 2. Copy current value from stack alloca to arena storage
                        Value* current_val = builder->CreateLoad(tagged_value_type, var_value, var_name + "_val");
                        builder->CreateStore(current_val, arena_storage);

                        // 3. Update symbol table to point to arena storage (so outer scope uses it too)
                        // This ensures set! in both outer scope and lambda modify the same storage
                        symbol_table[var_name] = arena_storage;

                        // 4. Store arena pointer as int64 in closure environment
                        Value* arena_ptr_int = builder->CreatePtrToInt(arena_storage, int64_type);
                        captured_val = packInt64ToTaggedValue(arena_ptr_int, true);

                        eshkol_debug("Closure escape fix: moved %s from stack to arena", var_name.c_str());
                    } else if (isa<AllocaInst>(var_value)) {
                        // TCO alloca - load the value and capture it (not pointer)
                        captured_val = builder->CreateLoad(tagged_value_type, var_value, var_name + "_val");
                    } else if (isa<GlobalVariable>(var_value)) {
                        captured_val = builder->CreateLoad(
                            dyn_cast<GlobalVariable>(var_value)->getValueType(), var_value);
                    } else if (isa<CallInst>(var_value) && var_value->getType()->isPointerTy()) {
                        // ARENA CAPTURE FIX: Handle arena-allocated storage (CallInst from arena_allocate)
                        // When a variable has been moved to arena storage by a previous lambda creation,
                        // symbol_table points to the CallInst result (a pointer). Load from it and store
                        // the arena pointer in the closure so mutations are shared.
                        Value* current_val = builder->CreateLoad(tagged_value_type, var_value, var_name + "_arena_val");

                        // Store arena pointer (not the value) so set! mutations are visible
                        Value* arena_ptr_int = builder->CreatePtrToInt(var_value, int64_type);
                        captured_val = packInt64ToTaggedValue(arena_ptr_int, true);
                        eshkol_debug("Closure using existing arena storage for %s", var_name.c_str());
                    } else if (isa<Argument>(var_value)) {
                        // MUTABLE CAPTURE FIX: Handle Argument which may be pointer to capture or direct value
                        Argument* arg = cast<Argument>(var_value);
                        Function* arg_parent = arg->getParent();

                        // NESTED FUNCTION FIX: Check if the Argument belongs to the current function
                        // If it's from a different function, we can't use it directly - we need to
                        // get it through the current function's captures instead
                        Function* current_func = builder->GetInsertBlock()->getParent();
                        if (arg_parent != current_func) {
                            // The Argument is from a different function (e.g., grandparent function)
                            // We need to find it in our function's capture parameters
                            // Look for a capture parameter with the same name in current function
                            bool found_in_captures = false;
                            for (auto& curr_arg : current_func->args()) {
                                std::string arg_name = curr_arg.getName().str();
                                if (arg_name == "captured_" + var_name) {
                                    // Found the capture parameter in current function
                                    if (curr_arg.getType()->isPointerTy()) {
                                        captured_val = builder->CreateLoad(tagged_value_type, &curr_arg);
                                    } else {
                                        captured_val = &curr_arg;
                                    }
                                    found_in_captures = true;
                                    eshkol_debug("Using current function's capture for %s (instead of outer arg)", var_name.c_str());
                                    break;
                                }
                            }
                            if (!found_in_captures) {
                                // Couldn't find in captures - check global symbol table for GlobalVariable
                                std::string capture_key = current_func->getName().str() + "_capture_" + var_name;
                                auto cap_it = global_symbol_table.find(capture_key);
                                if (cap_it != global_symbol_table.end() && isa<GlobalVariable>(cap_it->second)) {
                                    captured_val = builder->CreateLoad(tagged_value_type, cap_it->second);
                                    eshkol_debug("Using GlobalVariable capture for %s", var_name.c_str());
                                } else {
                                    eshkol_warn("Cannot capture %s from outer function - not found in current function", var_name.c_str());
                                    captured_val = nullptr;
                                }
                            }
                        } else if (var_value->getType()->isPointerTy()) {
                            // This is a pointer to a captured variable (from mutable capture fix)
                            // Load the tagged value from the pointer
                            captured_val = builder->CreateLoad(tagged_value_type, var_value);
                        } else {
                            // Function parameters are already loaded
                            captured_val = var_value;
                        }
                    } else if (isa<IntToPtrInst>(var_value)) {
                        // NESTED MUTABLE CAPTURE FIX: IntToPtrInst is a pointer from an
                        // outer lambda's mutable capture. This pointer points to the original
                        // let alloca. We need to re-capture this pointer so the inner lambda
                        // can also access the shared mutable storage.
                        // Convert the pointer back to int64 and store it as a tagged value.
                        Value* ptr_as_int = builder->CreatePtrToInt(var_value, int64_type);
                        captured_val = packInt64ToTaggedValue(ptr_as_int, true);
                        eshkol_debug("Re-capturing mutable pointer for nested lambda: %s", var_name.c_str());
                    } else {
                        captured_val = var_value;
                    }
                }

                if (captured_val) {
                    // Ensure value is tagged
                    if (captured_val->getType() != tagged_value_type) {
                        if (captured_val->getType()->isIntegerTy(64)) {
                            captured_val = packInt64ToTaggedValue(captured_val, true);
                        } else if (captured_val->getType()->isDoubleTy()) {
                            captured_val = packDoubleToTaggedValue(captured_val);
                        } else {
                            TypedValue tv = detectValueType(captured_val);
                            captured_val = typedValueToTaggedValue(tv);
                        }
                    }

                    // Calculate offset: 8 (header) + capture_idx * 16 (sizeof tagged_value)
                    size_t offset = 8 + capture_idx * 16;
                    Value* capture_slot = builder->CreateGEP(
                        int8_type, env_ptr,
                        ConstantInt::get(int64_type, offset));
                    Value* capture_slot_typed = builder->CreateBitCast(
                        capture_slot, PointerType::getUnqual(*context));
                    builder->CreateStore(captured_val, capture_slot_typed);

                    eshkol_debug("Stored capture %zu (%s) at offset %zu", capture_idx, var_name.c_str(), offset);
                }
                capture_idx++;
            }

            // Return closure pointer as CLOSURE_PTR tagged value
            Value* closure_tagged = packPtrToTaggedValue(closure_ptr, ESHKOL_VALUE_CLOSURE_PTR);
            return closure_tagged;
        }

        // HOMOICONICITY FIX: Even for lambdas without captures, create a closure
        // so we have a place to store the S-expression for display
        Value* func_ptr = builder->CreatePtrToInt(lambda_func, int64_type);

        // HOMOICONICITY FIX: Generate S-expression at closure creation time
        // We're past restoreIP so control flow disruption is acceptable
        Value* sexpr_ptr = codegenLambdaToSExpr(op);

        // Store to global variable so display code can also find it
        std::string nocap_sexpr_key = lambda_name + "_sexpr";
        GlobalVariable* nocap_sexpr_global = module->getNamedGlobal(nocap_sexpr_key);
        if (nocap_sexpr_global) {
            builder->CreateStore(sexpr_ptr, nocap_sexpr_global);
        }

        // Allocate closure with 0 captures but with S-expression
        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        Value* num_captures = ConstantInt::get(int64_type, 0);

        // Compute return type info for closure metadata (same logic as captures path)
        uint8_t return_type_category = CLOSURE_RETURN_UNKNOWN;
        uint32_t hott_type_id = eshkol::hott::BuiltinTypes::Value.id;  // Default to Value (top type)
        if (op->lambda_op.return_type) {
            hott_type_kind_t kind = op->lambda_op.return_type->kind;
            switch (kind) {
                case HOTT_TYPE_INTEGER:
                    return_type_category = CLOSURE_RETURN_SCALAR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Integer.id;
                    break;
                case HOTT_TYPE_REAL:
                    return_type_category = CLOSURE_RETURN_SCALAR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Real.id;
                    break;
                case HOTT_TYPE_NUMBER:
                    return_type_category = CLOSURE_RETURN_SCALAR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Number.id;
                    break;
                case HOTT_TYPE_VECTOR:
                    return_type_category = CLOSURE_RETURN_VECTOR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Vector.id;
                    break;
                case HOTT_TYPE_TENSOR:
                    return_type_category = CLOSURE_RETURN_VECTOR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Tensor.id;
                    break;
                case HOTT_TYPE_LIST:
                    return_type_category = CLOSURE_RETURN_LIST;
                    hott_type_id = eshkol::hott::BuiltinTypes::List.id;
                    break;
                case HOTT_TYPE_PAIR:
                    return_type_category = CLOSURE_RETURN_LIST;
                    hott_type_id = eshkol::hott::BuiltinTypes::Pair.id;
                    break;
                case HOTT_TYPE_ARROW:
                    return_type_category = CLOSURE_RETURN_FUNCTION;
                    hott_type_id = eshkol::hott::BuiltinTypes::Function.id;
                    break;
                case HOTT_TYPE_BOOLEAN:
                    return_type_category = CLOSURE_RETURN_BOOL;
                    hott_type_id = eshkol::hott::BuiltinTypes::Boolean.id;
                    break;
                case HOTT_TYPE_STRING:
                    return_type_category = CLOSURE_RETURN_STRING;
                    hott_type_id = eshkol::hott::BuiltinTypes::String.id;
                    break;
                case HOTT_TYPE_CHAR:
                    return_type_category = CLOSURE_RETURN_SCALAR;
                    hott_type_id = eshkol::hott::BuiltinTypes::Char.id;
                    break;
                case HOTT_TYPE_SYMBOL:
                    return_type_category = CLOSURE_RETURN_UNKNOWN;
                    hott_type_id = eshkol::hott::BuiltinTypes::Symbol.id;
                    break;
                case HOTT_TYPE_NULL:
                    return_type_category = CLOSURE_RETURN_VOID;
                    hott_type_id = eshkol::hott::BuiltinTypes::Null.id;
                    break;
                case HOTT_TYPE_NOTHING:
                    return_type_category = CLOSURE_RETURN_VOID;
                    hott_type_id = eshkol::hott::BuiltinTypes::Invalid.id;
                    break;
                case HOTT_TYPE_ANY:
                    return_type_category = CLOSURE_RETURN_UNKNOWN;
                    hott_type_id = eshkol::hott::BuiltinTypes::Value.id;
                    break;
                default:
                    return_type_category = CLOSURE_RETURN_UNKNOWN;
                    hott_type_id = eshkol::hott::BuiltinTypes::Value.id;
                    break;
            }
        }
        uint64_t return_type_info_val = (uint64_t)return_type_category;
        return_type_info_val |= ((uint64_t)(op->lambda_op.num_params & 0xFF)) << 8;
        return_type_info_val |= ((uint64_t)hott_type_id) << 16;  // Pack HoTT type ID into bits 16-47
        Value* return_type_info = ConstantInt::get(int64_type, return_type_info_val);

        Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                 {arena_ptr, func_ptr, num_captures, sexpr_ptr, return_type_info});

        Value* closure_tagged = packPtrToTaggedValue(closure_ptr, ESHKOL_VALUE_CLOSURE_PTR);
        return closure_tagged;
    }
    
    Value* codegenLet(const eshkol_operations_t* op) {
        if (!op || !op->let_op.body) {
            eshkol_error("Invalid let expression - missing body");
            return nullptr;
        }

        // Handle named let: (let loop ((var init) ...) body)
        // This is equivalent to: (letrec ((loop (lambda (var ...) body))) (loop init ...))
        if (op->let_op.name != nullptr) {
            return codegenNamedLet(op);
        }

        eshkol_debug("Processing let expression with %llu bindings",
                    (unsigned long long)op->let_op.num_bindings);

        // Save current symbol table state
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;
        // HoTT TYPE TRACKING: Also save HoTT type maps for proper scoping
        std::unordered_map<std::string, eshkol::hott::TypeId> prev_hott_types = symbol_hott_types;
        std::unordered_map<std::string, eshkol::hott::ParameterizedType> prev_param_types = symbol_param_types;

        // Process all bindings: evaluate values and add to symbol table
        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];
            
            // Binding is a cons cell: (variable . value)
            if (binding->type != ESHKOL_CONS || !binding->cons_cell.car || !binding->cons_cell.cdr) {
                eshkol_error("Invalid let binding structure at index %llu", (unsigned long long)i);
                continue;
            }
            
            // Extract variable name from car
            const eshkol_ast_t* var_ast = binding->cons_cell.car;
            if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) {
                eshkol_error("Let binding must have variable name");
                continue;
            }
            
            std::string var_name = var_ast->variable.id;

            // Evaluate value expression from cdr
            // CRITICAL FIX: Use codegenTypedAST to preserve type information
            // This matches what codegenVariableDefinition does
            const eshkol_ast_t* val_ast = binding->cons_cell.cdr;

            // HOMOICONICITY FIX: Check if val_ast is a lambda expression BEFORE codegen
            // This is needed because codegenLambda returns a tagged_value, not a Function*
            bool is_lambda_expr = val_ast && val_ast->type == ESHKOL_OP &&
                                   val_ast->operation.op == ESHKOL_LAMBDA_OP;

            TypedValue typed_val = codegenTypedAST(val_ast);
            Value* val = typed_val.llvm_value;
            if (!val) {
                eshkol_warn("Failed to evaluate let binding value for %s", var_name.c_str());
                continue;
            }

            // Determine storage type based on value type
            Type* storage_type = val->getType();

            // HOMOICONICITY FIX: Handle lambda expressions for S-expression display
            // This is separate from function registration to avoid skipping tagged_value handling
            if (is_lambda_expr) {
                // MODULE PREFIX FIX: Use last_generated_lambda_name directly instead of
                // computing the lambda number (which broke with module prefixes)
                std::string lambda_name = last_generated_lambda_name;
                Function* lambda_func = nullptr;

                if (!lambda_name.empty()) {
                    auto func_it = function_table.find(lambda_name);
                    if (func_it != function_table.end()) {
                        lambda_func = func_it->second;
                    }
                }

                if (lambda_func) {
                    eshkol_debug("Let binding: found outer lambda %s for lambda expression (nested fix)",
                               lambda_name.c_str());

                    // SCOPED NAMES FIX: Use enclosing function name to avoid collisions
                    std::string scope_prefix = "";
                    if (current_function) {
                        scope_prefix = current_function->getName().str() + ".";
                    }
                    std::string scoped_func_key = scope_prefix + var_name + "_func";
                    std::string scoped_sexpr_key = scope_prefix + var_name + "_sexpr";

                    // Store direct function reference for lambda resolution in BOTH tables
                    if (lambda_func) {
                        symbol_table[var_name + "_func"] = lambda_func;
                        symbol_table[scoped_func_key] = lambda_func;
                        global_symbol_table[var_name + "_func"] = lambda_func;
                        global_symbol_table[scoped_func_key] = lambda_func;
                        eshkol_debug("Let binding: stored lambda function reference %s -> %s",
                                   scoped_func_key.c_str(), lambda_func->getName().str().c_str());
                    }

                    // Create the S-expression GlobalVariable with scoped name
                    GlobalVariable* var_sexpr_global = module->getNamedGlobal(scoped_sexpr_key);
                    if (!var_sexpr_global) {
                        var_sexpr_global = new GlobalVariable(
                            *module, int64_type, false,
                            GlobalVariable::ExternalLinkage,
                            ConstantInt::get(int64_type, 0),
                            scoped_sexpr_key
                        );
                        global_symbol_table[scoped_sexpr_key] = var_sexpr_global;
                        eshkol_debug("Let binding: created S-expression global %s for lambda %s",
                                   scoped_sexpr_key.c_str(), lambda_name.c_str());
                    }

                    // Copy the lambda's S-expression to the variable's scoped global
                    std::string lambda_sexpr_key = lambda_name + "_sexpr";
                    GlobalVariable* lambda_sexpr_global = module->getNamedGlobal(lambda_sexpr_key);
                    if (lambda_sexpr_global && var_sexpr_global) {
                        Value* lambda_sexpr_val = builder->CreateLoad(int64_type, lambda_sexpr_global);
                        builder->CreateStore(lambda_sexpr_val, var_sexpr_global);
                        eshkol_debug("Let binding: copied S-expression from %s to %s",
                                   lambda_sexpr_key.c_str(), scoped_sexpr_key.c_str());
                    }
                }
            }

            // Check if value is a function directly (raw Function*)
            if (val && isa<Function>(val)) {
                Function* func = dyn_cast<Function>(val);
                storage_type = int64_type;

                // SCOPED NAMES FIX: Use enclosing function name to avoid collisions
                std::string scope_prefix = "";
                if (current_function) {
                    scope_prefix = current_function->getName().str() + ".";
                }
                std::string scoped_func_key = scope_prefix + var_name + "_func";

                // Store direct function reference for lambda resolution in BOTH tables
                symbol_table[var_name + "_func"] = func;
                symbol_table[scoped_func_key] = func;
                global_symbol_table[var_name + "_func"] = func;
                global_symbol_table[scoped_func_key] = func;
                eshkol_debug("Let binding: stored direct function reference %s -> %s",
                           scoped_func_key.c_str(), func->getName().str().c_str());

                val = builder->CreatePtrToInt(func, storage_type);
            }
            // CRITICAL FIX: Handle returned lambdas (tagged_value containing function pointer)
            // NESTED LAMBDA FIX: Skip this for lambda expressions - already handled above with correct logic
            else if (val && val->getType() == tagged_value_type && !is_lambda_expr) {
                // Extract type to check if it's a function pointer
                Value* val_type = getTaggedValueType(val);
                Value* val_base_type = builder->CreateAnd(val_type,
                    ConstantInt::get(int8_type, 0x0F));

                // Check if it's a CONS_PTR (function pointers are stored as CONS_PTR)
                Value* is_func_ptr = builder->CreateICmpEQ(val_base_type,
                    ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));

                // Extract the function pointer value
                Value* func_addr = unpackInt64FromTaggedValue(val);

                // Try to find matching lambda or nested function by searching function_table
                // Use the most recently created function (highest number)
                Function* matching_lambda = nullptr;
                int highest_lambda_num = -1;
                int highest_nested_num = -1;
                Function* highest_nested_func = nullptr;

                for (auto& func_entry : function_table) {
                    if (isLambdaName(func_entry.first)) {
                        // Extract lambda number from name
                        std::string num_str = func_entry.first.substr(7);  // Skip "lambda_"
                        try {
                            int lambda_num = std::stoi(num_str);
                            if (lambda_num > highest_lambda_num) {
                                highest_lambda_num = lambda_num;
                                matching_lambda = func_entry.second;
                            }
                        } catch (...) {
                            // Skip if number parsing fails
                        }
                    }
                    // Also check for nested functions (format: name_nested_N)
                    size_t nested_pos = func_entry.first.find("_nested_");
                    if (nested_pos != std::string::npos) {
                        std::string num_str = func_entry.first.substr(nested_pos + 8);
                        try {
                            int nested_num = std::stoi(num_str);
                            if (nested_num > highest_nested_num) {
                                highest_nested_num = nested_num;
                                highest_nested_func = func_entry.second;
                            }
                        } catch (...) {}
                    }
                }

                // Prefer most recent nested function if its number is higher
                if (highest_nested_func && highest_nested_num > highest_lambda_num) {
                    matching_lambda = highest_nested_func;
                }

                if (matching_lambda) {
                    symbol_table[var_name + "_func"] = matching_lambda;
                    global_symbol_table[var_name + "_func"] = matching_lambda;
                    eshkol_debug("Let binding: stored returned function reference %s_func -> %s",
                               var_name.c_str(), matching_lambda->getName().str().c_str());
                }
            }
            // CRITICAL FIX: Handle i64 closure pointer case (lambda without Function* return)
            // This occurs when codegenLambda returns a packed closure pointer
            else if (val && val->getType()->isIntegerTy(64) &&
                     val_ast->type == ESHKOL_OP && val_ast->operation.op == ESHKOL_LAMBDA_OP) {
                // Use last_generated_lambda_name to find the function
                if (!last_generated_lambda_name.empty()) {
                    auto func_it = function_table.find(last_generated_lambda_name);
                    if (func_it != function_table.end() && func_it->second) {
                        Function* lambda_func = func_it->second;

                        // Store function reference with _func suffix
                        std::string scope_prefix = "";
                        if (current_function) {
                            scope_prefix = current_function->getName().str() + ".";
                        }
                        std::string scoped_func_key = scope_prefix + var_name + "_func";

                        symbol_table[var_name + "_func"] = lambda_func;
                        symbol_table[scoped_func_key] = lambda_func;
                        global_symbol_table[var_name + "_func"] = lambda_func;
                        global_symbol_table[scoped_func_key] = lambda_func;
                        eshkol_debug("Let binding: stored closure function reference %s_func -> %s",
                                   var_name.c_str(), lambda_func->getName().str().c_str());
                    }
                }
            }

            // Create alloca for the variable in current function scope
            if (current_function) {
                // CRITICAL FIX: Always store as tagged_value to preserve type information
                // This ensures values like cons cells retain their CONS_PTR type
                // when loaded back from the alloca (fixes recursive function return corruption)
                Value* val_to_store = val;
                Type* actual_storage_type = storage_type;

                // Convert non-tagged values to tagged_value to preserve type
                if (storage_type != tagged_value_type) {
                    if (storage_type->isIntegerTy(64)) {
                        // Use the type info from codegenTypedAST if it has a specific type
                        // Otherwise fall back to detectValueType
                        TypedValue tv = typed_val;
                        if (tv.type == ESHKOL_VALUE_INT64) {
                            // Re-detect - codegenTypedAST might have defaulted to INT64
                            tv = detectValueType(val);
                        }
                        val_to_store = typedValueToTaggedValue(tv);
                        actual_storage_type = tagged_value_type;
                        eshkol_debug("Let binding: converting i64 to tagged_value (type=%d)", (int)tv.type);
                    } else if (storage_type->isDoubleTy()) {
                        val_to_store = packDoubleToTaggedValue(val);
                        actual_storage_type = tagged_value_type;
                    }
                }

                AllocaInst* var_alloca = builder->CreateAlloca(
                    actual_storage_type,
                    nullptr,
                    var_name.c_str()
                );

                // Set proper alignment
                if (actual_storage_type == tagged_value_type) {
                    var_alloca->setAlignment(Align(16));
                } else if (actual_storage_type->isIntegerTy(64)) {
                    var_alloca->setAlignment(Align(8));
                }

                builder->CreateStore(val_to_store, var_alloca);
                symbol_table[var_name] = var_alloca;

                // HoTT TYPE TRACKING: Store compile-time type for let bindings
                symbol_hott_types[var_name] = typed_val.hott_type;
                // HoTT PARAMETERIZED TYPE: Store element type for List<T>, Vector<T>
                if (typed_val.param_type.has_value()) {
                    symbol_param_types[var_name] = *typed_val.param_type;
                }

                eshkol_debug("Let binding: %s = <value> (stored as %s)",
                           var_name.c_str(),
                           actual_storage_type == tagged_value_type ? "tagged_value" : "raw");
            } else {
                eshkol_warn("Let expression outside function context - creating temporary binding");
                symbol_table[var_name] = val;
                // HoTT TYPE TRACKING: Store compile-time type even outside function context
                symbol_hott_types[var_name] = typed_val.hott_type;
                if (typed_val.param_type.has_value()) {
                    symbol_param_types[var_name] = *typed_val.param_type;
                }
            }
        }
        
        // Evaluate body in the new scope with bindings
        Value* body_result = codegenAST(op->let_op.body);
        
        // CRITICAL FIX (Bug #2): Preserve _func entries before restoring symbol table
        // Local functions defined in let bindings must be accessible for autodiff
        std::unordered_map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            // Preserve all entries ending with "_func" (function references for autodiff)
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {
                func_refs_to_preserve[entry.first] = entry.second;
                // Also ensure in global for gradient/derivative operators
                global_symbol_table[entry.first] = entry.second;
                eshkol_debug("Let: preserving function reference: %s", entry.first.c_str());
            }
            // MUTABLE CAPTURE FIX: Also preserve GlobalVariable captures
            // These are variables that were moved to GlobalVariables when captured by lambdas
            if (entry.second && isa<GlobalVariable>(entry.second)) {
                func_refs_to_preserve[entry.first] = entry.second;
            }
        }

        // Restore previous symbol table state
        symbol_table = prev_symbols;
        // HoTT TYPE TRACKING: Also restore HoTT type maps
        symbol_hott_types = prev_hott_types;
        symbol_param_types = prev_param_types;

        // Re-add preserved function references and GlobalVariable captures
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
        }

        return body_result ? body_result : ConstantInt::get(int64_type, 0);
    }

    // Named let: (let loop ((var init) ...) body)
    // Transforms to: (letrec ((loop (lambda (var ...) body))) (loop init ...))
    Value* codegenNamedLet(const eshkol_operations_t* op) {
        std::string loop_name = op->let_op.name;
        eshkol_debug("Processing named let '%s' with %llu bindings",
                    loop_name.c_str(), (unsigned long long)op->let_op.num_bindings);

        // Save current symbol table state
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;

        // Extract parameter names and initial values from bindings
        std::vector<std::string> param_names;
        std::vector<Value*> init_values;

        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];

            if (binding->type != ESHKOL_CONS || !binding->cons_cell.car || !binding->cons_cell.cdr) {
                eshkol_error("Invalid named let binding at index %llu", (unsigned long long)i);
                continue;
            }

            // Extract parameter name
            const eshkol_ast_t* var_ast = binding->cons_cell.car;
            if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) {
                eshkol_error("Named let binding must have variable name");
                continue;
            }
            param_names.push_back(var_ast->variable.id);

            // Evaluate initial value
            Value* init_val = codegenAST(binding->cons_cell.cdr);
            if (!init_val) {
                eshkol_error("Failed to evaluate initial value for named let parameter '%s'",
                            var_ast->variable.id);
                init_val = ConstantInt::get(int64_type, 0);
            }
            init_values.push_back(init_val);
        }

        // NAMED LET CAPTURE FIX: Find free variables in the loop body and create GlobalVariables
        // for non-global captures. This is similar to how letrec handles captures.
        // Variables that are already GlobalVariables can be accessed directly.
        // Variables that are AllocaInst or Argument need to be stored in GlobalVariables.

        // Build set of loop parameter names (these are bound, not free)
        std::set<std::string> bound_names(param_names.begin(), param_names.end());
        bound_names.insert(loop_name);  // The loop name itself is also bound

        // Find free variables in the body
        std::vector<std::string> free_vars;
        findFreeVariables(op->let_op.body, prev_symbols, nullptr, 0, free_vars);

        // Remove loop parameters from free vars
        free_vars.erase(
            std::remove_if(free_vars.begin(), free_vars.end(),
                [&bound_names](const std::string& var) { return bound_names.count(var) > 0; }),
            free_vars.end());

        // Create GlobalVariables for non-global captures
        static int named_let_counter = 0;
        int current_counter = named_let_counter++;
        std::unordered_map<std::string, GlobalVariable*> capture_globals;

        for (const std::string& fv : free_vars) {
            auto it = prev_symbols.find(fv);
            if (it == prev_symbols.end() || !it->second) continue;

            Value* outer_val = it->second;

            // If already a GlobalVariable, no need to create a new one
            if (isa<GlobalVariable>(outer_val)) {
                capture_globals[fv] = dyn_cast<GlobalVariable>(outer_val);
                eshkol_debug("Named let '%s': capture '%s' is already GlobalVariable",
                           loop_name.c_str(), fv.c_str());
            } else {
                // Create a new GlobalVariable to hold the captured value
                std::string global_name = module_prefix + "_named_let_capture_" + loop_name +
                                         "_" + fv + "_" + std::to_string(current_counter);
                GlobalVariable* capture_global = new GlobalVariable(
                    *module,
                    tagged_value_type,
                    false,  // not constant (mutable captures like set!)
                    GlobalValue::InternalLinkage,
                    UndefValue::get(tagged_value_type),
                    global_name
                );
                capture_globals[fv] = capture_global;

                // Load the value from the outer scope and store it in the global
                Value* captured_val = nullptr;
                if (isa<AllocaInst>(outer_val)) {
                    captured_val = builder->CreateLoad(
                        dyn_cast<AllocaInst>(outer_val)->getAllocatedType(), outer_val);
                } else if (isa<Argument>(outer_val)) {
                    // For Argument, check if it's a pointer type (capture pointer) or value type
                    // When the outer function is a lambda with captures, captured variables
                    // are passed as pointers to closure env slots
                    if (outer_val->getType()->isPointerTy()) {
                        captured_val = builder->CreateLoad(tagged_value_type, outer_val,
                                                          fv + "_cap_load");
                        eshkol_debug("Named let '%s': loading capture '%s' from pointer argument",
                                   loop_name.c_str(), fv.c_str());
                    } else {
                        captured_val = outer_val;  // Arguments are direct values
                    }
                } else {
                    captured_val = outer_val;
                }

                // Ensure tagged_value type
                if (captured_val->getType() != tagged_value_type) {
                    if (captured_val->getType()->isDoubleTy()) {
                        captured_val = packDoubleToTaggedValue(captured_val);
                    } else if (captured_val->getType()->isIntegerTy(64)) {
                        captured_val = packInt64ToTaggedValue(captured_val, true);
                    }
                }

                builder->CreateStore(captured_val, capture_global);
                eshkol_debug("Named let '%s': created GlobalVariable for capture '%s'",
                           loop_name.c_str(), fv.c_str());
            }
        }

        // Create the loop function: (lambda (param1 param2 ...) body)
        // Function signature: all parameters are tagged_value, returns tagged_value
        std::vector<Type*> param_types(param_names.size(), tagged_value_type);
        FunctionType* loop_func_type = FunctionType::get(tagged_value_type, param_types, false);

        std::string func_name = "named_let_" + loop_name + "_" + std::to_string(current_counter);
        Function* loop_func = Function::Create(
            loop_func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // Set parameter names
        auto arg_it = loop_func->arg_begin();
        for (size_t i = 0; i < param_names.size(); i++, ++arg_it) {
            arg_it->setName(param_names[i]);
        }

        // Register function so it can be called recursively
        function_table[loop_name] = loop_func;
        symbol_table[loop_name + "_func"] = loop_func;
        global_symbol_table[loop_name + "_func"] = loop_func;

        // Save current context
        Function* prev_function = current_function;
        BasicBlock* prev_block = builder->GetInsertBlock();

        // Create entry block for loop function
        BasicBlock* entry = BasicBlock::Create(*context, "entry", loop_func);
        builder->SetInsertPoint(entry);
        current_function = loop_func;

        // Clear symbol table for function scope
        symbol_table.clear();
        symbol_table[loop_name + "_func"] = loop_func;
        function_table[loop_name] = loop_func;

        // Add capture GlobalVariables to symbol table (they can be accessed from any function)
        for (auto& capture : capture_globals) {
            symbol_table[capture.first] = capture.second;
        }

        // Also add any other GlobalVariables from prev_symbols that weren't captured
        // (e.g., stdlib functions, other top-level defines)
        for (auto& entry : prev_symbols) {
            if (entry.second && isa<GlobalVariable>(entry.second) &&
                capture_globals.find(entry.first) == capture_globals.end()) {
                symbol_table[entry.first] = entry.second;
            }
        }

        // Add parameters to symbol table (these shadow any outer vars with same name)
        arg_it = loop_func->arg_begin();
        for (size_t i = 0; i < param_names.size(); i++, ++arg_it) {
            // Create alloca for parameter
            AllocaInst* param_alloca = builder->CreateAlloca(tagged_value_type, nullptr,
                                                              param_names[i] + "_storage");
            builder->CreateStore(&*arg_it, param_alloca);
            symbol_table[param_names[i]] = param_alloca;
        }

        // Generate body
        Value* body_result = codegenAST(op->let_op.body);
        if (!body_result) {
            body_result = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
        }
        // Ensure body result is tagged_value type
        if (body_result->getType() != tagged_value_type) {
            if (body_result->getType()->isDoubleTy()) {
                body_result = packDoubleToTaggedValue(body_result);
            } else if (body_result->getType()->isIntegerTy(64)) {
                body_result = packInt64ToTaggedValue(body_result, true);
            }
        }
        builder->CreateRet(body_result);

        // Restore context
        current_function = prev_function;
        if (prev_block) {
            builder->SetInsertPoint(prev_block);
        }

        // MUTABLE CAPTURE FIX: Preserve GlobalVariable captures before restoring
        std::unordered_map<std::string, Value*> globals_to_preserve;
        for (auto& entry : symbol_table) {
            if (isa<GlobalVariable>(entry.second)) {
                globals_to_preserve[entry.first] = entry.second;
            }
        }

        // Restore symbol table (but keep loop function registered)
        symbol_table = prev_symbols;
        symbol_table[loop_name + "_func"] = loop_func;
        function_table[loop_name] = loop_func;

        // Re-add preserved GlobalVariable captures
        for (auto& entry : globals_to_preserve) {
            symbol_table[entry.first] = entry.second;
        }

        // Call the loop function with initial values
        // Ensure initial values are tagged_value type
        std::vector<Value*> call_args;
        for (Value* init_val : init_values) {
            if (init_val->getType() != tagged_value_type) {
                if (init_val->getType()->isDoubleTy()) {
                    init_val = packDoubleToTaggedValue(init_val);
                } else if (init_val->getType()->isIntegerTy(64)) {
                    init_val = packInt64ToTaggedValue(init_val, true);
                } else if (init_val->getType()->isPointerTy()) {
                    // Load the value if it's a pointer
                    init_val = builder->CreateLoad(tagged_value_type, init_val);
                }
            }
            call_args.push_back(init_val);
        }

        Value* result = builder->CreateCall(loop_func, call_args);
        eshkol_debug("Named let '%s' completed", loop_name.c_str());
        return result;
    }

    // letrec - Recursive bindings (all bindings visible to all values)
    // Used for mutually recursive function definitions
    Value* codegenLetrec(const eshkol_operations_t* op) {
        if (!op || !op->let_op.body) {
            eshkol_error("Invalid letrec expression - missing body");
            return nullptr;
        }

        eshkol_debug("Processing letrec expression with %llu bindings",
                    (unsigned long long)op->let_op.num_bindings);

        // Save current symbol table state
        std::unordered_map<std::string, Value*> prev_symbols = symbol_table;

        // Collect binding info
        std::vector<std::string> var_names;
        std::vector<const eshkol_ast_t*> val_asts;
        std::vector<bool> is_lambda;
        std::vector<std::string> lambda_names;
        std::vector<std::vector<std::string>> lambda_free_vars;  // Free vars for each lambda

        // Build set of all letrec-bound names (for determining what's external)
        std::set<std::string> letrec_bound_names;
        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];
            if (binding->type == ESHKOL_CONS && binding->cons_cell.car &&
                binding->cons_cell.car->type == ESHKOL_VAR &&
                binding->cons_cell.car->variable.id) {
                letrec_bound_names.insert(binding->cons_cell.car->variable.id);
            }
        }

        // PHASE 1: Analyze all bindings and collect info
        static int letrec_lambda_counter = 0;
        for (uint64_t i = 0; i < op->let_op.num_bindings; i++) {
            const eshkol_ast_t* binding = &op->let_op.bindings[i];

            // Binding is a cons cell: (variable . value)
            if (binding->type != ESHKOL_CONS || !binding->cons_cell.car || !binding->cons_cell.cdr) {
                eshkol_error("Invalid letrec binding structure at index %llu", (unsigned long long)i);
                continue;
            }

            // Extract variable name from car
            const eshkol_ast_t* var_ast = binding->cons_cell.car;
            if (var_ast->type != ESHKOL_VAR || !var_ast->variable.id) {
                eshkol_error("Letrec binding must have variable name");
                continue;
            }

            std::string var_name = var_ast->variable.id;
            const eshkol_ast_t* val_ast = binding->cons_cell.cdr;

            var_names.push_back(var_name);
            val_asts.push_back(val_ast);

            // Check if this binding is a lambda
            bool binding_is_lambda = (val_ast->type == ESHKOL_OP &&
                                      val_ast->operation.op == ESHKOL_LAMBDA_OP);
            is_lambda.push_back(binding_is_lambda);

            if (binding_is_lambda) {
                // Use module prefix to prevent symbol collisions when linking with stdlib.o
                std::string lambda_name = module_prefix + "_letrec_lambda_" + std::to_string(letrec_lambda_counter++);
                lambda_names.push_back(lambda_name);

                const eshkol_operations_t* lambda_op = &val_ast->operation;

                // Find free variables in this lambda (variables from outer scope)
                std::vector<std::string> all_free_vars;
                findFreeVariables(lambda_op->lambda_op.body, symbol_table,
                                  lambda_op->lambda_op.parameters, lambda_op->lambda_op.num_params,
                                  all_free_vars);

                // Filter: only keep vars that are NOT letrec-bound (those need capture)
                // Letrec-bound vars will be accessed via globals/func refs
                std::vector<std::string> external_free_vars;
                for (const auto& fv : all_free_vars) {
                    if (letrec_bound_names.find(fv) == letrec_bound_names.end()) {
                        external_free_vars.push_back(fv);
                    }
                }
                lambda_free_vars.push_back(external_free_vars);

                eshkol_debug("Letrec lambda %s has %zu external free vars",
                           var_name.c_str(), external_free_vars.size());
            } else {
                lambda_names.push_back("");
                lambda_free_vars.push_back({});
            }
        }

        // PHASE 2: Create GlobalVariables for ALL letrec bindings (accessible from any function)
        // And create forward declarations for lambda bindings
        std::vector<GlobalVariable*> var_globals;
        for (uint64_t i = 0; i < var_names.size(); i++) {
            std::string var_name = var_names[i];

            // Create global variable for this binding
            // Use module prefix to prevent symbol collisions when linking with stdlib.o
            std::string global_name = module_prefix + "_letrec_" + var_name + "_" + std::to_string(letrec_lambda_counter + i);
            GlobalVariable* var_global = new GlobalVariable(
                *module,
                tagged_value_type,
                false,  // not constant
                GlobalValue::InternalLinkage,
                UndefValue::get(tagged_value_type),
                global_name
            );
            var_globals.push_back(var_global);
            symbol_table[var_name] = var_global;
            eshkol_debug("Letrec: created global %s for %s", global_name.c_str(), var_name.c_str());

            if (is_lambda[i]) {
                // Create forward declaration for lambda
                // Note: captures are loaded from globals, NOT passed as parameters
                const eshkol_operations_t* lambda_op = &val_asts[i]->operation;

                // Function type: only regular params (captures loaded from globals)
                std::vector<Type*> param_types;
                for (uint64_t j = 0; j < lambda_op->lambda_op.num_params; j++) {
                    param_types.push_back(tagged_value_type);
                }

                FunctionType* func_type = FunctionType::get(
                    tagged_value_type,
                    param_types,
                    false
                );

                Function* forward_decl = Function::Create(
                    func_type,
                    Function::ExternalLinkage,
                    lambda_names[i],
                    module.get()
                );

                // Register the forward declaration so recursive calls can find it
                symbol_table[var_name + "_func"] = forward_decl;
                global_symbol_table[var_name + "_func"] = forward_decl;
                function_table[lambda_names[i]] = forward_decl;

                eshkol_debug("Letrec phase 2: created forward declaration for %s -> %s",
                           var_name.c_str(), lambda_names[i].c_str());
            }
        }

        // PHASE 3: Store captured values in globals for each lambda
        // This must happen BEFORE generating lambda bodies, so captures are available
        std::unordered_map<std::string, std::unordered_map<std::string, GlobalVariable*>> lambda_capture_globals;
        for (uint64_t i = 0; i < var_names.size(); i++) {
            if (!is_lambda[i]) continue;

            const std::vector<std::string>& free_vars = lambda_free_vars[i];
            std::unordered_map<std::string, GlobalVariable*> capture_globals;

            for (const std::string& fv : free_vars) {
                // Load captured value from outer scope
                Value* captured_val = nullptr;
                auto it = symbol_table.find(fv);
                if (it != symbol_table.end() && it->second) {
                    Value* storage = it->second;
                    if (isa<AllocaInst>(storage)) {
                        captured_val = builder->CreateLoad(
                            dyn_cast<AllocaInst>(storage)->getAllocatedType(), storage);
                    } else if (isa<GlobalVariable>(storage)) {
                        captured_val = builder->CreateLoad(
                            dyn_cast<GlobalVariable>(storage)->getValueType(), storage);
                    } else {
                        captured_val = storage;
                    }
                }

                if (!captured_val) {
                    eshkol_warn("Could not resolve capture %s for letrec lambda %s",
                              fv.c_str(), var_names[i].c_str());
                    continue;
                }

                // NESTED CAPTURE FIX: If the captured variable is already stored in a GlobalVariable
                // (from an outer function's capture), reuse that GlobalVariable instead of creating a new one.
                GlobalVariable* capture_global = nullptr;
                Value* storage = it->second;
                if (storage && isa<GlobalVariable>(storage)) {
                    // The variable is already a GlobalVariable - reuse it directly
                    capture_global = dyn_cast<GlobalVariable>(storage);
                    eshkol_debug("Letrec phase 3: reusing existing GlobalVariable for capture '%s' -> '%s'",
                               fv.c_str(), capture_global->getName().str().c_str());
                } else {
                    // Ensure tagged value
                    if (captured_val->getType() != tagged_value_type) {
                        if (captured_val->getType()->isDoubleTy()) {
                            captured_val = packDoubleToTaggedValue(captured_val);
                        } else if (captured_val->getType()->isIntegerTy(64)) {
                            captured_val = packInt64ToTaggedValue(captured_val, ESHKOL_VALUE_INT64);
                        } else if (isa<Function>(captured_val)) {
                            Value* func_addr = builder->CreatePtrToInt(captured_val, int64_type);
                            captured_val = packInt64ToTaggedValue(func_addr, ESHKOL_VALUE_CONS_PTR);
                        }
                    }

                    // Create global to store capture
                    std::string capture_key = lambda_names[i] + "_capture_" + fv;
                    capture_global = new GlobalVariable(
                        *module,
                        tagged_value_type,
                        false,
                        GlobalValue::InternalLinkage,
                        UndefValue::get(tagged_value_type),
                        capture_key
                    );
                    builder->CreateStore(captured_val, capture_global);
                    symbol_table[capture_key] = capture_global;

                    // MUTABLE CAPTURE FIX: Also update the original variable's storage to use
                    // this GlobalVariable. This ensures set! inside the lambda and access from
                    // the enclosing scope use the same storage.
                    symbol_table[fv] = capture_global;

                    eshkol_debug("Letrec phase 3: stored capture '%s' for lambda '%s' (updated outer scope)", fv.c_str(), var_names[i].c_str());
                }
                capture_globals[fv] = capture_global;
            }
            lambda_capture_globals[var_names[i]] = capture_globals;
        }

        // PHASE 4: Generate lambda bodies and evaluate non-lambda expressions
        for (uint64_t i = 0; i < var_names.size(); i++) {
            const eshkol_ast_t* val_ast = val_asts[i];
            std::string var_name = var_names[i];

            Value* val = nullptr;

            if (is_lambda[i]) {
                // Get the forward declaration we created
                Value* forward_decl = symbol_table[var_name + "_func"];
                Function* forward_func = dyn_cast<Function>(forward_decl);

                if (forward_func) {
                    const eshkol_operations_t* lambda_op = &val_ast->operation;
                    const std::vector<std::string>& free_vars = lambda_free_vars[i];

                    // Create entry block for the function
                    BasicBlock* entry = BasicBlock::Create(*context, "entry", forward_func);
                    IRBuilderBase::InsertPoint old_point = builder->saveIP();
                    builder->SetInsertPoint(entry);

                    // Save current function context
                    Function* prev_function = current_function;
                    current_function = forward_func;
                    std::unordered_map<std::string, Value*> lambda_scope = symbol_table;

                    // TCO SETUP: Check if this lambda is self-tail-recursive
                    bool use_tco = isSelfTailRecursive(lambda_op, var_name);
                    TailCallContext prev_tco_context = tco_context;
                    BasicBlock* loop_body_bb = nullptr;
                    BasicBlock* return_bb = nullptr;

                    if (use_tco) {
                        eshkol_debug("TCO: Enabling tail call optimization for letrec lambda %s", var_name.c_str());

                        // Set up TCO context
                        tco_context.func_name = var_name;
                        tco_context.enabled = true;
                        tco_context.param_allocas.clear();
                        tco_context.param_names.clear();

                        // Create allocas for all parameters in entry block
                        auto arg_it_tco = forward_func->arg_begin();
                        if (lambda_op->lambda_op.parameters) {
                            for (uint64_t j = 0; j < lambda_op->lambda_op.num_params && arg_it_tco != forward_func->arg_end(); ++j, ++arg_it_tco) {
                                if (lambda_op->lambda_op.parameters[j].type == ESHKOL_VAR &&
                                    lambda_op->lambda_op.parameters[j].variable.id) {
                                    std::string param_name = lambda_op->lambda_op.parameters[j].variable.id;
                                    arg_it_tco->setName(param_name + "_arg");

                                    // Create alloca for this parameter
                                    AllocaInst* param_alloca = builder->CreateAlloca(
                                        tagged_value_type, nullptr, param_name + "_tco");

                                    // Store initial argument value
                                    builder->CreateStore(&(*arg_it_tco), param_alloca);

                                    tco_context.param_allocas.push_back(param_alloca);
                                    tco_context.param_names.push_back(param_name);
                                    symbol_table[param_name] = param_alloca;
                                }
                            }
                        }

                        // Create loop header block
                        loop_body_bb = BasicBlock::Create(*context, "tco_loop", forward_func);
                        return_bb = BasicBlock::Create(*context, "tco_return", forward_func);
                        tco_context.loop_header = loop_body_bb;

                        // Branch from entry to loop body
                        builder->CreateBr(loop_body_bb);

                        // Generate body in loop block
                        builder->SetInsertPoint(loop_body_bb);
                    } else {
                        // Non-TCO path: add parameters directly to symbol table
                        auto arg_it = forward_func->arg_begin();
                        if (lambda_op->lambda_op.parameters) {
                            for (uint64_t j = 0; j < lambda_op->lambda_op.num_params && arg_it != forward_func->arg_end(); ++j, ++arg_it) {
                                if (lambda_op->lambda_op.parameters[j].type == ESHKOL_VAR &&
                                    lambda_op->lambda_op.parameters[j].variable.id) {
                                    std::string param_name = lambda_op->lambda_op.parameters[j].variable.id;
                                    arg_it->setName(param_name);
                                    symbol_table[param_name] = &(*arg_it);
                                }
                            }
                        }
                    }

                    // CLOSURE MUTATION FIX: Store GlobalVariable directly so set! can modify captures
                    auto capture_it = lambda_capture_globals.find(var_name);
                    if (capture_it != lambda_capture_globals.end()) {
                        for (const auto& cap : capture_it->second) {
                            // Store the GlobalVariable directly (not loaded value) so set! can modify it
                            symbol_table[cap.first] = cap.second;
                            eshkol_debug("Letrec lambda %s: using global capture %s for mutability",
                                       var_name.c_str(), cap.first.c_str());
                        }
                    }

                    // Generate lambda body
                    Value* body_result = codegenAST(lambda_op->lambda_op.body);

                    // Handle return based on TCO mode
                    if (use_tco) {
                        // TCO mode: current block might be terminated by a tail call jump
                        BasicBlock* current_bb = builder->GetInsertBlock();
                        if (!current_bb->getTerminator()) {
                            // Body didn't end with tail call, needs a return
                            // Pack result and branch to return block
                            if (body_result) {
                                if (body_result->getType() != tagged_value_type) {
                                    if (body_result->getType()->isDoubleTy()) {
                                        body_result = packDoubleToTaggedValue(body_result);
                                    } else if (body_result->getType()->isIntegerTy(64)) {
                                        body_result = packInt64ToTaggedValue(body_result, ESHKOL_VALUE_INT64);
                                    } else if (body_result->getType()->isIntegerTy(32)) {
                                        body_result = packInt64ToTaggedValue(
                                            builder->CreateSExt(body_result, int64_type),
                                            ESHKOL_VALUE_INT64);
                                    } else if (body_result->getType()->isIntegerTy(1)) {
                                        body_result = packInt64ToTaggedValue(
                                            builder->CreateZExt(body_result, int64_type),
                                            ESHKOL_VALUE_INT64);
                                    }
                                }
                                builder->CreateRet(body_result);
                            } else {
                                builder->CreateRet(packNullToTaggedValue());
                            }
                        }

                        // Delete unused return block if it has no predecessors
                        if (return_bb && return_bb->hasNPredecessors(0)) {
                            return_bb->eraseFromParent();
                        }

                        // Restore TCO context
                        tco_context = prev_tco_context;
                    } else {
                        // Non-TCO path: normal return handling
                        if (body_result) {
                            if (body_result->getType() != tagged_value_type) {
                                if (body_result->getType()->isDoubleTy()) {
                                    body_result = packDoubleToTaggedValue(body_result);
                                } else if (body_result->getType()->isIntegerTy(64)) {
                                    body_result = packInt64ToTaggedValue(body_result, ESHKOL_VALUE_INT64);
                                } else if (body_result->getType()->isIntegerTy(32)) {
                                    // Handle i32 returns (e.g., from printf/newline)
                                    body_result = packInt64ToTaggedValue(
                                        builder->CreateSExt(body_result, int64_type),
                                        ESHKOL_VALUE_INT64);
                                } else if (body_result->getType()->isIntegerTy(1)) {
                                    body_result = packInt64ToTaggedValue(
                                        builder->CreateZExt(body_result, int64_type),
                                        ESHKOL_VALUE_INT64);
                                }
                            }
                            builder->CreateRet(body_result);
                        } else {
                            builder->CreateRet(packNullToTaggedValue());
                        }
                    }

                    // Restore context
                    symbol_table = lambda_scope;
                    current_function = prev_function;
                    builder->restoreIP(old_point);

                    // CLOSURE MUTATION FIX: Update outer scope to use GlobalVariables for captured variables
                    auto capture_it2 = lambda_capture_globals.find(var_name);
                    if (capture_it2 != lambda_capture_globals.end()) {
                        for (const auto& cap : capture_it2->second) {
                            symbol_table[cap.first] = cap.second;
                            eshkol_debug("Letrec: updated outer scope %s to use global storage", cap.first.c_str());
                        }
                    }

                    val = forward_func;
                    eshkol_debug("Letrec phase 4: generated body for %s", var_name.c_str());
                }
            } else {
                // Non-lambda binding - evaluate normally
                val = codegenAST(val_ast);
            }

            if (!val) {
                eshkol_warn("Failed to evaluate letrec binding value for %s", var_name.c_str());
                continue;
            }

            // Handle function bindings specially
            if (val && isa<Function>(val)) {
                Function* func = dyn_cast<Function>(val);

                // Store direct function reference
                symbol_table[var_name + "_func"] = func;
                global_symbol_table[var_name + "_func"] = func;

                // Convert function pointer to tagged value for storage
                val = packInt64ToTaggedValue(
                    builder->CreatePtrToInt(func, int64_type),
                    ESHKOL_VALUE_CONS_PTR
                );
            }
            // Ensure value is tagged_value_type for storage
            else if (val->getType() != tagged_value_type) {
                if (val->getType()->isDoubleTy()) {
                    val = packDoubleToTaggedValue(val);
                } else if (val->getType()->isIntegerTy(64)) {
                    val = packInt64ToTaggedValue(val, ESHKOL_VALUE_INT64);
                } else if (val->getType()->isIntegerTy(1)) {
                    val = packInt64ToTaggedValue(
                        builder->CreateZExt(val, int64_type),
                        ESHKOL_VALUE_INT64
                    );
                }
            }

            // Store value in global variable
            if (i < var_globals.size() && var_globals[i]) {
                builder->CreateStore(val, var_globals[i]);
                eshkol_debug("Letrec phase 4: stored value for %s", var_name.c_str());
            }
        }

        // PHASE 5: Evaluate body in the new scope with bindings
        Value* body_result = codegenAST(op->let_op.body);

        // Preserve _func entries before restoring symbol table
        std::unordered_map<std::string, Value*> func_refs_to_preserve;
        for (auto& entry : symbol_table) {
            if (entry.first.length() > 5 &&
                entry.first.substr(entry.first.length() - 5) == "_func") {
                func_refs_to_preserve[entry.first] = entry.second;
                global_symbol_table[entry.first] = entry.second;
                eshkol_debug("Letrec: preserving function reference: %s", entry.first.c_str());
            }
            // MUTABLE CAPTURE FIX: Also preserve GlobalVariable captures
            // These are variables that were moved to GlobalVariables when captured by lambdas
            if (isa<GlobalVariable>(entry.second)) {
                func_refs_to_preserve[entry.first] = entry.second;
                eshkol_debug("Letrec: preserving GlobalVariable capture: %s", entry.first.c_str());
            }
        }

        // Restore previous symbol table state
        symbol_table = prev_symbols;

        // Re-add preserved function references and GlobalVariable captures
        for (auto& entry : func_refs_to_preserve) {
            symbol_table[entry.first] = entry.second;
        }

        eshkol_debug("Letrec expression completed, scope restored (preserved %zu refs)",
                    func_refs_to_preserve.size());

        return body_result ? body_result : ConstantInt::get(int64_type, 0);
    }

    Value* codegenTensor(const eshkol_ast_t* ast) {
        if (!ast || ast->type != ESHKOL_TENSOR) return nullptr;
        
        // Use class member tensor_type (shared by all tensor operations)
        
        // Allocate memory for tensor structure
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* tensor_size = ConstantInt::get(int64_type, 
                                            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());
        
        // Allocate and populate dimensions array
        Value* dims_size = ConstantInt::get(int64_type, 
                                          ast->tensor_val.num_dimensions * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < ast->tensor_val.num_dimensions; i++) {
            Value* dim_ptr = builder->CreateGEP(int64_type, typed_dims_ptr, 
                                              ConstantInt::get(int64_type, i));
            builder->CreateStore(ConstantInt::get(int64_type, ast->tensor_val.dimensions[i]), dim_ptr);
        }
        
        // Allocate and populate elements array
        Value* elements_size = ConstantInt::get(int64_type, 
                                             ast->tensor_val.total_elements * sizeof(int64_t));
        Value* elements_ptr = builder->CreateCall(malloc_func, {elements_size});
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        for (uint64_t i = 0; i < ast->tensor_val.total_elements; i++) {
            Value* element_val = codegenAST(&ast->tensor_val.elements[i]);
            if (element_val) {
                // CRITICAL FIX: Store elements as int64, but preserve double bit patterns
                if (element_val->getType() != int64_type) {
                    if (element_val->getType()->isIntegerTy()) {
                        element_val = builder->CreateSExtOrTrunc(element_val, int64_type);
                    } else if (element_val->getType()->isFloatingPointTy()) {
                        // Use BitCast for doubles, NOT FPToSI (which truncates to integer!)
                        element_val = builder->CreateBitCast(element_val, int64_type);
                    } else {
                        element_val = ConstantInt::get(int64_type, 0);
                    }
                }
                
                Value* elem_ptr = builder->CreateGEP(int64_type, typed_elements_ptr,
                                                   ConstantInt::get(int64_type, i));
                builder->CreateStore(element_val, elem_ptr);
            }
        }
        
        // Store fields in tensor structure
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);
        
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, ast->tensor_val.num_dimensions), num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2);
        builder->CreateStore(typed_elements_ptr, elements_field_ptr);
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3);
        builder->CreateStore(ConstantInt::get(int64_type, ast->tensor_val.total_elements), total_elements_field_ptr);
        
        // Return pointer to tensor as int64
        return builder->CreatePtrToInt(typed_tensor_ptr, int64_type);
    }
    
    Value* codegenTensorVectorRef(const eshkol_operations_t* op) {
        // vref: (vref tensor index) - shorthand for (tensor-get tensor index)
        // Simplified 1D tensor access for numerical arrays
        // PHASE 3/4 FIX: Now AD-aware - detects and preserves AD node pointers
        if (op->call_op.num_vars != 2) {
            eshkol_error("vref requires exactly 2 arguments: tensor and index");
            return nullptr;
        }
        
        Value* vector_val = codegenAST(&op->call_op.variables[0]);
        Value* index = codegenAST(&op->call_op.variables[1]);
        if (!vector_val || !index) return nullptr;
        
        // CRITICAL FIX: Detect if input is AD_NODE_PTR (scalar gradient case) vs TENSOR_PTR
        // Gradient with scalar functions passes single AD node, not tensor!
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Check if vector_val is tagged_value with AD_NODE_PTR, VECTOR_PTR, or TENSOR_PTR type
        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(int8_type, 0x0F));

        Value* is_ad_node_ptr = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* is_vector_ptr = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* ad_node_input = BasicBlock::Create(*context, "vref_ad_node_input", current_func);
        BasicBlock* scheme_vector_input = BasicBlock::Create(*context, "vref_scheme_vector_input", current_func);
        BasicBlock* tensor_input = BasicBlock::Create(*context, "vref_tensor_input", current_func);
        BasicBlock* vref_final = BasicBlock::Create(*context, "vref_final", current_func);

        BasicBlock* check_vector = BasicBlock::Create(*context, "vref_check_vector", current_func);
        builder->CreateCondBr(is_ad_node_ptr, ad_node_input, check_vector);

        builder->SetInsertPoint(check_vector);
        builder->CreateCondBr(is_vector_ptr, scheme_vector_input, tensor_input);
        
        // AD NODE INPUT: Extract value directly from AD node structure (NOT tensor!)
        builder->SetInsertPoint(ad_node_input);
        
        // Unpack AD node pointer from tagged_value
        Value* ad_node_ptr = unpackPtrFromTaggedValue(vector_val);
        
        // AD node struct: {type, value, gradient, input1, input2, id}
        // We want field 1 (value)
        Value* value_field_ptr = builder->CreateStructGEP(ad_node_type, ad_node_ptr, 1);
        Value* ad_value = builder->CreateLoad(double_type, value_field_ptr);
        
        // Return value as tagged_value (gradient expects this)
        Value* ad_result = packPtrToTaggedValue(ad_node_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_final);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // SCHEME VECTOR INPUT: Handle Scheme vectors (from (vector ...))
        // Scheme vector layout: [length (8 bytes)] + [tagged_value elements (16 bytes each)]
        builder->SetInsertPoint(scheme_vector_input);

        Value* scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* scheme_vec_ptr = builder->CreateIntToPtr(scheme_vec_ptr_int, builder->getPtrTy());

        // Get index as int64
        Value* scheme_index_int = safeExtractInt64(index);

        // Get pointer to elements (after length field - 8 bytes offset)
        Value* scheme_elem_base = builder->CreateGEP(int8_type, scheme_vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* scheme_elem_base_typed = builder->CreateBitCast(scheme_elem_base, PointerType::getUnqual(*context));

        // Get element at index
        Value* scheme_elem_ptr = builder->CreateGEP(tagged_value_type, scheme_elem_base_typed, scheme_index_int);
        Value* scheme_result = builder->CreateLoad(tagged_value_type, scheme_elem_ptr);
        builder->CreateBr(vref_final);
        BasicBlock* scheme_vector_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Normal tensor access path (existing logic)
        builder->SetInsertPoint(tensor_input);
        
        // Unpack if tagged_value (lambda parameters are tagged_value)
        Value* vector_ptr_int = safeExtractInt64(vector_val);
        Value* index_int = safeExtractInt64(index);
        
        // Use class member tensor_type (shared by all tensor operations)
        
        Value* vector_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        // Get elements array
        Value* elements_field = builder->CreateStructGEP(tensor_type, vector_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Load element as int64 (could be double bitcasted OR AD node pointer)
        Value* elem_ptr = builder->CreateGEP(int64_type, typed_elements_ptr, index_int);
        Value* elem_as_int64 = builder->CreateLoad(int64_type, elem_ptr);
        
        // PHASE 1 FIX: Runtime AD mode detection using global flag
        // Handle 3 cases: small integers, doubles (bitcast), AD node pointers
        
        // PHASE 1 FIX: Check global __ad_mode_active flag at RUNTIME
        Value* in_ad_mode = builder->CreateLoad(int1_type, ad_mode_active);

        BasicBlock* ad_mode_check = BasicBlock::Create(*context, "vref_ad_mode_check", current_func);
        BasicBlock* normal_mode_check = BasicBlock::Create(*context, "vref_normal_mode_check", current_func);
        BasicBlock* int_path = BasicBlock::Create(*context, "vref_int", current_func);
        BasicBlock* check_large = BasicBlock::Create(*context, "vref_check_large", current_func);
        BasicBlock* double_path = BasicBlock::Create(*context, "vref_double", current_func);
        BasicBlock* tensor_ad_node_path = BasicBlock::Create(*context, "vref_tensor_ad_node", current_func);
        BasicBlock* vref_merge = BasicBlock::Create(*context, "vref_merge", current_func);
        
        builder->CreateCondBr(in_ad_mode, ad_mode_check, normal_mode_check);

        // AD mode path: MUST STILL distinguish AD nodes from regular doubles!
        // Captured tensors like 'x' contain regular doubles even when ad_mode_active=true
        builder->SetInsertPoint(ad_mode_check);
        Value* is_small_in_ad = builder->CreateICmpULT(elem_as_int64,
            ConstantInt::get(int64_type, 1000));
        BasicBlock* ad_mode_small = BasicBlock::Create(*context, "vref_ad_small", current_func);
        BasicBlock* ad_mode_large = BasicBlock::Create(*context, "vref_ad_large", current_func);
        builder->CreateCondBr(is_small_in_ad, ad_mode_small, ad_mode_large);

        // AD mode, small value: integer
        builder->SetInsertPoint(ad_mode_small);
        Value* ad_int_tagged = packInt64ToTaggedValue(elem_as_int64, true);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_small_exit = builder->GetInsertBlock();

        // AD mode, large value: CRITICAL FIX - use IEEE754 exponent check like normal mode
        // AD node pointers are memory addresses (no exponent bits in high position)
        // Doubles have exponent bits set (0x7FF0000000000000 mask)
        builder->SetInsertPoint(ad_mode_large);
        Value* ad_exponent_mask = ConstantInt::get(int64_type, 0x7FF0000000000000ULL);
        Value* ad_exponent_bits = builder->CreateAnd(elem_as_int64, ad_exponent_mask);
        Value* ad_has_exponent = builder->CreateICmpNE(ad_exponent_bits,
            ConstantInt::get(int64_type, 0));

        BasicBlock* ad_large_is_double = BasicBlock::Create(*context, "vref_ad_large_double", current_func);
        BasicBlock* ad_large_is_ptr = BasicBlock::Create(*context, "vref_ad_large_ptr", current_func);
        builder->CreateCondBr(ad_has_exponent, ad_large_is_double, ad_large_is_ptr);

        // AD mode, large value with exponent: it's a double (e.g., captured constant tensor)
        builder->SetInsertPoint(ad_large_is_double);
        Value* ad_elem_double = builder->CreateBitCast(elem_as_int64, double_type);
        Value* ad_double_tagged = packDoubleToTaggedValue(ad_elem_double);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_double_exit = builder->GetInsertBlock();

        // AD mode, large value without exponent: AD node pointer
        builder->SetInsertPoint(ad_large_is_ptr);
        Value* ad_ptr = builder->CreateIntToPtr(elem_as_int64, PointerType::getUnqual(*context));
        Value* ad_tagged = packPtrToTaggedValue(ad_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_large_exit = builder->GetInsertBlock();
        
        // Normal mode path: use existing IEEE754 heuristic
        builder->SetInsertPoint(normal_mode_check);
        Value* is_small_int = builder->CreateICmpULT(elem_as_int64,
            ConstantInt::get(int64_type, 1000));
        builder->CreateCondBr(is_small_int, int_path, check_large);
        
        // Small integer path: Pack as int64
        builder->SetInsertPoint(int_path);
        Value* int_tagged = packInt64ToTaggedValue(elem_as_int64, true);
        builder->CreateBr(vref_merge);
        BasicBlock* int_exit = builder->GetInsertBlock();
        
        // Check if large value is double (has exponent) or pointer (no exponent)
        builder->SetInsertPoint(check_large);
        Value* exponent_mask = ConstantInt::get(int64_type, 0x7FF0000000000000ULL);
        Value* exponent_bits = builder->CreateAnd(elem_as_int64, exponent_mask);
        Value* has_exponent = builder->CreateICmpNE(exponent_bits,
            ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(has_exponent, double_path, tensor_ad_node_path);
        
        // Double path: Bitcast int64 to double and pack
        builder->SetInsertPoint(double_path);
        Value* elem_double = builder->CreateBitCast(elem_as_int64, double_type);
        Value* double_tagged = packDoubleToTaggedValue(elem_double);
        builder->CreateBr(vref_merge);
        BasicBlock* double_exit = builder->GetInsertBlock();
        
        // AD node path: Treat as AD node pointer (fallback for normal mode)
        builder->SetInsertPoint(tensor_ad_node_path);
        Value* tensor_ad_node_ptr = builder->CreateIntToPtr(elem_as_int64, PointerType::getUnqual(*context));
        Value* tensor_ad_node_tagged = packPtrToTaggedValue(tensor_ad_node_ptr, ESHKOL_VALUE_AD_NODE_PTR);
        builder->CreateBr(vref_merge);
        BasicBlock* ad_exit = builder->GetInsertBlock();
        
        // Merge: Return tagged_value (int, double, or AD node from tensor)
        builder->SetInsertPoint(vref_merge);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 6, "vref_result");
        result_phi->addIncoming(ad_int_tagged, ad_small_exit);
        result_phi->addIncoming(ad_double_tagged, ad_double_exit);  // AD mode double (captured tensors)
        result_phi->addIncoming(ad_tagged, ad_large_exit);          // AD mode AD node pointer
        result_phi->addIncoming(int_tagged, int_exit);
        result_phi->addIncoming(double_tagged, double_exit);
        result_phi->addIncoming(tensor_ad_node_tagged, ad_exit);
        builder->CreateBr(vref_final);
        
        // Final merge: Return tensor element, Scheme vector element, or AD node
        builder->SetInsertPoint(vref_final);
        PHINode* final_result = builder->CreatePHI(tagged_value_type, 3, "vref_final_result");
        final_result->addIncoming(ad_result, ad_node_exit);
        final_result->addIncoming(scheme_result, scheme_vector_exit);
        final_result->addIncoming(result_phi, vref_merge);

        return final_result;
    }

    // flatten: (flatten tensor) - Return 1D view of tensor
    Value* codegenFlatten(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("flatten requires exactly 1 argument");
            return nullptr;
        }

        Value* src_tensor = codegenAST(&op->call_op.variables[0]);
        if (!src_tensor) return nullptr;

        Value* src_ptr;
        if (src_tensor->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(src_tensor);
            src_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            src_ptr = builder->CreateIntToPtr(src_tensor, builder->getPtrTy());
        }

        // Get source total elements
        Value* src_total_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 3);
        Value* src_total = builder->CreateLoad(int64_type, src_total_field_ptr);

        // Get source elements pointer
        Value* src_elements_field_ptr = builder->CreateStructGEP(tensor_type, src_ptr, 2);
        Value* src_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_elements_field_ptr);

        // Create new 1D tensor (zero-copy - reuse elements)
        Function* malloc_func = function_table["malloc"];
        Value* tensor_size = ConstantInt::get(int64_type,
                                             module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* new_tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_new_tensor_ptr = builder->CreatePointerCast(new_tensor_ptr, builder->getPtrTy());

        // Allocate single dimension
        Value* dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        builder->CreateStore(src_total, typed_dims_ptr);

        // Store tensor fields
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 0);
        builder->CreateStore(typed_dims_ptr, dims_field_ptr);

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 1), num_dims_field_ptr);

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 2);
        builder->CreateStore(src_elements_ptr, elements_field_ptr);  // Zero-copy!

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_new_tensor_ptr, 3);
        builder->CreateStore(src_total, total_elements_field_ptr);

        return packPtrToTaggedValue(typed_new_tensor_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }

    // matmul: (matmul A B) - Matrix multiplication [M x K] @ [K x N] -> [M x N]
    Value* codegenMatmul(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_error("matmul requires exactly 2 arguments");
            return nullptr;
        }

        Value* tensor_a = codegenAST(&op->call_op.variables[0]);
        Value* tensor_b = codegenAST(&op->call_op.variables[1]);
        if (!tensor_a || !tensor_b) return nullptr;

        // Extract tensor pointers
        Value* ptr_a;
        if (tensor_a->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(tensor_a);
            ptr_a = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            ptr_a = builder->CreateIntToPtr(tensor_a, builder->getPtrTy());
        }

        Value* ptr_b;
        if (tensor_b->getType() == tagged_value_type) {
            Value* ptr_int = unpackInt64FromTaggedValue(tensor_b);
            ptr_b = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
        } else {
            ptr_b = builder->CreateIntToPtr(tensor_b, builder->getPtrTy());
        }

        // Get A dimensions [M x K]
        Value* a_dims_field_ptr = builder->CreateStructGEP(tensor_type, ptr_a, 0);
        Value* a_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), a_dims_field_ptr);
        Value* typed_a_dims_ptr = builder->CreatePointerCast(a_dims_ptr, builder->getPtrTy());
        Value* M = builder->CreateLoad(int64_type, typed_a_dims_ptr);
        Value* a_dim1_ptr = builder->CreateGEP(int64_type, typed_a_dims_ptr,
                                              ConstantInt::get(int64_type, 1));
        Value* K = builder->CreateLoad(int64_type, a_dim1_ptr);

        // Get B dimensions [K x N]
        Value* b_dims_field_ptr = builder->CreateStructGEP(tensor_type, ptr_b, 0);
        Value* b_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), b_dims_field_ptr);
        Value* typed_b_dims_ptr = builder->CreatePointerCast(b_dims_ptr, builder->getPtrTy());
        Value* b_dim1_ptr = builder->CreateGEP(int64_type, typed_b_dims_ptr,
                                              ConstantInt::get(int64_type, 1));
        Value* N = builder->CreateLoad(int64_type, b_dim1_ptr);

        // Get elements pointers
        Value* a_elements_field_ptr = builder->CreateStructGEP(tensor_type, ptr_a, 2);
        Value* a_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), a_elements_field_ptr);
        Value* typed_a_elements = builder->CreatePointerCast(a_elements_ptr, builder->getPtrTy());

        Value* b_elements_field_ptr = builder->CreateStructGEP(tensor_type, ptr_b, 2);
        Value* b_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), b_elements_field_ptr);
        Value* typed_b_elements = builder->CreatePointerCast(b_elements_ptr, builder->getPtrTy());

        // Create result tensor [M x N]
        std::vector<Value*> result_dims = {M, N};
        Value* result_ptr = tensor_->createTensorWithDims(result_dims, nullptr, true);  // Zero-fill
        if (!result_ptr) return nullptr;

        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, result_ptr, 2);
        Value* result_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), result_elements_field_ptr);
        Value* typed_result_elements = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());

        // Triple nested loop for matrix multiplication
        // C[i][j] = sum_k(A[i][k] * B[k][j])
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* i_cond = BasicBlock::Create(*context, "mm_i_cond", current_func);
        BasicBlock* i_body = BasicBlock::Create(*context, "mm_i_body", current_func);
        BasicBlock* j_cond = BasicBlock::Create(*context, "mm_j_cond", current_func);
        BasicBlock* j_body = BasicBlock::Create(*context, "mm_j_body", current_func);
        BasicBlock* k_cond = BasicBlock::Create(*context, "mm_k_cond", current_func);
        BasicBlock* k_body = BasicBlock::Create(*context, "mm_k_body", current_func);
        BasicBlock* k_exit = BasicBlock::Create(*context, "mm_k_exit", current_func);
        BasicBlock* j_exit = BasicBlock::Create(*context, "mm_j_exit", current_func);
        BasicBlock* i_exit = BasicBlock::Create(*context, "mm_i_exit", current_func);

        Value* i_counter = builder->CreateAlloca(int64_type, nullptr, "mm_i");
        Value* j_counter = builder->CreateAlloca(int64_type, nullptr, "mm_j");
        Value* k_counter = builder->CreateAlloca(int64_type, nullptr, "mm_k");
        Value* sum_acc = builder->CreateAlloca(double_type, nullptr, "mm_sum");

        builder->CreateStore(ConstantInt::get(int64_type, 0), i_counter);
        builder->CreateBr(i_cond);

        // i loop
        builder->SetInsertPoint(i_cond);
        Value* i = builder->CreateLoad(int64_type, i_counter);
        Value* i_cmp = builder->CreateICmpULT(i, M);
        builder->CreateCondBr(i_cmp, i_body, i_exit);

        builder->SetInsertPoint(i_body);
        builder->CreateStore(ConstantInt::get(int64_type, 0), j_counter);
        builder->CreateBr(j_cond);

        // j loop
        builder->SetInsertPoint(j_cond);
        Value* j = builder->CreateLoad(int64_type, j_counter);
        Value* j_cmp = builder->CreateICmpULT(j, N);
        builder->CreateCondBr(j_cmp, j_body, j_exit);

        builder->SetInsertPoint(j_body);
        builder->CreateStore(ConstantFP::get(double_type, 0.0), sum_acc);
        builder->CreateStore(ConstantInt::get(int64_type, 0), k_counter);
        builder->CreateBr(k_cond);

        // k loop (inner accumulation)
        builder->SetInsertPoint(k_cond);
        Value* k = builder->CreateLoad(int64_type, k_counter);
        Value* k_cmp = builder->CreateICmpULT(k, K);
        builder->CreateCondBr(k_cmp, k_body, k_exit);

        builder->SetInsertPoint(k_body);
        // A[i][k] = A[i * K + k]
        Value* a_idx = builder->CreateMul(i, K);
        a_idx = builder->CreateAdd(a_idx, k);
        Value* a_elem_ptr = builder->CreateGEP(int64_type, typed_a_elements, a_idx);
        Value* a_bits = builder->CreateLoad(int64_type, a_elem_ptr);
        Value* a_val = builder->CreateBitCast(a_bits, double_type);

        // B[k][j] = B[k * N + j]
        Value* b_idx = builder->CreateMul(k, N);
        b_idx = builder->CreateAdd(b_idx, j);
        Value* b_elem_ptr = builder->CreateGEP(int64_type, typed_b_elements, b_idx);
        Value* b_bits = builder->CreateLoad(int64_type, b_elem_ptr);
        Value* b_val = builder->CreateBitCast(b_bits, double_type);

        // sum += A[i][k] * B[k][j]
        Value* product = builder->CreateFMul(a_val, b_val);
        Value* current_sum = builder->CreateLoad(double_type, sum_acc);
        Value* new_sum = builder->CreateFAdd(current_sum, product);
        builder->CreateStore(new_sum, sum_acc);

        Value* next_k = builder->CreateAdd(k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_k, k_counter);
        builder->CreateBr(k_cond);

        // k exit - store result
        builder->SetInsertPoint(k_exit);
        Value* final_sum = builder->CreateLoad(double_type, sum_acc);
        Value* result_bits = builder->CreateBitCast(final_sum, int64_type);
        // C[i][j] = C[i * N + j]
        Value* c_idx = builder->CreateMul(i, N);
        c_idx = builder->CreateAdd(c_idx, j);
        Value* c_elem_ptr = builder->CreateGEP(int64_type, typed_result_elements, c_idx);
        builder->CreateStore(result_bits, c_elem_ptr);

        Value* next_j = builder->CreateAdd(j, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_j, j_counter);
        builder->CreateBr(j_cond);

        // j exit
        builder->SetInsertPoint(j_exit);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, i_counter);
        builder->CreateBr(i_cond);

        // i exit
        builder->SetInsertPoint(i_exit);
        return packPtrToTaggedValue(result_ptr, ESHKOL_VALUE_TENSOR_PTR);
    }


    // trace: (trace matrix) - Sum of diagonal elements
    Value* codegenTrace(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("trace requires exactly 1 argument");
            return nullptr;
        }

        Value* src_val = codegenAST(&op->call_op.variables[0]);
        if (!src_val) return nullptr;

        // Get tensor pointer
        Value* tensor_ptr_int = unpackInt64FromTaggedValue(src_val);
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());

        // Load tensor structure
        Value* dims_ptr_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_ptr_field);
        Value* ndim_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* ndim = builder->CreateLoad(int64_type, ndim_field);
        Value* elems_ptr_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elems_ptr_field);

        // Verify 2D matrix
        Value* is_2d = builder->CreateICmpEQ(ndim, ConstantInt::get(int64_type, 2));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* valid_bb = BasicBlock::Create(*context, "trace_valid", current_func);
        BasicBlock* invalid_bb = BasicBlock::Create(*context, "trace_invalid", current_func);
        BasicBlock* merge_bb = BasicBlock::Create(*context, "trace_merge", current_func);

        builder->CreateCondBr(is_2d, valid_bb, invalid_bb);

        // Invalid case - return 0
        builder->SetInsertPoint(invalid_bb);
        Value* zero_result = ConstantFP::get(double_type, 0.0);
        builder->CreateBr(merge_bb);
        BasicBlock* invalid_exit = builder->GetInsertBlock();

        // Valid case - sum diagonal
        builder->SetInsertPoint(valid_bb);
        Value* rows = builder->CreateLoad(int64_type, dims_ptr);
        Value* cols_ptr = builder->CreateGEP(int64_type, dims_ptr,
            ConstantInt::get(int64_type, 1));
        Value* cols = builder->CreateLoad(int64_type, cols_ptr);

        // min(rows, cols) for diagonal length
        Value* rows_less = builder->CreateICmpULT(rows, cols);
        Value* diag_len = builder->CreateSelect(rows_less, rows, cols);

        // Sum loop
        BasicBlock* loop_cond = BasicBlock::Create(*context, "trace_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "trace_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "trace_exit", current_func);

        Value* sum_alloca = builder->CreateAlloca(double_type, nullptr, "trace_sum");
        Value* i_alloca = builder->CreateAlloca(int64_type, nullptr, "trace_i");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), sum_alloca);
        builder->CreateStore(ConstantInt::get(int64_type, 0), i_alloca);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(int64_type, i_alloca);
        Value* cond = builder->CreateICmpULT(i, diag_len);
        builder->CreateCondBr(cond, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        // Linear index: i * cols + i = i * (cols + 1)
        Value* cols_plus_1 = builder->CreateAdd(cols, ConstantInt::get(int64_type, 1));
        Value* idx = builder->CreateMul(i, cols_plus_1);
        Value* elem_ptr = builder->CreateGEP(int64_type, elems_ptr, idx);
        Value* elem_bits = builder->CreateLoad(int64_type, elem_ptr);
        Value* elem_val = builder->CreateBitCast(elem_bits, double_type);

        Value* cur_sum = builder->CreateLoad(double_type, sum_alloca);
        Value* new_sum = builder->CreateFAdd(cur_sum, elem_val);
        builder->CreateStore(new_sum, sum_alloca);

        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, i_alloca);
        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);
        Value* trace_result = builder->CreateLoad(double_type, sum_alloca);
        builder->CreateBr(merge_bb);
        BasicBlock* valid_exit = builder->GetInsertBlock();

        // Merge
        builder->SetInsertPoint(merge_bb);
        PHINode* result_phi = builder->CreatePHI(double_type, 2, "trace_result");
        result_phi->addIncoming(zero_result, invalid_exit);
        result_phi->addIncoming(trace_result, valid_exit);

        return packDoubleToTaggedValue(result_phi);
    }

    // det: Now implemented in lib/math.esk using pure Eshkol
    // The compiler-level implementation was removed due to complexity.

    // norm: (norm vector) - Euclidean norm (L2 norm)
    Value* codegenNorm(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("norm requires exactly 1 argument");
            return nullptr;
        }

        Value* src_val = codegenAST(&op->call_op.variables[0]);
        if (!src_val) return nullptr;

        // Check type
        Value* val_type = getTaggedValueType(src_val);
        Value* is_scheme_vector = builder->CreateICmpEQ(val_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* scheme_vec_bb = BasicBlock::Create(*context, "norm_svec", current_func);
        BasicBlock* tensor_bb = BasicBlock::Create(*context, "norm_tensor", current_func);
        BasicBlock* merge_bb = BasicBlock::Create(*context, "norm_merge", current_func);

        builder->CreateCondBr(is_scheme_vector, scheme_vec_bb, tensor_bb);

        // Scheme vector path
        builder->SetInsertPoint(scheme_vec_bb);
        Value* svec_ptr_int = unpackInt64FromTaggedValue(src_val);
        Value* svec_ptr = builder->CreateIntToPtr(svec_ptr_int, builder->getPtrTy());
        Value* svec_len = builder->CreateLoad(int64_type, svec_ptr);

        BasicBlock* svec_loop_cond = BasicBlock::Create(*context, "norm_svec_cond", current_func);
        BasicBlock* svec_loop_body = BasicBlock::Create(*context, "norm_svec_body", current_func);
        BasicBlock* svec_loop_exit = BasicBlock::Create(*context, "norm_svec_exit", current_func);

        Value* svec_sum = builder->CreateAlloca(double_type, nullptr, "norm_svec_sum");
        Value* svec_i = builder->CreateAlloca(int64_type, nullptr, "norm_svec_i");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), svec_sum);
        builder->CreateStore(ConstantInt::get(int64_type, 0), svec_i);
        builder->CreateBr(svec_loop_cond);

        builder->SetInsertPoint(svec_loop_cond);
        Value* si = builder->CreateLoad(int64_type, svec_i);
        Value* scond = builder->CreateICmpULT(si, svec_len);
        builder->CreateCondBr(scond, svec_loop_body, svec_loop_exit);

        builder->SetInsertPoint(svec_loop_body);
        Value* svec_elems = builder->CreateGEP(int8_type, svec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* svec_elems_typed = builder->CreatePointerCast(svec_elems, PointerType::getUnqual(*context));
        Value* svec_elem_ptr = builder->CreateGEP(tagged_value_type, svec_elems_typed, si);
        Value* svec_elem_tagged = builder->CreateLoad(tagged_value_type, svec_elem_ptr);
        Value* svec_elem_val = unpackDoubleFromTaggedValue(svec_elem_tagged);

        Value* squared = builder->CreateFMul(svec_elem_val, svec_elem_val);
        Value* cur_sum = builder->CreateLoad(double_type, svec_sum);
        Value* new_sum = builder->CreateFAdd(cur_sum, squared);
        builder->CreateStore(new_sum, svec_sum);

        Value* next_si = builder->CreateAdd(si, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_si, svec_i);
        builder->CreateBr(svec_loop_cond);

        builder->SetInsertPoint(svec_loop_exit);
        Value* svec_final_sum = builder->CreateLoad(double_type, svec_sum);
        Value* svec_norm = builder->CreateCall(function_table["sqrt"], {svec_final_sum});
        builder->CreateBr(merge_bb);
        BasicBlock* svec_exit = builder->GetInsertBlock();

        // Tensor path
        builder->SetInsertPoint(tensor_bb);
        Value* tensor_ptr_int = unpackInt64FromTaggedValue(src_val);
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        Value* total_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* total = builder->CreateLoad(int64_type, total_field);
        Value* elems_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elems_field);

        BasicBlock* tensor_loop_cond = BasicBlock::Create(*context, "norm_tensor_cond", current_func);
        BasicBlock* tensor_loop_body = BasicBlock::Create(*context, "norm_tensor_body", current_func);
        BasicBlock* tensor_loop_exit = BasicBlock::Create(*context, "norm_tensor_exit", current_func);

        Value* tensor_sum = builder->CreateAlloca(double_type, nullptr, "norm_tensor_sum");
        Value* tensor_i = builder->CreateAlloca(int64_type, nullptr, "norm_tensor_i");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), tensor_sum);
        builder->CreateStore(ConstantInt::get(int64_type, 0), tensor_i);
        builder->CreateBr(tensor_loop_cond);

        builder->SetInsertPoint(tensor_loop_cond);
        Value* ti = builder->CreateLoad(int64_type, tensor_i);
        Value* tcond = builder->CreateICmpULT(ti, total);
        builder->CreateCondBr(tcond, tensor_loop_body, tensor_loop_exit);

        builder->SetInsertPoint(tensor_loop_body);
        Value* tensor_elem_ptr = builder->CreateGEP(int64_type, elems_ptr, ti);
        Value* tensor_elem_bits = builder->CreateLoad(int64_type, tensor_elem_ptr);
        Value* tensor_elem_val = builder->CreateBitCast(tensor_elem_bits, double_type);

        Value* t_squared = builder->CreateFMul(tensor_elem_val, tensor_elem_val);
        Value* t_cur_sum = builder->CreateLoad(double_type, tensor_sum);
        Value* t_new_sum = builder->CreateFAdd(t_cur_sum, t_squared);
        builder->CreateStore(t_new_sum, tensor_sum);

        Value* next_ti = builder->CreateAdd(ti, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_ti, tensor_i);
        builder->CreateBr(tensor_loop_cond);

        builder->SetInsertPoint(tensor_loop_exit);
        Value* tensor_final_sum = builder->CreateLoad(double_type, tensor_sum);
        Value* tensor_norm = builder->CreateCall(function_table["sqrt"], {tensor_final_sum});
        builder->CreateBr(merge_bb);
        BasicBlock* tensor_exit = builder->GetInsertBlock();

        // Merge
        builder->SetInsertPoint(merge_bb);
        PHINode* norm_result = builder->CreatePHI(double_type, 2, "norm_result");
        norm_result->addIncoming(svec_norm, svec_exit);
        norm_result->addIncoming(tensor_norm, tensor_exit);

        return packDoubleToTaggedValue(norm_result);
    }

    // outer: (outer v1 v2) - Outer product of two vectors
    Value* codegenOuterProduct(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_error("outer requires exactly 2 arguments");
            return nullptr;
        }

        Value* v1_val = codegenAST(&op->call_op.variables[0]);
        Value* v2_val = codegenAST(&op->call_op.variables[1]);
        if (!v1_val || !v2_val) return nullptr;

        Function* malloc_func = function_table["malloc"];

        // Get vectors (assuming tensors for simplicity)
        Value* v1_ptr_int = unpackInt64FromTaggedValue(v1_val);
        Value* v1_ptr = builder->CreateIntToPtr(v1_ptr_int, builder->getPtrTy());
        Value* v2_ptr_int = unpackInt64FromTaggedValue(v2_val);
        Value* v2_ptr = builder->CreateIntToPtr(v2_ptr_int, builder->getPtrTy());

        // Get lengths
        Value* v1_total_field = builder->CreateStructGEP(tensor_type, v1_ptr, 3);
        Value* m = builder->CreateLoad(int64_type, v1_total_field);
        Value* v2_total_field = builder->CreateStructGEP(tensor_type, v2_ptr, 3);
        Value* n = builder->CreateLoad(int64_type, v2_total_field);

        // Get element pointers
        Value* v1_elems_field = builder->CreateStructGEP(tensor_type, v1_ptr, 2);
        Value* v1_elems = builder->CreateLoad(PointerType::getUnqual(*context), v1_elems_field);
        Value* v2_elems_field = builder->CreateStructGEP(tensor_type, v2_ptr, 2);
        Value* v2_elems = builder->CreateLoad(PointerType::getUnqual(*context), v2_elems_field);

        // Allocate result tensor (m x n matrix)
        Value* result_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_ptr = builder->CreateCall(malloc_func, {result_size});

        // Allocate dims (2 elements)
        Value* dims_size = ConstantInt::get(int64_type, 2 * sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        builder->CreateStore(m, dims_ptr);
        Value* dims_1 = builder->CreateGEP(int64_type, dims_ptr,
            ConstantInt::get(int64_type, 1));
        builder->CreateStore(n, dims_1);

        // Allocate elements (m*n doubles)
        Value* total = builder->CreateMul(m, n);
        Value* elems_size = builder->CreateMul(total, ConstantInt::get(int64_type, sizeof(double)));
        Value* elems_ptr = builder->CreateCall(malloc_func, {elems_size});

        // Set tensor structure
        builder->CreateStore(dims_ptr, builder->CreateStructGEP(tensor_type, result_ptr, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 2),
            builder->CreateStructGEP(tensor_type, result_ptr, 1));
        builder->CreateStore(elems_ptr, builder->CreateStructGEP(tensor_type, result_ptr, 2));
        builder->CreateStore(total, builder->CreateStructGEP(tensor_type, result_ptr, 3));

        // Compute outer product: result[i,j] = v1[i] * v2[j]
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* outer_i_cond = BasicBlock::Create(*context, "outer_i_cond", current_func);
        BasicBlock* outer_i_body = BasicBlock::Create(*context, "outer_i_body", current_func);
        BasicBlock* outer_j_cond = BasicBlock::Create(*context, "outer_j_cond", current_func);
        BasicBlock* outer_j_body = BasicBlock::Create(*context, "outer_j_body", current_func);
        BasicBlock* outer_j_exit = BasicBlock::Create(*context, "outer_j_exit", current_func);
        BasicBlock* outer_i_exit = BasicBlock::Create(*context, "outer_i_exit", current_func);

        Value* i_alloca = builder->CreateAlloca(int64_type, nullptr, "outer_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), i_alloca);
        builder->CreateBr(outer_i_cond);

        builder->SetInsertPoint(outer_i_cond);
        Value* i = builder->CreateLoad(int64_type, i_alloca);
        Value* i_cond = builder->CreateICmpULT(i, m);
        builder->CreateCondBr(i_cond, outer_i_body, outer_i_exit);

        builder->SetInsertPoint(outer_i_body);
        // Load v1[i]
        Value* v1_i_ptr = builder->CreateGEP(int64_type, v1_elems, i);
        Value* v1_i_bits = builder->CreateLoad(int64_type, v1_i_ptr);
        Value* v1_i = builder->CreateBitCast(v1_i_bits, double_type);

        Value* j_alloca = builder->CreateAlloca(int64_type, nullptr, "outer_j");
        builder->CreateStore(ConstantInt::get(int64_type, 0), j_alloca);
        builder->CreateBr(outer_j_cond);

        builder->SetInsertPoint(outer_j_cond);
        Value* j = builder->CreateLoad(int64_type, j_alloca);
        Value* j_cond = builder->CreateICmpULT(j, n);
        builder->CreateCondBr(j_cond, outer_j_body, outer_j_exit);

        builder->SetInsertPoint(outer_j_body);
        // Load v2[j]
        Value* v2_j_ptr = builder->CreateGEP(int64_type, v2_elems, j);
        Value* v2_j_bits = builder->CreateLoad(int64_type, v2_j_ptr);
        Value* v2_j = builder->CreateBitCast(v2_j_bits, double_type);

        // result[i*n + j] = v1[i] * v2[j]
        Value* prod = builder->CreateFMul(v1_i, v2_j);
        Value* prod_bits = builder->CreateBitCast(prod, int64_type);
        Value* idx = builder->CreateAdd(builder->CreateMul(i, n), j);
        Value* res_elem_ptr = builder->CreateGEP(int64_type, elems_ptr, idx);
        builder->CreateStore(prod_bits, res_elem_ptr);

        Value* next_j = builder->CreateAdd(j, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_j, j_alloca);
        builder->CreateBr(outer_j_cond);

        builder->SetInsertPoint(outer_j_exit);
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, i_alloca);
        builder->CreateBr(outer_i_cond);

        builder->SetInsertPoint(outer_i_exit);
        Value* result_int = builder->CreatePtrToInt(result_ptr, int64_type);
        return packPtrToTaggedValue(result_int, ESHKOL_VALUE_TENSOR_PTR);
    }

    // Symbolic differentiation function
    // Returns S-expression (list) representing symbolic derivative formula
    Value* codegenDiff(const eshkol_operations_t* op) {
        if (!op->diff_op.expression || !op->diff_op.variable) {
            eshkol_error("Invalid diff operation");
            return nullptr;
        }
        
        const char* var = op->diff_op.variable;
        eshkol_info("Building symbolic derivative S-expression for %s", var);
        
        // STEP 1: Build symbolic derivative as AST (compile-time)
        eshkol_ast_t* symbolic_deriv = buildSymbolicDerivative(
            op->diff_op.expression,
            var
        );
        
        if (!symbolic_deriv) {
            eshkol_error("Failed to build symbolic derivative");
            return packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
        }
        
        // STEP 2: Generate runtime code that constructs the S-expression
        // For simple constants, return them directly (not as lists)
        if (symbolic_deriv->type == ESHKOL_INT64 || symbolic_deriv->type == ESHKOL_DOUBLE) {
            Value* result = codegenQuotedAST(symbolic_deriv);
            
            // Clean up temporary AST
            eshkol_ast_clean(symbolic_deriv);
            free(symbolic_deriv);
            
            eshkol_info("Generated constant symbolic derivative");
            return result;
        }
        
        // For complex expressions, convert to S-expression list
        Value* result = codegenQuotedAST(symbolic_deriv);
        
        // Clean up temporary AST
        eshkol_ast_clean(symbolic_deriv);
        free(symbolic_deriv);
        
        eshkol_info("Generated symbolic derivative S-expression");
        
        return result;
    }
    
    // ===== PHASE 0: AUTODIFF TYPE-AWARE HELPERS =====
    
    // Helper: Detect if an expression evaluates to double type
    bool isDoubleExpression(const eshkol_ast_t* expr) {
        if (!expr) return false;
        
        switch (expr->type) {
            case ESHKOL_DOUBLE:
                return true;
                
            case ESHKOL_INT64:
            case ESHKOL_VAR:
                return false;
                
            case ESHKOL_OP:
                // Check operation type
                if (expr->operation.op == ESHKOL_CALL_OP &&
                    expr->operation.call_op.func &&
                    expr->operation.call_op.func->type == ESHKOL_VAR) {
                    std::string func_name = expr->operation.call_op.func->variable.id;
                    
                    // Division always returns double
                    if (func_name == "/") return true;
                    
                    // Trig functions return double
                    if (func_name == "sin" || func_name == "cos" ||
                        func_name == "exp" || func_name == "log" ||
                        func_name == "sqrt" || func_name == "pow") {
                        return true;
                    }
                    
                    // For arithmetic ops, check if any operand is double
                    if (func_name == "+" || func_name == "-" || func_name == "*") {
                        for (uint64_t i = 0; i < expr->operation.call_op.num_vars; i++) {
                            if (isDoubleExpression(&expr->operation.call_op.variables[i])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
                
            default:
                return false;
        }
    }
    
    // Helper: Create type-appropriate constant (int64 or double)
    Value* createTypedConstant(double value, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            return ConstantFP::get(double_type, value);
        } else {
            return ConstantInt::get(int64_type, static_cast<int64_t>(value));
        }
    }
    
    // Helper: Type-aware multiplication for derivatives
    Value* createTypedMul(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, double_type);
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, double_type);
            }
            return builder->CreateFMul(a, b);
        } else {
            // Integer multiplication
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, int64_type);
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, int64_type);
            }
            return builder->CreateMul(a, b);
        }
    }
    
    // Helper: Type-aware addition for derivatives
    Value* createTypedAdd(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, double_type);
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, double_type);
            }
            return builder->CreateFAdd(a, b);
        } else {
            // Integer addition
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, int64_type);
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, int64_type);
            }
            return builder->CreateAdd(a, b);
        }
    }
    
    // Helper: Type-aware subtraction for derivatives
    Value* createTypedSub(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        if (isDoubleExpression(reference_expr)) {
            // Convert both to double if needed
            if (a->getType()->isIntegerTy()) {
                a = builder->CreateSIToFP(a, double_type);
            }
            if (b->getType()->isIntegerTy()) {
                b = builder->CreateSIToFP(b, double_type);
            }
            return builder->CreateFSub(a, b);
        } else {
            // Integer subtraction
            if (a->getType()->isFloatingPointTy()) {
                a = builder->CreateFPToSI(a, int64_type);
            }
            if (b->getType()->isFloatingPointTy()) {
                b = builder->CreateFPToSI(b, int64_type);
            }
            return builder->CreateSub(a, b);
        }
    }
    
    // Helper: Type-aware division for derivatives
    Value* createTypedDiv(Value* a, Value* b, const eshkol_ast_t* reference_expr) {
        // Division always returns double
        if (a->getType()->isIntegerTy()) {
            a = builder->CreateSIToFP(a, double_type);
        }
        if (b->getType()->isIntegerTy()) {
            b = builder->CreateSIToFP(b, double_type);
        }
        return builder->CreateFDiv(a, b);
    }
    // ===== SYMBOLIC DIFFERENTIATION HELPER FUNCTIONS =====
    // AST-based symbolic derivative builder (compile-time transformation)
    
    // Helper: Check if AST is a constant (number)
    bool isConstant(const eshkol_ast_t* ast) {
        return ast && (ast->type == ESHKOL_INT64 || ast->type == ESHKOL_DOUBLE);
    }
    
    // Helper: Check if AST is specific variable
    bool isVariable(const eshkol_ast_t* ast, const char* var_name) {
        return ast && ast->type == ESHKOL_VAR &&
               ast->variable.id && strcmp(ast->variable.id, var_name) == 0;
    }
    
    // Helper: Check if constant equals specific value
    bool isConstantValue(const eshkol_ast_t* ast, double value) {
        if (ast->type == ESHKOL_INT64) return (double)ast->int64_val == value;
        if (ast->type == ESHKOL_DOUBLE) return ast->double_val == value;
        return false;
    }
    
    // Helper: Check if constant equals 0
    bool isConstantZero(const eshkol_ast_t* ast) {
        return isConstantValue(ast, 0.0);
    }
    
    // Helper: Check if constant equals 1
    bool isConstantOne(const eshkol_ast_t* ast) {
        return isConstantValue(ast, 1.0);
    }
    
    // Core symbolic differentiation function (AST → AST transformation)
    eshkol_ast_t* buildSymbolicDerivative(const eshkol_ast_t* expr, const char* var) {
        if (!expr || !var) return eshkol_make_int_ast(0);
        
        switch (expr->type) {
            case ESHKOL_INT64:
            case ESHKOL_DOUBLE:
                // d/dx(c) = 0
                return eshkol_make_int_ast(0);
                
            case ESHKOL_VAR:
                // d/dx(x) = 1, d/dx(y) = 0
                if (expr->variable.id && strcmp(expr->variable.id, var) == 0)
                    return eshkol_make_int_ast(1);
                else
                    return eshkol_make_int_ast(0);
                    
            case ESHKOL_OP:
                return differentiateOperationSymbolic(&expr->operation, var);
                
            default:
                return eshkol_make_int_ast(0);
        }
    }
    
    // Differentiate operations (symbolic, AST-based)
    eshkol_ast_t* differentiateOperationSymbolic(const eshkol_operations_t* op, const char* var) {
        if (!op || op->op != ESHKOL_CALL_OP) {
            return eshkol_make_int_ast(0);
        }
        
        if (!op->call_op.func || op->call_op.func->type != ESHKOL_VAR ||
            !op->call_op.func->variable.id) {
            return eshkol_make_int_ast(0);
        }
        
        const char* func_name = op->call_op.func->variable.id;
        
        // ADDITION RULE: d/dx(f + g) = f' + g'
        if (strcmp(func_name, "+") == 0 && op->call_op.num_vars >= 2) {
            eshkol_ast_t* result = buildSymbolicDerivative(&op->call_op.variables[0], var);
            
            for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
                eshkol_ast_t* term = buildSymbolicDerivative(&op->call_op.variables[i], var);
                
                // Simplification: skip adding 0
                if (isConstantZero(term)) {
                    continue;
                } else if (isConstantZero(result)) {
                    result = term;
                } else {
                    result = eshkol_make_binary_op_ast("+", result, term);
                }
            }
            return result;
        }
        
        // SUBTRACTION RULE: d/dx(f - g) = f' - g'
        if (strcmp(func_name, "-") == 0 && op->call_op.num_vars == 2) {
            eshkol_ast_t* f_prime = buildSymbolicDerivative(&op->call_op.variables[0], var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(&op->call_op.variables[1], var);
            
            // Simplification: f' - 0 = f'
            if (isConstantZero(g_prime)) return f_prime;
            // Simplification: 0 - g' = -g' (would need negation)
            if (isConstantZero(f_prime)) {
                return eshkol_make_unary_call_ast("-", g_prime);
            }
            
            return eshkol_make_binary_op_ast("-", f_prime, g_prime);
        }
        
        // PRODUCT RULE: d/dx(f * g) = f'*g + f*g'
        if (strcmp(func_name, "*") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* g = &op->call_op.variables[1];
            
            // SPECIAL CASE: d/dx(c * x) = c (constant * variable)
            if (isConstant(f) && isVariable(g, var)) {
                return eshkol_copy_ast(f);
            }
            if (isVariable(f, var) && isConstant(g)) {
                return eshkol_copy_ast(g);
            }
            
            // SPECIAL CASE: d/dx(x * x) = 2*x (simplified)
            if (isVariable(f, var) && isVariable(g, var)) {
                // Return '(* 2 x) as S-expression
                return eshkol_make_binary_op_ast("*",
                    eshkol_make_int_ast(2),
                    eshkol_make_var_ast(var));
            }
            
            // GENERAL CASE: f'*g + f*g'
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(g, var);
            
            // Simplification: 0*g + f*0 = 0
            if (isConstantZero(f_prime) && isConstantZero(g_prime)) {
                return eshkol_make_int_ast(0);
            }
            // Simplification: 0*g + f*g' = f*g'
            if (isConstantZero(f_prime)) {
                return eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            }
            // Simplification: f'*g + f*0 = f'*g
            if (isConstantZero(g_prime)) {
                return eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            }
            
            eshkol_ast_t* term1 = eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            eshkol_ast_t* term2 = eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            return eshkol_make_binary_op_ast("+", term1, term2);
        }
        
        // QUOTIENT RULE: d/dx(f / g) = (f'*g - f*g') / g²
        if (strcmp(func_name, "/") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* g = &op->call_op.variables[1];
            
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* g_prime = buildSymbolicDerivative(g, var);
            
            // Build: (f'*g - f*g') / g²
            eshkol_ast_t* f_prime_g = eshkol_make_binary_op_ast("*", f_prime, eshkol_copy_ast(g));
            eshkol_ast_t* f_g_prime = eshkol_make_binary_op_ast("*", eshkol_copy_ast(f), g_prime);
            eshkol_ast_t* numerator = eshkol_make_binary_op_ast("-", f_prime_g, f_g_prime);
            eshkol_ast_t* g_squared = eshkol_make_binary_op_ast("*", eshkol_copy_ast(g), eshkol_copy_ast(g));
            
            return eshkol_make_binary_op_ast("/", numerator, g_squared);
        }
        
        // CHAIN RULE: d/dx(sin(f)) = cos(f) * f'
        if (strcmp(func_name, "sin") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* cos_f = eshkol_make_unary_call_ast("cos", eshkol_copy_ast(f));
            
            // Special case: d/dx(sin(x)) = cos(x) (not cos(x)*1)
            if (isConstantOne(f_prime)) {
                return cos_f;
            }
            
            return eshkol_make_binary_op_ast("*", cos_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(cos(f)) = -sin(f) * f'
        if (strcmp(func_name, "cos") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* sin_f = eshkol_make_unary_call_ast("sin", eshkol_copy_ast(f));
            eshkol_ast_t* neg_sin_f = eshkol_make_unary_call_ast("-", sin_f);
            
            // Special case: d/dx(cos(x)) = -sin(x) (not -sin(x)*1)
            if (isConstantOne(f_prime)) {
                return neg_sin_f;
            }
            
            return eshkol_make_binary_op_ast("*", neg_sin_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(exp(f)) = exp(f) * f'
        if (strcmp(func_name, "exp") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            eshkol_ast_t* exp_f = eshkol_make_unary_call_ast("exp", eshkol_copy_ast(f));
            
            // Special case: d/dx(exp(x)) = exp(x)
            if (isConstantOne(f_prime)) {
                return exp_f;
            }
            
            return eshkol_make_binary_op_ast("*", exp_f, f_prime);
        }
        
        // CHAIN RULE: d/dx(log(f)) = f' / f
        if (strcmp(func_name, "log") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            
            // Special case: d/dx(log(x)) = 1/x
            if (isConstantOne(f_prime)) {
                return eshkol_make_binary_op_ast("/", eshkol_make_int_ast(1), eshkol_copy_ast(f));
            }
            
            return eshkol_make_binary_op_ast("/", f_prime, eshkol_copy_ast(f));
        }
        
        // POWER RULE: d/dx(f^n) = n * f^(n-1) * f' (constant exponent)
        if (strcmp(func_name, "pow") == 0 && op->call_op.num_vars == 2) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            const eshkol_ast_t* n = &op->call_op.variables[1];
            
            // Only handle constant exponents
            if (isConstant(n)) {
                eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
                
                // Build: n * f^(n-1) * f'
                eshkol_ast_t* n_minus_1 = nullptr;
                if (n->type == ESHKOL_INT64) {
                    n_minus_1 = eshkol_make_int_ast(n->int64_val - 1);
                } else {
                    n_minus_1 = eshkol_make_double_ast(n->double_val - 1.0);
                }
                
                eshkol_ast_t* f_power = eshkol_make_binary_op_ast("pow", eshkol_copy_ast(f), n_minus_1);
                eshkol_ast_t* n_times_power = eshkol_make_binary_op_ast("*", eshkol_copy_ast(n), f_power);
                
                // Special case: f'=1, simplify to n * f^(n-1)
                if (isConstantOne(f_prime)) {
                    return n_times_power;
                }
                
                return eshkol_make_binary_op_ast("*", n_times_power, f_prime);
            }
        }
        
        // SQRT RULE: d/dx(sqrt(f)) = f' / (2*sqrt(f))
        if (strcmp(func_name, "sqrt") == 0 && op->call_op.num_vars == 1) {
            const eshkol_ast_t* f = &op->call_op.variables[0];
            eshkol_ast_t* f_prime = buildSymbolicDerivative(f, var);
            
            // Build: f' / (2*sqrt(f))
            eshkol_ast_t* sqrt_f = eshkol_make_unary_call_ast("sqrt", eshkol_copy_ast(f));
            eshkol_ast_t* two_sqrt_f = eshkol_make_binary_op_ast("*", eshkol_make_int_ast(2), sqrt_f);
            
            // Special case: f'=1, simplify to 1 / (2*sqrt(f))
            if (isConstantOne(f_prime)) {
                return eshkol_make_binary_op_ast("/", eshkol_make_int_ast(1), two_sqrt_f);
            }
            
            return eshkol_make_binary_op_ast("/", f_prime, two_sqrt_f);
        }
        
        // Unknown operation - return 0
        return eshkol_make_int_ast(0);
    }
    
    // Convert AST to runtime S-expression (quoted list)
    Value* codegenQuotedAST(const eshkol_ast_t* ast) {
        if (!ast) return packNullToTaggedValue();

        switch (ast->type) {
            case ESHKOL_INT64:
                // Return integer directly (not as list)
                return packInt64ToTaggedValue(
                    ConstantInt::get(int64_type, ast->int64_val),
                    true);

            case ESHKOL_DOUBLE:
                // Return double directly (not as list)
                return packDoubleToTaggedValue(
                    ConstantFP::get(double_type, ast->double_val));

            case ESHKOL_VAR:
                // Return symbol as string - use STRING_PTR type for symbols
                return packPtrToTaggedValue(
                    codegenString(ast->variable.id),
                    ESHKOL_VALUE_STRING_PTR);

            case ESHKOL_BOOL:
                // Return boolean as proper BOOL type (NOT as string symbol!)
                // This ensures equal? works correctly when comparing quoted lists
                // containing booleans with computed lists containing booleans
                return packBoolToTaggedValue(
                    ConstantInt::get(int1_type, ast->int64_val ? 1 : 0));

            case ESHKOL_STRING:
                // Return string literal
                return packPtrToTaggedValue(
                    codegenString(ast->str_val.ptr),
                    ESHKOL_VALUE_STRING_PTR);

            case ESHKOL_CHAR:
                // Return character as #\char symbol
                {
                    char char_buf[16];
                    char ch = (char)ast->int64_val;
                    if (ch == ' ') snprintf(char_buf, sizeof(char_buf), "#\\space");
                    else if (ch == '\n') snprintf(char_buf, sizeof(char_buf), "#\\newline");
                    else if (ch == '\t') snprintf(char_buf, sizeof(char_buf), "#\\tab");
                    else snprintf(char_buf, sizeof(char_buf), "#\\%c", ch);
                    return packPtrToTaggedValue(
                        codegenString(char_buf),
                        ESHKOL_VALUE_STRING_PTR);
                }

            case ESHKOL_OP:
                return codegenQuotedOperation(&ast->operation);

            case ESHKOL_NULL:
                // Empty list / null - return properly tagged NULL value
                return packNullToTaggedValue();

            case ESHKOL_UINT64:
                // Type 0 often represents empty/null in quoted data
                if (ast->int64_val == 0) {
                    return packNullToTaggedValue();
                }
                return packInt64ToTaggedValue(
                    ConstantInt::get(int64_type, ast->int64_val), true);

            default:
                // Unknown type - return as symbol with type name
                eshkol_debug("codegenQuotedAST: unhandled type %d", ast->type);
                return packNullToTaggedValue();
        }
    }

    // Handle operation AST nodes for S-expression generation
    Value* codegenQuotedOperation(const eshkol_operations_t* op) {
        if (!op) return packNullToTaggedValue();

        switch (op->op) {
            case ESHKOL_CALL_OP: {
                // Build list: (op arg1 arg2 ...) and wrap as tagged_value
                Value* list_ptr = codegenQuotedList(op);
                if (list_ptr == ConstantInt::get(int64_type, 0)) {
                    return packNullToTaggedValue();
                }
                return packPtrToTaggedValue(
                    builder->CreateIntToPtr(list_ptr, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }

            case ESHKOL_LAMBDA_OP: {
                // MEMOIZATION FIX: Check if this lambda was already compiled and has an S-expression global
                // This prevents exponential IR generation for deeply nested lambdas
                auto memo_it = lambda_ast_to_name.find(op);
                if (memo_it != lambda_ast_to_name.end()) {
                    // Lambda already compiled - load from existing sexpr global instead of regenerating
                    std::string sexpr_key = memo_it->second + "_sexpr";
                    GlobalVariable* sexpr_global = module->getNamedGlobal(sexpr_key);
                    if (sexpr_global) {
                        Value* loaded_sexpr = builder->CreateLoad(int64_type, sexpr_global);
                        return packPtrToTaggedValue(
                            builder->CreateIntToPtr(loaded_sexpr, builder->getPtrTy()),
                            ESHKOL_VALUE_CONS_PTR);
                    }
                }

                // Handle nested lambdas in S-expression generation
                Value* nested_sexpr = codegenLambdaToSExpr(op);
                if (nested_sexpr == ConstantInt::get(int64_type, 0)) {
                    return packNullToTaggedValue();
                }
                return packPtrToTaggedValue(
                    builder->CreateIntToPtr(nested_sexpr, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }

            case ESHKOL_IF_OP: {
                // Build (if test then else)
                // IF_OP uses call_op structure: variables[0]=condition, variables[1]=then, variables[2]=else
                Value* if_sym = packPtrToTaggedValue(codegenString("if"), ESHKOL_VALUE_STRING_PTR);

                // Build from right to left: else -> then -> test -> if
                Value* result = packNullToTaggedValue();

                // Add else branch if present (variables[2])
                if (op->call_op.num_vars >= 3) {
                    Value* else_branch = codegenQuotedAST(&op->call_op.variables[2]);
                    result = codegenTaggedArenaConsCellFromTaggedValue(else_branch, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }

                // Add then branch (variables[1])
                if (op->call_op.num_vars >= 2) {
                    Value* then_branch = codegenQuotedAST(&op->call_op.variables[1]);
                    result = codegenTaggedArenaConsCellFromTaggedValue(then_branch, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }

                // Add condition (variables[0])
                if (op->call_op.num_vars >= 1) {
                    Value* test = codegenQuotedAST(&op->call_op.variables[0]);
                    result = codegenTaggedArenaConsCellFromTaggedValue(test, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }

                result = codegenTaggedArenaConsCellFromTaggedValue(if_sym, result);
                return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
            }

            case ESHKOL_AND_OP: {
                // Build (and expr1 expr2 ...)
                // AND_OP uses sequence_op structure
                return codegenQuotedNaryOp("and", op->sequence_op.expressions, op->sequence_op.num_expressions);
            }

            case ESHKOL_OR_OP: {
                // Build (or expr1 expr2 ...)
                // OR_OP uses sequence_op structure
                return codegenQuotedNaryOp("or", op->sequence_op.expressions, op->sequence_op.num_expressions);
            }

            case ESHKOL_COND_OP: {
                // Build (cond (test1 expr1) (test2 expr2) ...)
                // COND_OP uses call_op structure where each variable is a clause
                Value* cond_sym = packPtrToTaggedValue(codegenString("cond"), ESHKOL_VALUE_STRING_PTR);
                Value* result = packNullToTaggedValue();

                // Build clauses from right to left
                for (int64_t i = op->call_op.num_vars - 1; i >= 0; i--) {
                    const eshkol_ast_t* clause_ast = &op->call_op.variables[i];
                    // Each clause is itself a CALL_OP with test as func and body as first var
                    Value* clause;
                    if (clause_ast->type == ESHKOL_OP && clause_ast->operation.op == ESHKOL_CALL_OP) {
                        Value* test = codegenQuotedAST(clause_ast->operation.call_op.func);
                        // Build (test expr1 expr2 ...) clause
                        clause = packNullToTaggedValue();
                        for (int64_t j = clause_ast->operation.call_op.num_vars - 1; j >= 0; j--) {
                            Value* expr = codegenQuotedAST(&clause_ast->operation.call_op.variables[j]);
                            clause = codegenTaggedArenaConsCellFromTaggedValue(expr, clause);
                            clause = packPtrToTaggedValue(builder->CreateIntToPtr(clause, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                        }
                        clause = codegenTaggedArenaConsCellFromTaggedValue(test, clause);
                        clause = packPtrToTaggedValue(builder->CreateIntToPtr(clause, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    } else {
                        // Fallback: just quote the clause directly
                        clause = codegenQuotedAST(clause_ast);
                    }

                    result = codegenTaggedArenaConsCellFromTaggedValue(clause, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }

                result = codegenTaggedArenaConsCellFromTaggedValue(cond_sym, result);
                return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
            }

            case ESHKOL_SEQUENCE_OP: {
                // Build (begin expr1 expr2 ...)
                return codegenQuotedNaryOp("begin", op->sequence_op.expressions, op->sequence_op.num_expressions);
            }

            case ESHKOL_LET_OP:
            case ESHKOL_LET_STAR_OP:
            case ESHKOL_LETREC_OP: {
                // Build (let/let*/letrec ((var1 val1) ...) body)
                // let_op has bindings (array of cons cells), num_bindings, and body
                const char* let_name = op->op == ESHKOL_LET_OP ? "let" :
                                       op->op == ESHKOL_LET_STAR_OP ? "let*" : "letrec";
                Value* let_sym = packPtrToTaggedValue(codegenString(let_name), ESHKOL_VALUE_STRING_PTR);

                // Build bindings list
                Value* bindings = packNullToTaggedValue();
                for (int64_t i = op->let_op.num_bindings - 1; i >= 0; i--) {
                    const eshkol_ast_t* binding_cons = &op->let_op.bindings[i];
                    // Each binding is a cons cell: (variable . value)
                    Value* binding;
                    if (binding_cons->type == ESHKOL_CONS && binding_cons->cons_cell.car) {
                        // Get variable name from car
                        const eshkol_ast_t* var_ast = binding_cons->cons_cell.car;
                        Value* var;
                        if (var_ast->type == ESHKOL_VAR && var_ast->variable.id) {
                            var = packPtrToTaggedValue(codegenString(var_ast->variable.id), ESHKOL_VALUE_STRING_PTR);
                        } else {
                            var = codegenQuotedAST(var_ast);
                        }
                        // Get value from cdr
                        Value* val = codegenQuotedAST(binding_cons->cons_cell.cdr);

                        // Build (var val) binding
                        binding = packNullToTaggedValue();
                        binding = codegenTaggedArenaConsCellFromTaggedValue(val, binding);
                        binding = packPtrToTaggedValue(builder->CreateIntToPtr(binding, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                        binding = codegenTaggedArenaConsCellFromTaggedValue(var, binding);
                        binding = packPtrToTaggedValue(builder->CreateIntToPtr(binding, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    } else {
                        // Fallback: quote the binding directly
                        binding = codegenQuotedAST(binding_cons);
                    }

                    bindings = codegenTaggedArenaConsCellFromTaggedValue(binding, bindings);
                    bindings = packPtrToTaggedValue(builder->CreateIntToPtr(bindings, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }

                // Build body
                Value* body = codegenQuotedAST(op->let_op.body);

                // Combine: (let bindings body)
                Value* result = packNullToTaggedValue();
                result = codegenTaggedArenaConsCellFromTaggedValue(body, result);
                result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                result = codegenTaggedArenaConsCellFromTaggedValue(bindings, result);
                result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                result = codegenTaggedArenaConsCellFromTaggedValue(let_sym, result);
                return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
            }

            case ESHKOL_DEFINE_OP: {
                // Build (define name value) or (define (name params) body)
                Value* define_sym = packPtrToTaggedValue(codegenString("define"), ESHKOL_VALUE_STRING_PTR);
                Value* name = packPtrToTaggedValue(codegenString(op->define_op.name), ESHKOL_VALUE_STRING_PTR);

                if (op->define_op.is_function) {
                    // Build (define (name params...) body)
                    // First build the name+params list
                    Value* name_params = packNullToTaggedValue();
                    for (int64_t i = op->define_op.num_params - 1; i >= 0; i--) {
                        Value* param = packPtrToTaggedValue(
                            codegenString(op->define_op.parameters[i].variable.id),
                            ESHKOL_VALUE_STRING_PTR);
                        name_params = codegenTaggedArenaConsCellFromTaggedValue(param, name_params);
                        name_params = packPtrToTaggedValue(builder->CreateIntToPtr(name_params, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    }
                    name_params = codegenTaggedArenaConsCellFromTaggedValue(name, name_params);
                    name_params = packPtrToTaggedValue(builder->CreateIntToPtr(name_params, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);

                    Value* body = codegenQuotedAST(op->define_op.value);

                    Value* result = packNullToTaggedValue();
                    result = codegenTaggedArenaConsCellFromTaggedValue(body, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    result = codegenTaggedArenaConsCellFromTaggedValue(name_params, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    result = codegenTaggedArenaConsCellFromTaggedValue(define_sym, result);
                    return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                } else {
                    // Build (define name value)
                    Value* value = codegenQuotedAST(op->define_op.value);
                    Value* result = packNullToTaggedValue();
                    result = codegenTaggedArenaConsCellFromTaggedValue(value, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    result = codegenTaggedArenaConsCellFromTaggedValue(name, result);
                    result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    result = codegenTaggedArenaConsCellFromTaggedValue(define_sym, result);
                    return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                }
            }

            default:
                eshkol_debug("codegenQuotedOperation: unhandled op type %d", op->op);
                return packNullToTaggedValue();
        }
    }

    // Helper to build (op arg1 arg2 ...) for n-ary operations
    Value* codegenQuotedNaryOp(const char* op_name, const eshkol_ast_t* args, uint64_t num_args) {
        Value* op_sym = packPtrToTaggedValue(codegenString(op_name), ESHKOL_VALUE_STRING_PTR);
        Value* result = packNullToTaggedValue();

        // Build args from right to left
        for (int64_t i = num_args - 1; i >= 0; i--) {
            Value* arg = codegenQuotedAST(&args[i]);
            result = codegenTaggedArenaConsCellFromTaggedValue(arg, result);
            result = packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        }

        result = codegenTaggedArenaConsCellFromTaggedValue(op_sym, result);
        return packPtrToTaggedValue(builder->CreateIntToPtr(result, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
    }
    
    // Build runtime S-expression list from call operation
    Value* codegenQuotedList(const eshkol_operations_t* op) {
        if (!op || op->op != ESHKOL_CALL_OP) {
            return packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
        }
        
        // Build list from right to left: (op arg1 arg2 ...)
        // Start with empty list (null)
        Value* result_int = ConstantInt::get(int64_type, 0);
        
        // Add arguments in reverse
        for (int64_t i = op->call_op.num_vars - 1; i >= 0; i--) {
            Value* elem_tagged = codegenQuotedAST(&op->call_op.variables[i]);
            
            // Convert result_int to tagged value
            Value* result_tagged;
            if (result_int == ConstantInt::get(int64_type, 0)) {
                result_tagged = packNullToTaggedValue();
            } else {
                result_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result_int, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }
            
            // Create cons cell from two tagged values
            Value* cons_cell = codegenTaggedArenaConsCellFromTaggedValue(elem_tagged, result_tagged);
            result_int = cons_cell;
        }
        
        // Add operator symbol at front
        // CRITICAL: Must check func->type is ESHKOL_VAR before accessing variable.id
        // func could be any AST type (lambda call, nested call, etc.)
        // EXCEPTION: Skip adding "list" operator for quoted data lists - they should just be (1 2 3), not (list 1 2 3)
        if (op->call_op.func && op->call_op.func->type == ESHKOL_VAR && op->call_op.func->variable.id) {
            std::string func_name = op->call_op.func->variable.id;

            // For "list" function (used to represent quoted data), just return the list without the operator
            if (func_name == "list") {
                // Return result_int as a tagged value
                if (result_int == ConstantInt::get(int64_type, 0)) {
                    return ConstantInt::get(int64_type, 0);
                }
                return result_int;
            }

            Value* op_string = codegenString(op->call_op.func->variable.id);
            TypedValue op_symbol(op_string, ESHKOL_VALUE_STRING_PTR, true);
            Value* op_tagged = typedValueToTaggedValue(op_symbol);

            Value* result_tagged;
            if (result_int == ConstantInt::get(int64_type, 0)) {
                result_tagged = packNullToTaggedValue();
            } else {
                result_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result_int, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }

            Value* final_list = codegenTaggedArenaConsCellFromTaggedValue(op_tagged, result_tagged);
            // SYMBOLIC DIFF FIX: Return int64 pointer, not tagged (for consistency with codegenQuotedAST caller)
            return final_list;
        }
        
        // SYMBOLIC DIFF FIX: Return int64 pointer, not tagged (for consistency with codegenQuotedAST caller)
        return result_int;
    }
        
    // ===== LAMBDA S-EXPRESSION HOMOICONIC DISPLAY =====
    // Convert lambda AST to runtime S-expression for code-as-data display
    
    // Helper: Build parameter list as cons chain: (param1 param2 ...)
    Value* buildParameterList(const eshkol_ast_t* params, uint64_t num_params) {
        if (num_params == 0) {
            return ConstantInt::get(int64_type, 0); // Empty list
        }
        
        Value* result = ConstantInt::get(int64_type, 0); // Start with null
        
        // Build list backwards for proper cons chain
        for (int64_t i = num_params - 1; i >= 0; i--) {
            if (params[i].type != ESHKOL_VAR || !params[i].variable.id) continue;
            
            // Create parameter symbol string
            Value* param_name = codegenString(params[i].variable.id);
            Value* param_tagged = packPtrToTaggedValue(param_name, ESHKOL_VALUE_STRING_PTR);
            
            // Get rest of list as tagged value
            Value* rest_tagged;
            if (result == ConstantInt::get(int64_type, 0)) {
                rest_tagged = packNullToTaggedValue();
            } else {
                rest_tagged = packPtrToTaggedValue(
                    builder->CreateIntToPtr(result, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
            }
            
            // Cons parameter onto rest
            result = codegenTaggedArenaConsCellFromTaggedValue(param_tagged, rest_tagged);
        }
        
        return result;
    }
    
    // Convert lambda or function definition AST to runtime S-expression for homoiconic display
    // Returns cons list pointer (int64): (lambda (param1 param2 ...) body)
    // Handles both LAMBDA_OP and DEFINE_OP (for named function definitions)
    Value* codegenLambdaToSExpr(const eshkol_operations_t* op) {
        if (!op) {
            eshkol_error("codegenLambdaToSExpr: null operation");
            return ConstantInt::get(int64_type, 0);
        }

        // Extract parameters and body based on operation type
        const eshkol_ast_t* params = nullptr;
        uint64_t num_params = 0;
        const eshkol_ast_t* body = nullptr;

        if (op->op == ESHKOL_LAMBDA_OP) {
            params = op->lambda_op.parameters;
            num_params = op->lambda_op.num_params;
            body = op->lambda_op.body;
        } else if (op->op == ESHKOL_DEFINE_OP && op->define_op.is_function) {
            params = op->define_op.parameters;
            num_params = op->define_op.num_params;
            body = op->define_op.value;
        } else {
            eshkol_error("codegenLambdaToSExpr: not a lambda or function definition");
            return ConstantInt::get(int64_type, 0);
        }

        // Step 1: Build parameter list - (param1 param2 ...)
        Value* param_list = buildParameterList(params, num_params);

        // Step 2: Convert body AST to quoted S-expression
        // NOTE: codegenQuotedAST returns a tagged_value, which we should use directly
        Value* body_tagged = packNullToTaggedValue();
        if (body) {
            body_tagged = codegenQuotedAST(body);
            // Ensure it's a tagged value
            if (!body_tagged || body_tagged->getType() != tagged_value_type) {
                body_tagged = packNullToTaggedValue();
            }
        }
        
        // Step 3: Build complete structure: (lambda (params) body)
        
        // 3a: Create "lambda" symbol string
        Value* lambda_symbol = codegenString("lambda");
        Value* lambda_tagged = packPtrToTaggedValue(lambda_symbol, ESHKOL_VALUE_STRING_PTR);
        
        // 3b: Pack param_list as tagged value
        Value* param_list_tagged;
        if (param_list == ConstantInt::get(int64_type, 0)) {
            param_list_tagged = packNullToTaggedValue();
        } else {
            param_list_tagged = packPtrToTaggedValue(
                builder->CreateIntToPtr(param_list, builder->getPtrTy()),
                ESHKOL_VALUE_CONS_PTR);
        }
        
        // 3c: body_tagged is already a tagged_value from step 2 (no re-packing needed)

        // 3d: Build ((params) . (body . null))
        Value* body_null_tagged = packNullToTaggedValue();
        Value* body_cons = codegenTaggedArenaConsCellFromTaggedValue(body_tagged, body_null_tagged);
        Value* body_cons_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(body_cons, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* params_body = codegenTaggedArenaConsCellFromTaggedValue(
            param_list_tagged, body_cons_tagged);
        
        // 3e: Build (lambda . (params body))
        Value* params_body_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(params_body, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* result = codegenTaggedArenaConsCellFromTaggedValue(
            lambda_tagged, params_body_tagged);
        
        eshkol_debug("Generated lambda S-expression with %llu parameters",
                    (unsigned long long)num_params);
        
        return result;
    }

    // ===== END LAMBDA S-EXPRESSION HOMOICONIC DISPLAY =====
    
    // ===== DUAL NUMBER LLVM IR HELPER FUNCTIONS =====
    
    // MIGRATED: Pack value and derivative into dual number struct - delegates to AutodiffCodegen
    Value* packDualNumber(Value* value, Value* derivative) {
        return autodiff_->createDualNumber(value, derivative);
    }

    // MIGRATED: Unpack dual number into value and derivative components - uses AutodiffCodegen
    std::pair<Value*, Value*> unpackDualNumber(Value* dual) {
        if (!dual) return {nullptr, nullptr};
        return {autodiff_->getDualPrimal(dual), autodiff_->getDualTangent(dual)};
    }
    
    // MIGRATED: Pack dual number into tagged value for storage - delegates to AutodiffCodegen
    Value* packDualToTaggedValue(Value* dual) {
        return autodiff_->packDualToTagged(dual);
    }

    // MIGRATED: Unpack dual number from tagged value - delegates to AutodiffCodegen
    Value* unpackDualFromTaggedValue(Value* tagged) {
        return autodiff_->unpackDualFromTagged(tagged);
    }
    
    // ===== END DUAL NUMBER HELPERS =====
    
    // ===== PHASE 2: DUAL NUMBER ARITHMETIC OPERATIONS =====
    // MIGRATED: These all delegate to AutodiffCodegen

    // MIGRATED: Addition: (a, a') + (b, b') = (a+b, a'+b')
    Value* dualAdd(Value* dual_a, Value* dual_b) {
        return autodiff_->dualAdd(dual_a, dual_b);
    }

    // MIGRATED: Subtraction: (a, a') - (b, b') = (a-b, a'-b')
    Value* dualSub(Value* dual_a, Value* dual_b) {
        return autodiff_->dualSub(dual_a, dual_b);
    }

    // MIGRATED: Multiplication: (a, a') * (b, b') = (a*b, a'*b + a*b')
    Value* dualMul(Value* dual_a, Value* dual_b) {
        return autodiff_->dualMul(dual_a, dual_b);
    }

    // MIGRATED: Division: (a, a') / (b, b') = (a/b, (a'*b - a*b')/b²)
    Value* dualDiv(Value* dual_a, Value* dual_b) {
        return autodiff_->dualDiv(dual_a, dual_b);
    }
    
    // MIGRATED: Dual number math operations - now delegate to AutodiffCodegen

    // Sine: sin(a, a') = (sin(a), a' * cos(a))
    Value* dualSin(Value* dual_a) {
        return autodiff_->dualSin(dual_a);
    }

    // Cosine: cos(a, a') = (cos(a), -a' * sin(a))
    Value* dualCos(Value* dual_a) {
        return autodiff_->dualCos(dual_a);
    }

    // Exponential: exp(a, a') = (exp(a), a' * exp(a))
    Value* dualExp(Value* dual_a) {
        return autodiff_->dualExp(dual_a);
    }

    // Logarithm: log(a, a') = (log(a), a'/a)
    Value* dualLog(Value* dual_a) {
        return autodiff_->dualLog(dual_a);
    }

    // Tangent: tan(a, a') = (tan(a), a' * sec²(a))
    Value* dualTan(Value* dual_a) {
        return autodiff_->dualTan(dual_a);
    }

    // Hyperbolic sine: sinh(a, a') = (sinh(a), a' * cosh(a))
    Value* dualSinh(Value* dual_a) {
        return autodiff_->dualSinh(dual_a);
    }

    // Hyperbolic cosine: cosh(a, a') = (cosh(a), a' * sinh(a))
    Value* dualCosh(Value* dual_a) {
        return autodiff_->dualCosh(dual_a);
    }

    // Hyperbolic tangent: tanh(a, a') = (tanh(a), a' * sech²(a))
    Value* dualTanh(Value* dual_a) {
        return autodiff_->dualTanh(dual_a);
    }

    // Absolute value: abs(a, a') = (|a|, a' * sign(a))
    Value* dualAbs(Value* dual_a) {
        return autodiff_->dualAbs(dual_a);
    }

    // Square root: sqrt(a, a') = (sqrt(a), a' / (2 * sqrt(a)))
    Value* dualSqrt(Value* dual_a) {
        return autodiff_->dualSqrt(dual_a);
    }

    // Power: (a, a')^(b, b') = (a^b, a^b * (b' * log(a) + b * a'/a))
    Value* dualPow(Value* dual_a, Value* dual_b) {
        return autodiff_->dualPow(dual_a, dual_b);
    }

    // Negation: -(a, a') = (-a, -a')
    Value* dualNeg(Value* dual_a) {
        return autodiff_->dualNeg(dual_a);
    }
    
    // ===== END DUAL NUMBER ARITHMETIC =====

    // ===== NESTED GRADIENT SUPPORT: TAPE STACK OPERATIONS =====
    // MIGRATED: These delegate to AutodiffCodegen

    // Push current tape context onto stack and activate new tape
    void pushTapeContext(Value* new_tape) {
        autodiff_->pushTapeContext(new_tape);
    }

    // Pop tape context from stack, restoring previous tape
    void popTapeContext() {
        autodiff_->popTapeContext();
    }

    // ===== DOUBLE BACKWARD HELPER FUNCTIONS =====
    // MIGRATED: These delegate to AutodiffCodegen

    // Get the outer tape (from stack[depth-1])
    Value* getOuterTape() {
        return autodiff_->getOuterTape();
    }

    // Check if currently nested (tape_depth > 0)
    Value* isNested() {
        return autodiff_->isNested();
    }

    // MIGRATED: Create AD constant node on a specific tape - delegates to AutodiffCodegen
    Value* createADConstantOnTape(Value* tape_ptr, Value* value) {
        return autodiff_->createADConstantOnTape(tape_ptr, value);
    }

    // MIGRATED: Record binary operation on a specific tape - delegates to AutodiffCodegen
    Value* recordADNodeBinaryOnTape(Value* tape_ptr, uint32_t op_type, Value* left_node, Value* right_node) {
        return autodiff_->recordADNodeBinaryOnTape(tape_ptr, op_type, left_node, right_node);
    }

    // ===== PHASE 3: AD NODE HELPER FUNCTIONS =====
    // Computational graph construction for reverse-mode automatic differentiation
    
    // MIGRATED: Create AD node for a constant value - delegates to AutodiffCodegen
    Value* createADConstant(Value* value) {
        return autodiff_->createADConstant(value);
    }
    
    // MIGRATED: Create AD variable node - delegates to AutodiffCodegen
    Value* createADVariable(Value* value, size_t var_index) {
        return autodiff_->createADVariable(value, var_index);
    }

    // MIGRATED: Record binary operation node - delegates to AutodiffCodegen
    Value* recordADNodeBinary(uint32_t op_type, Value* left_node, Value* right_node) {
        return autodiff_->recordADNodeBinary(op_type, left_node, right_node);
    }

    // MIGRATED: Record unary operation node - delegates to AutodiffCodegen
    Value* recordADNodeUnary(uint32_t op_type, Value* input_node) {
        return autodiff_->recordADNodeUnary(op_type, input_node);
    }
    
    // MIGRATED: AD node helpers delegate to AutodiffCodegen
    Value* loadNodeValue(Value* node_ptr) {
        return autodiff_->loadNodeValue(node_ptr);
    }

    Value* loadNodeGradient(Value* node_ptr) {
        return autodiff_->loadNodeGradient(node_ptr);
    }

    void storeNodeGradient(Value* node_ptr, Value* gradient) {
        autodiff_->storeNodeGradient(node_ptr, gradient);
    }

    void accumulateGradient(Value* node_ptr, Value* gradient_to_add) {
        autodiff_->accumulateGradient(node_ptr, gradient_to_add);
    }
    
    // MIGRATED: Load input node pointers - delegates to AutodiffCodegen
    Value* loadNodeInput1(Value* node_ptr) {
        return autodiff_->loadNodeInput1(node_ptr);
    }

    Value* loadNodeInput2(Value* node_ptr) {
        return autodiff_->loadNodeInput2(node_ptr);
    }
    
    // ===== END AD NODE HELPERS =====
    // ===== PHASE 3: BACKWARD PASS IMPLEMENTATION =====
    // Backpropagation through computational graph (delegated to AutodiffCodegen)

    // Main backward pass function - delegates to AutodiffCodegen
    void codegenBackward(Value* output_node_ptr, Value* tape_ptr) {
        autodiff_->backpropagate(tape_ptr, output_node_ptr);
    }

    // ===== END BACKWARD PASS =====
    
    
    // ===== PHASE 2: DERIVATIVE OPERATOR IMPLEMENTATION =====
    // Runtime derivative computation using dual numbers

    // Helper function to load captures for an autodiff function call
    // Returns a vector of captured values that should be appended to call arguments
    std::vector<Value*> loadCapturesForAutodiff(Function* func_ptr, const std::string& context_name) {
        std::vector<Value*> capture_args;

        FunctionType* func_type = func_ptr->getFunctionType();
        if (func_type->getNumParams() <= 1) {
            return capture_args; // No captures
        }

        size_t num_captures = func_type->getNumParams() - 1;
        std::string lambda_name = func_ptr->getName().str();

        // REPL MODE: Get capture names from registry instead of parameter names
        std::vector<std::string> capture_names;
        if (g_repl_mode_enabled) {
            std::lock_guard<std::mutex> lock(g_repl_mutex);
            auto captures_it = g_repl_lambda_captures.find(lambda_name);
            if (captures_it != g_repl_lambda_captures.end()) {
                capture_names = captures_it->second;
            }
        }

        for (size_t i = 0; i < num_captures; i++) {
            std::string var_name;
            if (i < capture_names.size()) {
                var_name = capture_names[i];
            } else {
                // Fallback to LLVM parameter names (for non-REPL mode)
                auto arg_it = func_ptr->arg_begin();
                std::advance(arg_it, i + 1);  // Skip first parameter
                if (arg_it != func_ptr->arg_end()) {
                    var_name = arg_it->getName().str();
                    if (var_name.find("captured_") == 0) {
                        var_name = var_name.substr(9);
                    }
                }
            }

            std::string capture_key = lambda_name + "_capture_" + var_name;

            // First try capture-specific key in symbol tables
            auto it = global_symbol_table.find(capture_key);
            bool found_in_global = (it != global_symbol_table.end());
            if (!found_in_global) {
                it = symbol_table.find(capture_key);
            }

            bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

            // FALLBACK: Try raw variable name (for top-level global variables)
            if (!found) {
                it = global_symbol_table.find(var_name);
                found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(var_name);
                }
                found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());
                if (found) {
                    eshkol_debug("%s: found capture '%s' via raw variable name", context_name.c_str(), var_name.c_str());
                }
            }

            // REPL MODE: Try creating external declaration for capture global
            if (!found && g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto sym_it = g_repl_symbol_addresses.find(capture_key);
                if (sym_it != g_repl_symbol_addresses.end()) {
                    // Create external declaration for capture global
                    GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                    if (!capture_global) {
                        capture_global = new GlobalVariable(
                            *module,
                            tagged_value_type,
                            false,
                            GlobalValue::ExternalLinkage,
                            nullptr,
                            capture_key
                        );
                    }
                    // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                    capture_args.push_back(capture_global);
                    continue;
                }
            }

            if (found && it->second) {
                Value* storage = it->second;
                // MUTABLE CAPTURE FIX: For let-bound allocas or arena pointers, pack the address
                // as int64 in a tagged_value, store in temp, pass pointer to temp
                // CLOSURE ESCAPE FIX: Also handle arena pointers (from escaped closure captures)
                bool needs_ptr_packing = isa<AllocaInst>(storage) ||
                    (storage->getType()->isPointerTy() && !isa<GlobalVariable>(storage) && !isa<Argument>(storage));

                if (needs_ptr_packing) {
                    Function* current_func = builder->GetInsertBlock()->getParent();
                    IRBuilder<> entry_builder(&current_func->getEntryBlock(),
                                              current_func->getEntryBlock().begin());
                    AllocaInst* temp_alloca = entry_builder.CreateAlloca(
                        tagged_value_type, nullptr, var_name + "_autodiff_capture_storage");

                    // Pack the storage address as an int64 in a tagged_value
                    Value* ptr_as_int = builder->CreatePtrToInt(storage, int64_type);
                    Value* packed_ptr = packInt64ToTaggedValue(ptr_as_int, true);
                    builder->CreateStore(packed_ptr, temp_alloca);

                    capture_args.push_back(temp_alloca);
                } else {
                    // GlobalVariable or other - pass directly
                    capture_args.push_back(storage);
                }
            } else {
                // MUTABLE CAPTURE FIX: Push null pointer instead of packed zero
                capture_args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                eshkol_warn("%s: capture '%s' not found, using null pointer", context_name.c_str(), var_name.c_str());
            }
        }

        return capture_args;
    }

    // Higher-order derivative: (derivative f) returns a closure that computes derivatives
    Value* codegenDerivativeHigherOrder(const eshkol_operations_t* op) {
        static int derivative_ho_counter = 0;
        eshkol_info("Creating higher-order derivative function (derivative f -> df)");

        // Get the function to differentiate
        Value* func = resolveLambdaFunction(op->derivative_op.function);

        // RUNTIME FUNCTION PARAMETER FIX: If resolveLambdaFunction returns nullptr,
        // check if this is a function parameter and create a runtime derivative wrapper
        if (!func) {
            const eshkol_ast_t* func_ast = op->derivative_op.function;
            if (func_ast && func_ast->type == ESHKOL_VAR) {
                std::string func_name = func_ast->variable.id;
                eshkol_debug("derivative HO: trying runtime function parameter '%s'", func_name.c_str());

                // Check if this is a function parameter or captured value
                Value* var_value = nullptr;
                auto local_it = symbol_table.find(func_name);
                if (local_it != symbol_table.end()) {
                    var_value = local_it->second;
                } else {
                    auto global_it = global_symbol_table.find(func_name);
                    if (global_it != global_symbol_table.end()) {
                        var_value = global_it->second;
                    }
                }

                if (var_value) {
                    // Get the closure value for runtime dispatch
                    Value* closure_val = nullptr;
                    if (isa<Argument>(var_value) && var_value->getType() == tagged_value_type) {
                        closure_val = var_value;
                    } else if (isa<Argument>(var_value) && var_value->getType()->isPointerTy()) {
                        closure_val = builder->CreateLoad(tagged_value_type, var_value);
                    } else if (isa<AllocaInst>(var_value)) {
                        AllocaInst* alloca = cast<AllocaInst>(var_value);
                        if (alloca->getAllocatedType() == tagged_value_type) {
                            closure_val = builder->CreateLoad(tagged_value_type, var_value);
                        }
                    } else if (isa<LoadInst>(var_value) && var_value->getType() == tagged_value_type) {
                        closure_val = var_value;
                    } else if (isa<GlobalVariable>(var_value)) {
                        GlobalVariable* global = cast<GlobalVariable>(var_value);
                        closure_val = builder->CreateLoad(global->getValueType(), var_value);
                    }

                    if (closure_val) {
                        eshkol_debug("derivative HO: creating runtime derivative wrapper for '%s'", func_name.c_str());

                        // Create a derivative wrapper that captures the function and calls it at runtime
                        std::string deriv_func_name = "derivative_runtime_" + std::to_string(derivative_ho_counter++);

                        // Wrapper function takes: (x_tagged, captured_f_ptr)
                        // captured_f_ptr is a pointer to the closure tagged_value
                        std::vector<Type*> param_types = {tagged_value_type, PointerType::getUnqual(*context)};
                        FunctionType* deriv_func_type = FunctionType::get(tagged_value_type, param_types, false);
                        Function* deriv_func = Function::Create(
                            deriv_func_type,
                            Function::ExternalLinkage,
                            deriv_func_name,
                            module.get()
                        );

                        // Save current insertion point
                        BasicBlock* saved_bb = builder->GetInsertBlock();
                        BasicBlock::iterator saved_point = builder->GetInsertPoint();

                        // Create function body
                        BasicBlock* entry = BasicBlock::Create(*context, "entry", deriv_func);
                        builder->SetInsertPoint(entry);

                        auto arg_it = deriv_func->arg_begin();
                        Value* x_tagged = &(*arg_it);
                        x_tagged->setName("x");
                        ++arg_it;
                        Value* captured_f_ptr = &(*arg_it);
                        captured_f_ptr->setName("captured_f");

                        // Load the captured function closure
                        Value* f_closure = builder->CreateLoad(tagged_value_type, captured_f_ptr);

                        // HIGHER-ORDER DERIVATIVE FIX: Use numerical differentiation (central difference)
                        // instead of forward-mode AD. This works for ANY function, including derivatives.
                        // Forward-mode AD doesn't work here because the captured function (e.g., df4)
                        // expects a plain double, not a dual number.
                        //
                        // Central difference formula: f'(x) ≈ (f(x+h) - f(x-h)) / (2h)
                        Value* x = unpackDoubleFromTaggedValue(x_tagged);
                        Value* h = ConstantFP::get(double_type, 1e-8);  // Small step for numerical derivative
                        Value* two_h = ConstantFP::get(double_type, 2e-8);

                        // Compute f(x + h)
                        Value* x_plus_h = builder->CreateFAdd(x, h);
                        Value* x_plus_h_tagged = packDoubleToTaggedValue(x_plus_h);
                        std::vector<Value*> call_args_plus = {x_plus_h_tagged};
                        Value* f_plus = codegenClosureCall(f_closure, call_args_plus, "derivative-plus");
                        Value* f_plus_val = unpackDoubleFromTaggedValue(f_plus);

                        // Compute f(x - h)
                        Value* x_minus_h = builder->CreateFSub(x, h);
                        Value* x_minus_h_tagged = packDoubleToTaggedValue(x_minus_h);
                        std::vector<Value*> call_args_minus = {x_minus_h_tagged};
                        Value* f_minus = codegenClosureCall(f_closure, call_args_minus, "derivative-minus");
                        Value* f_minus_val = unpackDoubleFromTaggedValue(f_minus);

                        // Compute derivative: (f(x+h) - f(x-h)) / (2h)
                        Value* diff = builder->CreateFSub(f_plus_val, f_minus_val);
                        Value* derivative_val = builder->CreateFDiv(diff, two_h);
                        Value* result_tagged = packDoubleToTaggedValue(derivative_val);
                        builder->CreateRet(result_tagged);

                        // Restore insertion point
                        if (saved_bb) {
                            builder->SetInsertPoint(saved_bb, saved_point);
                        }

                        // Register the derivative function
                        function_table[deriv_func_name] = deriv_func;

                        // Create closure capturing the function parameter
                        Value* func_ptr_int = builder->CreatePtrToInt(deriv_func, int64_type);
                        Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

                        uint64_t packed_info = 1;  // 1 capture (the function)
                        Value* packed_captures = ConstantInt::get(int64_type, packed_info);
                        Value* sexpr_ptr = ConstantInt::get(int64_type, 0);
                        // Derivative function returns a scalar
                        Value* return_type_info = ConstantInt::get(int64_type, CLOSURE_RETURN_SCALAR | (1 << 8));

                        Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                                 {arena_ptr, func_ptr_int, packed_captures, sexpr_ptr, return_type_info});

                        // Store captured function
                        Value* env_ptr_ptr = builder->CreateGEP(int8_type, closure_ptr, ConstantInt::get(int64_type, 8));
                        Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_ptr);
                        Value* captures_base = builder->CreateGEP(int8_type, env_ptr, ConstantInt::get(int64_type, 8));
                        builder->CreateStore(closure_val, captures_base);

                        // Return closure as tagged value
                        Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
                        return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
                    }
                }
            }
            eshkol_error("Failed to resolve function for higher-order derivative");
            return nullptr;
        }

        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("higher-order derivative requires a function");
            return nullptr;
        }

        std::string orig_func_name = func_ptr->getName().str();
        std::string deriv_func_name = "derivative_" + orig_func_name + "_" + std::to_string(derivative_ho_counter++);

        // Create derivative wrapper function: takes x, returns derivative at x
        std::vector<Type*> param_types = {tagged_value_type};  // Takes one tagged_value (x)

        // Add capture parameters for the original function if it has captures
        FunctionType* orig_func_type = func_ptr->getFunctionType();
        size_t orig_num_captures = 0;
        if (orig_func_type->getNumParams() > 1) {
            orig_num_captures = orig_func_type->getNumParams() - 1;
            for (size_t i = 0; i < orig_num_captures; i++) {
                param_types.push_back(PointerType::getUnqual(*context));  // Capture pointers
            }
        }

        FunctionType* deriv_func_type = FunctionType::get(tagged_value_type, param_types, false);
        Function* deriv_func = Function::Create(
            deriv_func_type,
            Function::ExternalLinkage,
            deriv_func_name,
            module.get()
        );

        // Save current insertion point
        BasicBlock* saved_bb = builder->GetInsertBlock();
        BasicBlock::iterator saved_point = builder->GetInsertPoint();

        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", deriv_func);
        builder->SetInsertPoint(entry);

        // Get x parameter
        auto arg_it = deriv_func->arg_begin();
        Value* x_tagged = &(*arg_it);
        x_tagged->setName("x");

        // Extract double from x
        Value* x = unpackDoubleFromTaggedValue(x_tagged);

        // Create dual number with seed = 1.0
        Value* one = ConstantFP::get(double_type, 1.0);
        Value* x_dual = packDualNumber(x, one);
        Value* x_dual_tagged = packDualToTaggedValue(x_dual);

        // Build call arguments: (x_dual_tagged, captures...)
        std::vector<Value*> call_args = {x_dual_tagged};
        ++arg_it;
        for (size_t i = 0; i < orig_num_captures; i++, ++arg_it) {
            call_args.push_back(&(*arg_it));
        }

        // Call the original function with dual number
        Value* result = builder->CreateCall(orig_func_type, func_ptr, call_args);

        // Extract derivative from result (tangent part of dual number)
        Value* result_dual = unpackDualFromTaggedValue(result);
        Value* derivative_val = autodiff_->getDualTangent(result_dual);

        // Pack result as tagged double
        Value* result_tagged = packDoubleToTaggedValue(derivative_val);
        builder->CreateRet(result_tagged);

        // Restore insertion point
        if (saved_bb) {
            builder->SetInsertPoint(saved_bb, saved_point);
        }

        // Register the derivative function
        function_table[deriv_func_name] = deriv_func;

        // If original function has captures, we need to create a closure
        if (orig_num_captures > 0) {
            // Get capture values from the original function's closure
            std::string orig_lambda_name = func_ptr->getName().str();
            std::vector<Value*> capture_vals;

            for (size_t i = 0; i < orig_num_captures; i++) {
                // Get capture name from original function's parameter
                auto orig_arg_it = func_ptr->arg_begin();
                std::advance(orig_arg_it, i + 1);
                std::string var_name = orig_arg_it->getName().str();
                if (var_name.find("captured_") == 0) {
                    var_name = var_name.substr(9);
                }

                std::string capture_key = orig_lambda_name + "_capture_" + var_name;

                // Find capture value
                Value* cap_val = nullptr;
                auto git = global_symbol_table.find(capture_key);
                if (git != global_symbol_table.end() && isa<GlobalVariable>(git->second)) {
                    cap_val = builder->CreateLoad(tagged_value_type, git->second);
                } else {
                    auto lit = symbol_table.find(capture_key);
                    if (lit != symbol_table.end()) {
                        if (isa<AllocaInst>(lit->second)) {
                            cap_val = builder->CreateLoad(tagged_value_type, lit->second);
                        } else {
                            cap_val = lit->second;
                        }
                    }
                }

                if (!cap_val) {
                    // Try direct variable lookup
                    auto vit = symbol_table.find(var_name);
                    if (vit != symbol_table.end()) {
                        if (isa<AllocaInst>(vit->second)) {
                            cap_val = builder->CreateLoad(tagged_value_type, vit->second);
                        } else {
                            cap_val = vit->second;
                        }
                    } else {
                        auto gvit = global_symbol_table.find(var_name);
                        if (gvit != global_symbol_table.end() && isa<GlobalVariable>(gvit->second)) {
                            cap_val = builder->CreateLoad(tagged_value_type, gvit->second);
                        }
                    }
                }

                if (cap_val) {
                    capture_vals.push_back(cap_val);
                } else {
                    eshkol_warn("Could not find capture %s for derivative closure", var_name.c_str());
                    capture_vals.push_back(packNullToTaggedValue());
                }
            }

            // Allocate closure with captures
            Value* func_ptr_int = builder->CreatePtrToInt(deriv_func, int64_type);
            Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

            uint64_t packed_info = orig_num_captures & 0xFFFF;
            Value* packed_captures = ConstantInt::get(int64_type, packed_info);
            Value* sexpr_ptr = ConstantInt::get(int64_type, 0);
            // Derivative function returns a scalar
            Value* return_type_info = ConstantInt::get(int64_type, CLOSURE_RETURN_SCALAR | (1 << 8));

            Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                     {arena_ptr, func_ptr_int, packed_captures, sexpr_ptr, return_type_info});

            // Store captures
            Value* env_ptr_ptr = builder->CreateGEP(int8_type, closure_ptr, ConstantInt::get(int64_type, 8));
            Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_ptr);
            Value* captures_base = builder->CreateGEP(int8_type, env_ptr, ConstantInt::get(int64_type, 8));

            for (size_t i = 0; i < capture_vals.size(); i++) {
                Value* cap_slot = builder->CreateGEP(tagged_value_type, captures_base,
                    ConstantInt::get(int64_type, i));
                builder->CreateStore(capture_vals[i], cap_slot);
            }

            // Return closure as tagged value
            Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
            return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
        } else {
            // No captures - still need to allocate a closure structure
            Value* func_ptr_int = builder->CreatePtrToInt(deriv_func, int64_type);
            Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

            uint64_t packed_info = 0;  // 0 captures
            Value* packed_captures = ConstantInt::get(int64_type, packed_info);
            Value* sexpr_ptr = ConstantInt::get(int64_type, 0);
            // Derivative function returns a scalar
            Value* return_type_info = ConstantInt::get(int64_type, CLOSURE_RETURN_SCALAR | (1 << 8));

            Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                     {arena_ptr, func_ptr_int, packed_captures, sexpr_ptr, return_type_info});

            // Return closure as tagged value
            Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
            return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
        }
    }

    Value* codegenDerivative(const eshkol_operations_t* op) {
        if (!op->derivative_op.function) {
            eshkol_error("Invalid derivative operation - missing function");
            return nullptr;
        }

        // Higher-order form: (derivative f) returns a closure that computes derivatives
        if (!op->derivative_op.point) {
            return codegenDerivativeHigherOrder(op);
        }

        eshkol_info("Computing derivative using forward-mode AD (dual numbers)");

        // Get evaluation point - must be a scalar double
        Value* x = codegenAST(op->derivative_op.point);
        if (!x) {
            eshkol_error("Failed to evaluate derivative point");
            return nullptr;
        }

        // Convert x to double if it's an integer or tagged_value
        if (x->getType()->isIntegerTy()) {
            x = builder->CreateSIToFP(x, double_type);
        } else if (x->getType() == tagged_value_type) {
            // Handle computed values that return tagged_value_t
            // Extract the double from the data field
            x = unpackDoubleFromTaggedValue(x);
        } else if (!x->getType()->isDoubleTy()) {
            eshkol_error("derivative point must be numeric (int64 or double)");
            return nullptr;
        }

        // Create dual number with seed derivative = 1.0
        // This means: "we're computing the derivative with respect to this input"
        Value* one = ConstantFP::get(double_type, 1.0);
        Value* x_dual = packDualNumber(x, one);

        // Pack dual number into tagged_value for function call
        Value* x_dual_tagged = packDualToTaggedValue(x_dual);

        // Get the function to differentiate
        Value* func = resolveLambdaFunction(op->derivative_op.function);

        // RUNTIME FUNCTION PARAMETER FIX: If resolveLambdaFunction returns nullptr,
        // check if this is a function parameter (runtime closure) and use codegenClosureCall
        if (!func) {
            const eshkol_ast_t* func_ast = op->derivative_op.function;
            if (func_ast && func_ast->type == ESHKOL_VAR) {
                std::string func_name = func_ast->variable.id;
                eshkol_debug("derivative: trying runtime function parameter '%s'", func_name.c_str());

                // Check if this is a function parameter or captured value
                Value* var_value = nullptr;
                auto local_it = symbol_table.find(func_name);
                if (local_it != symbol_table.end()) {
                    var_value = local_it->second;
                } else {
                    auto global_it = global_symbol_table.find(func_name);
                    if (global_it != global_symbol_table.end()) {
                        var_value = global_it->second;
                    }
                }

                if (var_value) {
                    // Check if it's a function parameter (Argument) with tagged_value type
                    // Also check isStructTy() as a fallback for tagged_value_type matching
                    if (isa<Argument>(var_value) && (var_value->getType() == tagged_value_type || var_value->getType()->isStructTy())) {
                        eshkol_debug("derivative: using runtime dispatch for function parameter '%s'", func_name.c_str());
                        std::vector<Value*> call_args = {x_dual_tagged};
                        Value* result = codegenClosureCall(var_value, call_args);

                        // Unpack result and extract derivative
                        Value* result_dual = unpackDualFromTaggedValue(result);
                        auto [value, derivative] = unpackDualNumber(result_dual);
                        return packDoubleToTaggedValue(derivative);
                    }
                    // Check if it's a pointer to closure (mutable capture)
                    if (isa<Argument>(var_value) && var_value->getType()->isPointerTy()) {
                        eshkol_debug("derivative: using runtime dispatch for captured function '%s'", func_name.c_str());
                        Value* loaded_val = builder->CreateLoad(tagged_value_type, var_value);
                        std::vector<Value*> call_args = {x_dual_tagged};
                        Value* result = codegenClosureCall(loaded_val, call_args);

                        // Unpack result and extract derivative
                        Value* result_dual = unpackDualFromTaggedValue(result);
                        auto [value, derivative] = unpackDualNumber(result_dual);
                        return packDoubleToTaggedValue(derivative);
                    }
                    // Check if it's an AllocaInst (local variable holding a closure)
                    if (isa<AllocaInst>(var_value) && var_value->getType()->isPointerTy()) {
                        AllocaInst* alloca = cast<AllocaInst>(var_value);
                        if (alloca->getAllocatedType() == tagged_value_type) {
                            eshkol_debug("derivative: using runtime dispatch for local function '%s'", func_name.c_str());
                            Value* loaded_val = builder->CreateLoad(tagged_value_type, var_value);
                            std::vector<Value*> call_args = {x_dual_tagged};
                            Value* result = codegenClosureCall(loaded_val, call_args);

                            // Unpack result and extract derivative
                            Value* result_dual = unpackDualFromTaggedValue(result);
                            auto [value, derivative] = unpackDualNumber(result_dual);
                            return packDoubleToTaggedValue(derivative);
                        }
                    }
                    // Check if it's a LoadInst (already loaded closure value)
                    if (isa<LoadInst>(var_value) && var_value->getType() == tagged_value_type) {
                        eshkol_debug("derivative: using runtime dispatch for loaded function '%s'", func_name.c_str());
                        std::vector<Value*> call_args = {x_dual_tagged};
                        Value* result = codegenClosureCall(var_value, call_args);

                        // Unpack result and extract derivative
                        Value* result_dual = unpackDualFromTaggedValue(result);
                        auto [value, derivative] = unpackDualNumber(result_dual);
                        return packDoubleToTaggedValue(derivative);
                    }
                    // Check if it's a GlobalVariable (letrec captured function)
                    if (isa<GlobalVariable>(var_value)) {
                        eshkol_debug("derivative: using runtime dispatch for global function '%s'", func_name.c_str());
                        GlobalVariable* global = cast<GlobalVariable>(var_value);
                        Value* loaded_val = builder->CreateLoad(global->getValueType(), var_value);
                        std::vector<Value*> call_args = {x_dual_tagged};
                        Value* result = codegenClosureCall(loaded_val, call_args);

                        // Unpack result and extract derivative
                        Value* result_dual = unpackDualFromTaggedValue(result);
                        auto [value, derivative] = unpackDualNumber(result_dual);
                        return packDoubleToTaggedValue(derivative);
                    }
                }
            }
            eshkol_error("Failed to resolve function for derivative");
            return nullptr;
        }

        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("derivative operator requires a function");
            return nullptr;
        }

        // Build arguments for derivative lambda call
        std::vector<Value*> deriv_call_args = {x_dual_tagged};

        // CLOSURE FIX: Load captures from STORAGE
        FunctionType* deriv_func_type = func_ptr->getFunctionType();
        if (deriv_func_type->getNumParams() > 1) {
            size_t num_captures = deriv_func_type->getNumParams() - 1;
            std::string lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            // (LLVM external declarations may have empty parameter names)
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t i = 0; i < num_captures; i++) {
                std::string var_name;
                if (i < capture_names.size()) {
                    var_name = capture_names[i];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto arg_it = func_ptr->arg_begin();
                    std::advance(arg_it, i + 1);  // Skip first parameter
                    if (arg_it != func_ptr->arg_end()) {
                        var_name = arg_it->getName().str();
                        if (var_name.find("captured_") == 0) {
                            var_name = var_name.substr(9);
                        }
                    }
                }

                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try local symbol tables with capture_key
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                // INNER FUNCTION FIX: If capture_key not found, try plain variable name
                // This handles lambdas inside functions where captures are function parameters
                // (not stored as GlobalVariables with _capture_ keys)
                // Also handles top-level global variables that are captured by lambdas
                if (!found) {
                    it = global_symbol_table.find(var_name);
                    found_in_global = (it != global_symbol_table.end());
                    if (!found_in_global) {
                        it = symbol_table.find(var_name);
                    }
                    found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());
                    if (found) {
                        eshkol_debug("Derivative: found capture '%s' via plain variable name", var_name.c_str());
                    }
                }

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                capture_key
                            );
                        }
                        // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                        deriv_call_args.push_back(capture_global);
                        continue;
                    }
                }

                if (found && it->second) {
                    Value* storage = it->second;
                    // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                    // But first check if we need to create a temporary storage for pass-by-value
                    if (storage->getType()->isPointerTy()) {
                        deriv_call_args.push_back(storage);
                    } else {
                        // Value is not a pointer - need to create temporary storage
                        // This happens when capturing function parameters (pass-by-value)
                        Value* temp_storage = builder->CreateAlloca(tagged_value_type, nullptr, "capture_temp");
                        builder->CreateStore(storage, temp_storage);
                        deriv_call_args.push_back(temp_storage);
                        eshkol_debug("Derivative: created temp storage for capture '%s'", var_name.c_str());
                    }
                } else {
                    // MUTABLE CAPTURE FIX: Push null pointer instead of packed zero
                    deriv_call_args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                    eshkol_warn("Derivative: capture '%s' not found, using null pointer", var_name.c_str());
                }
            }
        }
        
        // Call function with dual number input and captures
        // The function will automatically use dual arithmetic, propagating derivatives
        Value* result_tagged = builder->CreateCall(func_ptr, deriv_call_args);
        
        // Unpack result from tagged_value
        Value* result_dual = unpackDualFromTaggedValue(result_tagged);
        
        // Extract derivative component from result
        auto [value, derivative] = unpackDualNumber(result_dual);

        eshkol_debug("Derivative operator: extracted derivative component");

        // Return derivative as tagged_value for consistent handling in arithmetic
        return packDoubleToTaggedValue(derivative);
    }
    
    // ===== END DERIVATIVE OPERATOR =====
    // ===== PHASE 3: GRADIENT OPERATOR IMPLEMENTATION =====
    // Reverse-mode automatic differentiation for vector gradients

    // Higher-order gradient: (gradient f) returns a closure that computes gradients
    // Supports N-dimensional inputs using numerical differentiation (central difference)
    Value* codegenGradientHigherOrder(const eshkol_operations_t* op) {
        static int gradient_ho_counter = 0;
        eshkol_info("Creating higher-order gradient function (gradient f -> grad_f)");

        // Resolve the function at compile-time if possible
        Value* func = resolveLambdaFunction(op->gradient_op.function);
        Value* closure_val = nullptr;

        if (!func) {
            // Runtime function parameter - get the closure value
            const eshkol_ast_t* func_ast = op->gradient_op.function;
            if (func_ast && func_ast->type == ESHKOL_VAR) {
                std::string func_name = func_ast->variable.id;
                Value* var_value = nullptr;

                auto local_it = symbol_table.find(func_name);
                if (local_it != symbol_table.end()) {
                    var_value = local_it->second;
                } else {
                    auto global_it = global_symbol_table.find(func_name);
                    if (global_it != global_symbol_table.end()) {
                        var_value = global_it->second;
                    }
                }

                if (var_value) {
                    if (isa<Argument>(var_value) && var_value->getType() == tagged_value_type) {
                        closure_val = var_value;
                    } else if (isa<AllocaInst>(var_value)) {
                        closure_val = builder->CreateLoad(tagged_value_type, var_value);
                    } else if (isa<GlobalVariable>(var_value)) {
                        closure_val = builder->CreateLoad(tagged_value_type, var_value);
                    }
                }
            }

            if (!closure_val) {
                eshkol_error("Failed to resolve function for higher-order gradient");
                return nullptr;
            }
        }

        // Create gradient wrapper function
        // This is VARIADIC: accepts args like (grad-f x y z ...) as a cons list
        // Computes partial derivatives numerically using central difference
        std::string grad_func_name = "gradient_ho_" + std::to_string(gradient_ho_counter++);

        // CRITICAL: Save and disable TCO context during gradient function generation
        // The gradient function has its own internal loops that must not be confused with TCO
        auto saved_tco_ctx = binding_->getTCOContext();
        binding_->getTCOContext().enabled = false;
        binding_->getTCOContext().func_name = "";
        binding_->getTCOContext().loop_header = nullptr;

        // Function takes a rest list (variadic args packaged as cons list) + captured function
        std::vector<Type*> param_types = {tagged_value_type, PointerType::getUnqual(*context)};
        FunctionType* grad_func_type = FunctionType::get(tagged_value_type, param_types, false);
        Function* grad_func = Function::Create(
            grad_func_type,
            Function::ExternalLinkage,
            grad_func_name,
            module.get()
        );

        BasicBlock* saved_bb = builder->GetInsertBlock();
        BasicBlock::iterator saved_point = builder->GetInsertPoint();

        // Create the gradient computation body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", grad_func);
        builder->SetInsertPoint(entry);

        auto arg_it = grad_func->arg_begin();
        Value* args_list = &(*arg_it);  // First arg: rest list of arguments
        args_list->setName("args");
        ++arg_it;
        Value* captured_f_ptr = &(*arg_it);  // Captured function pointer
        captured_f_ptr->setName("captured_f");

        Value* f_closure = builder->CreateLoad(tagged_value_type, captured_f_ptr);

        // Constants for numerical differentiation (central difference)
        Value* h = ConstantFP::get(double_type, 1e-8);
        Value* two_h = ConstantFP::get(double_type, 2e-8);

        // Get cons accessor functions - avoid struct-by-value ABI issues on ARM64
        Function* cons_get_double = function_table["arena_tagged_cons_get_double"];
        Function* cons_get_type = function_table["arena_tagged_cons_get_type"];
        Function* cons_get_ptr = function_table["arena_tagged_cons_get_ptr"];
        if (!cons_get_double || !cons_get_type || !cons_get_ptr) {
            eshkol_error("Cons accessor functions not found");
            if (saved_bb) builder->SetInsertPoint(saved_bb, saved_point);
            return nullptr;
        }

        // First, convert the cons list to a vector and count dimensions
        // Count list length using simple loop with direct tagged_value access
        BasicBlock* count_loop = BasicBlock::Create(*context, "count_loop", grad_func);
        BasicBlock* count_done = BasicBlock::Create(*context, "count_done", grad_func);
        BasicBlock* count_body = BasicBlock::Create(*context, "count_body", grad_func);

        builder->CreateBr(count_loop);
        builder->SetInsertPoint(count_loop);
        PHINode* count_phi = builder->CreatePHI(int64_type, 2, "count");
        count_phi->addIncoming(ConstantInt::get(int64_type, 0), entry);
        PHINode* curr_phi = builder->CreatePHI(tagged_value_type, 2, "curr");
        curr_phi->addIncoming(args_list, entry);

        // Check if current is null (end of list)
        Value* curr_type = getTaggedValueType(curr_phi);
        Value* curr_base = builder->CreateAnd(curr_type, ConstantInt::get(int8_type, 0x0F));
        Value* is_null = builder->CreateICmpEQ(curr_base, ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        builder->CreateCondBr(is_null, count_done, count_body);

        // Count body - increment and get cdr using separate type/ptr accessors (ARM64 ABI fix)
        builder->SetInsertPoint(count_body);
        Value* count_next = builder->CreateAdd(count_phi, ConstantInt::get(int64_type, 1));
        Value* curr_ptr = builder->CreateIntToPtr(unpackInt64FromTaggedValue(curr_phi), PointerType::getUnqual(*context));
        // Get cdr type and pointer separately, then pack into tagged_value
        Value* cdr_type = builder->CreateCall(cons_get_type, {curr_ptr, ConstantInt::get(int1_type, 1)});
        Value* cdr_ptr = builder->CreateCall(cons_get_ptr, {curr_ptr, ConstantInt::get(int1_type, 1)});
        Value* cdr_val = packPtrToTaggedValueWithFlags(cdr_ptr, cdr_type, ConstantInt::get(int8_type, 0));
        count_phi->addIncoming(count_next, count_body);
        curr_phi->addIncoming(cdr_val, count_body);
        builder->CreateBr(count_loop);

        // Count done - dim_val has the list length
        builder->SetInsertPoint(count_done);
        Value* dim_val = count_phi;

        // Allocate vector for the point (length + elements)
        Value* vec_total_size = builder->CreateAdd(ConstantInt::get(int64_type, 1), dim_val);
        Value* vec_bytes = builder->CreateMul(vec_total_size, ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tagged_value_type)));
        Value* point_ptr = builder->CreateCall(function_table["malloc"], {vec_bytes});
        builder->CreateStore(dim_val, point_ptr);  // Store length

        // Copy list elements to vector using simple loop
        BasicBlock* copy_loop = BasicBlock::Create(*context, "copy_loop", grad_func);
        BasicBlock* copy_done = BasicBlock::Create(*context, "copy_done", grad_func);
        BasicBlock* copy_body = BasicBlock::Create(*context, "copy_body", grad_func);

        builder->CreateBr(copy_loop);
        builder->SetInsertPoint(copy_loop);
        PHINode* copy_idx = builder->CreatePHI(int64_type, 2, "copy_idx");
        copy_idx->addIncoming(ConstantInt::get(int64_type, 0), count_done);
        PHINode* copy_curr = builder->CreatePHI(tagged_value_type, 2, "copy_curr");
        copy_curr->addIncoming(args_list, count_done);

        Value* copy_type = getTaggedValueType(copy_curr);
        Value* copy_base = builder->CreateAnd(copy_type, ConstantInt::get(int8_type, 0x0F));
        Value* copy_is_null = builder->CreateICmpEQ(copy_base, ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
        builder->CreateCondBr(copy_is_null, copy_done, copy_body);

        // Copy body - store car and advance using separate type/ptr accessors (ARM64 ABI fix)
        builder->SetInsertPoint(copy_body);

        Value* copy_ptr = builder->CreateIntToPtr(unpackInt64FromTaggedValue(copy_curr), PointerType::getUnqual(*context));
        // Get car type and value separately, then pack into tagged_value
        Value* car_type_raw = builder->CreateCall(cons_get_type, {copy_ptr, ConstantInt::get(int1_type, 0)});
        Value* car_double = builder->CreateCall(cons_get_double, {copy_ptr, ConstantInt::get(int1_type, 0)});
        Value* car_val = packDoubleToTaggedValue(car_double);

        Value* vec_elem_offset = builder->CreateAdd(ConstantInt::get(int64_type, 1), copy_idx);
        Value* vec_elem_ptr = builder->CreateGEP(tagged_value_type, point_ptr, vec_elem_offset);
        builder->CreateStore(car_val, vec_elem_ptr);
        Value* copy_idx_next = builder->CreateAdd(copy_idx, ConstantInt::get(int64_type, 1));
        // Get cdr type and pointer separately, then pack into tagged_value
        Value* cdr_type_raw = builder->CreateCall(cons_get_type, {copy_ptr, ConstantInt::get(int1_type, 1)});
        Value* cdr_ptr_raw = builder->CreateCall(cons_get_ptr, {copy_ptr, ConstantInt::get(int1_type, 1)});
        Value* copy_cdr = packPtrToTaggedValueWithFlags(cdr_ptr_raw, cdr_type_raw, ConstantInt::get(int8_type, 0));
        copy_idx->addIncoming(copy_idx_next, copy_body);
        copy_curr->addIncoming(copy_cdr, copy_body);
        builder->CreateBr(copy_loop);

        // Copy done - now point_ptr is a proper vector
        builder->SetInsertPoint(copy_done);

        // Allocate result tensor data
        Value* result_size = builder->CreateMul(dim_val, ConstantInt::get(int64_type, 8));
        Value* result_data = builder->CreateCall(function_table["malloc"], {result_size});

        // SIMPLIFIED GRADIENT: Use switch-based dispatch like derivative does
        // Instead of complex loops, generate static code paths for each arg count
        const int MAX_GRADIENT_ARGS = 8;

        BasicBlock* switch_default = BasicBlock::Create(*context, "grad_default", grad_func);
        BasicBlock* grad_done = BasicBlock::Create(*context, "grad_done", grad_func);

        SwitchInst* dim_switch = builder->CreateSwitch(dim_val, switch_default, MAX_GRADIENT_ARGS);
        std::vector<std::pair<BasicBlock*, Value*>> results;

        // Generate a case for each dimension count (1 to MAX_GRADIENT_ARGS)
        for (int dim_count = 1; dim_count <= MAX_GRADIENT_ARGS; dim_count++) {
            BasicBlock* case_bb = BasicBlock::Create(*context,
                "grad_dim_" + std::to_string(dim_count), grad_func);
            dim_switch->addCase(ConstantInt::get(int64_type, dim_count), case_bb);
            builder->SetInsertPoint(case_bb);

            // Load all arguments from point_ptr into a local array
            std::vector<Value*> base_args;
            for (int i = 0; i < dim_count; i++) {
                Value* elem_offset = ConstantInt::get(int64_type, 1 + i);
                Value* elem_ptr = builder->CreateGEP(tagged_value_type, point_ptr, elem_offset);
                Value* loaded_arg = builder->CreateLoad(tagged_value_type, elem_ptr);
                base_args.push_back(loaded_arg);
            }

            // For each dimension, compute partial derivative using central difference
            for (int i = 0; i < dim_count; i++) {
                // Get the original value at dimension i
                Value* orig_val = unpackDoubleFromTaggedValue(base_args[i]);
                Value* plus_val = builder->CreateFAdd(orig_val, h);
                Value* minus_val = builder->CreateFSub(orig_val, h);

                // Build plus args (copy base_args with modified index i)
                std::vector<Value*> plus_args = base_args;
                plus_args[i] = packDoubleToTaggedValue(plus_val);

                // Build minus args
                std::vector<Value*> minus_args = base_args;
                minus_args[i] = packDoubleToTaggedValue(minus_val);

                // Call f(plus_args) and f(minus_args) using codegenClosureCall
                Value* f_plus = codegenClosureCall(f_closure, plus_args);
                Value* f_minus = codegenClosureCall(f_closure, minus_args);

                // Compute partial derivative: (f_plus - f_minus) / (2h)
                Value* f_plus_d = unpackDoubleFromTaggedValue(f_plus);
                Value* f_minus_d = unpackDoubleFromTaggedValue(f_minus);
                Value* diff = builder->CreateFSub(f_plus_d, f_minus_d);
                Value* partial = builder->CreateFDiv(diff, two_h);

                // Store in result array
                Value* result_slot = builder->CreateGEP(double_type, result_data,
                    ConstantInt::get(int64_type, i));
                builder->CreateStore(partial, result_slot);
            }

            builder->CreateBr(grad_done);
            results.push_back({builder->GetInsertBlock(), dim_val});
        }

        // Default case: unsupported dimension count, return null tensor
        builder->SetInsertPoint(switch_default);
        builder->CreateBr(grad_done);
        results.push_back({switch_default, ConstantInt::get(int64_type, 0)});

        // Grad done - create result tensor using proper tensor struct format
        builder->SetInsertPoint(grad_done);

        // Tensor struct format:
        // Field 0: dims (pointer to dimensions array)
        // Field 1: num_dims (number of dimensions)
        // Field 2: elements (pointer to double data)
        // Field 3: total_elements

        // Allocate tensor struct
        Value* tensor_size = ConstantInt::get(int64_type, module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_mem = builder->CreateCall(function_table["malloc"], {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_mem, PointerType::getUnqual(tensor_type));

        // Allocate dimensions array (1 element for 1D tensor)
        Value* dims_array = builder->CreateCall(function_table["malloc"],
            {ConstantInt::get(int64_type, 8)});  // 1 * sizeof(int64)
        builder->CreateStore(dim_val, dims_array);  // dims[0] = number of gradient components

        // Fill tensor struct fields
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0);
        builder->CreateStore(dims_array, dims_field_ptr);  // Field 0: dims pointer

        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 1), num_dims_field_ptr);  // Field 1: num_dims = 1

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2);
        builder->CreateStore(result_data, elements_field_ptr);  // Field 2: elements pointer

        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3);
        builder->CreateStore(dim_val, total_elements_field_ptr);  // Field 3: total_elements = dim_val

        Value* result_tensor = packPtrToTaggedValue(
            builder->CreatePtrToInt(typed_tensor_ptr, int64_type),
            ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateRet(result_tensor);

        // Restore insertion point
        if (saved_bb) {
            builder->SetInsertPoint(saved_bb, saved_point);
        }

        // Restore TCO context
        binding_->getTCOContext() = saved_tco_ctx;

        // Register the gradient function
        function_table[grad_func_name] = grad_func;
        nested_function_captures[grad_func_name] = {"f"};  // 1 capture

        // Create closure capturing the original function
        if (!closure_val && func) {
            // Static function - pack as closure
            closure_val = packPtrToTaggedValue(
                builder->CreatePtrToInt(func, int64_type),
                ESHKOL_VALUE_LAMBDA_SEXPR);
        }

        Value* func_ptr_int = builder->CreatePtrToInt(grad_func, int64_type);
        Value* arena = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        // packed_info format: bits 0-15 = num_captures, bits 16-31 = fixed_params, bit 63 = is_variadic
        // We have 1 capture, 0 fixed params, and IS variadic
        uint64_t packed_info = 1 | (0ULL << 16) | (1ULL << 63);  // 1 capture, variadic
        Value* packed_captures = ConstantInt::get(int64_type, packed_info);
        Value* sexpr_ptr = ConstantInt::get(int64_type, 0);
        // Gradient returns a vector
        Value* return_type_info = ConstantInt::get(int64_type, CLOSURE_RETURN_VECTOR | (1 << 8));
        Value* closure_ptr = builder->CreateCall(getArenaAllocateClosureFunc(),
                                                 {arena, func_ptr_int, packed_captures, sexpr_ptr, return_type_info});

        // Store captured function in closure environment
        Value* env_ptr_ptr = builder->CreateGEP(int8_type, closure_ptr, ConstantInt::get(int64_type, 8));
        Value* env_ptr = builder->CreateLoad(PointerType::getUnqual(*context), env_ptr_ptr);
        Value* captures_base = builder->CreateGEP(int8_type, env_ptr, ConstantInt::get(int64_type, 8));
        builder->CreateStore(closure_val, captures_base);

        // Return closure as tagged value
        Value* closure_int = builder->CreatePtrToInt(closure_ptr, int64_type);
        return packPtrToTaggedValue(closure_int, ESHKOL_VALUE_CLOSURE_PTR);
    }

    Value* codegenGradient(const eshkol_operations_t* op) {
        if (!op->gradient_op.function) {
            eshkol_error("Invalid gradient operation - missing function");
            return nullptr;
        }

        // Higher-order form: (gradient f) returns a closure that computes gradients
        if (!op->gradient_op.point) {
            return codegenGradientHigherOrder(op);
        }

        // Resolve function (lambda or function reference)
        Value* func = resolveLambdaFunction(op->gradient_op.function);

        // RUNTIME FUNCTION PARAMETER FIX: Handle functions passed as parameters
        // For gradient with runtime function parameters, we need to use a different approach
        // since gradient requires knowing the function structure at compile time.
        // For now, we'll check if the function AST is a variable and look it up.
        if (!func) {
            const eshkol_ast_t* func_ast = op->gradient_op.function;
            if (func_ast && func_ast->type == ESHKOL_VAR) {
                std::string func_name = func_ast->variable.id;
                eshkol_debug("gradient: checking runtime function parameter '%s'", func_name.c_str());

                // Check if this is a function parameter or captured value
                Value* var_value = nullptr;

                // NESTED FUNCTION FIX: First check if there's a GlobalVariable for this capture
                // This handles nested functions where captures are stored in GlobalVariables
                Function* current_func = builder->GetInsertBlock()->getParent();
                std::string capture_key = current_func->getName().str() + "_capture_" + func_name;
                auto gv_it = global_symbol_table.find(capture_key);
                if (gv_it != global_symbol_table.end() && isa<GlobalVariable>(gv_it->second)) {
                    var_value = gv_it->second;
                }

                // If not found as a capture, try regular symbol_table lookup
                if (!var_value) {
                    auto local_it = symbol_table.find(func_name);
                    if (local_it != symbol_table.end()) {
                        var_value = local_it->second;
                    } else {
                        auto global_it = global_symbol_table.find(func_name);
                        if (global_it != global_symbol_table.end()) {
                            var_value = global_it->second;
                        }
                    }
                }

                // NESTED FUNCTION FIX: Check if the Argument belongs to the current function
                // If it's from a different function, we need to find it in our captures
                // Also handle pointer-type captures (used for mutable closures)
                if (var_value && isa<Argument>(var_value)) {
                    Argument* arg = cast<Argument>(var_value);
                    Function* arg_parent = arg->getParent();
                    Function* current_func = builder->GetInsertBlock()->getParent();

                    // POINTER CAPTURE FIX: If this is a pointer-type capture argument,
                    // load the tagged value from it before proceeding
                    if (arg_parent == current_func && arg->getType()->isPointerTy()) {
                        var_value = builder->CreateLoad(tagged_value_type, arg);
                    }

                    if (arg_parent != current_func) {
                        // The Argument is from a different function - find it in current function's captures
                        bool found_in_captures = false;
                        for (auto& curr_arg : current_func->args()) {
                            std::string arg_name = curr_arg.getName().str();
                            if (arg_name == "captured_" + func_name) {
                                // Found the capture parameter in current function
                                if (curr_arg.getType()->isPointerTy()) {
                                    var_value = builder->CreateLoad(tagged_value_type, &curr_arg);
                                } else {
                                    var_value = &curr_arg;
                                }
                                found_in_captures = true;
                                eshkol_debug("gradient: using current function's capture for %s", func_name.c_str());
                                break;
                            }
                        }
                        if (!found_in_captures) {
                            // Check GlobalVariable captures
                            std::string capture_key = current_func->getName().str() + "_capture_" + func_name;
                            auto cap_it = global_symbol_table.find(capture_key);
                            if (cap_it != global_symbol_table.end() && isa<GlobalVariable>(cap_it->second)) {
                                var_value = builder->CreateLoad(tagged_value_type, cap_it->second);
                                found_in_captures = true;
                                eshkol_debug("gradient: using GlobalVariable capture for %s", func_name.c_str());
                            } else {
                                // Try just the variable name as global key
                                auto var_cap_it = global_symbol_table.find(func_name);
                                if (var_cap_it != global_symbol_table.end() && isa<GlobalVariable>(var_cap_it->second)) {
                                    var_value = builder->CreateLoad(tagged_value_type, var_cap_it->second);
                                    found_in_captures = true;
                                    eshkol_debug("gradient: using GlobalVariable %s directly", func_name.c_str());
                                }
                            }
                        }
                        if (!found_in_captures) {
                            eshkol_error("gradient: could not find capture for '%s'", func_name.c_str());
                            return nullptr;
                        }
                    }

                    // Use forward-mode AD by calling function n times with directional derivatives
                    // For each dimension i, we create a Scheme vector with dual numbers where
                    // tangent=1 at position i and tangent=0 elsewhere

                    // Get the input point
                    Value* point_val = codegenAST(op->gradient_op.point);
                    if (!point_val) {
                        eshkol_error("Failed to evaluate gradient point");
                        return nullptr;
                    }

                    // Ensure point is tagged
                    if (point_val->getType() != tagged_value_type) {
                        if (point_val->getType()->isIntegerTy(64)) {
                            point_val = packInt64ToTaggedValue(point_val, true);
                        } else if (point_val->getType()->isDoubleTy()) {
                            point_val = packDoubleToTaggedValue(point_val);
                        }
                    }

                    // Note: current_func already defined above for capture lookup

                    // Get arena_allocate for Scheme vector allocation
                    Function* arena_allocate_func = function_table["arena_allocate"];
                    Function* malloc_func = function_table["malloc"];
                    if (!arena_allocate_func || !malloc_func) {
                        eshkol_error("arena_allocate or malloc not found for gradient");
                        return nullptr;
                    }
                    Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

                    // Get tagged_value size
                    uint64_t tagged_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);

                    // Check input type - handle Scheme vector (VECTOR_PTR), tensor (TENSOR_PTR), or scalar
                    Value* input_type = getTaggedValueType(point_val);
                    Value* input_base = builder->CreateAnd(input_type, ConstantInt::get(int8_type, 0x0F));
                    Value* is_scheme_vec = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
                    Value* is_tensor = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));

                    BasicBlock* scheme_vec_path = BasicBlock::Create(*context, "grad_rt_svec", current_func);
                    BasicBlock* tensor_path = BasicBlock::Create(*context, "grad_rt_tensor", current_func);
                    BasicBlock* scalar_path = BasicBlock::Create(*context, "grad_rt_scalar", current_func);
                    BasicBlock* check_tensor = BasicBlock::Create(*context, "grad_rt_check_tensor", current_func);
                    BasicBlock* grad_rt_compute = BasicBlock::Create(*context, "grad_rt_compute", current_func);

                    builder->CreateCondBr(is_scheme_vec, scheme_vec_path, check_tensor);

                    builder->SetInsertPoint(check_tensor);
                    builder->CreateCondBr(is_tensor, tensor_path, scalar_path);

                    // Scheme vector path - use input directly
                    builder->SetInsertPoint(scheme_vec_path);
                    Value* svec_ptr = unpackPtrFromTaggedValue(point_val);
                    Value* svec_len = builder->CreateLoad(int64_type, svec_ptr);
                    Value* svec_elems = builder->CreateGEP(int8_type, svec_ptr, ConstantInt::get(int64_type, 8));
                    Value* svec_elems_typed = builder->CreatePointerCast(svec_elems, PointerType::getUnqual(tagged_value_type));
                    builder->CreateBr(grad_rt_compute);
                    BasicBlock* svec_exit = builder->GetInsertBlock();

                    // Tensor path - convert tensor elements to Scheme vector of tagged doubles
                    builder->SetInsertPoint(tensor_path);
                    Value* tensor_ptr_int = safeExtractInt64(point_val);
                    Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
                    Value* dims_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
                    Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
                    Value* typed_dims = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
                    Value* tensor_n = builder->CreateLoad(int64_type, typed_dims);
                    Value* tensor_elems_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
                    Value* tensor_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), tensor_elems_field);
                    Value* tensor_elems_typed = builder->CreatePointerCast(tensor_elems_ptr, builder->getPtrTy());

                    // Allocate Scheme vector for tensor elements
                    Value* tconv_size = builder->CreateAdd(
                        builder->CreateMul(tensor_n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* tconv_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, tconv_size});
                    builder->CreateStore(tensor_n, tconv_vec);
                    Value* tconv_elems = builder->CreateGEP(int8_type, tconv_vec, ConstantInt::get(int64_type, 8));
                    Value* tconv_elems_typed = builder->CreatePointerCast(tconv_elems, PointerType::getUnqual(tagged_value_type));

                    // Copy tensor elements as tagged doubles
                    Value* tconv_i = builder->CreateAlloca(int64_type, nullptr, "tconv_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), tconv_i);
                    BasicBlock* tconv_cond = BasicBlock::Create(*context, "tconv_cond", current_func);
                    BasicBlock* tconv_body = BasicBlock::Create(*context, "tconv_body", current_func);
                    BasicBlock* tconv_end = BasicBlock::Create(*context, "tconv_end", current_func);
                    builder->CreateBr(tconv_cond);

                    builder->SetInsertPoint(tconv_cond);
                    Value* tc_idx = builder->CreateLoad(int64_type, tconv_i);
                    builder->CreateCondBr(builder->CreateICmpULT(tc_idx, tensor_n), tconv_body, tconv_end);

                    builder->SetInsertPoint(tconv_body);
                    Value* tc_src = builder->CreateGEP(int64_type, tensor_elems_typed, tc_idx);
                    Value* tc_bits = builder->CreateLoad(int64_type, tc_src);
                    Value* tc_dbl = builder->CreateBitCast(tc_bits, double_type);
                    Value* tc_tagged = packDoubleToTaggedValue(tc_dbl);
                    Value* tc_dst = builder->CreateGEP(tagged_value_type, tconv_elems_typed, tc_idx);
                    builder->CreateStore(tc_tagged, tc_dst);
                    builder->CreateStore(builder->CreateAdd(tc_idx, ConstantInt::get(int64_type, 1)), tconv_i);
                    builder->CreateBr(tconv_cond);

                    builder->SetInsertPoint(tconv_end);
                    builder->CreateBr(grad_rt_compute);
                    BasicBlock* tensor_exit = builder->GetInsertBlock();

                    // Scalar path - create 1-element Scheme vector
                    builder->SetInsertPoint(scalar_path);
                    Value* scalar_val = unpackDoubleFromTaggedValue(point_val);
                    Value* scalar_vec_size = ConstantInt::get(int64_type, 8 + tagged_size);
                    Value* scalar_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, scalar_vec_size});
                    builder->CreateStore(ConstantInt::get(int64_type, 1), scalar_vec);
                    Value* scalar_elem = builder->CreateGEP(int8_type, scalar_vec, ConstantInt::get(int64_type, 8));
                    Value* scalar_elem_typed = builder->CreatePointerCast(scalar_elem, PointerType::getUnqual(tagged_value_type));
                    Value* scalar_tagged = packDoubleToTaggedValue(scalar_val);
                    builder->CreateStore(scalar_tagged, scalar_elem_typed);
                    builder->CreateBr(grad_rt_compute);
                    BasicBlock* scalar_exit = builder->GetInsertBlock();

                    // Merge input paths
                    builder->SetInsertPoint(grad_rt_compute);
                    PHINode* n = builder->CreatePHI(int64_type, 3, "grad_n");
                    n->addIncoming(svec_len, svec_exit);
                    n->addIncoming(tensor_n, tensor_exit);
                    n->addIncoming(ConstantInt::get(int64_type, 1), scalar_exit);

                    PHINode* input_elems = builder->CreatePHI(PointerType::getUnqual(tagged_value_type), 3, "grad_elems");
                    input_elems->addIncoming(svec_elems_typed, svec_exit);
                    input_elems->addIncoming(tconv_elems_typed, tensor_exit);
                    input_elems->addIncoming(scalar_elem_typed, scalar_exit);

                    // Allocate result tensor
                    Value* result_size = ConstantInt::get(int64_type,
                        module->getDataLayout().getTypeAllocSize(tensor_type));
                    Value* result_ptr = builder->CreateCall(malloc_func, {result_size});
                    Value* typed_result = builder->CreatePointerCast(result_ptr, builder->getPtrTy());

                    Value* result_dims_ptr = builder->CreateCall(malloc_func, {ConstantInt::get(int64_type, 8)});
                    Value* typed_result_dims = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
                    builder->CreateStore(n, typed_result_dims);
                    builder->CreateStore(typed_result_dims, builder->CreateStructGEP(tensor_type, typed_result, 0));
                    builder->CreateStore(ConstantInt::get(int64_type, 1), builder->CreateStructGEP(tensor_type, typed_result, 1));
                    builder->CreateStore(n, builder->CreateStructGEP(tensor_type, typed_result, 3));

                    Value* result_elems_size = builder->CreateMul(n, ConstantInt::get(int64_type, sizeof(double)));
                    Value* result_elems_ptr = builder->CreateCall(malloc_func, {result_elems_size});
                    Value* typed_result_elems = builder->CreatePointerCast(result_elems_ptr, builder->getPtrTy());
                    builder->CreateStore(typed_result_elems, builder->CreateStructGEP(tensor_type, typed_result, 2));

                    // Allocate Scheme vector for dual numbers (reused each iteration)
                    Value* dual_vec_size = builder->CreateAdd(
                        builder->CreateMul(n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* dual_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, dual_vec_size});
                    builder->CreateStore(n, dual_vec);
                    Value* dual_elems = builder->CreateGEP(int8_type, dual_vec, ConstantInt::get(int64_type, 8));
                    Value* dual_elems_typed = builder->CreatePointerCast(dual_elems, PointerType::getUnqual(tagged_value_type));

                    // Outer loop: for each dimension i, compute partial derivative
                    Value* dim_counter = builder->CreateAlloca(int64_type, nullptr, "grad_dim_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), dim_counter);

                    BasicBlock* dim_cond = BasicBlock::Create(*context, "grad_dim_cond", current_func);
                    BasicBlock* dim_body = BasicBlock::Create(*context, "grad_dim_body", current_func);
                    BasicBlock* dim_end = BasicBlock::Create(*context, "grad_dim_end", current_func);

                    builder->CreateBr(dim_cond);

                    builder->SetInsertPoint(dim_cond);
                    Value* dim_i = builder->CreateLoad(int64_type, dim_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(dim_i, n), dim_body, dim_end);

                    builder->SetInsertPoint(dim_body);

                    // Inner loop: create dual vector with tangent=1 at dim_i
                    Value* inner_counter = builder->CreateAlloca(int64_type, nullptr, "grad_inner_j");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), inner_counter);

                    BasicBlock* inner_cond = BasicBlock::Create(*context, "grad_inner_cond", current_func);
                    BasicBlock* inner_body = BasicBlock::Create(*context, "grad_inner_body", current_func);
                    BasicBlock* inner_end = BasicBlock::Create(*context, "grad_inner_end", current_func);

                    builder->CreateBr(inner_cond);

                    builder->SetInsertPoint(inner_cond);
                    Value* inner_j = builder->CreateLoad(int64_type, inner_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(inner_j, n), inner_body, inner_end);

                    builder->SetInsertPoint(inner_body);
                    // Load primal value at position j from input elements
                    Value* in_elem_ptr = builder->CreateGEP(tagged_value_type, input_elems, inner_j);
                    Value* in_elem = builder->CreateLoad(tagged_value_type, in_elem_ptr);
                    Value* primal_val = unpackDoubleFromTaggedValue(in_elem);

                    // Set tangent: 1.0 if j == i, else 0.0
                    Value* is_active = builder->CreateICmpEQ(inner_j, dim_i);
                    Value* tangent = builder->CreateSelect(is_active,
                        ConstantFP::get(double_type, 1.0),
                        ConstantFP::get(double_type, 0.0));

                    // Create dual number and store in dual vector
                    Value* dual_num = packDualNumber(primal_val, tangent);
                    Value* dual_tagged = packDualToTaggedValue(dual_num);
                    Value* dual_elem_ptr = builder->CreateGEP(tagged_value_type, dual_elems_typed, inner_j);
                    builder->CreateStore(dual_tagged, dual_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(inner_j, ConstantInt::get(int64_type, 1)), inner_counter);
                    builder->CreateBr(inner_cond);

                    builder->SetInsertPoint(inner_end);

                    // Pack dual vector as Scheme vector (VECTOR_PTR)
                    Value* dual_vec_tagged = packPtrToTaggedValue(
                        builder->CreatePtrToInt(dual_vec, int64_type),
                        ESHKOL_VALUE_VECTOR_PTR);

                    // Call function via closure dispatch
                    std::vector<Value*> call_args = {dual_vec_tagged};
                    Value* call_result = codegenClosureCall(var_value, call_args);

                    // CONSTANT RESULT FIX: Check if result is a dual number before unpacking
                    // If function returns a constant (not using its argument), it won't be dual
                    Value* rt_result_type = getTaggedValueType(call_result);
                    Value* rt_result_base = builder->CreateAnd(rt_result_type, ConstantInt::get(int8_type, 0x0F));
                    Value* rt_is_dual = builder->CreateICmpEQ(rt_result_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));

                    BasicBlock* rt_dual_bb = BasicBlock::Create(*context, "grad_rt_dual", current_func);
                    BasicBlock* rt_const_bb = BasicBlock::Create(*context, "grad_rt_const", current_func);
                    BasicBlock* rt_merge_bb = BasicBlock::Create(*context, "grad_rt_merge", current_func);

                    builder->CreateCondBr(rt_is_dual, rt_dual_bb, rt_const_bb);

                    // Dual path: extract tangent normally
                    builder->SetInsertPoint(rt_dual_bb);
                    Value* rt_result_dual = unpackDualFromTaggedValue(call_result);
                    auto [rt_result_primal, rt_dual_deriv] = unpackDualNumber(rt_result_dual);
                    builder->CreateBr(rt_merge_bb);
                    BasicBlock* rt_dual_exit = builder->GetInsertBlock();

                    // Constant path: derivative is 0.0
                    builder->SetInsertPoint(rt_const_bb);
                    Value* rt_zero_deriv = ConstantFP::get(double_type, 0.0);
                    builder->CreateBr(rt_merge_bb);
                    BasicBlock* rt_const_exit = builder->GetInsertBlock();

                    // Merge paths
                    builder->SetInsertPoint(rt_merge_bb);
                    PHINode* deriv = builder->CreatePHI(double_type, 2, "grad_deriv");
                    deriv->addIncoming(rt_dual_deriv, rt_dual_exit);
                    deriv->addIncoming(rt_zero_deriv, rt_const_exit);

                    // Store derivative in result tensor
                    Value* result_elem_ptr = builder->CreateGEP(int64_type, typed_result_elems, dim_i);
                    Value* deriv_bits = builder->CreateBitCast(deriv, int64_type);
                    builder->CreateStore(deriv_bits, result_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(dim_i, ConstantInt::get(int64_type, 1)), dim_counter);
                    builder->CreateBr(dim_cond);

                    builder->SetInsertPoint(dim_end);
                    Value* result_int = builder->CreatePtrToInt(typed_result, int64_type);
                    return packPtrToTaggedValue(result_int, ESHKOL_VALUE_TENSOR_PTR);
                }

                // NESTED FUNCTION CAPTURE FIX: Handle pointer-type Arguments (captured functions)
                // In nested functions like (define (step point) (gradient f point)),
                // 'f' is captured and passed as a pointer to the closure environment
                if (var_value && isa<Argument>(var_value) && var_value->getType()->isPointerTy()) {
                    eshkol_debug("gradient: using forward-mode AD for captured function '%s'", func_name.c_str());

                    // Load the function from the capture pointer
                    Value* loaded_func = builder->CreateLoad(tagged_value_type, var_value);

                    // Get the input point
                    Value* point_val = codegenAST(op->gradient_op.point);
                    if (!point_val) {
                        eshkol_error("Failed to evaluate gradient point");
                        return nullptr;
                    }

                    // Ensure point is tagged
                    if (point_val->getType() != tagged_value_type) {
                        if (point_val->getType()->isIntegerTy(64)) {
                            point_val = packInt64ToTaggedValue(point_val, true);
                        } else if (point_val->getType()->isDoubleTy()) {
                            point_val = packDoubleToTaggedValue(point_val);
                        }
                    }

                    Function* current_func = builder->GetInsertBlock()->getParent();

                    // Get arena_allocate for Scheme vector allocation
                    Function* arena_allocate_func = function_table["arena_allocate"];
                    Function* malloc_func = function_table["malloc"];
                    if (!arena_allocate_func || !malloc_func) {
                        eshkol_error("arena_allocate or malloc not found for gradient");
                        return nullptr;
                    }
                    Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

                    // Get tagged_value size
                    uint64_t tagged_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);

                    // Check input type - handle Scheme vector (VECTOR_PTR), tensor (TENSOR_PTR), or scalar
                    Value* input_type = getTaggedValueType(point_val);
                    Value* input_base = builder->CreateAnd(input_type, ConstantInt::get(int8_type, 0x0F));
                    Value* is_scheme_vec = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
                    Value* is_tensor = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));

                    BasicBlock* cap_scheme_vec_path = BasicBlock::Create(*context, "grad_cap_svec", current_func);
                    BasicBlock* cap_tensor_path = BasicBlock::Create(*context, "grad_cap_tensor", current_func);
                    BasicBlock* cap_scalar_path = BasicBlock::Create(*context, "grad_cap_scalar", current_func);
                    BasicBlock* cap_check_tensor = BasicBlock::Create(*context, "grad_cap_check_tensor", current_func);
                    BasicBlock* cap_grad_compute = BasicBlock::Create(*context, "grad_cap_compute", current_func);

                    builder->CreateCondBr(is_scheme_vec, cap_scheme_vec_path, cap_check_tensor);

                    builder->SetInsertPoint(cap_check_tensor);
                    builder->CreateCondBr(is_tensor, cap_tensor_path, cap_scalar_path);

                    // Scheme vector path - use input directly
                    builder->SetInsertPoint(cap_scheme_vec_path);
                    Value* cap_svec_ptr = unpackPtrFromTaggedValue(point_val);
                    Value* cap_svec_len = builder->CreateLoad(int64_type, cap_svec_ptr);
                    Value* cap_svec_elems = builder->CreateGEP(int8_type, cap_svec_ptr, ConstantInt::get(int64_type, 8));
                    Value* cap_svec_elems_typed = builder->CreatePointerCast(cap_svec_elems, PointerType::getUnqual(tagged_value_type));
                    builder->CreateBr(cap_grad_compute);
                    BasicBlock* cap_svec_exit = builder->GetInsertBlock();

                    // Tensor path - convert tensor elements to Scheme vector of tagged doubles
                    builder->SetInsertPoint(cap_tensor_path);
                    Value* cap_tensor_ptr_int = safeExtractInt64(point_val);
                    Value* cap_tensor_ptr = builder->CreateIntToPtr(cap_tensor_ptr_int, builder->getPtrTy());
                    Value* cap_dims_field = builder->CreateStructGEP(tensor_type, cap_tensor_ptr, 0);
                    Value* cap_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), cap_dims_field);
                    Value* cap_typed_dims = builder->CreatePointerCast(cap_dims_ptr, builder->getPtrTy());
                    Value* cap_tensor_n = builder->CreateLoad(int64_type, cap_typed_dims);
                    Value* cap_tensor_elems_field = builder->CreateStructGEP(tensor_type, cap_tensor_ptr, 2);
                    Value* cap_tensor_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), cap_tensor_elems_field);
                    Value* cap_tensor_elems_typed = builder->CreatePointerCast(cap_tensor_elems_ptr, builder->getPtrTy());

                    // Allocate Scheme vector for tensor elements
                    Value* cap_tconv_size = builder->CreateAdd(
                        builder->CreateMul(cap_tensor_n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* cap_tconv_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, cap_tconv_size});
                    builder->CreateStore(cap_tensor_n, cap_tconv_vec);
                    Value* cap_tconv_elems = builder->CreateGEP(int8_type, cap_tconv_vec, ConstantInt::get(int64_type, 8));
                    Value* cap_tconv_elems_typed = builder->CreatePointerCast(cap_tconv_elems, PointerType::getUnqual(tagged_value_type));

                    // Copy tensor elements as tagged doubles
                    Value* cap_tconv_i = builder->CreateAlloca(int64_type, nullptr, "cap_tconv_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), cap_tconv_i);
                    BasicBlock* cap_tconv_cond = BasicBlock::Create(*context, "cap_tconv_cond", current_func);
                    BasicBlock* cap_tconv_body = BasicBlock::Create(*context, "cap_tconv_body", current_func);
                    BasicBlock* cap_tconv_end = BasicBlock::Create(*context, "cap_tconv_end", current_func);
                    builder->CreateBr(cap_tconv_cond);

                    builder->SetInsertPoint(cap_tconv_cond);
                    Value* cap_tc_idx = builder->CreateLoad(int64_type, cap_tconv_i);
                    builder->CreateCondBr(builder->CreateICmpULT(cap_tc_idx, cap_tensor_n), cap_tconv_body, cap_tconv_end);

                    builder->SetInsertPoint(cap_tconv_body);
                    Value* cap_tc_src = builder->CreateGEP(int64_type, cap_tensor_elems_typed, cap_tc_idx);
                    Value* cap_tc_bits = builder->CreateLoad(int64_type, cap_tc_src);
                    Value* cap_tc_dbl = builder->CreateBitCast(cap_tc_bits, double_type);
                    Value* cap_tc_tagged = packDoubleToTaggedValue(cap_tc_dbl);
                    Value* cap_tc_dst = builder->CreateGEP(tagged_value_type, cap_tconv_elems_typed, cap_tc_idx);
                    builder->CreateStore(cap_tc_tagged, cap_tc_dst);
                    builder->CreateStore(builder->CreateAdd(cap_tc_idx, ConstantInt::get(int64_type, 1)), cap_tconv_i);
                    builder->CreateBr(cap_tconv_cond);

                    builder->SetInsertPoint(cap_tconv_end);
                    builder->CreateBr(cap_grad_compute);
                    BasicBlock* cap_tensor_exit = builder->GetInsertBlock();

                    // Scalar path - create 1-element Scheme vector
                    builder->SetInsertPoint(cap_scalar_path);
                    Value* cap_scalar_val = unpackDoubleFromTaggedValue(point_val);
                    Value* cap_scalar_vec_size = ConstantInt::get(int64_type, 8 + tagged_size);
                    Value* cap_scalar_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, cap_scalar_vec_size});
                    builder->CreateStore(ConstantInt::get(int64_type, 1), cap_scalar_vec);
                    Value* cap_scalar_elem = builder->CreateGEP(int8_type, cap_scalar_vec, ConstantInt::get(int64_type, 8));
                    Value* cap_scalar_elem_typed = builder->CreatePointerCast(cap_scalar_elem, PointerType::getUnqual(tagged_value_type));
                    Value* cap_scalar_tagged = packDoubleToTaggedValue(cap_scalar_val);
                    builder->CreateStore(cap_scalar_tagged, cap_scalar_elem_typed);
                    builder->CreateBr(cap_grad_compute);
                    BasicBlock* cap_scalar_exit = builder->GetInsertBlock();

                    // Merge input paths
                    builder->SetInsertPoint(cap_grad_compute);
                    PHINode* cap_n = builder->CreatePHI(int64_type, 3, "cap_grad_n");
                    cap_n->addIncoming(cap_svec_len, cap_svec_exit);
                    cap_n->addIncoming(cap_tensor_n, cap_tensor_exit);
                    cap_n->addIncoming(ConstantInt::get(int64_type, 1), cap_scalar_exit);

                    PHINode* cap_input_elems = builder->CreatePHI(PointerType::getUnqual(tagged_value_type), 3, "cap_grad_elems");
                    cap_input_elems->addIncoming(cap_svec_elems_typed, cap_svec_exit);
                    cap_input_elems->addIncoming(cap_tconv_elems_typed, cap_tensor_exit);
                    cap_input_elems->addIncoming(cap_scalar_elem_typed, cap_scalar_exit);

                    // Allocate result tensor
                    Value* cap_result_size = ConstantInt::get(int64_type,
                        module->getDataLayout().getTypeAllocSize(tensor_type));
                    Value* cap_result_ptr = builder->CreateCall(malloc_func, {cap_result_size});
                    Value* cap_typed_result = builder->CreatePointerCast(cap_result_ptr, builder->getPtrTy());

                    Value* cap_result_dims_ptr = builder->CreateCall(malloc_func, {ConstantInt::get(int64_type, 8)});
                    Value* cap_typed_result_dims = builder->CreatePointerCast(cap_result_dims_ptr, builder->getPtrTy());
                    builder->CreateStore(cap_n, cap_typed_result_dims);
                    builder->CreateStore(cap_typed_result_dims, builder->CreateStructGEP(tensor_type, cap_typed_result, 0));
                    builder->CreateStore(ConstantInt::get(int64_type, 1), builder->CreateStructGEP(tensor_type, cap_typed_result, 1));
                    builder->CreateStore(cap_n, builder->CreateStructGEP(tensor_type, cap_typed_result, 3));

                    Value* cap_result_elems_size = builder->CreateMul(cap_n, ConstantInt::get(int64_type, sizeof(double)));
                    Value* cap_result_elems_ptr = builder->CreateCall(malloc_func, {cap_result_elems_size});
                    Value* cap_typed_result_elems = builder->CreatePointerCast(cap_result_elems_ptr, builder->getPtrTy());
                    builder->CreateStore(cap_typed_result_elems, builder->CreateStructGEP(tensor_type, cap_typed_result, 2));

                    // Allocate Scheme vector for dual numbers (reused each iteration)
                    Value* cap_dual_vec_size = builder->CreateAdd(
                        builder->CreateMul(cap_n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* cap_dual_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, cap_dual_vec_size});
                    builder->CreateStore(cap_n, cap_dual_vec);
                    Value* cap_dual_elems = builder->CreateGEP(int8_type, cap_dual_vec, ConstantInt::get(int64_type, 8));
                    Value* cap_dual_elems_typed = builder->CreatePointerCast(cap_dual_elems, PointerType::getUnqual(tagged_value_type));

                    // Outer loop: for each dimension i, compute partial derivative
                    Value* cap_dim_counter = builder->CreateAlloca(int64_type, nullptr, "cap_grad_dim_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), cap_dim_counter);

                    BasicBlock* cap_dim_cond = BasicBlock::Create(*context, "cap_grad_dim_cond", current_func);
                    BasicBlock* cap_dim_body = BasicBlock::Create(*context, "cap_grad_dim_body", current_func);
                    BasicBlock* cap_dim_end = BasicBlock::Create(*context, "cap_grad_dim_end", current_func);

                    builder->CreateBr(cap_dim_cond);

                    builder->SetInsertPoint(cap_dim_cond);
                    Value* cap_dim_i = builder->CreateLoad(int64_type, cap_dim_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(cap_dim_i, cap_n), cap_dim_body, cap_dim_end);

                    builder->SetInsertPoint(cap_dim_body);

                    // Inner loop: create dual vector with tangent=1 at dim_i
                    Value* cap_inner_counter = builder->CreateAlloca(int64_type, nullptr, "cap_grad_inner_j");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), cap_inner_counter);

                    BasicBlock* cap_inner_cond = BasicBlock::Create(*context, "cap_grad_inner_cond", current_func);
                    BasicBlock* cap_inner_body = BasicBlock::Create(*context, "cap_grad_inner_body", current_func);
                    BasicBlock* cap_inner_end = BasicBlock::Create(*context, "cap_grad_inner_end", current_func);

                    builder->CreateBr(cap_inner_cond);

                    builder->SetInsertPoint(cap_inner_cond);
                    Value* cap_inner_j = builder->CreateLoad(int64_type, cap_inner_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(cap_inner_j, cap_n), cap_inner_body, cap_inner_end);

                    builder->SetInsertPoint(cap_inner_body);
                    // Load primal value at position j from input elements
                    Value* cap_in_elem_ptr = builder->CreateGEP(tagged_value_type, cap_input_elems, cap_inner_j);
                    Value* cap_in_elem = builder->CreateLoad(tagged_value_type, cap_in_elem_ptr);
                    Value* cap_primal_val = unpackDoubleFromTaggedValue(cap_in_elem);

                    // Set tangent: 1.0 if j == i, else 0.0
                    Value* cap_is_active = builder->CreateICmpEQ(cap_inner_j, cap_dim_i);
                    Value* cap_tangent = builder->CreateSelect(cap_is_active,
                        ConstantFP::get(double_type, 1.0),
                        ConstantFP::get(double_type, 0.0));

                    // Create dual number and store in dual vector
                    Value* cap_dual_num = packDualNumber(cap_primal_val, cap_tangent);
                    Value* cap_dual_tagged = packDualToTaggedValue(cap_dual_num);
                    Value* cap_dual_elem_ptr = builder->CreateGEP(tagged_value_type, cap_dual_elems_typed, cap_inner_j);
                    builder->CreateStore(cap_dual_tagged, cap_dual_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(cap_inner_j, ConstantInt::get(int64_type, 1)), cap_inner_counter);
                    builder->CreateBr(cap_inner_cond);

                    builder->SetInsertPoint(cap_inner_end);

                    // Pack dual vector as Scheme vector (VECTOR_PTR)
                    Value* cap_dual_vec_tagged = packPtrToTaggedValue(
                        builder->CreatePtrToInt(cap_dual_vec, int64_type),
                        ESHKOL_VALUE_VECTOR_PTR);

                    // Call function via closure dispatch (using loaded_func, not var_value)
                    std::vector<Value*> cap_call_args = {cap_dual_vec_tagged};
                    Value* cap_call_result = codegenClosureCall(loaded_func, cap_call_args);

                    // CONSTANT RESULT FIX: Check if result is a dual number before unpacking
                    Value* cap_result_type = getTaggedValueType(cap_call_result);
                    Value* cap_result_base = builder->CreateAnd(cap_result_type, ConstantInt::get(int8_type, 0x0F));
                    Value* cap_is_dual = builder->CreateICmpEQ(cap_result_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));

                    BasicBlock* cap_dual_bb = BasicBlock::Create(*context, "grad_cap_dual", current_func);
                    BasicBlock* cap_const_bb = BasicBlock::Create(*context, "grad_cap_const", current_func);
                    BasicBlock* cap_merge_bb = BasicBlock::Create(*context, "grad_cap_merge", current_func);

                    builder->CreateCondBr(cap_is_dual, cap_dual_bb, cap_const_bb);

                    // Dual path: extract tangent normally
                    builder->SetInsertPoint(cap_dual_bb);
                    Value* cap_result_dual = unpackDualFromTaggedValue(cap_call_result);
                    auto [cap_result_primal, cap_dual_deriv] = unpackDualNumber(cap_result_dual);
                    builder->CreateBr(cap_merge_bb);
                    BasicBlock* cap_dual_exit = builder->GetInsertBlock();

                    // Constant path: derivative is 0.0
                    builder->SetInsertPoint(cap_const_bb);
                    Value* cap_zero_deriv = ConstantFP::get(double_type, 0.0);
                    builder->CreateBr(cap_merge_bb);
                    BasicBlock* cap_const_exit = builder->GetInsertBlock();

                    // Merge paths
                    builder->SetInsertPoint(cap_merge_bb);
                    PHINode* cap_deriv = builder->CreatePHI(double_type, 2, "grad_cap_deriv");
                    cap_deriv->addIncoming(cap_dual_deriv, cap_dual_exit);
                    cap_deriv->addIncoming(cap_zero_deriv, cap_const_exit);

                    // Store derivative in result tensor
                    Value* cap_result_elem_ptr = builder->CreateGEP(int64_type, cap_typed_result_elems, cap_dim_i);
                    Value* cap_deriv_bits = builder->CreateBitCast(cap_deriv, int64_type);
                    builder->CreateStore(cap_deriv_bits, cap_result_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(cap_dim_i, ConstantInt::get(int64_type, 1)), cap_dim_counter);
                    builder->CreateBr(cap_dim_cond);

                    builder->SetInsertPoint(cap_dim_end);
                    Value* cap_result_int = builder->CreatePtrToInt(cap_typed_result, int64_type);
                    return packPtrToTaggedValue(cap_result_int, ESHKOL_VALUE_TENSOR_PTR);
                }

                // GLOBALVARIABLE FIX: Handle captured functions stored in GlobalVariables
                // This happens when a nested function captures 'f' from an outer function
                if (var_value && isa<GlobalVariable>(var_value)) {
                    eshkol_debug("gradient: using forward-mode AD for GlobalVariable function '%s'", func_name.c_str());

                    // Load the function from the GlobalVariable
                    GlobalVariable* gv = cast<GlobalVariable>(var_value);
                    Value* loaded_func = builder->CreateLoad(gv->getValueType(), var_value);

                    // Get the input point
                    Value* point_val = codegenAST(op->gradient_op.point);
                    if (!point_val) {
                        eshkol_error("Failed to evaluate gradient point");
                        return nullptr;
                    }

                    // Ensure point is tagged
                    if (point_val->getType() != tagged_value_type) {
                        if (point_val->getType()->isIntegerTy(64)) {
                            point_val = packInt64ToTaggedValue(point_val, true);
                        } else if (point_val->getType()->isDoubleTy()) {
                            point_val = packDoubleToTaggedValue(point_val);
                        }
                    }

                    Function* current_func = builder->GetInsertBlock()->getParent();

                    // Get arena_allocate for Scheme vector allocation
                    Function* arena_allocate_func = function_table["arena_allocate"];
                    Function* malloc_func = function_table["malloc"];
                    if (!arena_allocate_func || !malloc_func) {
                        eshkol_error("arena_allocate or malloc not found for gradient");
                        return nullptr;
                    }
                    Value* arena_ptr = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);

                    // Get tagged_value size
                    uint64_t tagged_size = module->getDataLayout().getTypeAllocSize(tagged_value_type);

                    // Check input type - handle Scheme vector (VECTOR_PTR), tensor (TENSOR_PTR), or scalar
                    Value* input_type = getTaggedValueType(point_val);
                    Value* input_base = builder->CreateAnd(input_type, ConstantInt::get(int8_type, 0x0F));
                    Value* is_scheme_vec = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
                    Value* is_tensor = builder->CreateICmpEQ(input_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));

                    BasicBlock* gv_scheme_vec_path = BasicBlock::Create(*context, "grad_gv_svec", current_func);
                    BasicBlock* gv_tensor_path = BasicBlock::Create(*context, "grad_gv_tensor", current_func);
                    BasicBlock* gv_scalar_path = BasicBlock::Create(*context, "grad_gv_scalar", current_func);
                    BasicBlock* gv_check_tensor = BasicBlock::Create(*context, "grad_gv_check_tensor", current_func);
                    BasicBlock* gv_grad_compute = BasicBlock::Create(*context, "grad_gv_compute", current_func);

                    builder->CreateCondBr(is_scheme_vec, gv_scheme_vec_path, gv_check_tensor);

                    builder->SetInsertPoint(gv_check_tensor);
                    builder->CreateCondBr(is_tensor, gv_tensor_path, gv_scalar_path);

                    // Scheme vector path - use input directly
                    builder->SetInsertPoint(gv_scheme_vec_path);
                    Value* gv_svec_ptr = unpackPtrFromTaggedValue(point_val);
                    Value* gv_svec_len = builder->CreateLoad(int64_type, gv_svec_ptr);
                    Value* gv_svec_elems = builder->CreateGEP(int8_type, gv_svec_ptr, ConstantInt::get(int64_type, 8));
                    Value* gv_svec_elems_typed = builder->CreatePointerCast(gv_svec_elems, PointerType::getUnqual(tagged_value_type));
                    builder->CreateBr(gv_grad_compute);
                    BasicBlock* gv_svec_exit = builder->GetInsertBlock();

                    // Tensor path - convert tensor elements to Scheme vector of tagged doubles
                    builder->SetInsertPoint(gv_tensor_path);
                    Value* gv_tensor_ptr_int = safeExtractInt64(point_val);
                    Value* gv_tensor_ptr = builder->CreateIntToPtr(gv_tensor_ptr_int, builder->getPtrTy());
                    Value* gv_dims_field = builder->CreateStructGEP(tensor_type, gv_tensor_ptr, 0);
                    Value* gv_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), gv_dims_field);
                    Value* gv_typed_dims = builder->CreatePointerCast(gv_dims_ptr, builder->getPtrTy());
                    Value* gv_tensor_n = builder->CreateLoad(int64_type, gv_typed_dims);
                    Value* gv_tensor_elems_field = builder->CreateStructGEP(tensor_type, gv_tensor_ptr, 2);
                    Value* gv_tensor_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), gv_tensor_elems_field);
                    Value* gv_tensor_elems_typed = builder->CreatePointerCast(gv_tensor_elems_ptr, builder->getPtrTy());

                    // Allocate Scheme vector for tensor elements
                    Value* gv_tconv_size = builder->CreateAdd(
                        builder->CreateMul(gv_tensor_n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* gv_tconv_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, gv_tconv_size});
                    builder->CreateStore(gv_tensor_n, gv_tconv_vec);
                    Value* gv_tconv_elems = builder->CreateGEP(int8_type, gv_tconv_vec, ConstantInt::get(int64_type, 8));
                    Value* gv_tconv_elems_typed = builder->CreatePointerCast(gv_tconv_elems, PointerType::getUnqual(tagged_value_type));

                    // Copy tensor elements as tagged doubles
                    Value* gv_tconv_i = builder->CreateAlloca(int64_type, nullptr, "gv_tconv_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), gv_tconv_i);
                    BasicBlock* gv_tconv_cond = BasicBlock::Create(*context, "gv_tconv_cond", current_func);
                    BasicBlock* gv_tconv_body = BasicBlock::Create(*context, "gv_tconv_body", current_func);
                    BasicBlock* gv_tconv_end = BasicBlock::Create(*context, "gv_tconv_end", current_func);
                    builder->CreateBr(gv_tconv_cond);

                    builder->SetInsertPoint(gv_tconv_cond);
                    Value* gv_tc_idx = builder->CreateLoad(int64_type, gv_tconv_i);
                    builder->CreateCondBr(builder->CreateICmpULT(gv_tc_idx, gv_tensor_n), gv_tconv_body, gv_tconv_end);

                    builder->SetInsertPoint(gv_tconv_body);
                    Value* gv_tc_src = builder->CreateGEP(int64_type, gv_tensor_elems_typed, gv_tc_idx);
                    Value* gv_tc_bits = builder->CreateLoad(int64_type, gv_tc_src);
                    Value* gv_tc_dbl = builder->CreateBitCast(gv_tc_bits, double_type);
                    Value* gv_tc_tagged = packDoubleToTaggedValue(gv_tc_dbl);
                    Value* gv_tc_dst = builder->CreateGEP(tagged_value_type, gv_tconv_elems_typed, gv_tc_idx);
                    builder->CreateStore(gv_tc_tagged, gv_tc_dst);
                    builder->CreateStore(builder->CreateAdd(gv_tc_idx, ConstantInt::get(int64_type, 1)), gv_tconv_i);
                    builder->CreateBr(gv_tconv_cond);

                    builder->SetInsertPoint(gv_tconv_end);
                    builder->CreateBr(gv_grad_compute);
                    BasicBlock* gv_tensor_exit = builder->GetInsertBlock();

                    // Scalar path - create 1-element Scheme vector
                    builder->SetInsertPoint(gv_scalar_path);
                    Value* gv_scalar_val = unpackDoubleFromTaggedValue(point_val);
                    Value* gv_scalar_vec_size = ConstantInt::get(int64_type, 8 + tagged_size);
                    Value* gv_scalar_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, gv_scalar_vec_size});
                    builder->CreateStore(ConstantInt::get(int64_type, 1), gv_scalar_vec);
                    Value* gv_scalar_elem = builder->CreateGEP(int8_type, gv_scalar_vec, ConstantInt::get(int64_type, 8));
                    Value* gv_scalar_elem_typed = builder->CreatePointerCast(gv_scalar_elem, PointerType::getUnqual(tagged_value_type));
                    Value* gv_scalar_tagged = packDoubleToTaggedValue(gv_scalar_val);
                    builder->CreateStore(gv_scalar_tagged, gv_scalar_elem_typed);
                    builder->CreateBr(gv_grad_compute);
                    BasicBlock* gv_scalar_exit = builder->GetInsertBlock();

                    // Merge input paths
                    builder->SetInsertPoint(gv_grad_compute);
                    PHINode* gv_n = builder->CreatePHI(int64_type, 3, "gv_grad_n");
                    gv_n->addIncoming(gv_svec_len, gv_svec_exit);
                    gv_n->addIncoming(gv_tensor_n, gv_tensor_exit);
                    gv_n->addIncoming(ConstantInt::get(int64_type, 1), gv_scalar_exit);

                    PHINode* gv_input_elems = builder->CreatePHI(PointerType::getUnqual(tagged_value_type), 3, "gv_grad_elems");
                    gv_input_elems->addIncoming(gv_svec_elems_typed, gv_svec_exit);
                    gv_input_elems->addIncoming(gv_tconv_elems_typed, gv_tensor_exit);
                    gv_input_elems->addIncoming(gv_scalar_elem_typed, gv_scalar_exit);

                    // Allocate result tensor
                    Value* gv_result_size = ConstantInt::get(int64_type,
                        module->getDataLayout().getTypeAllocSize(tensor_type));
                    Value* gv_result_ptr = builder->CreateCall(malloc_func, {gv_result_size});
                    Value* gv_typed_result = builder->CreatePointerCast(gv_result_ptr, builder->getPtrTy());

                    Value* gv_result_dims_ptr = builder->CreateCall(malloc_func, {ConstantInt::get(int64_type, 8)});
                    Value* gv_typed_result_dims = builder->CreatePointerCast(gv_result_dims_ptr, builder->getPtrTy());
                    builder->CreateStore(gv_n, gv_typed_result_dims);
                    builder->CreateStore(gv_typed_result_dims, builder->CreateStructGEP(tensor_type, gv_typed_result, 0));
                    builder->CreateStore(ConstantInt::get(int64_type, 1), builder->CreateStructGEP(tensor_type, gv_typed_result, 1));
                    builder->CreateStore(gv_n, builder->CreateStructGEP(tensor_type, gv_typed_result, 3));

                    Value* gv_result_elems_size = builder->CreateMul(gv_n, ConstantInt::get(int64_type, sizeof(double)));
                    Value* gv_result_elems_ptr = builder->CreateCall(malloc_func, {gv_result_elems_size});
                    Value* gv_typed_result_elems = builder->CreatePointerCast(gv_result_elems_ptr, builder->getPtrTy());
                    builder->CreateStore(gv_typed_result_elems, builder->CreateStructGEP(tensor_type, gv_typed_result, 2));

                    // Allocate Scheme vector for dual numbers (reused each iteration)
                    Value* gv_dual_vec_size = builder->CreateAdd(
                        builder->CreateMul(gv_n, ConstantInt::get(int64_type, tagged_size)),
                        ConstantInt::get(int64_type, 8));
                    Value* gv_dual_vec = builder->CreateCall(arena_allocate_func, {arena_ptr, gv_dual_vec_size});
                    builder->CreateStore(gv_n, gv_dual_vec);
                    Value* gv_dual_elems = builder->CreateGEP(int8_type, gv_dual_vec, ConstantInt::get(int64_type, 8));
                    Value* gv_dual_elems_typed = builder->CreatePointerCast(gv_dual_elems, PointerType::getUnqual(tagged_value_type));

                    // Outer loop: for each dimension i, compute partial derivative
                    Value* gv_dim_counter = builder->CreateAlloca(int64_type, nullptr, "gv_grad_dim_i");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), gv_dim_counter);

                    BasicBlock* gv_dim_cond = BasicBlock::Create(*context, "gv_grad_dim_cond", current_func);
                    BasicBlock* gv_dim_body = BasicBlock::Create(*context, "gv_grad_dim_body", current_func);
                    BasicBlock* gv_dim_end = BasicBlock::Create(*context, "gv_grad_dim_end", current_func);

                    builder->CreateBr(gv_dim_cond);

                    builder->SetInsertPoint(gv_dim_cond);
                    Value* gv_dim_i = builder->CreateLoad(int64_type, gv_dim_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(gv_dim_i, gv_n), gv_dim_body, gv_dim_end);

                    builder->SetInsertPoint(gv_dim_body);

                    // Inner loop: create dual vector with tangent=1 at dim_i
                    Value* gv_inner_counter = builder->CreateAlloca(int64_type, nullptr, "gv_grad_inner_j");
                    builder->CreateStore(ConstantInt::get(int64_type, 0), gv_inner_counter);

                    BasicBlock* gv_inner_cond = BasicBlock::Create(*context, "gv_grad_inner_cond", current_func);
                    BasicBlock* gv_inner_body = BasicBlock::Create(*context, "gv_grad_inner_body", current_func);
                    BasicBlock* gv_inner_end = BasicBlock::Create(*context, "gv_grad_inner_end", current_func);

                    builder->CreateBr(gv_inner_cond);

                    builder->SetInsertPoint(gv_inner_cond);
                    Value* gv_inner_j = builder->CreateLoad(int64_type, gv_inner_counter);
                    builder->CreateCondBr(builder->CreateICmpULT(gv_inner_j, gv_n), gv_inner_body, gv_inner_end);

                    builder->SetInsertPoint(gv_inner_body);
                    // Load primal value at position j from input elements
                    Value* gv_in_elem_ptr = builder->CreateGEP(tagged_value_type, gv_input_elems, gv_inner_j);
                    Value* gv_in_elem = builder->CreateLoad(tagged_value_type, gv_in_elem_ptr);
                    Value* gv_primal_val = unpackDoubleFromTaggedValue(gv_in_elem);

                    // Set tangent: 1.0 if j == i, else 0.0
                    Value* gv_is_active = builder->CreateICmpEQ(gv_inner_j, gv_dim_i);
                    Value* gv_tangent = builder->CreateSelect(gv_is_active,
                        ConstantFP::get(double_type, 1.0),
                        ConstantFP::get(double_type, 0.0));

                    // Create dual number and store in dual vector
                    Value* gv_dual_num = packDualNumber(gv_primal_val, gv_tangent);
                    Value* gv_dual_tagged = packDualToTaggedValue(gv_dual_num);
                    Value* gv_dual_elem_ptr = builder->CreateGEP(tagged_value_type, gv_dual_elems_typed, gv_inner_j);
                    builder->CreateStore(gv_dual_tagged, gv_dual_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(gv_inner_j, ConstantInt::get(int64_type, 1)), gv_inner_counter);
                    builder->CreateBr(gv_inner_cond);

                    builder->SetInsertPoint(gv_inner_end);

                    // Pack dual vector as Scheme vector (VECTOR_PTR)
                    Value* gv_dual_vec_tagged = packPtrToTaggedValue(
                        builder->CreatePtrToInt(gv_dual_vec, int64_type),
                        ESHKOL_VALUE_VECTOR_PTR);

                    // Call function via closure dispatch (using loaded_func)
                    std::vector<Value*> gv_call_args = {gv_dual_vec_tagged};
                    Value* gv_call_result = codegenClosureCall(loaded_func, gv_call_args);

                    // CONSTANT RESULT FIX: Check if result is a dual number before unpacking
                    Value* gv_result_type = getTaggedValueType(gv_call_result);
                    Value* gv_result_base = builder->CreateAnd(gv_result_type, ConstantInt::get(int8_type, 0x0F));
                    Value* gv_is_dual = builder->CreateICmpEQ(gv_result_base,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));

                    BasicBlock* gv_dual_bb = BasicBlock::Create(*context, "grad_gv_dual", current_func);
                    BasicBlock* gv_const_bb = BasicBlock::Create(*context, "grad_gv_const", current_func);
                    BasicBlock* gv_merge_bb = BasicBlock::Create(*context, "grad_gv_merge", current_func);

                    builder->CreateCondBr(gv_is_dual, gv_dual_bb, gv_const_bb);

                    // Dual path: extract tangent normally
                    builder->SetInsertPoint(gv_dual_bb);
                    Value* gv_result_dual = unpackDualFromTaggedValue(gv_call_result);
                    auto [gv_result_primal, gv_dual_deriv] = unpackDualNumber(gv_result_dual);
                    builder->CreateBr(gv_merge_bb);
                    BasicBlock* gv_dual_exit = builder->GetInsertBlock();

                    // Constant path: derivative is 0.0
                    builder->SetInsertPoint(gv_const_bb);
                    Value* gv_zero_deriv = ConstantFP::get(double_type, 0.0);
                    builder->CreateBr(gv_merge_bb);
                    BasicBlock* gv_const_exit = builder->GetInsertBlock();

                    // Merge paths
                    builder->SetInsertPoint(gv_merge_bb);
                    PHINode* gv_deriv = builder->CreatePHI(double_type, 2, "grad_gv_deriv");
                    gv_deriv->addIncoming(gv_dual_deriv, gv_dual_exit);
                    gv_deriv->addIncoming(gv_zero_deriv, gv_const_exit);

                    // Store derivative in result tensor
                    Value* gv_result_elem_ptr = builder->CreateGEP(int64_type, gv_typed_result_elems, gv_dim_i);
                    Value* gv_deriv_bits = builder->CreateBitCast(gv_deriv, int64_type);
                    builder->CreateStore(gv_deriv_bits, gv_result_elem_ptr);

                    builder->CreateStore(builder->CreateAdd(gv_dim_i, ConstantInt::get(int64_type, 1)), gv_dim_counter);
                    builder->CreateBr(gv_dim_cond);

                    builder->SetInsertPoint(gv_dim_end);
                    Value* gv_result_int = builder->CreatePtrToInt(gv_typed_result, int64_type);
                    return packPtrToTaggedValue(gv_result_int, ESHKOL_VALUE_TENSOR_PTR);
                }
            }
            eshkol_error("Failed to resolve function for gradient computation");
            return nullptr;
        }

        Function* func_ptr = dyn_cast<Function>(func);

        if (!func_ptr) {
            eshkol_error("Gradient operator requires actual function, got non-function value");
            return nullptr;
        }
        
        // Evaluate point to get input vector
        Value* vector_val_raw = codegenAST(op->gradient_op.point);
        if (!vector_val_raw) {
            eshkol_error("Failed to evaluate gradient evaluation point");
            return nullptr;
        }
        
        // CRITICAL FIX: Ensure input is tagged_value (codegenAST can return raw types for literals)
        Value* vector_val;
        if (vector_val_raw->getType() == tagged_value_type) {
            vector_val = vector_val_raw; // Already tagged
        } else if (vector_val_raw->getType()->isIntegerTy(64)) {
            vector_val = packInt64ToTaggedValue(vector_val_raw, true); // Pack int64
        } else if (vector_val_raw->getType()->isDoubleTy()) {
            vector_val = packDoubleToTaggedValue(vector_val_raw); // Pack double
        } else {
            TypedValue tv = detectValueType(vector_val_raw);
            vector_val = typedValueToTaggedValue(tv); // Pack other types
        }
        
        // SCALAR→VECTOR AUTO-PROMOTION: Detect input type BEFORE tensor structure access
        // This prevents segfault when users pass scalars like 3.0 instead of vectors like #(3.0)

        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Extract type from input (may be DOUBLE, INT64, TENSOR_PTR, or AD_NODE_PTR for nested gradients)
        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(int8_type, 0x0F));

        // DOUBLE BACKWARD: Check if input is an AD node (from outer gradient)
        // This happens in nested gradients like (gradient (lambda (y) (gradient f y)) x)
        Value* is_ad_node_input = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));

        // Check if input is scalar (INT64 or DOUBLE)
        Value* is_int64 = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_INT64));
        Value* is_double = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
        Value* is_scalar = builder->CreateOr(is_int64, is_double);

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        // Branch: AD node input (nested), scalar input (promotion), scheme vector (convert), or tensor input (normal)
        BasicBlock* ad_node_input = BasicBlock::Create(*context, "grad_ad_node_input", current_func);
        BasicBlock* scalar_input = BasicBlock::Create(*context, "grad_scalar_input", current_func);
        BasicBlock* scheme_vector_input = BasicBlock::Create(*context, "grad_scheme_vector_input", current_func);
        BasicBlock* vector_input = BasicBlock::Create(*context, "grad_vector_input", current_func);
        BasicBlock* grad_merge_input = BasicBlock::Create(*context, "grad_merge_input", current_func);
        // Create grad_done early so scheme_vector_input path can branch to it
        BasicBlock* grad_done = BasicBlock::Create(*context, "grad_done", current_func);

        // First check if AD node (nested gradient)
        BasicBlock* check_scalar = BasicBlock::Create(*context, "grad_check_scalar", current_func);
        builder->CreateCondBr(is_ad_node_input, ad_node_input, check_scalar);

        // NESTED GRADIENT (AD_NODE_PTR input): Extract value and wrap in tensor for uniform handling
        builder->SetInsertPoint(ad_node_input);
        eshkol_debug("Gradient: detected AD_NODE_PTR input (nested gradient)");

        // Extract the AD node pointer
        Value* outer_ad_node = unpackPtrFromTaggedValue(vector_val);

        // DOUBLE BACKWARD: Store outer AD node in global for later use
        // This allows the backward pass to connect to outer computation graph
        builder->CreateStore(outer_ad_node, outer_ad_node_storage);

        // Extract the VALUE from the AD node (field 1)
        Value* ad_value_ptr = builder->CreateStructGEP(ad_node_type, outer_ad_node, 1);
        Value* ad_value = builder->CreateLoad(double_type, ad_value_ptr);

        // Create a 1D tensor containing this value (so rest of gradient code works uniformly)
        Function* malloc_func_nested = function_table["malloc"];
        Value* nested_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* nested_tensor_ptr = builder->CreateCall(malloc_func_nested, {nested_tensor_size});
        Value* typed_ad_tensor = builder->CreatePointerCast(nested_tensor_ptr, builder->getPtrTy());

        // Set up 1D tensor structure
        Value* nested_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* nested_dims_ptr = builder->CreateCall(malloc_func_nested, {nested_dims_size});
        Value* typed_ad_dims = builder->CreatePointerCast(nested_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(int64_type, 1), typed_ad_dims);

        builder->CreateStore(typed_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 1));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 3));

        Value* nested_elems_size = ConstantInt::get(int64_type, sizeof(int64_t));
        Value* nested_elems_ptr = builder->CreateCall(malloc_func_nested, {nested_elems_size});
        Value* typed_nested_elems = builder->CreatePointerCast(nested_elems_ptr, builder->getPtrTy());
        Value* nested_value_as_int64 = builder->CreateBitCast(ad_value, int64_type);
        builder->CreateStore(nested_value_as_int64, typed_nested_elems);
        builder->CreateStore(typed_nested_elems,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor, 2));

        Value* nested_tensor_int = builder->CreatePtrToInt(typed_ad_tensor, int64_type);
        Value* ad_promoted_tagged = packPtrToTaggedValue(nested_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_merge_input);
        BasicBlock* ad_node_exit = builder->GetInsertBlock();

        // Check for scalar
        builder->SetInsertPoint(check_scalar);

        // DOUBLE BACKWARD: Clear outer AD node storage for non-nested case
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)),
            outer_ad_node_storage);

        // Check: scalar → scalar_input, scheme_vector → scheme_vector_input, else → vector_input (tensor)
        BasicBlock* check_scheme_vector = BasicBlock::Create(*context, "grad_check_scheme_vec", current_func);
        builder->CreateCondBr(is_scalar, scalar_input, check_scheme_vector);

        builder->SetInsertPoint(check_scheme_vector);
        builder->CreateCondBr(is_scheme_vector, scheme_vector_input, vector_input);

        // SCALAR INPUT: Auto-promote scalar to 1D tensor #(scalar_value)
        builder->SetInsertPoint(scalar_input);
        eshkol_debug("Gradient: auto-promoting scalar input to 1D vector");
        
        // Extract scalar value (INT64 or DOUBLE)
        Value* scalar_val_int = unpackInt64FromTaggedValue(vector_val);
        
        // Convert to double if needed
        Value* scalar_double = builder->CreateSelect(is_double,
            builder->CreateBitCast(scalar_val_int, double_type),
            builder->CreateSIToFP(scalar_val_int, double_type));
        
        // Get malloc for tensor creation
        Function* malloc_func_scalar = function_table["malloc"];
        
        // Allocate 1D tensor structure for promoted scalar
        Value* promoted_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* promoted_tensor_ptr = builder->CreateCall(malloc_func_scalar, {promoted_tensor_size});
        Value* typed_promoted_tensor = builder->CreatePointerCast(promoted_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions: [1] (1D tensor with single element)
        Value* promoted_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* promoted_dims_ptr = builder->CreateCall(malloc_func_scalar, {promoted_dims_size});
        Value* typed_promoted_dims = builder->CreatePointerCast(promoted_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(int64_type, 1), typed_promoted_dims);
        
        // Set tensor metadata
        builder->CreateStore(typed_promoted_dims,
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 0));  // dimensions = [1]
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 1));  // num_dimensions = 1
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 3));  // total_elements = 1
        
        // Allocate and set elements: [scalar_value]
        Value* promoted_elems_size = ConstantInt::get(int64_type, sizeof(int64_t));
        Value* promoted_elems_ptr = builder->CreateCall(malloc_func_scalar, {promoted_elems_size});
        Value* typed_promoted_elems = builder->CreatePointerCast(promoted_elems_ptr, builder->getPtrTy());
        
        // Store scalar as bitcast int64 (preserves IEEE754 bits for doubles)
        Value* scalar_as_int64 = builder->CreateBitCast(scalar_double, int64_type);
        builder->CreateStore(scalar_as_int64, typed_promoted_elems);
        
        builder->CreateStore(typed_promoted_elems,
            builder->CreateStructGEP(tensor_type, typed_promoted_tensor, 2));  // elements
        
        // Pack promoted tensor as tagged_value with TENSOR_PTR type
        Value* promoted_tensor_int = builder->CreatePtrToInt(typed_promoted_tensor, int64_type);
        Value* promoted_vector_tagged = packPtrToTaggedValue(promoted_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        builder->CreateBr(grad_merge_input);
        BasicBlock* scalar_input_exit = builder->GetInsertBlock();
        
        // SCHEME VECTOR INPUT: Use forward-mode AD with dual numbers (preserves Scheme vector format)
        // This allows functions that use vector-ref to work correctly with gradient
        builder->SetInsertPoint(scheme_vector_input);
        eshkol_debug("Gradient: using forward-mode AD for Scheme vector input");

        // Get Scheme vector pointer and length
        Value* svec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* svec_ptr = builder->CreateIntToPtr(svec_ptr_int, builder->getPtrTy());
        Value* svec_n = builder->CreateLoad(int64_type, svec_ptr);
        Value* svec_elems_base = builder->CreateGEP(int8_type, svec_ptr, ConstantInt::get(int64_type, 8));
        Value* svec_elems = builder->CreatePointerCast(svec_elems_base, PointerType::getUnqual(tagged_value_type));

        // Allocate result tensor for gradient
        Function* malloc_svec = function_table["malloc"];
        Value* svec_result_tensor_size = ConstantInt::get(int64_type, module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* svec_result_tensor = builder->CreateCall(malloc_svec, {svec_result_tensor_size});
        Value* svec_typed_result = builder->CreatePointerCast(svec_result_tensor, builder->getPtrTy());

        // Set result tensor dimensions
        Value* svec_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* svec_dims_ptr = builder->CreateCall(malloc_svec, {svec_dims_size});
        Value* svec_typed_dims = builder->CreatePointerCast(svec_dims_ptr, builder->getPtrTy());
        builder->CreateStore(svec_n, svec_typed_dims);
        builder->CreateStore(svec_typed_dims, builder->CreateStructGEP(tensor_type, svec_typed_result, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1), builder->CreateStructGEP(tensor_type, svec_typed_result, 1));
        builder->CreateStore(svec_n, builder->CreateStructGEP(tensor_type, svec_typed_result, 3));

        // Allocate result elements
        Value* svec_result_elems_size = builder->CreateMul(svec_n, ConstantInt::get(int64_type, sizeof(int64_t)));
        Value* svec_result_elems = builder->CreateCall(malloc_svec, {svec_result_elems_size});
        Value* svec_typed_result_elems = builder->CreatePointerCast(svec_result_elems, builder->getPtrTy());
        builder->CreateStore(svec_typed_result_elems, builder->CreateStructGEP(tensor_type, svec_typed_result, 2));

        // Get arena for dual vector allocation
        Function* arena_alloc_svec = function_table["arena_allocate"];
        Value* arena_svec = builder->CreateLoad(PointerType::getUnqual(*context), global_arena);
        uint64_t tagged_size_svec = module->getDataLayout().getTypeAllocSize(tagged_value_type);

        // Outer loop: for each dimension i, compute ∂f/∂xᵢ using forward-mode AD
        Value* svec_dim_i = builder->CreateAlloca(int64_type, nullptr, "svec_dim_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), svec_dim_i);

        BasicBlock* svec_dim_cond = BasicBlock::Create(*context, "svec_dim_cond", current_func);
        BasicBlock* svec_dim_body = BasicBlock::Create(*context, "svec_dim_body", current_func);
        BasicBlock* svec_dim_end = BasicBlock::Create(*context, "svec_dim_end", current_func);

        builder->CreateBr(svec_dim_cond);

        builder->SetInsertPoint(svec_dim_cond);
        Value* svec_i = builder->CreateLoad(int64_type, svec_dim_i);
        builder->CreateCondBr(builder->CreateICmpULT(svec_i, svec_n), svec_dim_body, svec_dim_end);

        builder->SetInsertPoint(svec_dim_body);

        // Allocate dual vector (Scheme vector of dual numbers)
        Value* svec_dual_size = builder->CreateAdd(ConstantInt::get(int64_type, 8),
            builder->CreateMul(svec_n, ConstantInt::get(int64_type, tagged_size_svec)));
        Value* svec_dual_vec = builder->CreateCall(arena_alloc_svec, {arena_svec, svec_dual_size});
        builder->CreateStore(svec_n, svec_dual_vec);
        Value* svec_dual_elems = builder->CreateGEP(int8_type, svec_dual_vec, ConstantInt::get(int64_type, 8));
        Value* svec_dual_elems_typed = builder->CreatePointerCast(svec_dual_elems, PointerType::getUnqual(tagged_value_type));

        // Inner loop: create dual vector with tangent=1 at position i, 0 elsewhere
        Value* svec_inner_j = builder->CreateAlloca(int64_type, nullptr, "svec_inner_j");
        builder->CreateStore(ConstantInt::get(int64_type, 0), svec_inner_j);

        BasicBlock* svec_inner_cond = BasicBlock::Create(*context, "svec_inner_cond", current_func);
        BasicBlock* svec_inner_body = BasicBlock::Create(*context, "svec_inner_body", current_func);
        BasicBlock* svec_inner_end = BasicBlock::Create(*context, "svec_inner_end", current_func);

        builder->CreateBr(svec_inner_cond);

        builder->SetInsertPoint(svec_inner_cond);
        Value* svec_j = builder->CreateLoad(int64_type, svec_inner_j);
        builder->CreateCondBr(builder->CreateICmpULT(svec_j, svec_n), svec_inner_body, svec_inner_end);

        builder->SetInsertPoint(svec_inner_body);
        // Load primal value from input
        Value* svec_in_ptr = builder->CreateGEP(tagged_value_type, svec_elems, svec_j);
        Value* svec_in_val = builder->CreateLoad(tagged_value_type, svec_in_ptr);
        Value* svec_primal = unpackDoubleFromTaggedValue(svec_in_val);
        // Tangent: 1.0 if j == i, else 0.0
        Value* svec_is_active = builder->CreateICmpEQ(svec_j, svec_i);
        Value* svec_tangent = builder->CreateSelect(svec_is_active,
            ConstantFP::get(double_type, 1.0), ConstantFP::get(double_type, 0.0));
        // Create dual number and store
        Value* svec_dual = packDualNumber(svec_primal, svec_tangent);
        Value* svec_dual_tagged = packDualToTaggedValue(svec_dual);
        Value* svec_dual_ptr = builder->CreateGEP(tagged_value_type, svec_dual_elems_typed, svec_j);
        builder->CreateStore(svec_dual_tagged, svec_dual_ptr);
        builder->CreateStore(builder->CreateAdd(svec_j, ConstantInt::get(int64_type, 1)), svec_inner_j);
        builder->CreateBr(svec_inner_cond);

        builder->SetInsertPoint(svec_inner_end);

        // Pack dual vector as Scheme vector
        Value* svec_dual_tagged_vec = packPtrToTaggedValue(
            builder->CreatePtrToInt(svec_dual_vec, int64_type), ESHKOL_VALUE_VECTOR_PTR);

        // Call function with dual vector
        std::vector<Value*> svec_call_args = {svec_dual_tagged_vec};
        // Add captures if function has them
        if (func_ptr->getFunctionType()->getNumParams() > 1) {
            size_t svec_num_captures = func_ptr->getFunctionType()->getNumParams() - 1;
            std::string svec_lambda_name = func_ptr->getName().str();
            for (size_t ci = 0; ci < svec_num_captures; ci++) {
                auto arg_it = func_ptr->arg_begin();
                std::advance(arg_it, ci + 1);
                std::string var_name = arg_it->getName().str();
                if (var_name.find("captured_") == 0) var_name = var_name.substr(9);
                std::string cap_key = svec_lambda_name + "_capture_" + var_name;

                // Try capture key in global and local symbol tables
                auto cap_it = global_symbol_table.find(cap_key);
                bool found = (cap_it != global_symbol_table.end() && cap_it->second);
                if (!found) {
                    cap_it = symbol_table.find(cap_key);
                    found = (cap_it != symbol_table.end() && cap_it->second);
                }

                if (found) {
                    svec_call_args.push_back(cap_it->second);
                } else {
                    // FALLBACK: Try raw variable name (for top-level global variables and let bindings)
                    Value* storage = nullptr;
                    auto raw_it = global_symbol_table.find(var_name);
                    if (raw_it != global_symbol_table.end() && raw_it->second) {
                        storage = raw_it->second;
                    } else {
                        // Also check local symbol table
                        auto local_it = symbol_table.find(var_name);
                        if (local_it != symbol_table.end() && local_it->second) {
                            storage = local_it->second;
                        }
                    }

                    if (storage) {
                        // MUTABLE CAPTURE FIX: For let-bound allocas or arena pointers, pack the address
                        // as int64 in a tagged_value, store in temp, pass pointer to temp
                        // CLOSURE ESCAPE FIX: Also handle arena pointers (from escaped closure captures)
                        bool needs_ptr_packing = isa<AllocaInst>(storage) ||
                            (storage->getType()->isPointerTy() && !isa<GlobalVariable>(storage) && !isa<Argument>(storage));

                        if (needs_ptr_packing) {
                            Function* svec_current_func = builder->GetInsertBlock()->getParent();
                            IRBuilder<> entry_builder(&svec_current_func->getEntryBlock(),
                                                      svec_current_func->getEntryBlock().begin());
                            AllocaInst* temp_alloca = entry_builder.CreateAlloca(
                                tagged_value_type, nullptr, var_name + "_svec_capture_storage");

                            // Pack the storage address as an int64 in a tagged_value
                            Value* ptr_as_int = builder->CreatePtrToInt(storage, int64_type);
                            Value* packed_ptr = packInt64ToTaggedValue(ptr_as_int, true);
                            builder->CreateStore(packed_ptr, temp_alloca);

                            svec_call_args.push_back(temp_alloca);
                        } else {
                            // GlobalVariable or other - pass directly
                            svec_call_args.push_back(storage);
                        }
                    } else {
                        svec_call_args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                        eshkol_warn("Gradient (svec): capture '%s' not found", var_name.c_str());
                    }
                }
            }
        }
        Value* svec_call_result = builder->CreateCall(func_ptr, svec_call_args);

        // CONSTANT RESULT FIX: Check if result is a dual number before unpacking
        Value* svec_result_type = getTaggedValueType(svec_call_result);
        Value* svec_result_base = builder->CreateAnd(svec_result_type, ConstantInt::get(int8_type, 0x0F));
        Value* svec_is_dual = builder->CreateICmpEQ(svec_result_base,
            ConstantInt::get(int8_type, ESHKOL_VALUE_DUAL_NUMBER));

        BasicBlock* svec_dual_bb = BasicBlock::Create(*context, "grad_svec_dual", current_func);
        BasicBlock* svec_const_bb = BasicBlock::Create(*context, "grad_svec_const", current_func);
        BasicBlock* svec_merge_bb = BasicBlock::Create(*context, "grad_svec_merge", current_func);

        builder->CreateCondBr(svec_is_dual, svec_dual_bb, svec_const_bb);

        // Dual path: extract tangent normally
        builder->SetInsertPoint(svec_dual_bb);
        Value* svec_result_dual = unpackDualFromTaggedValue(svec_call_result);
        auto [svec_result_primal, svec_dual_deriv] = unpackDualNumber(svec_result_dual);
        builder->CreateBr(svec_merge_bb);
        BasicBlock* svec_dual_exit = builder->GetInsertBlock();

        // Constant path: derivative is 0.0
        builder->SetInsertPoint(svec_const_bb);
        Value* svec_zero_deriv = ConstantFP::get(double_type, 0.0);
        builder->CreateBr(svec_merge_bb);
        BasicBlock* svec_const_exit = builder->GetInsertBlock();

        // Merge paths
        builder->SetInsertPoint(svec_merge_bb);
        PHINode* svec_deriv = builder->CreatePHI(double_type, 2, "grad_svec_deriv");
        svec_deriv->addIncoming(svec_dual_deriv, svec_dual_exit);
        svec_deriv->addIncoming(svec_zero_deriv, svec_const_exit);

        // Store derivative in result tensor
        Value* svec_result_ptr = builder->CreateGEP(int64_type, svec_typed_result_elems, svec_i);
        Value* svec_deriv_bits = builder->CreateBitCast(svec_deriv, int64_type);
        builder->CreateStore(svec_deriv_bits, svec_result_ptr);

        builder->CreateStore(builder->CreateAdd(svec_i, ConstantInt::get(int64_type, 1)), svec_dim_i);
        builder->CreateBr(svec_dim_cond);

        builder->SetInsertPoint(svec_dim_end);
        // Return result tensor
        Value* svec_result_int = builder->CreatePtrToInt(svec_typed_result, int64_type);
        Value* scheme_vector_tagged = packPtrToTaggedValue(svec_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_done);  // Skip reverse-mode AD, go directly to done
        BasicBlock* scheme_vector_exit = builder->GetInsertBlock();

        // VECTOR INPUT: Use original vector as-is (existing behavior - tensor format)
        builder->SetInsertPoint(vector_input);
        builder->CreateBr(grad_merge_input);
        BasicBlock* vector_input_exit = builder->GetInsertBlock();

        // MERGE: PHI node selects AD node promoted, scalar promoted, or original tensor
        // NOTE: Scheme vector path now uses forward-mode AD and branches directly to grad_done
        builder->SetInsertPoint(grad_merge_input);
        PHINode* actual_input = builder->CreatePHI(tagged_value_type, 3, "gradient_input");
        actual_input->addIncoming(ad_promoted_tagged, ad_node_exit);  // Nested gradient path
        actual_input->addIncoming(promoted_vector_tagged, scalar_input_exit);
        actual_input->addIncoming(vector_val, vector_input_exit);
        
        // Continue with gradient computation using merged input (guaranteed to be tensor!)
        Value* vector_ptr_int = safeExtractInt64(actual_input);

        // Get malloc for tensor allocations
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found for gradient computation");
            return nullptr;
        }
        // Use class member tensor_type (shared by all tensor operations)


        // Convert int64 pointer to typed tensor pointer
        Value* vector_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());

        // Extract ALL tensor properties (MUST access all fields correctly)
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, vector_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());

        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, vector_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Load dimension n from tensor (RUNTIME value, NOT hardcoded)
        Value* dim0_ptr = builder->CreateGEP(int64_type, typed_dims_ptr,
            ConstantInt::get(int64_type, 0));

        Value* n = builder->CreateLoad(int64_type, dim0_ptr);
        
        // VALIDATION: Check dimension > 0 (scalars already promoted to tensors, so type check not needed)
        Value* n_is_positive = builder->CreateICmpUGT(n, ConstantInt::get(int64_type, 0));
        
        BasicBlock* dim_valid = BasicBlock::Create(*context, "grad_dim_valid", current_func);
        BasicBlock* dim_invalid = BasicBlock::Create(*context, "grad_dim_invalid", current_func);
        // grad_done already created earlier for scheme_vector_input forward-mode path

        // CRITICAL FIX: Create empty tensor BEFORE branching (for PHI node dominance)
        // This ensures null_tagged_grad is available in all paths
        Value* empty_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* empty_tensor_ptr = builder->CreateCall(malloc_func, {empty_tensor_size});
        Value* typed_empty_tensor = builder->CreatePointerCast(empty_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions array (size 1, value 0)
        Value* empty_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* empty_dims_ptr = builder->CreateCall(malloc_func, {empty_dims_size});
        Value* typed_empty_dims = builder->CreatePointerCast(empty_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(int64_type, 0), typed_empty_dims);
        
        builder->CreateStore(typed_empty_dims,
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 1));
        builder->CreateStore(ConstantInt::get(int64_type, 0),
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 3));
        
        // Empty elements array
        Value* empty_elems_size = ConstantInt::get(int64_type, sizeof(double));
        Value* empty_elems_ptr = builder->CreateCall(malloc_func, {empty_elems_size});
        Value* typed_empty_elems = builder->CreatePointerCast(empty_elems_ptr, builder->getPtrTy());
        builder->CreateStore(typed_empty_elems,
            builder->CreateStructGEP(tensor_type, typed_empty_tensor, 2));
        
        // Pack as tagged_value (TENSOR_PTR type) - available in all paths
        Value* empty_tensor_int = builder->CreatePtrToInt(typed_empty_tensor, int64_type);
        Value* null_tagged_grad = packPtrToTaggedValue(empty_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        builder->CreateCondBr(n_is_positive, dim_valid, dim_invalid);
        
        // Invalid input: return empty tensor
        builder->SetInsertPoint(dim_invalid);
        eshkol_debug("Gradient: invalid input tensor (dimension must be > 0)");
        builder->CreateBr(grad_done);
        
        // Valid dimension: compute gradient
        builder->SetInsertPoint(dim_valid);
        
        // Allocate result gradient vector (SAME structure as input vector)
        Value* result_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor_ptr = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Set result tensor dimension (1D vector of size n)
        Value* result_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims_ptr = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_result_dims_ptr);
        
        // Store dimension in result tensor
        Value* result_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 0);
        builder->CreateStore(typed_result_dims_ptr, result_dims_field_ptr);
        
        // Store num_dimensions = 1
        Value* result_num_dims_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 1), result_num_dims_field_ptr);
        
        // Store total_elements = n
        Value* result_total_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 3);
        builder->CreateStore(n, result_total_field_ptr);
        
        // Allocate result elements array (n doubles for partial derivatives)
        Value* result_elements_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* result_elements_ptr = builder->CreateCall(malloc_func, {result_elements_size});
        Value* typed_result_elements_ptr = builder->CreatePointerCast(result_elements_ptr, builder->getPtrTy());
        
        // Store elements pointer in result tensor
        Value* result_elements_field_ptr = builder->CreateStructGEP(tensor_type, typed_result_tensor_ptr, 2);
        builder->CreateStore(typed_result_elements_ptr, result_elements_field_ptr);
        
        // ===== MAIN GRADIENT COMPUTATION LOOP =====
        // For each component i from 0 to n-1, compute ∂f/∂xᵢ
        
        BasicBlock* grad_loop_cond = BasicBlock::Create(*context, "grad_loop_cond", current_func);
        BasicBlock* grad_loop_body = BasicBlock::Create(*context, "grad_loop_body", current_func);
        BasicBlock* grad_loop_exit = BasicBlock::Create(*context, "grad_loop_exit", current_func);
        
        // Allocate loop counter
        Value* component_idx = builder->CreateAlloca(int64_type, nullptr, "component_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), component_idx);
        
        builder->CreateBr(grad_loop_cond);
        
        // Loop condition: i < n
        builder->SetInsertPoint(grad_loop_cond);
        Value* i = builder->CreateLoad(int64_type, component_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, grad_loop_body, grad_loop_exit);
        
        // Loop body: Compute ∂f/∂xᵢ using reverse-mode AD
        builder->SetInsertPoint(grad_loop_body);
        
        // Step 1: Create tape for this partial derivative
        Value* arena_ptr = getArenaPtr();
        Value* tape_capacity = ConstantInt::get(int64_type, 1024);
        Value* partial_tape = builder->CreateCall(getArenaAllocateTapeFunc(),
            {arena_ptr, tape_capacity});
        
        // Store tape as current (required by recordADNode* functions)
        Value* saved_tape = current_tape_ptr;
        current_tape_ptr = partial_tape;
        
        // Step 2: Create n AD variable nodes (one per vector component)
        // Allocate array to hold variable node pointers
        Value* var_nodes_array_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(void*)));
        Value* var_nodes_array = builder->CreateCall(malloc_func, {var_nodes_array_size});
        Value* typed_var_nodes = builder->CreatePointerCast(var_nodes_array, builder->getPtrTy());
        
        // Loop to create and initialize variable nodes
        BasicBlock* init_vars_cond = BasicBlock::Create(*context, "init_vars_cond", current_func);
        BasicBlock* init_vars_body = BasicBlock::Create(*context, "init_vars_body", current_func);
        BasicBlock* init_vars_exit = BasicBlock::Create(*context, "init_vars_exit", current_func);
        
        Value* init_idx = builder->CreateAlloca(int64_type, nullptr, "init_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), init_idx);
        builder->CreateBr(init_vars_cond);
        
        builder->SetInsertPoint(init_vars_cond);
        Value* j = builder->CreateLoad(int64_type, init_idx);
        Value* j_less_n = builder->CreateICmpULT(j, n);
        builder->CreateCondBr(j_less_n, init_vars_body, init_vars_exit);
        
        builder->SetInsertPoint(init_vars_body);

        // CRITICAL FIX: Tensor elements are stored as int64, load as int64 then convert to double
        Value* elem_ptr = builder->CreateGEP(int64_type,
            typed_elements_ptr, j);
        Value* elem_val_int64 = builder->CreateLoad(int64_type, elem_ptr);

        // NESTED GRADIENT FIX: Check if element might be an AD node pointer (from outer gradient)
        // Don't check tape depth - the element itself tells us if it's an AD node
        // When a gradient's input contains an AD node, we detect it and set up double backward
        BasicBlock* check_ad_ptr = BasicBlock::Create(*context, "check_ad_ptr", current_func);
        BasicBlock* is_regular_double = BasicBlock::Create(*context, "is_regular_double", current_func);
        BasicBlock* merge_elem = BasicBlock::Create(*context, "merge_elem", current_func);

        // Check if the value could be a pointer (in valid heap address range)
        // On 64-bit systems:
        // - Heap pointers are typically 0x100000000 to 0x00007FFFFFFFFFFF (small as int64)
        // - Normal doubles like 2.0 = 0x4000000000000000, 12.0 = 0x4028... (LARGE as int64)
        // So a potential pointer is: non-zero AND less than typical double values
        // Use threshold 0x0001000000000000 (~281 trillion) - catches all user space addresses
        // but excludes normal positive doubles (which are >= 0x3FF0000000000000 for >= 1.0)
        Value* not_zero = builder->CreateICmpNE(elem_val_int64,
            ConstantInt::get(int64_type, 0));
        Value* in_ptr_range = builder->CreateICmpULT(elem_val_int64,
            ConstantInt::get(int64_type, 0x0001000000000000ULL));
        Value* could_be_ptr = builder->CreateAnd(not_zero, in_ptr_range);
        builder->CreateCondBr(could_be_ptr, check_ad_ptr, is_regular_double);

        // CHECK AD POINTER: Try to validate it's actually an AD node
        builder->SetInsertPoint(check_ad_ptr);
        Value* ad_ptr_candidate = builder->CreateIntToPtr(elem_val_int64, PointerType::getUnqual(*context));
        // Check if pointer is non-null and has valid AD node type
        Value* ptr_not_null = builder->CreateICmpNE(elem_val_int64,
            ConstantInt::get(int64_type, 0));

        BasicBlock* check_ad_type = BasicBlock::Create(*context, "check_ad_type", current_func);
        BasicBlock* not_ad_node = BasicBlock::Create(*context, "not_ad_node", current_func);
        builder->CreateCondBr(ptr_not_null, check_ad_type, not_ad_node);

        // Check AD node type field
        builder->SetInsertPoint(check_ad_type);
        Value* type_field_ptr = builder->CreateStructGEP(ad_node_type, ad_ptr_candidate, 0);
        Value* type_field = builder->CreateLoad(int32_type, type_field_ptr);
        // Valid AD node types are 0-7 (CONSTANT, PTR, ADD, SUB, MUL, DIV, SIN, COS)
        // Also check that it's exactly type 1 (AD_NODE_PTR) since that's what variables are
        Value* is_ad_var = builder->CreateICmpEQ(type_field, ConstantInt::get(int32_type, 1));

        BasicBlock* use_existing_ad = BasicBlock::Create(*context, "use_existing_ad", current_func);
        builder->CreateCondBr(is_ad_var, use_existing_ad, not_ad_node);

        // USE EXISTING AD NODE: This element is an AD node from outer gradient
        // CRITICAL FIX: Do NOT reuse the outer AD node directly!
        // The inner backward would write to its gradient field, contaminating it.
        // Instead, create a new AD variable with the same value and record the outer node.
        builder->SetInsertPoint(use_existing_ad);
        Value* detected_outer_node = ad_ptr_candidate;
        // Store outer AD node for double backward connection
        builder->CreateStore(detected_outer_node, outer_ad_node_storage);
        // Extract the VALUE from outer AD node and create NEW variable for inner gradient
        Value* detected_outer_val_ptr = builder->CreateStructGEP(ad_node_type, detected_outer_node, 1);
        Value* detected_outer_val = builder->CreateLoad(double_type, detected_outer_val_ptr);
        Value* new_inner_var = createADVariable(detected_outer_val, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* use_ad_exit = builder->GetInsertBlock();

        // NOT AN AD NODE: Treat as double
        builder->SetInsertPoint(not_ad_node);
        Value* elem_as_double2 = builder->CreateBitCast(elem_val_int64, double_type);
        Value* new_var_node2 = createADVariable(elem_as_double2, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* not_ad_exit = builder->GetInsertBlock();

        // REGULAR DOUBLE: Normal case - just treat as double
        builder->SetInsertPoint(is_regular_double);
        Value* elem_val = builder->CreateBitCast(elem_val_int64, double_type);
        Value* new_var_node = createADVariable(elem_val, 0);
        builder->CreateBr(merge_elem);
        BasicBlock* regular_double_exit = builder->GetInsertBlock();

        // MERGE: PHI to select the right AD node
        builder->SetInsertPoint(merge_elem);
        PHINode* var_node = builder->CreatePHI(PointerType::getUnqual(*context), 3, "var_node_phi");
        var_node->addIncoming(new_inner_var, use_ad_exit);
        var_node->addIncoming(new_var_node2, not_ad_exit);
        var_node->addIncoming(new_var_node, regular_double_exit);
        
        // Store node pointer in array
        Value* node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, j);
        builder->CreateStore(var_node, node_slot);
        
        // Increment init counter
        Value* next_j = builder->CreateAdd(j, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_j, init_idx);
        builder->CreateBr(init_vars_cond);
        
        builder->SetInsertPoint(init_vars_exit);
        
        // Step 3: Get active variable node (the one we're computing gradient for)
        Value* active_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, i);
        Value* active_var_node = builder->CreateLoad(PointerType::getUnqual(*context),
            active_node_slot);
        
        // Step 4: Call function with variable nodes to build computational graph
        // CRITICAL: Function must operate on AD nodes, not raw doubles
        // This requires the function to use recordADNode* operations
        
        // Build tensor of AD node pointers to pass to function
        Value* ad_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* ad_tensor_ptr = builder->CreateCall(malloc_func, {ad_tensor_size});
        Value* typed_ad_tensor_ptr = builder->CreatePointerCast(ad_tensor_ptr, builder->getPtrTy());
        
        // Set AD tensor dimensions (same as input)
        builder->CreateStore(typed_result_dims_ptr,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 3));
        
        // Allocate and fill AD tensor elements with node pointers
        Value* ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* ad_elems_ptr = builder->CreateCall(malloc_func, {ad_elems_size});
        Value* typed_ad_elems_ptr = builder->CreatePointerCast(ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_ad_elems_ptr,
            builder->CreateStructGEP(tensor_type, typed_ad_tensor_ptr, 2));
        
        // Copy node pointers into AD tensor
        BasicBlock* copy_nodes_cond = BasicBlock::Create(*context, "copy_nodes_cond", current_func);
        BasicBlock* copy_nodes_body = BasicBlock::Create(*context, "copy_nodes_body", current_func);
        BasicBlock* copy_nodes_exit = BasicBlock::Create(*context, "copy_nodes_exit", current_func);
        
        Value* copy_idx = builder->CreateAlloca(int64_type, nullptr, "copy_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), copy_idx);
        builder->CreateBr(copy_nodes_cond);
        
        builder->SetInsertPoint(copy_nodes_cond);
        Value* k = builder->CreateLoad(int64_type, copy_idx);
        Value* k_less_n = builder->CreateICmpULT(k, n);
        builder->CreateCondBr(k_less_n, copy_nodes_body, copy_nodes_exit);
        
        builder->SetInsertPoint(copy_nodes_body);
        Value* src_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, k);
        Value* src_node_ptr = builder->CreateLoad(PointerType::getUnqual(*context), src_node_slot);
        Value* node_as_int64 = builder->CreatePtrToInt(src_node_ptr, int64_type);
        
        Value* dst_elem_slot = builder->CreateGEP(int64_type,
            typed_ad_elems_ptr, k);
        builder->CreateStore(node_as_int64, dst_elem_slot);
        
        Value* next_k = builder->CreateAdd(k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_k, copy_idx);
        builder->CreateBr(copy_nodes_cond);
        
        builder->SetInsertPoint(copy_nodes_exit);
        
        // Step 5: Call function with AD node (scalar) or tensor (vector)
        // SCALAR FUNCTION FIX: For n=1, extract the single AD node and pass it directly!
        // This allows scalar functions like (lambda (x) (* x x)) to work


        Value* n_is_one = builder->CreateICmpEQ(n, ConstantInt::get(int64_type, 1));
        
        BasicBlock* scalar_call = BasicBlock::Create(*context, "grad_scalar_call", current_func);
        BasicBlock* vector_call = BasicBlock::Create(*context, "grad_vector_call", current_func);
        BasicBlock* after_func_call = BasicBlock::Create(*context, "grad_after_func_call", current_func);
        
        builder->CreateCondBr(n_is_one, scalar_call, vector_call);
        
        // SCALAR: Extract single AD node and pass directly
        builder->SetInsertPoint(scalar_call);
        Value* single_ad_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_var_nodes, ConstantInt::get(int64_type, 0));
        Value* single_ad_node = builder->CreateLoad(PointerType::getUnqual(*context), single_ad_node_slot);
        Value* scalar_ad_tagged = packPtrToTaggedValue(single_ad_node, ESHKOL_VALUE_AD_NODE_PTR);

        std::vector<Value*> scalar_args = {scalar_ad_tagged};

        // CRITICAL FIX: Add captured arguments for scalar path too!
        FunctionType* scalar_func_type = func_ptr->getFunctionType();
        if (scalar_func_type->getNumParams() > 1) {
            size_t scalar_num_captures = scalar_func_type->getNumParams() - 1;
            std::string scalar_lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(scalar_lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t ci = 0; ci < scalar_num_captures; ci++) {
                std::string scalar_var_name;
                if (ci < capture_names.size()) {
                    scalar_var_name = capture_names[ci];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto scalar_arg_it = func_ptr->arg_begin();
                    std::advance(scalar_arg_it, ci + 1);  // Skip first parameter
                    if (scalar_arg_it != func_ptr->arg_end()) {
                        scalar_var_name = scalar_arg_it->getName().str();
                        if (scalar_var_name.find("captured_") == 0) {
                            scalar_var_name = scalar_var_name.substr(9);
                        }
                    }
                }

                std::string scalar_capture_key = scalar_lambda_name + "_capture_" + scalar_var_name;

                // First try capture-specific key in symbol tables
                auto scalar_it = global_symbol_table.find(scalar_capture_key);
                bool found_in_global = (scalar_it != global_symbol_table.end());
                if (!found_in_global) {
                    scalar_it = symbol_table.find(scalar_capture_key);
                }

                bool found = found_in_global ? (scalar_it != global_symbol_table.end()) : (scalar_it != symbol_table.end());

                // FALLBACK: Try raw variable name (for top-level global variables)
                if (!found) {
                    scalar_it = global_symbol_table.find(scalar_var_name);
                    found_in_global = (scalar_it != global_symbol_table.end());
                    if (!found_in_global) {
                        scalar_it = symbol_table.find(scalar_var_name);
                    }
                    found = found_in_global ? (scalar_it != global_symbol_table.end()) : (scalar_it != symbol_table.end());
                    if (found) {
                        eshkol_debug("Gradient (scalar): found capture '%s' via raw variable name", scalar_var_name.c_str());
                    }
                }

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(scalar_capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(scalar_capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                scalar_capture_key
                            );
                        }
                        // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                        scalar_args.push_back(capture_global);
                        continue;
                    }
                }

                if (found && scalar_it->second) {
                    Value* scalar_storage = scalar_it->second;
                    // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                    scalar_args.push_back(scalar_storage);
                } else {
                    // MUTABLE CAPTURE FIX: Push null pointer instead of packed zero
                    scalar_args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                    eshkol_warn("Gradient (scalar): capture '%s' not found, using null pointer", scalar_var_name.c_str());
                }
            }
        }

        // NESTED GRADIENT FIX: Save outer_ad_node_storage before calling function
        // Nested gradients will overwrite it, so we save and restore to support n-dimensional derivatives
        Value* saved_outer_ad_node_scalar = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);

        // NESTED GRADIENT FIX: Push tape context (saves outer gradient's tape if any)
        pushTapeContext(partial_tape);

        Value* scalar_output = builder->CreateCall(func_ptr, scalar_args);

        // NESTED GRADIENT FIX: Pop tape context (restores outer gradient's tape if any)
        popTapeContext();

        // NESTED GRADIENT FIX: Restore outer_ad_node_storage after function returns
        builder->CreateStore(saved_outer_ad_node_scalar, outer_ad_node_storage);

        builder->CreateBr(after_func_call);
        BasicBlock* scalar_call_exit = builder->GetInsertBlock();
        
        // VECTOR: Pass AD tensor as usual
        builder->SetInsertPoint(vector_call);
        Value* ad_tensor_int = builder->CreatePtrToInt(typed_ad_tensor_ptr, int64_type);
        Value* ad_tensor_tagged = packPtrToTaggedValue(ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        std::vector<Value*> grad_call_args = {ad_tensor_tagged};
        
        FunctionType* grad_func_type = func_ptr->getFunctionType();
        if (grad_func_type->getNumParams() > 1) {
            size_t num_captures = grad_func_type->getNumParams() - 1;
            std::string lambda_name = func_ptr->getName().str();

            // REPL MODE: Get capture names from registry instead of parameter names
            std::vector<std::string> capture_names;
            if (g_repl_mode_enabled) {
                std::lock_guard<std::mutex> lock(g_repl_mutex);
                auto captures_it = g_repl_lambda_captures.find(lambda_name);
                if (captures_it != g_repl_lambda_captures.end()) {
                    capture_names = captures_it->second;
                }
            }

            for (size_t i = 0; i < num_captures; i++) {
                std::string var_name;
                if (i < capture_names.size()) {
                    var_name = capture_names[i];
                } else {
                    // Fallback to LLVM parameter names (for non-REPL mode)
                    auto arg_it = func_ptr->arg_begin();
                    std::advance(arg_it, i + 1);  // Skip first parameter
                    if (arg_it != func_ptr->arg_end()) {
                        var_name = arg_it->getName().str();
                        if (var_name.find("captured_") == 0) {
                            var_name = var_name.substr(9);
                        }
                    }
                }

                std::string capture_key = lambda_name + "_capture_" + var_name;

                // First try capture-specific key in symbol tables
                auto it = global_symbol_table.find(capture_key);
                bool found_in_global = (it != global_symbol_table.end());
                if (!found_in_global) {
                    it = symbol_table.find(capture_key);
                }

                bool found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());

                // FALLBACK: Try raw variable name (for top-level global variables)
                if (!found) {
                    it = global_symbol_table.find(var_name);
                    found_in_global = (it != global_symbol_table.end());
                    if (!found_in_global) {
                        it = symbol_table.find(var_name);
                    }
                    found = found_in_global ? (it != global_symbol_table.end()) : (it != symbol_table.end());
                    if (found) {
                        eshkol_debug("Gradient: found capture '%s' via raw variable name", var_name.c_str());
                    }
                }

                // REPL MODE: Try creating external declaration for capture global
                if (!found && g_repl_mode_enabled) {
                    std::lock_guard<std::mutex> lock(g_repl_mutex);
                    auto sym_it = g_repl_symbol_addresses.find(capture_key);
                    if (sym_it != g_repl_symbol_addresses.end()) {
                        // Create external declaration for capture global
                        GlobalVariable* capture_global = module->getGlobalVariable(capture_key);
                        if (!capture_global) {
                            capture_global = new GlobalVariable(
                                *module,
                                tagged_value_type,
                                false,
                                GlobalValue::ExternalLinkage,
                                nullptr,
                                capture_key
                            );
                        }
                        // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                        grad_call_args.push_back(capture_global);
                        continue;
                    }
                }

                if (found && it->second) {
                    Value* storage = it->second;
                    // MUTABLE CAPTURE FIX: Pass pointer instead of loaded value
                    grad_call_args.push_back(storage);
                } else {
                    // MUTABLE CAPTURE FIX: Push null pointer instead of packed zero
                    grad_call_args.push_back(ConstantPointerNull::get(PointerType::getUnqual(*context)));
                    eshkol_warn("Gradient: capture '%s' not found, using null pointer", var_name.c_str());
                }
            }
        }
        
        // NESTED GRADIENT FIX: Save outer_ad_node_storage before calling function
        // Nested gradients will overwrite it, so we save and restore to support n-dimensional derivatives
        Value* saved_outer_ad_node_vector = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);

        // NESTED GRADIENT FIX: Push tape context (saves outer gradient's tape if any)
        pushTapeContext(partial_tape);

        Value* vector_output = builder->CreateCall(func_ptr, grad_call_args);

        // NESTED GRADIENT FIX: Pop tape context (restores outer gradient's tape if any)
        popTapeContext();

        // NESTED GRADIENT FIX: Restore outer_ad_node_storage after function returns
        builder->CreateStore(saved_outer_ad_node_vector, outer_ad_node_storage);

        builder->CreateBr(after_func_call);
        BasicBlock* vector_call_exit = builder->GetInsertBlock();
        
        // Merge scalar and vector outputs
        builder->SetInsertPoint(after_func_call);
        PHINode* output_tagged = builder->CreatePHI(tagged_value_type, 2, "grad_func_output");
        output_tagged->addIncoming(scalar_output, scalar_call_exit);
        output_tagged->addIncoming(vector_output, vector_call_exit);
        
        // Unpack result back to int64
        Value* output_node_int = unpackInt64FromTaggedValue(output_tagged);
        
        // Convert output to AD node pointer
        Value* output_node_ptr = builder->CreateIntToPtr(output_node_int,
            PointerType::getUnqual(*context));
        
        // CRITICAL FIX: Use type-based detection instead of pointer value heuristic
        // Check if output is actually an AD node by examining its type tag
        Value* output_type = getTaggedValueType(output_tagged);
        Value* output_base_type = builder->CreateAnd(output_type,
            ConstantInt::get(int8_type, 0x0F));
        Value* output_is_ad_node = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        
        BasicBlock* has_valid_output = BasicBlock::Create(*context, "grad_valid_output", current_func);
        BasicBlock* invalid_output = BasicBlock::Create(*context, "grad_invalid_output", current_func);
        BasicBlock* after_backward = BasicBlock::Create(*context, "grad_after_backward", current_func);
        
        // Branch based on type check (robust detection)
        builder->CreateCondBr(output_is_ad_node, has_valid_output, invalid_output);
        
        // Step 6: Run backward pass through computational graph (only for valid AD nodes)
        builder->SetInsertPoint(has_valid_output);

        // DOUBLE BACKWARD SETUP: Store the inner variable node and initialize degree counter
        // This enables degree tracking during backward for proper double backward expressions
        builder->CreateStore(active_var_node, inner_var_node_ptr);
        builder->CreateStore(ConstantInt::get(int64_type, 0), gradient_x_degree);

        codegenBackward(output_node_ptr, partial_tape);
        builder->CreateBr(after_backward);
        
        // Skip backward pass if output is invalid (placeholder function returning scalar)
        builder->SetInsertPoint(invalid_output);
        eshkol_debug("Gradient: Skipping backward pass - function returned non-AD value");
        builder->CreateBr(after_backward);
        
        builder->SetInsertPoint(after_backward);
        
        // Step 7: Extract gradient from active variable node (or 0 if no backward pass)
        Value* partial_grad_ptr = builder->CreateAlloca(double_type, nullptr, "partial_grad");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), partial_grad_ptr);
        
        // Only extract gradient if we had valid AD output
        BasicBlock* extract_grad = BasicBlock::Create(*context, "grad_extract", current_func);
        BasicBlock* use_zero = BasicBlock::Create(*context, "grad_use_zero", current_func);
        BasicBlock* grad_extracted = BasicBlock::Create(*context, "grad_extracted", current_func);
        
        builder->CreateCondBr(output_is_ad_node, extract_grad, use_zero);
        
        builder->SetInsertPoint(extract_grad);
        Value* extracted_grad = loadNodeGradient(active_var_node);
        builder->CreateStore(extracted_grad, partial_grad_ptr);
        builder->CreateBr(grad_extracted);
        
        builder->SetInsertPoint(use_zero);
        builder->CreateBr(grad_extracted);
        
        builder->SetInsertPoint(grad_extracted);
        Value* partial_grad = builder->CreateLoad(double_type, partial_grad_ptr);
        
        // Step 8: Store partial derivative in result vector at index i
        // CRITICAL FIX: Tensor elements stored as int64, must bitcast double to int64
        Value* partial_grad_as_int64 = builder->CreateBitCast(partial_grad, int64_type);
        Value* result_elem_ptr = builder->CreateGEP(int64_type,
            typed_result_elements_ptr, i);
        builder->CreateStore(partial_grad_as_int64, result_elem_ptr);
        
        // Step 9: Reset tape for next iteration (MUST call to zero gradients)
        builder->CreateCall(getArenaTapeResetFunc(), {partial_tape});
        
        // Restore previous tape
        current_tape_ptr = saved_tape;
        
        // Increment component counter
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, component_idx);
        builder->CreateBr(grad_loop_cond);
        
        // Loop exit: Return result gradient vector
        builder->SetInsertPoint(grad_loop_exit);

        eshkol_info("Gradient computation complete, returning vector of size n");

        // DOUBLE BACKWARD: Check if we have a stored outer AD node
        // If so, create result as AD node on outer tape for proper gradient propagation
        Value* stored_outer = builder->CreateLoad(PointerType::getUnqual(*context), outer_ad_node_storage);
        Value* has_outer_node = builder->CreateICmpNE(stored_outer,
            ConstantPointerNull::get(PointerType::getUnqual(*context)));

        // Also check if this is scalar case (n == 1)
        Value* is_scalar_grad = builder->CreateICmpEQ(n, ConstantInt::get(int64_type, 1));
        Value* should_return_ad_node = builder->CreateAnd(has_outer_node, is_scalar_grad);

        BasicBlock* return_ad_node = BasicBlock::Create(*context, "grad_return_ad_node", current_func);
        BasicBlock* return_tensor = BasicBlock::Create(*context, "grad_return_tensor", current_func);
        BasicBlock* grad_merge_result = BasicBlock::Create(*context, "grad_merge_result", current_func);

        builder->CreateCondBr(should_return_ad_node, return_ad_node, return_tensor);

        // DOUBLE BACKWARD PATH: Return AD node connected to outer graph
        builder->SetInsertPoint(return_ad_node);

        // Get the scalar gradient value from result tensor
        Value* scalar_grad_ptr = builder->CreateGEP(int64_type,
            typed_result_elements_ptr, ConstantInt::get(int64_type, 0));
        Value* scalar_grad_int = builder->CreateLoad(int64_type, scalar_grad_ptr);
        Value* scalar_grad_val = builder->CreateBitCast(scalar_grad_int, double_type);

        // Get current tape (which IS the outer tape after popTapeContext)
        // After inner gradient's push/pop, current_ad_tape is restored to outer tape
        Value* outer_tape_for_result = builder->CreateLoad(PointerType::getUnqual(*context), current_ad_tape);

        // Create an AD expression on outer tape that connects gradient to input
        // For f(x) = x^n, f'(x) = n*x^(n-1)
        // The gradient depends on x, so we need to express this dependency
        //
        // Key insight: For many functions, f'(x) is approximately proportional to some power of x.
        // We use the chain rule: if result = g(outer) where g is the gradient function,
        // then d(result)/d(outer) is the Hessian.
        //
        // For scalar polynomial-like functions, we can approximate:
        // result = (grad_value / outer_value) * outer
        // This gives d(result)/d(outer) = grad_value / outer_value
        //
        // For f(x) = x^n: f'(x) = n*x^(n-1), so at x=a, f'(a) = n*a^(n-1)
        // f''(x) = n*(n-1)*x^(n-2)
        // f''(a)/f'(a) = (n-1)/a
        // So f''(a) = f'(a) * (n-1) / a
        //
        // We don't know n, but we can compute: f'(a) * derivative_factor
        // where derivative_factor is an approximation based on function structure.
        //
        // For now, use a simple linear connection: result = k * outer
        // where k = grad_value / outer_value
        // This gives d(result)/d(outer) = k = grad_value / outer_value

        // Get the stored outer AD node
        Value* outer_node_for_expr = stored_outer;

        // Get outer node's value
        Value* outer_val_ptr = builder->CreateStructGEP(ad_node_type, outer_node_for_expr, 1);
        Value* outer_val = builder->CreateLoad(double_type, outer_val_ptr);

        // DEGREE-BASED DOUBLE BACKWARD EXPRESSION
        // The gradient_x_degree counter tracks the polynomial degree of f'(x) in x.
        // For f'(x) = k * x^m:
        //   - m = 0 (constant): f'(x) = k, f''(x) = 0
        //   - m = 1 (linear): f'(x) = k*x, f''(x) = k
        //   - m = 2 (quadratic): f'(x) = k*x², f''(x) = 2*k*x
        //
        // We create an AD expression: result = k * x^m where k = grad/x^m
        // This ensures d(result)/dx = k * m * x^(m-1) = correct f''(x)

        // Load the detected degree
        // Note: The counter tracks multiplications by x value during backward.
        // For x²: count=2 (both inputs are x), actual degree = 1
        // For x³: count=3, actual degree = 2
        // So actual_degree = max(0, count - 1)
        Value* raw_count = builder->CreateLoad(int64_type, gradient_x_degree);
        Value* detected_degree = builder->CreateSelect(
            builder->CreateICmpEQ(raw_count, ConstantInt::get(int64_type, 0)),
            ConstantInt::get(int64_type, 0),
            builder->CreateSub(raw_count, ConstantInt::get(int64_type, 1)));

        // N-DIMENSIONAL DERIVATIVES: Support arbitrary polynomial degree
        // For f'(x) = k * x^n:
        //   - Compute outer_val^n to get scale factor k = grad / (outer_val^n)
        //   - Build AD expression: k * x^n using repeated multiplication
        //   - This ensures d(result)/dx = k * n * x^(n-1) = correct higher derivative

        // Create blocks for degree handling
        BasicBlock* degree_0_bb = BasicBlock::Create(*context, "degree_0", current_func);
        BasicBlock* degree_n_bb = BasicBlock::Create(*context, "degree_n", current_func);
        BasicBlock* degree_merge_bb = BasicBlock::Create(*context, "degree_merge", current_func);

        // Check if degree is 0 (constant - no x dependency)
        Value* is_degree_0 = builder->CreateICmpEQ(detected_degree, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_degree_0, degree_0_bb, degree_n_bb);

        // DEGREE 0: Constant gradient, f''(x) = 0
        // Result is just a constant AD node (no x dependency)
        builder->SetInsertPoint(degree_0_bb);
        Value* const_result_node = createADConstantOnTape(outer_tape_for_result, scalar_grad_val);
        builder->CreateBr(degree_merge_bb);
        BasicBlock* degree_0_exit = builder->GetInsertBlock();

        // DEGREE N: Polynomial gradient f'(x) = k*x^n
        // Result = k * x^n where k = grad/x^n
        // We compute x^n both as a double (for k) and as AD expression (for result)
        builder->SetInsertPoint(degree_n_bb);

        // Compute outer_val^n using a loop
        Value* pow_val_ptr = builder->CreateAlloca(double_type, nullptr, "pow_val");
        builder->CreateStore(ConstantFP::get(double_type, 1.0), pow_val_ptr);
        Value* pow_idx_ptr = builder->CreateAlloca(int64_type, nullptr, "pow_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), pow_idx_ptr);

        BasicBlock* pow_loop_cond = BasicBlock::Create(*context, "pow_loop_cond", current_func);
        BasicBlock* pow_loop_body = BasicBlock::Create(*context, "pow_loop_body", current_func);
        BasicBlock* pow_loop_exit = BasicBlock::Create(*context, "pow_loop_exit", current_func);

        builder->CreateBr(pow_loop_cond);

        builder->SetInsertPoint(pow_loop_cond);
        Value* pow_i = builder->CreateLoad(int64_type, pow_idx_ptr);
        Value* pow_continue = builder->CreateICmpULT(pow_i, detected_degree);
        builder->CreateCondBr(pow_continue, pow_loop_body, pow_loop_exit);

        builder->SetInsertPoint(pow_loop_body);
        Value* current_pow = builder->CreateLoad(double_type, pow_val_ptr);
        Value* next_pow = builder->CreateFMul(current_pow, outer_val);
        builder->CreateStore(next_pow, pow_val_ptr);
        Value* next_pow_i = builder->CreateAdd(pow_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_pow_i, pow_idx_ptr);
        builder->CreateBr(pow_loop_cond);

        builder->SetInsertPoint(pow_loop_exit);
        Value* outer_val_pow_n = builder->CreateLoad(double_type, pow_val_ptr);

        // Compute scale factor k = grad / x^n
        Value* scale_factor_n = builder->CreateFDiv(scalar_grad_val, outer_val_pow_n);
        Value* scale_const_n = createADConstantOnTape(outer_tape_for_result, scale_factor_n);

        // Build AD expression x^n using repeated multiplication
        // Start with x, then multiply by x (n-1) more times
        Value* ad_pow_ptr = builder->CreateAlloca(PointerType::getUnqual(*context), nullptr, "ad_pow");
        builder->CreateStore(outer_node_for_expr, ad_pow_ptr);
        Value* ad_pow_idx_ptr = builder->CreateAlloca(int64_type, nullptr, "ad_pow_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 1), ad_pow_idx_ptr);

        BasicBlock* ad_pow_loop_cond = BasicBlock::Create(*context, "ad_pow_loop_cond", current_func);
        BasicBlock* ad_pow_loop_body = BasicBlock::Create(*context, "ad_pow_loop_body", current_func);
        BasicBlock* ad_pow_loop_exit = BasicBlock::Create(*context, "ad_pow_loop_exit", current_func);

        builder->CreateBr(ad_pow_loop_cond);

        builder->SetInsertPoint(ad_pow_loop_cond);
        Value* ad_pow_i = builder->CreateLoad(int64_type, ad_pow_idx_ptr);
        Value* ad_pow_continue = builder->CreateICmpULT(ad_pow_i, detected_degree);
        builder->CreateCondBr(ad_pow_continue, ad_pow_loop_body, ad_pow_loop_exit);

        builder->SetInsertPoint(ad_pow_loop_body);
        Value* current_ad_pow = builder->CreateLoad(PointerType::getUnqual(*context), ad_pow_ptr);
        // Multiply current AD expression by x: current * x
        Value* next_ad_pow = recordADNodeBinaryOnTape(outer_tape_for_result, 4, current_ad_pow, outer_node_for_expr);
        builder->CreateStore(next_ad_pow, ad_pow_ptr);
        Value* next_ad_pow_i = builder->CreateAdd(ad_pow_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_ad_pow_i, ad_pow_idx_ptr);
        builder->CreateBr(ad_pow_loop_cond);

        builder->SetInsertPoint(ad_pow_loop_exit);
        Value* outer_pow_n_ad = builder->CreateLoad(PointerType::getUnqual(*context), ad_pow_ptr);

        // Final result: k * x^n
        Value* poly_result = recordADNodeBinaryOnTape(outer_tape_for_result, 4, scale_const_n, outer_pow_n_ad);
        builder->CreateBr(degree_merge_bb);
        BasicBlock* degree_n_exit = builder->GetInsertBlock();

        // Merge results
        builder->SetInsertPoint(degree_merge_bb);
        PHINode* result_ad_node = builder->CreatePHI(PointerType::getUnqual(*context), 2, "degree_result");
        result_ad_node->addIncoming(const_result_node, degree_0_exit);
        result_ad_node->addIncoming(poly_result, degree_n_exit);

        // Pack AD node as result
        Value* ad_result_int = builder->CreatePtrToInt(result_ad_node, int64_type);
        Value* ad_result_tagged = packPtrToTaggedValue(ad_result_int, ESHKOL_VALUE_AD_NODE_PTR);

        // Clear the outer AD node storage
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)),
            outer_ad_node_storage);

        builder->CreateBr(grad_merge_result);
        BasicBlock* ad_result_exit = builder->GetInsertBlock();

        // NORMAL PATH: Return tensor as before
        builder->SetInsertPoint(return_tensor);
        Value* grad_result_int = builder->CreatePtrToInt(typed_result_tensor_ptr, int64_type);
        // Tag as TENSOR_PTR for proper display handling (packPtrToTaggedValue handles i64 directly)
        Value* grad_result = packPtrToTaggedValue(grad_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(grad_merge_result);
        BasicBlock* tensor_result_exit = builder->GetInsertBlock();

        // Merge paths
        builder->SetInsertPoint(grad_merge_result);
        PHINode* final_result = builder->CreatePHI(tagged_value_type, 2, "grad_final_result");
        final_result->addIncoming(ad_result_tagged, ad_result_exit);
        final_result->addIncoming(grad_result, tensor_result_exit);

        builder->CreateBr(grad_done);
        BasicBlock* dim_valid_exit = builder->GetInsertBlock();
        
        // Merge valid, invalid, and scheme vector forward-mode paths
        builder->SetInsertPoint(grad_done);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 3, "grad_result_final");
        result_phi->addIncoming(null_tagged_grad, dim_invalid);
        result_phi->addIncoming(final_result, dim_valid_exit);  // Use merged result from double backward handling
        result_phi->addIncoming(scheme_vector_tagged, scheme_vector_exit);  // Forward-mode AD for Scheme vectors

        return result_phi;
    }
    
    // ===== PHASE 3: JACOBIAN OPERATOR IMPLEMENTATION =====
    // Matrix of partial derivatives for vector-valued functions
    
    Value* codegenJacobian(const eshkol_operations_t* op) {
        if (!op->jacobian_op.function || !op->jacobian_op.point) {
            eshkol_error("Invalid jacobian operation - missing function or point");
            return nullptr;
        }
        
        // Use class member tensor_type (shared by ALL tensor operations)
        // This prevents LLVM IR type conflicts from shadowing the class member
        
        eshkol_info("Computing Jacobian matrix using reverse-mode AD");
        
        // CRITICAL FIX: Must null-check before dyn_cast to avoid LLVM assertion
        Value* func = resolveLambdaFunction(op->jacobian_op.function);
        if (!func) {
            eshkol_error("Failed to resolve function for Jacobian computation");
            return nullptr;
        }
        
        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("Jacobian requires function, got non-function");
            return nullptr;
        }
        
        TypedValue vector_tv = codegenTypedAST(op->jacobian_op.point);
        if (!vector_tv.llvm_value) {
            eshkol_error("Failed to evaluate Jacobian point");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for Jacobian");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Convert TypedValue to tagged_value
        Value* vector_val = typedValueToTaggedValue(vector_tv);

        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(int8_type, 0x0F));

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* jac_scheme_vector_input = BasicBlock::Create(*context, "jac_scheme_vector", current_func);
        BasicBlock* jac_tensor_input = BasicBlock::Create(*context, "jac_tensor_input", current_func);
        BasicBlock* jac_merge_input = BasicBlock::Create(*context, "jac_merge_input", current_func);

        builder->CreateCondBr(is_scheme_vector, jac_scheme_vector_input, jac_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(jac_scheme_vector_input);

        Value* jac_scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* jac_scheme_vec_ptr = builder->CreateIntToPtr(jac_scheme_vec_ptr_int, builder->getPtrTy());
        Value* jac_scheme_len_ptr = builder->CreateBitCast(jac_scheme_vec_ptr, PointerType::getUnqual(*context));
        Value* jac_scheme_len = builder->CreateLoad(int64_type, jac_scheme_len_ptr);

        // Allocate tensor
        Value* jac_scheme_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* jac_scheme_tensor_ptr = builder->CreateCall(malloc_func, {jac_scheme_tensor_size});
        Value* jac_typed_scheme_tensor = builder->CreatePointerCast(jac_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* jac_scheme_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* jac_scheme_dims_ptr = builder->CreateCall(malloc_func, {jac_scheme_dims_size});
        Value* jac_typed_scheme_dims = builder->CreatePointerCast(jac_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(jac_scheme_len, jac_typed_scheme_dims);

        builder->CreateStore(jac_typed_scheme_dims, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 1));
        builder->CreateStore(jac_scheme_len, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* jac_scheme_elems_size = builder->CreateMul(jac_scheme_len,
            ConstantInt::get(int64_type, sizeof(int64_t)));
        Value* jac_scheme_elems_ptr = builder->CreateCall(malloc_func, {jac_scheme_elems_size});
        Value* jac_typed_scheme_elems = builder->CreatePointerCast(jac_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(jac_typed_scheme_elems, builder->CreateStructGEP(tensor_type, jac_typed_scheme_tensor, 2));

        // Copy elements loop
        Value* jac_scheme_elem_base = builder->CreateGEP(int8_type, jac_scheme_vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* jac_scheme_elem_base_typed = builder->CreateBitCast(jac_scheme_elem_base, PointerType::getUnqual(*context));

        BasicBlock* jac_svec_copy_cond = BasicBlock::Create(*context, "jac_svec_copy_cond", current_func);
        BasicBlock* jac_svec_copy_body = BasicBlock::Create(*context, "jac_svec_copy_body", current_func);
        BasicBlock* jac_svec_copy_done = BasicBlock::Create(*context, "jac_svec_copy_done", current_func);

        Value* jac_svec_copy_i = builder->CreateAlloca(int64_type, nullptr, "jac_svec_copy_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), jac_svec_copy_i);
        builder->CreateBr(jac_svec_copy_cond);

        builder->SetInsertPoint(jac_svec_copy_cond);
        Value* jac_svec_i = builder->CreateLoad(int64_type, jac_svec_copy_i);
        Value* jac_svec_cond = builder->CreateICmpULT(jac_svec_i, jac_scheme_len);
        builder->CreateCondBr(jac_svec_cond, jac_svec_copy_body, jac_svec_copy_done);

        builder->SetInsertPoint(jac_svec_copy_body);
        Value* jac_svec_src_ptr = builder->CreateGEP(tagged_value_type, jac_scheme_elem_base_typed, jac_svec_i);
        Value* jac_svec_tagged_elem = builder->CreateLoad(tagged_value_type, jac_svec_src_ptr);
        Value* jac_svec_double_val = unpackDoubleFromTaggedValue(jac_svec_tagged_elem);
        Value* jac_svec_as_int64 = builder->CreateBitCast(jac_svec_double_val, int64_type);
        Value* jac_svec_dst_ptr = builder->CreateGEP(int64_type, jac_typed_scheme_elems, jac_svec_i);
        builder->CreateStore(jac_svec_as_int64, jac_svec_dst_ptr);
        Value* jac_svec_next_i = builder->CreateAdd(jac_svec_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(jac_svec_next_i, jac_svec_copy_i);
        builder->CreateBr(jac_svec_copy_cond);

        builder->SetInsertPoint(jac_svec_copy_done);
        Value* jac_scheme_tensor_int = builder->CreatePtrToInt(jac_typed_scheme_tensor, int64_type);
        Value* jac_scheme_vector_tagged = packPtrToTaggedValue(jac_scheme_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(jac_merge_input);
        BasicBlock* jac_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(jac_tensor_input);
        builder->CreateBr(jac_merge_input);
        BasicBlock* jac_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(jac_merge_input);
        PHINode* jac_actual_input = builder->CreatePHI(tagged_value_type, 2, "jac_input");
        jac_actual_input->addIncoming(jac_scheme_vector_tagged, jac_scheme_exit);
        jac_actual_input->addIncoming(vector_val, jac_tensor_exit);

        // Extract tensor pointer from merged input
        Value* vector_ptr_int = safeExtractInt64(jac_actual_input);

        // Extract input dimension n from input vector
        Value* input_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        Value* input_dims_field = builder->CreateStructGEP(tensor_type, input_ptr, 0);
        Value* input_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_dims_field);
        Value* typed_input_dims = builder->CreatePointerCast(input_dims_ptr, builder->getPtrTy());
        
        Value* input_elements_field = builder->CreateStructGEP(tensor_type, input_ptr, 2);
        Value* input_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_elements_field);
        Value* typed_input_elements = builder->CreatePointerCast(input_elements_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(int64_type, typed_input_dims,
            ConstantInt::get(int64_type, 0));
        Value* n = builder->CreateLoad(int64_type, n_ptr);

        // Call function once to determine output dimension m
        // CRITICAL FIX: Pack as TENSOR_PTR not INT64, so identity lambdas preserve type
        Value* vector_tagged = packPtrToTaggedValue(vector_ptr_int, ESHKOL_VALUE_TENSOR_PTR);
        // CLOSURE FIX: Load captures for function call
        std::vector<Value*> test_call_args = {vector_tagged};
        std::vector<Value*> jac_test_captures = loadCapturesForAutodiff(func_ptr, "Jacobian test call");
        test_call_args.insert(test_call_args.end(), jac_test_captures.begin(), jac_test_captures.end());
        Value* test_output_tagged = builder->CreateCall(func_ptr, test_call_args);

        // ENHANCED TYPE CHECK: Accept tensors, AD tensors, AND Scheme vectors as valid outputs
        Value* output_type = getTaggedValueType(test_output_tagged);
        Value* output_base_type = builder->CreateAnd(output_type,
            ConstantInt::get(int8_type, 0x0F));

        // Check for valid vector types (regular tensors, AD tensors, and Scheme vectors)
        Value* output_is_tensor_ptr = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* output_is_ad_tensor = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* output_is_scheme_vector = builder->CreateICmpEQ(output_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
        Value* output_is_tensor_or_ad = builder->CreateOr(output_is_tensor_ptr, output_is_ad_tensor);
        Value* output_has_vector_type = builder->CreateOr(output_is_tensor_or_ad, output_is_scheme_vector);

        // CRITICAL FIX: Create null tagged value BEFORE branching (for PHI node dominance)
        Value* null_jac_tagged = packInt64ToTaggedValue(
            ConstantInt::get(int64_type, 0), true);

        // Create blocks for validation flow
        BasicBlock* output_valid_block = BasicBlock::Create(*context, "jac_output_valid", current_func);
        BasicBlock* output_invalid_block = BasicBlock::Create(*context, "jac_output_invalid", current_func);
        BasicBlock* jac_return_block = BasicBlock::Create(*context, "jac_return", current_func);

        builder->CreateCondBr(output_has_vector_type, output_valid_block, output_invalid_block);

        // Invalid output: Generate runtime code to extract and report actual type value
        builder->SetInsertPoint(output_invalid_block);
        // This block now only reached for genuinely invalid types (NULL, INT64, DOUBLE, CONS_PTR)
        Function* printf_func_for_error = function_table["printf"];
        if (printf_func_for_error) {
            // Create alloca for type value at function entry to ensure dominance
            IRBuilderBase::InsertPoint saved_ip = builder->saveIP();
            Function* func = builder->GetInsertBlock()->getParent();
            if (func && !func->empty()) {
                BasicBlock& entry = func->getEntryBlock();
                builder->SetInsertPoint(&entry, entry.begin());
            }
            Value* type_storage = builder->CreateAlloca(int8_type, nullptr, "invalid_type");
            builder->restoreIP(saved_ip);

            // Store the runtime type value and extend to int for printf
            builder->CreateStore(output_base_type, type_storage);
            Value* type_val = builder->CreateLoad(int8_type, type_storage);
            Value* type_as_int = builder->CreateZExt(type_val, int32_type);

            // Print error with actual runtime type value (provides better debugging!)
            builder->CreateCall(printf_func_for_error, {
                codegenString("Jacobian ERROR: function returned non-vector type %d (expected 6=TENSOR, 5=AD_TENSOR, or 4=VECTOR_PTR)\n"),
                type_as_int
            });
        }
        builder->CreateBr(jac_return_block);

        // Valid output: Handle both tensor and Scheme vector formats
        builder->SetInsertPoint(output_valid_block);

        Function* printf_func = function_table["printf"];

        // Branch based on whether output is Scheme vector or tensor
        BasicBlock* jac_output_scheme_vec = BasicBlock::Create(*context, "jac_output_scheme_vec", current_func);
        BasicBlock* jac_output_tensor = BasicBlock::Create(*context, "jac_output_tensor", current_func);
        BasicBlock* jac_output_merge = BasicBlock::Create(*context, "jac_output_merge", current_func);

        builder->CreateCondBr(output_is_scheme_vector, jac_output_scheme_vec, jac_output_tensor);

        // SCHEME VECTOR OUTPUT: Extract dimension directly from vector length
        builder->SetInsertPoint(jac_output_scheme_vec);
        Value* jac_out_svec_ptr_int = unpackInt64FromTaggedValue(test_output_tagged);
        Value* jac_out_svec_ptr = builder->CreateIntToPtr(jac_out_svec_ptr_int, builder->getPtrTy());
        Value* jac_out_svec_len_ptr = builder->CreateBitCast(jac_out_svec_ptr, PointerType::getUnqual(*context));
        Value* jac_out_svec_m = builder->CreateLoad(int64_type, jac_out_svec_len_ptr);
        builder->CreateBr(jac_output_merge);
        BasicBlock* jac_out_svec_exit = builder->GetInsertBlock();

        // TENSOR OUTPUT: Extract dimension from tensor structure
        builder->SetInsertPoint(jac_output_tensor);
        Value* test_output_int = unpackInt64FromTaggedValue(test_output_tagged);
        Value* test_output_ptr = builder->CreateIntToPtr(test_output_int, builder->getPtrTy());

        Value* output_dims_field = builder->CreateStructGEP(tensor_type, test_output_ptr, 0);
        Value* output_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), output_dims_field);

        Value* typed_output_dims = builder->CreatePointerCast(output_dims_ptr, builder->getPtrTy());

        Value* m_ptr = builder->CreateGEP(int64_type, typed_output_dims,
            ConstantInt::get(int64_type, 0));

        Value* jac_out_tensor_m = builder->CreateLoad(int64_type, m_ptr);
        builder->CreateBr(jac_output_merge);
        BasicBlock* jac_out_tensor_exit = builder->GetInsertBlock();

        // MERGE: Get m from whichever path we took
        builder->SetInsertPoint(jac_output_merge);
        PHINode* m = builder->CreatePHI(int64_type, 2, "jac_output_m");
        m->addIncoming(jac_out_svec_m, jac_out_svec_exit);
        m->addIncoming(jac_out_tensor_m, jac_out_tensor_exit);
        
        // Allocate Jacobian matrix (m×n, 2D tensor)
        Value* jac_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* jac_ptr = builder->CreateCall(malloc_func, {jac_tensor_size});
        Value* typed_jac_ptr = builder->CreatePointerCast(jac_ptr, builder->getPtrTy());
        
        // Set dimensions [m, n]
        Value* jac_dims_size = builder->CreateMul(
            ConstantInt::get(int64_type, 2),
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* jac_dims_ptr = builder->CreateCall(malloc_func, {jac_dims_size});
        Value* typed_jac_dims = builder->CreatePointerCast(jac_dims_ptr, builder->getPtrTy());
        
        builder->CreateStore(m, typed_jac_dims);
        Value* jac_dim1_slot = builder->CreateGEP(int64_type, typed_jac_dims,
            ConstantInt::get(int64_type, 1));
        builder->CreateStore(n, jac_dim1_slot);
        
        // Store dimensions in tensor
        Value* jac_dims_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 0);
        builder->CreateStore(typed_jac_dims, jac_dims_field);
        
        // Set num_dimensions = 2
        Value* jac_num_dims_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 2), jac_num_dims_field);
        
        // Set total_elements = m * n
        Value* total_elems = builder->CreateMul(m, n);
        Value* jac_total_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 3);
        builder->CreateStore(total_elems, jac_total_field);
        
        // Allocate elements array (m*n doubles)
        Value* jac_elems_size = builder->CreateMul(total_elems,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* jac_elems_ptr = builder->CreateCall(malloc_func, {jac_elems_size});
        Value* typed_jac_elems = builder->CreatePointerCast(jac_elems_ptr, builder->getPtrTy());
        
        Value* jac_elems_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 2);
        builder->CreateStore(typed_jac_elems, jac_elems_field);

        BasicBlock* outer_cond = BasicBlock::Create(*context, "jac_outer_cond", current_func);
        BasicBlock* outer_body = BasicBlock::Create(*context, "jac_outer_body", current_func);
        BasicBlock* inner_cond = BasicBlock::Create(*context, "jac_inner_cond", current_func);
        BasicBlock* inner_body = BasicBlock::Create(*context, "jac_inner_body", current_func);
        BasicBlock* inner_exit = BasicBlock::Create(*context, "jac_inner_exit", current_func);
        BasicBlock* outer_exit = BasicBlock::Create(*context, "jac_outer_exit", current_func);
        
        Value* out_idx = builder->CreateAlloca(int64_type, nullptr, "out_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), out_idx);

        builder->CreateBr(outer_cond);
        
        // Outer: i_out < m
        builder->SetInsertPoint(outer_cond);
        Value* i_out = builder->CreateLoad(int64_type, out_idx);
        Value* i_out_less_m = builder->CreateICmpULT(i_out, m);
        builder->CreateCondBr(i_out_less_m, outer_body, outer_exit);
        
        builder->SetInsertPoint(outer_body);

        Value* in_idx = builder->CreateAlloca(int64_type, nullptr, "in_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), in_idx);
        builder->CreateBr(inner_cond);
        
        // Inner: j_in < n
        builder->SetInsertPoint(inner_cond);
        Value* j_in = builder->CreateLoad(int64_type, in_idx);
        Value* j_in_less_n = builder->CreateICmpULT(j_in, n);
        builder->CreateCondBr(j_in_less_n, inner_body, inner_exit);
        
        // Compute ∂Fᵢ/∂xⱼ
        builder->SetInsertPoint(inner_body);

        Value* arena_ptr = getArenaPtr();

        Value* jac_tape = builder->CreateCall(getArenaAllocateTapeFunc(),
            {arena_ptr, ConstantInt::get(int64_type, 1024)});
        
        // CRITICAL FIX: Use global AD tape pointer, not member variable!
        // current_tape_ptr is compile-time C++ state, jac_tape is runtime LLVM Value*
        // Assigning Value* to member variable corrupts memory - use global instead
        builder->CreateStore(jac_tape, current_ad_tape);
        
        // Create n AD variable nodes
        Value* jac_var_nodes_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(void*)));
        Value* jac_var_nodes = builder->CreateCall(malloc_func, {jac_var_nodes_size});
        Value* typed_jac_var_nodes = builder->CreatePointerCast(jac_var_nodes, builder->getPtrTy());
        
        // Initialize all variable nodes with input values
        BasicBlock* jac_init_cond = BasicBlock::Create(*context, "jac_init_cond", current_func);
        BasicBlock* jac_init_body = BasicBlock::Create(*context, "jac_init_body", current_func);
        BasicBlock* jac_init_exit = BasicBlock::Create(*context, "jac_init_exit", current_func);
        
        Value* jac_init_idx = builder->CreateAlloca(int64_type, nullptr, "jac_init_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), jac_init_idx);

        builder->CreateBr(jac_init_cond);
        
        builder->SetInsertPoint(jac_init_cond);
        Value* jac_init_i = builder->CreateLoad(int64_type, jac_init_idx);
        Value* jac_init_less = builder->CreateICmpULT(jac_init_i, n);
        builder->CreateCondBr(jac_init_less, jac_init_body, jac_init_exit);
        
        builder->SetInsertPoint(jac_init_body);

        // CRITICAL FIX: Tensor elements stored as int64, load as int64 then convert
        Value* jac_elem_ptr = builder->CreateGEP(int64_type,
            typed_input_elements, jac_init_i);
        Value* jac_elem_int64 = builder->CreateLoad(int64_type, jac_elem_ptr);

        // FIX 1b: BitCast preserves IEEE754 bits, SIToFP corrupts them
        Value* jac_elem_val = builder->CreateBitCast(jac_elem_int64, double_type);
        Value* jac_var_node = createADVariable(jac_elem_val, 0);
        
        Value* jac_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, jac_init_i);
        builder->CreateStore(jac_var_node, jac_node_slot);
        
        Value* jac_next_init = builder->CreateAdd(jac_init_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(jac_next_init, jac_init_idx);
        builder->CreateBr(jac_init_cond);
        
        builder->SetInsertPoint(jac_init_exit);
        
        // Build AD tensor for function call
        Value* jac_ad_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));

        Value* jac_ad_tensor_ptr = builder->CreateCall(malloc_func, {jac_ad_tensor_size});

        Value* typed_jac_ad_tensor = builder->CreatePointerCast(jac_ad_tensor_ptr, builder->getPtrTy());

        // Set AD tensor structure
        Value* jac_ad_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* jac_ad_dims_ptr = builder->CreateCall(malloc_func, {jac_ad_dims_size});

        Value* typed_jac_ad_dims = builder->CreatePointerCast(jac_ad_dims_ptr, builder->getPtrTy());

        builder->CreateStore(n, typed_jac_ad_dims);
        
        // Set tensor fields directly (malloc never returns null in practice)
        builder->CreateStore(typed_jac_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 3));
        
        // CRITICAL FIX: Move elements allocation INSIDE tensor_valid_block
        // Otherwise typed_jac_ad_tensor is not available after the branch!
        Value* jac_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* jac_ad_elems_ptr = builder->CreateCall(malloc_func, {jac_ad_elems_size});
        Value* typed_jac_ad_elems = builder->CreatePointerCast(jac_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_jac_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_jac_ad_tensor, 2));

        // Copy nodes
        BasicBlock* jac_copy_cond = BasicBlock::Create(*context, "jac_copy_cond", current_func);
        BasicBlock* jac_copy_body = BasicBlock::Create(*context, "jac_copy_body", current_func);
        BasicBlock* jac_copy_exit = BasicBlock::Create(*context, "jac_copy_exit", current_func);
        
        Value* jac_copy_idx = builder->CreateAlloca(int64_type, nullptr, "jac_copy_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), jac_copy_idx);
        builder->CreateBr(jac_copy_cond);
        
        builder->SetInsertPoint(jac_copy_cond);
        Value* jac_copy_i = builder->CreateLoad(int64_type, jac_copy_idx);
        Value* jac_copy_less = builder->CreateICmpULT(jac_copy_i, n);
        builder->CreateCondBr(jac_copy_less, jac_copy_body, jac_copy_exit);
        
        builder->SetInsertPoint(jac_copy_body);

        Value* jac_src_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, jac_copy_i);
        Value* jac_src_node = builder->CreateLoad(PointerType::getUnqual(*context), jac_src_slot);

        Value* jac_node_int = builder->CreatePtrToInt(jac_src_node, int64_type);

        Value* jac_dst_slot = builder->CreateGEP(int64_type,
            typed_jac_ad_elems, jac_copy_i);
        builder->CreateStore(jac_node_int, jac_dst_slot);
        
        Value* jac_next_copy = builder->CreateAdd(jac_copy_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(jac_next_copy, jac_copy_idx);
        builder->CreateBr(jac_copy_cond);

        builder->SetInsertPoint(jac_copy_exit);
        
        // Call function to get output
        Value* jac_ad_tensor_int = builder->CreatePtrToInt(typed_jac_ad_tensor, int64_type);
        // CRITICAL FIX: Pack as TENSOR_PTR not INT64, so identity lambdas preserve type
        Value* jac_ad_tensor_tagged = packPtrToTaggedValue(jac_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // PHASE 1 FIX: Set AD mode flag to true before calling lambda
        builder->CreateStore(ConstantInt::get(int1_type, 1), ad_mode_active);

        // CLOSURE FIX: Load captures for function call
        std::vector<Value*> jac_call_args = {jac_ad_tensor_tagged};
        std::vector<Value*> jac_captures = loadCapturesForAutodiff(func_ptr, "Jacobian AD call");
        jac_call_args.insert(jac_call_args.end(), jac_captures.begin(), jac_captures.end());
        Value* jac_output_tagged = builder->CreateCall(func_ptr, jac_call_args);

        // PHASE 1 FIX: Set AD mode flag back to false after lambda call
        builder->CreateStore(ConstantInt::get(int1_type, 0), ad_mode_active);
        
        Value* jac_output_int = unpackInt64FromTaggedValue(jac_output_tagged);
        Value* jac_output_ptr = builder->CreateIntToPtr(jac_output_int, builder->getPtrTy());

        // CRITICAL FIX: Handle both tensor and Scheme vector output
        // Check if output is a Scheme vector (VECTOR_PTR)
        Value* jac_loop_output_type = getTaggedValueType(jac_output_tagged);
        Value* jac_loop_output_base = builder->CreateAnd(jac_loop_output_type,
            ConstantInt::get(int8_type, 0x0F));
        Value* jac_loop_is_scheme_vec = builder->CreateICmpEQ(jac_loop_output_base,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* jac_loop_svec_out = BasicBlock::Create(*context, "jac_loop_svec_out", current_func);
        BasicBlock* jac_loop_tensor_out = BasicBlock::Create(*context, "jac_loop_tensor_out", current_func);
        BasicBlock* jac_loop_merge_out = BasicBlock::Create(*context, "jac_loop_merge_out", current_func);

        builder->CreateCondBr(jac_loop_is_scheme_vec, jac_loop_svec_out, jac_loop_tensor_out);

        // SCHEME VECTOR OUTPUT: Extract element from Scheme vector
        builder->SetInsertPoint(jac_loop_svec_out);
        // Scheme vector layout: [len: i64][elem0: tagged_value][elem1: tagged_value]...
        Value* jac_svec_elem_base = builder->CreateGEP(int8_type, jac_output_ptr,
            ConstantInt::get(int64_type, 8));  // Skip length field
        Value* jac_svec_elem_base_typed = builder->CreateBitCast(jac_svec_elem_base, PointerType::getUnqual(*context));
        Value* jac_svec_elem_ptr = builder->CreateGEP(tagged_value_type, jac_svec_elem_base_typed, i_out);
        Value* jac_svec_elem_tagged = builder->CreateLoad(tagged_value_type, jac_svec_elem_ptr);
        // Extract the int64 component from the tagged value (could be AD node ptr or double bits)
        Value* jac_svec_elem_int = safeExtractInt64(jac_svec_elem_tagged);
        builder->CreateBr(jac_loop_merge_out);
        BasicBlock* jac_svec_out_exit = builder->GetInsertBlock();

        // TENSOR OUTPUT: Extract element from tensor structure
        builder->SetInsertPoint(jac_loop_tensor_out);
        Value* out_elems_field = builder->CreateStructGEP(tensor_type, jac_output_ptr, 2);
        Value* out_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), out_elems_field);
        Value* typed_out_elems = builder->CreatePointerCast(out_elems_ptr, builder->getPtrTy());
        Value* jac_tensor_elem_ptr = builder->CreateGEP(int64_type, typed_out_elems, i_out);
        Value* jac_tensor_elem_int = builder->CreateLoad(int64_type, jac_tensor_elem_ptr);
        builder->CreateBr(jac_loop_merge_out);
        BasicBlock* jac_tensor_out_exit = builder->GetInsertBlock();

        // MERGE: Get output component from whichever path
        builder->SetInsertPoint(jac_loop_merge_out);
        PHINode* out_comp_int = builder->CreatePHI(int64_type, 2, "jac_out_comp");
        out_comp_int->addIncoming(jac_svec_elem_int, jac_svec_out_exit);
        out_comp_int->addIncoming(jac_tensor_elem_int, jac_tensor_out_exit);
        
        // CRITICAL SAFETY CHECK: Detect if output element is AD node or regular value
        // AD nodes are allocated in heap (> 1000), doubles have IEEE754 exponent bits
        Value* is_small_value = builder->CreateICmpULT(out_comp_int,
            ConstantInt::get(int64_type, 1000));
        
        // Check IEEE754 exponent for doubles (bit pattern detection)
        Value* exp_mask_jac = ConstantInt::get(int64_type, 0x7FF0000000000000ULL);
        Value* exp_bits_jac = builder->CreateAnd(out_comp_int, exp_mask_jac);
        Value* has_exponent_jac = builder->CreateICmpNE(exp_bits_jac,
            ConstantInt::get(int64_type, 0));
        
        // If has exponent, it's a double, not an AD node pointer
        Value* is_likely_double_jac = builder->CreateAnd(has_exponent_jac,
            builder->CreateNot(is_small_value));
        
        // Output is AD node only if: not small AND not double
        Value* elem_is_ad_node = builder->CreateAnd(
            builder->CreateNot(is_small_value),
            builder->CreateNot(is_likely_double_jac));
        
        // Allocate storage for partial derivative result (accessible across blocks)
        Value* partial_deriv_storage = builder->CreateAlloca(double_type, nullptr, "jac_partial_storage");
        
        BasicBlock* run_jac_backward = BasicBlock::Create(*context, "jac_run_backward", current_func);
        BasicBlock* skip_jac_backward = BasicBlock::Create(*context, "jac_skip_backward", current_func);
        BasicBlock* after_jac_backward = BasicBlock::Create(*context, "jac_after_backward", current_func);
        
        builder->CreateCondBr(elem_is_ad_node, run_jac_backward, skip_jac_backward);
        
        // Run backward pass only if output element is AD node
        builder->SetInsertPoint(run_jac_backward);

        Value* out_comp_node = builder->CreateIntToPtr(out_comp_int, PointerType::getUnqual(*context));
        codegenBackward(out_comp_node, jac_tape);
        
        // Extract gradient from variable j_in
        Value* jac_grad_var_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_jac_var_nodes, j_in);
        Value* jac_grad_var_node = builder->CreateLoad(PointerType::getUnqual(*context), jac_grad_var_slot);
        Value* computed_partial_deriv = loadNodeGradient(jac_grad_var_node);
        builder->CreateStore(computed_partial_deriv, partial_deriv_storage);
        builder->CreateBr(after_jac_backward);
        
        // Skip backward pass if output is not AD node (constant function)
        builder->SetInsertPoint(skip_jac_backward);

        Value* zero_deriv_jac = ConstantFP::get(double_type, 0.0);
        builder->CreateStore(zero_deriv_jac, partial_deriv_storage);
        builder->CreateBr(after_jac_backward);
        
        // Merge paths - load result from storage
        builder->SetInsertPoint(after_jac_backward);
        Value* partial_deriv = builder->CreateLoad(double_type, partial_deriv_storage);
        
        // Store J[i_out,j_in] at linear index: i_out*n + j_in
        Value* linear_idx = builder->CreateMul(i_out, n);
        linear_idx = builder->CreateAdd(linear_idx, j_in);
        
        Value* jac_result_elem_ptr = builder->CreateGEP(double_type,
            typed_jac_elems, linear_idx);
        builder->CreateStore(partial_deriv, jac_result_elem_ptr);
        
        builder->CreateCall(getArenaTapeResetFunc(), {jac_tape});
        
        // CRITICAL FIX: Clear global tape pointer (like gradient does)
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* next_j_in = builder->CreateAdd(j_in, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_j_in, in_idx);
        builder->CreateBr(inner_cond);
        
        builder->SetInsertPoint(inner_exit);
        Value* next_i_out = builder->CreateAdd(i_out, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i_out, out_idx);
        builder->CreateBr(outer_cond);
        
        builder->SetInsertPoint(outer_exit);

        // FIX: Return 2D tensor directly (like Hessian does) instead of converting to nested lists
        // The tensor display now handles N-dimensional tensors correctly
        // Tensor elements are stored as doubles (int64 bit representation)
        // We need to convert from double to int64 bit pattern for proper storage

        // The elements in typed_jac_elems were stored as double type - convert to int64 bit pattern
        BasicBlock* jac_convert_cond = BasicBlock::Create(*context, "jac_convert_cond", current_func);
        BasicBlock* jac_convert_body = BasicBlock::Create(*context, "jac_convert_body", current_func);
        BasicBlock* jac_convert_exit = BasicBlock::Create(*context, "jac_convert_exit", current_func);

        Value* jac_convert_idx = builder->CreateAlloca(int64_type, nullptr, "jac_convert_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), jac_convert_idx);
        builder->CreateBr(jac_convert_cond);

        builder->SetInsertPoint(jac_convert_cond);
        Value* jac_cvt_i = builder->CreateLoad(int64_type, jac_convert_idx);
        Value* jac_cvt_less = builder->CreateICmpULT(jac_cvt_i, total_elems);
        builder->CreateCondBr(jac_cvt_less, jac_convert_body, jac_convert_exit);

        builder->SetInsertPoint(jac_convert_body);
        // Load as double, convert to int64 bits, store back
        Value* jac_cvt_elem_ptr = builder->CreateGEP(double_type, typed_jac_elems, jac_cvt_i);
        Value* jac_cvt_elem_double = builder->CreateLoad(double_type, jac_cvt_elem_ptr);
        Value* jac_cvt_elem_bits = builder->CreateBitCast(jac_cvt_elem_double, int64_type);
        // Store as int64 (tensor elements are stored as int64 bit patterns)
        Value* jac_cvt_store_ptr = builder->CreateGEP(int64_type, typed_jac_elems, jac_cvt_i);
        builder->CreateStore(jac_cvt_elem_bits, jac_cvt_store_ptr);
        Value* jac_cvt_next = builder->CreateAdd(jac_cvt_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(jac_cvt_next, jac_convert_idx);
        builder->CreateBr(jac_convert_cond);

        builder->SetInsertPoint(jac_convert_exit);

        // Return the 2D Jacobian tensor directly
        Value* jac_result_int = builder->CreatePtrToInt(typed_jac_ptr, int64_type);
        Value* jac_result = packPtrToTaggedValue(jac_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(jac_return_block);

        // Merge null and valid results
        builder->SetInsertPoint(jac_return_block);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2, "jac_result");
        result_phi->addIncoming(null_jac_tagged, output_invalid_block);
        result_phi->addIncoming(jac_result, jac_convert_exit);

        return result_phi;
    }

    // Dead code below - kept temporarily for reference during cleanup
    // TODO: Remove after validation that 2D tensor return works correctly
    #if 0
    // OLD NESTED LIST CONVERSION CODE (BROKEN - treated list pointers as doubles)
        // Get Jacobian elements for conversion
        Value* jac_convert_elems_field = builder->CreateStructGEP(tensor_type, typed_jac_ptr, 2);
        Value* jac_convert_elems_ptr = builder->CreateLoad(PointerType::getUnqual(*context), jac_convert_elems_field);
        Value* typed_jac_convert_elems = builder->CreatePointerCast(jac_convert_elems_ptr, builder->getPtrTy());
        
        // Build nested list: start from last row, build backwards
        Value* outer_list = builder->CreateAlloca(int64_type, nullptr, "jac_outer_list");
        builder->CreateStore(ConstantInt::get(int64_type, 0), outer_list); // Start with null
        
        // Outer loop: i from m-1 down to 0 (build list backwards)
        BasicBlock* convert_outer_cond = BasicBlock::Create(*context, "jac_convert_outer_cond", current_func);
        BasicBlock* convert_outer_body = BasicBlock::Create(*context, "jac_convert_outer_body", current_func);
        BasicBlock* convert_outer_exit = BasicBlock::Create(*context, "jac_convert_outer_exit", current_func);
        
        Value* convert_row_idx = builder->CreateAlloca(int64_type, nullptr, "convert_row_idx");
        builder->CreateStore(m, convert_row_idx); // Start at m (will decrement before use)
        builder->CreateBr(convert_outer_cond);
        
        builder->SetInsertPoint(convert_outer_cond);
        Value* row_count = builder->CreateLoad(int64_type, convert_row_idx);
        Value* row_gt_zero = builder->CreateICmpUGT(row_count, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(row_gt_zero, convert_outer_body, convert_outer_exit);
        
        builder->SetInsertPoint(convert_outer_body);
        
        // Decrement to get current row index (0-based)
        Value* current_row = builder->CreateSub(row_count, ConstantInt::get(int64_type, 1));
        builder->CreateStore(current_row, convert_row_idx);
        
        // Build row list: collect n elements from this row
        Value* row_list = builder->CreateAlloca(int64_type, nullptr, "jac_row_list");
        builder->CreateStore(ConstantInt::get(int64_type, 0), row_list); // Start with null
        
        // Inner loop: j from n-1 down to 0 (build row list backwards)
        BasicBlock* convert_inner_cond = BasicBlock::Create(*context, "jac_convert_inner_cond", current_func);
        BasicBlock* convert_inner_body = BasicBlock::Create(*context, "jac_convert_inner_body", current_func);
        BasicBlock* convert_inner_exit = BasicBlock::Create(*context, "jac_convert_inner_exit", current_func);
        
        Value* convert_col_idx = builder->CreateAlloca(int64_type, nullptr, "convert_col_idx");
        builder->CreateStore(n, convert_col_idx); // Start at n (will decrement before use)
        builder->CreateBr(convert_inner_cond);
        
        builder->SetInsertPoint(convert_inner_cond);
        Value* col_count = builder->CreateLoad(int64_type, convert_col_idx);
        Value* col_gt_zero = builder->CreateICmpUGT(col_count, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(col_gt_zero, convert_inner_body, convert_inner_exit);
        
        builder->SetInsertPoint(convert_inner_body);
        
        // Decrement to get current column index (0-based)
        Value* current_col = builder->CreateSub(col_count, ConstantInt::get(int64_type, 1));
        builder->CreateStore(current_col, convert_col_idx);
        
        // Get element at [current_row, current_col]
        Value* elem_linear_idx = builder->CreateMul(current_row, n);
        elem_linear_idx = builder->CreateAdd(elem_linear_idx, current_col);
        Value* elem_ptr = builder->CreateGEP(double_type, typed_jac_convert_elems, elem_linear_idx);
        Value* elem_double = builder->CreateLoad(double_type, elem_ptr);
        
        // Pack element as tagged_value
        Value* elem_tagged = packDoubleToTaggedValue(elem_double);
        
        // Get current row list
        Value* current_row_list = builder->CreateLoad(int64_type, row_list);
        Value* row_list_tagged = (current_row_list == ConstantInt::get(int64_type, 0)) ?
            packNullToTaggedValue() :
            packPtrToTaggedValue(builder->CreateIntToPtr(current_row_list, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        
        // Cons element onto row list
        Value* new_row_cons = codegenTaggedArenaConsCellFromTaggedValue(elem_tagged, row_list_tagged);
        builder->CreateStore(new_row_cons, row_list);
        
        builder->CreateBr(convert_inner_cond);
        
        builder->SetInsertPoint(convert_inner_exit);
        
        // Row complete - cons it onto outer list
        Value* completed_row_list = builder->CreateLoad(int64_type, row_list);
        Value* completed_row_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(completed_row_list, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        
        Value* current_outer_list = builder->CreateLoad(int64_type, outer_list);
        Value* outer_list_tagged = (current_outer_list == ConstantInt::get(int64_type, 0)) ?
            packNullToTaggedValue() :
            packPtrToTaggedValue(builder->CreateIntToPtr(current_outer_list, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
        
        // Cons row onto outer list
        Value* new_outer_cons = codegenTaggedArenaConsCellFromTaggedValue(completed_row_tagged, outer_list_tagged);
        builder->CreateStore(new_outer_cons, outer_list);
        
        builder->CreateBr(convert_outer_cond);
        
        builder->SetInsertPoint(convert_outer_exit);
        
        // JACOBIAN FIX: Create 1D tensor containing row lists as elements
        // This displays as #((row1) (row2)) - tensor prefix with nested row structure
        
        // Allocate result tensor (1D, m elements where each is a row list pointer)
        Value* result_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_tensor_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_tensor = builder->CreatePointerCast(result_tensor_ptr, builder->getPtrTy());
        
        // Set dimensions: [m] (1D vector of m rows)
        Value* result_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(m, typed_result_dims);
        
        // Set tensor fields
        builder->CreateStore(typed_result_dims,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 0)); // dimensions
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 1)); // num_dimensions = 1
        builder->CreateStore(m,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 3)); // total_elements = m
        
        // Allocate elements array (m pointers to row lists)
        Value* result_elems_size = builder->CreateMul(m,
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* result_elems_ptr = builder->CreateCall(malloc_func, {result_elems_size});
        Value* typed_result_elems = builder->CreatePointerCast(result_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_result_elems,
            builder->CreateStructGEP(tensor_type, typed_result_tensor, 2)); // elements
        
        // Fill elements array with row list pointers (extract from nested list)
        BasicBlock* fill_tensor_cond = BasicBlock::Create(*context, "jac_fill_tensor_cond", current_func);
        BasicBlock* fill_tensor_body = BasicBlock::Create(*context, "jac_fill_tensor_body", current_func);
        BasicBlock* fill_tensor_exit = BasicBlock::Create(*context, "jac_fill_tensor_exit", current_func);
        
        Value* fill_idx = builder->CreateAlloca(int64_type, nullptr, "fill_idx");
        Value* list_walker = builder->CreateAlloca(int64_type, nullptr, "list_walker");
        
        Value* final_nested_list = builder->CreateLoad(int64_type, outer_list);
        builder->CreateStore(ConstantInt::get(int64_type, 0), fill_idx);
        builder->CreateStore(final_nested_list, list_walker);
        builder->CreateBr(fill_tensor_cond);
        
        builder->SetInsertPoint(fill_tensor_cond);
        Value* fill_i = builder->CreateLoad(int64_type, fill_idx);
        Value* walker_val = builder->CreateLoad(int64_type, list_walker);
        Value* fill_i_less_m = builder->CreateICmpULT(fill_i, m);
        Value* walker_not_null = builder->CreateICmpNE(walker_val, ConstantInt::get(int64_type, 0));
        Value* continue_fill = builder->CreateAnd(fill_i_less_m, walker_not_null);
        builder->CreateCondBr(continue_fill, fill_tensor_body, fill_tensor_exit);
        
        builder->SetInsertPoint(fill_tensor_body);
        
        // Extract car (row list pointer) from current cons cell
        Value* walker_cons_ptr = builder->CreateIntToPtr(walker_val, builder->getPtrTy());
        Value* row_list_tagged_fill = extractCarAsTaggedValue(walker_val);
        Value* row_list_ptr = unpackInt64FromTaggedValue(row_list_tagged_fill);
        
        // Store row list pointer in tensor elements array
        Value* elem_slot = builder->CreateGEP(int64_type, typed_result_elems, fill_i);
        builder->CreateStore(row_list_ptr, elem_slot);
        
        // Move to next row (cdr)
        Value* is_cdr_walker = ConstantInt::get(int1_type, 1);
        Value* next_walker = builder->CreateCall(getTaggedConsGetPtrFunc(),
            {walker_cons_ptr, is_cdr_walker});
        builder->CreateStore(next_walker, list_walker);
        
        Value* next_fill_idx = builder->CreateAdd(fill_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_fill_idx, fill_idx);
        builder->CreateBr(fill_tensor_cond);
        
        builder->SetInsertPoint(fill_tensor_exit);
        
        // Return tensor of row lists as TENSOR_PTR
        Value* jac_result_int = builder->CreatePtrToInt(typed_result_tensor, int64_type);
        Value* jac_result = packPtrToTaggedValue(jac_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(jac_return_block);
        
        // Merge null and valid results
        builder->SetInsertPoint(jac_return_block);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2, "jac_result");
        result_phi->addIncoming(null_jac_tagged, output_invalid_block);
        result_phi->addIncoming(jac_result, fill_tensor_exit);
        
#endif
    // ===== PHASE 3: HESSIAN OPERATOR IMPLEMENTATION =====
    // Matrix of second derivatives (Jacobian of gradient)
    
    Value* codegenHessian(const eshkol_operations_t* op) {
        if (!op->hessian_op.function || !op->hessian_op.point) {
            eshkol_error("Invalid hessian operation");
            return nullptr;
        }
        
        eshkol_info("Computing Hessian matrix (second derivatives)");
        
        // CRITICAL FIX: Must null-check before dyn_cast to avoid LLVM assertion
        Value* func = resolveLambdaFunction(op->hessian_op.function);
        if (!func) {
            eshkol_error("Failed to resolve function for Hessian computation");
            return nullptr;
        }
        
        Function* func_ptr = dyn_cast<Function>(func);
        if (!func_ptr) {
            eshkol_error("Hessian requires function");
            return nullptr;
        }
        
        TypedValue vector_tv = codegenTypedAST(op->hessian_op.point);
        if (!vector_tv.llvm_value) {
            eshkol_error("Failed to evaluate Hessian point");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        // Get current function for basic blocks
        Function* current_func = builder->GetInsertBlock()->getParent();

        // Convert TypedValue to tagged_value
        Value* vector_val = typedValueToTaggedValue(vector_tv);

        Value* input_type = getTaggedValueType(vector_val);
        Value* input_base_type = builder->CreateAnd(input_type,
            ConstantInt::get(int8_type, 0x0F));

        // Check if input is Scheme VECTOR_PTR (needs conversion to tensor format)
        Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* hess_scheme_vector_input = BasicBlock::Create(*context, "hess_scheme_vector", current_func);
        BasicBlock* hess_tensor_input = BasicBlock::Create(*context, "hess_tensor_input", current_func);
        BasicBlock* hess_merge_input = BasicBlock::Create(*context, "hess_merge_input", current_func);

        builder->CreateCondBr(is_scheme_vector, hess_scheme_vector_input, hess_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(hess_scheme_vector_input);

        Value* hess_scheme_vec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* hess_scheme_vec_ptr = builder->CreateIntToPtr(hess_scheme_vec_ptr_int, builder->getPtrTy());
        Value* hess_scheme_len_ptr = builder->CreateBitCast(hess_scheme_vec_ptr, PointerType::getUnqual(*context));
        Value* hess_scheme_len = builder->CreateLoad(int64_type, hess_scheme_len_ptr);

        // Allocate tensor
        Value* hess_scheme_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* hess_scheme_tensor_ptr = builder->CreateCall(malloc_func, {hess_scheme_tensor_size});
        Value* hess_typed_scheme_tensor = builder->CreatePointerCast(hess_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* hess_scheme_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* hess_scheme_dims_ptr = builder->CreateCall(malloc_func, {hess_scheme_dims_size});
        Value* hess_typed_scheme_dims = builder->CreatePointerCast(hess_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(hess_scheme_len, hess_typed_scheme_dims);

        builder->CreateStore(hess_typed_scheme_dims, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 1));
        builder->CreateStore(hess_scheme_len, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* hess_scheme_elems_size = builder->CreateMul(hess_scheme_len,
            ConstantInt::get(int64_type, sizeof(int64_t)));
        Value* hess_scheme_elems_ptr = builder->CreateCall(malloc_func, {hess_scheme_elems_size});
        Value* hess_typed_scheme_elems = builder->CreatePointerCast(hess_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(hess_typed_scheme_elems, builder->CreateStructGEP(tensor_type, hess_typed_scheme_tensor, 2));

        // Copy elements loop
        Value* hess_scheme_elem_base = builder->CreateGEP(int8_type, hess_scheme_vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* hess_scheme_elem_base_typed = builder->CreateBitCast(hess_scheme_elem_base, PointerType::getUnqual(*context));

        BasicBlock* hess_svec_copy_cond = BasicBlock::Create(*context, "hess_svec_copy_cond", current_func);
        BasicBlock* hess_svec_copy_body = BasicBlock::Create(*context, "hess_svec_copy_body", current_func);
        BasicBlock* hess_svec_copy_done = BasicBlock::Create(*context, "hess_svec_copy_done", current_func);

        Value* hess_svec_copy_i = builder->CreateAlloca(int64_type, nullptr, "hess_svec_copy_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), hess_svec_copy_i);
        builder->CreateBr(hess_svec_copy_cond);

        builder->SetInsertPoint(hess_svec_copy_cond);
        Value* hess_svec_i = builder->CreateLoad(int64_type, hess_svec_copy_i);
        Value* hess_svec_cond = builder->CreateICmpULT(hess_svec_i, hess_scheme_len);
        builder->CreateCondBr(hess_svec_cond, hess_svec_copy_body, hess_svec_copy_done);

        builder->SetInsertPoint(hess_svec_copy_body);
        Value* hess_svec_src_ptr = builder->CreateGEP(tagged_value_type, hess_scheme_elem_base_typed, hess_svec_i);
        Value* hess_svec_tagged_elem = builder->CreateLoad(tagged_value_type, hess_svec_src_ptr);
        Value* hess_svec_double_val = unpackDoubleFromTaggedValue(hess_svec_tagged_elem);
        Value* hess_svec_as_int64 = builder->CreateBitCast(hess_svec_double_val, int64_type);
        Value* hess_svec_dst_ptr = builder->CreateGEP(int64_type, hess_typed_scheme_elems, hess_svec_i);
        builder->CreateStore(hess_svec_as_int64, hess_svec_dst_ptr);
        Value* hess_svec_next_i = builder->CreateAdd(hess_svec_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(hess_svec_next_i, hess_svec_copy_i);
        builder->CreateBr(hess_svec_copy_cond);

        builder->SetInsertPoint(hess_svec_copy_done);
        Value* hess_scheme_tensor_int = builder->CreatePtrToInt(hess_typed_scheme_tensor, int64_type);
        Value* hess_scheme_vector_tagged = packPtrToTaggedValue(hess_scheme_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(hess_merge_input);
        BasicBlock* hess_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(hess_tensor_input);
        builder->CreateBr(hess_merge_input);
        BasicBlock* hess_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(hess_merge_input);
        PHINode* hess_actual_input = builder->CreatePHI(tagged_value_type, 2, "hess_input");
        hess_actual_input->addIncoming(hess_scheme_vector_tagged, hess_scheme_exit);
        hess_actual_input->addIncoming(vector_val, hess_tensor_exit);

        // Extract tensor pointer from merged input
        Value* vector_ptr_int = safeExtractInt64(hess_actual_input);

        // Use class member tensor_type (shared by all tensor operations)

        // Extract input dimension n
        Value* input_ptr = builder->CreateIntToPtr(vector_ptr_int, builder->getPtrTy());
        
        Value* input_dims_field = builder->CreateStructGEP(tensor_type, input_ptr, 0);
        Value* input_dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_dims_field);
        Value* typed_input_dims = builder->CreatePointerCast(input_dims_ptr, builder->getPtrTy());
        
        Value* input_elements_field = builder->CreateStructGEP(tensor_type, input_ptr, 2);
        Value* input_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), input_elements_field);
        Value* typed_input_elements = builder->CreatePointerCast(input_elements_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(int64_type, typed_input_dims,
            ConstantInt::get(int64_type, 0));
        Value* n = builder->CreateLoad(int64_type, n_ptr);

        // Allocate n×n Hessian matrix
        Value* hess_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* hess_ptr = builder->CreateCall(malloc_func, {hess_tensor_size});
        Value* typed_hess_ptr = builder->CreatePointerCast(hess_ptr, builder->getPtrTy());
        
        // Set dimensions [n, n]
        Value* hess_dims_size = builder->CreateMul(
            ConstantInt::get(int64_type, 2),
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* hess_dims_ptr = builder->CreateCall(malloc_func, {hess_dims_size});
        Value* typed_hess_dims = builder->CreatePointerCast(hess_dims_ptr, builder->getPtrTy());
        
        builder->CreateStore(n, typed_hess_dims);
        Value* hess_dim1_slot = builder->CreateGEP(int64_type, typed_hess_dims,
            ConstantInt::get(int64_type, 1));
        builder->CreateStore(n, hess_dim1_slot);
        
        Value* hess_dims_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 0);
        builder->CreateStore(typed_hess_dims, hess_dims_field);
        
        Value* hess_num_dims_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 2), hess_num_dims_field);
        
        Value* total_hess_elems = builder->CreateMul(n, n);
        Value* hess_total_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 3);
        builder->CreateStore(total_hess_elems, hess_total_field);
        
        // Allocate elements array
        Value* hess_elems_size = builder->CreateMul(total_hess_elems,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* hess_elems_ptr = builder->CreateCall(malloc_func, {hess_elems_size});
        Value* typed_hess_elems = builder->CreatePointerCast(hess_elems_ptr, builder->getPtrTy());
        
        Value* hess_elems_field = builder->CreateStructGEP(tensor_type, typed_hess_ptr, 2);
        builder->CreateStore(typed_hess_elems, hess_elems_field);
        
        // Numerical differentiation epsilon
        Value* epsilon = ConstantFP::get(double_type, 1e-8);
        
        // Compute gradient at original point first
        // Create gradient operation structure - but we can't easily do this
        // Instead, inline the gradient computation
        
        // Allocate array for base gradient
        Value* base_grad_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* base_grad_ptr = builder->CreateCall(malloc_func, {base_grad_size});
        Value* typed_base_grad = builder->CreatePointerCast(base_grad_ptr, builder->getPtrTy());
        
        // Compute base gradient (similar to codegenGradient but store in array)
        BasicBlock* base_grad_loop_cond = BasicBlock::Create(*context, "base_grad_cond", current_func);
        BasicBlock* base_grad_loop_body = BasicBlock::Create(*context, "base_grad_body", current_func);
        BasicBlock* base_grad_loop_exit = BasicBlock::Create(*context, "base_grad_exit", current_func);
        
        Value* base_grad_idx = builder->CreateAlloca(int64_type, nullptr, "base_grad_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), base_grad_idx);
        builder->CreateBr(base_grad_loop_cond);
        
        builder->SetInsertPoint(base_grad_loop_cond);
        Value* bg_i = builder->CreateLoad(int64_type, base_grad_idx);
        Value* bg_i_less_n = builder->CreateICmpULT(bg_i, n);
        builder->CreateCondBr(bg_i_less_n, base_grad_loop_body, base_grad_loop_exit);
        
        builder->SetInsertPoint(base_grad_loop_body);
        
        // Create tape and AD nodes
        Value* arena_ptr = getArenaPtr();
        Value* bg_tape = builder->CreateCall(getArenaAllocateTapeFunc(),
            {arena_ptr, ConstantInt::get(int64_type, 1024)});
        
        // CRITICAL: Set global tape pointer (runtime Value*, not compile-time member)
        builder->CreateStore(bg_tape, current_ad_tape);
        
        // Create variable nodes
        Value* bg_nodes_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(void*)));
        Value* bg_nodes_ptr = builder->CreateCall(malloc_func, {bg_nodes_size});
        Value* typed_bg_nodes = builder->CreatePointerCast(bg_nodes_ptr, builder->getPtrTy());
        
        // Initialize nodes loop
        BasicBlock* bg_init_cond = BasicBlock::Create(*context, "bg_init_cond", current_func);
        BasicBlock* bg_init_body = BasicBlock::Create(*context, "bg_init_body", current_func);
        BasicBlock* bg_init_exit = BasicBlock::Create(*context, "bg_init_exit", current_func);
        
        Value* bg_init_idx = builder->CreateAlloca(int64_type, nullptr, "bg_init_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), bg_init_idx);
        builder->CreateBr(bg_init_cond);
        
        builder->SetInsertPoint(bg_init_cond);
        Value* bg_j = builder->CreateLoad(int64_type, bg_init_idx);
        Value* bg_j_less_n = builder->CreateICmpULT(bg_j, n);
        builder->CreateCondBr(bg_j_less_n, bg_init_body, bg_init_exit);
        
        builder->SetInsertPoint(bg_init_body);
        // CRITICAL FIX: Tensor elements stored as int64, load as int64 then convert
        Value* bg_elem_ptr = builder->CreateGEP(int64_type,
            typed_input_elements, bg_j);
        Value* bg_elem_int64 = builder->CreateLoad(int64_type, bg_elem_ptr);
        // FIX 1c: BitCast preserves IEEE754 bits, SIToFP corrupts them
        Value* bg_elem = builder->CreateBitCast(bg_elem_int64, double_type);
        Value* bg_node = createADVariable(bg_elem, 0);
        
        Value* bg_node_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_j);
        builder->CreateStore(bg_node, bg_node_slot);
        
        Value* bg_next_j = builder->CreateAdd(bg_j, ConstantInt::get(int64_type, 1));
        builder->CreateStore(bg_next_j, bg_init_idx);
        builder->CreateBr(bg_init_cond);
        
        builder->SetInsertPoint(bg_init_exit);
        
        // Build and call function (similar to gradient)
        Value* bg_ad_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* bg_ad_tensor_ptr = builder->CreateCall(malloc_func, {bg_ad_tensor_size});
        Value* typed_bg_ad_tensor = builder->CreatePointerCast(bg_ad_tensor_ptr, builder->getPtrTy());
        
        Value* bg_ad_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* bg_ad_dims_ptr = builder->CreateCall(malloc_func, {bg_ad_dims_size});
        Value* typed_bg_ad_dims = builder->CreatePointerCast(bg_ad_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_bg_ad_dims);
        
        builder->CreateStore(typed_bg_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 3));
        
        Value* bg_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* bg_ad_elems_ptr = builder->CreateCall(malloc_func, {bg_ad_elems_size});
        Value* typed_bg_ad_elems = builder->CreatePointerCast(bg_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_bg_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_bg_ad_tensor, 2));
        
        // Copy nodes
        BasicBlock* bg_copy_cond = BasicBlock::Create(*context, "bg_copy_cond", current_func);
        BasicBlock* bg_copy_body = BasicBlock::Create(*context, "bg_copy_body", current_func);
        BasicBlock* bg_copy_exit = BasicBlock::Create(*context, "bg_copy_exit", current_func);
        
        Value* bg_copy_idx = builder->CreateAlloca(int64_type, nullptr, "bg_copy_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), bg_copy_idx);
        builder->CreateBr(bg_copy_cond);
        
        builder->SetInsertPoint(bg_copy_cond);
        Value* bg_k = builder->CreateLoad(int64_type, bg_copy_idx);
        Value* bg_k_less_n = builder->CreateICmpULT(bg_k, n);
        builder->CreateCondBr(bg_k_less_n, bg_copy_body, bg_copy_exit);
        
        builder->SetInsertPoint(bg_copy_body);
        Value* bg_src_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_k);
        Value* bg_src_node = builder->CreateLoad(PointerType::getUnqual(*context), bg_src_slot);
        Value* bg_node_int = builder->CreatePtrToInt(bg_src_node, int64_type);
        
        Value* bg_dst_slot = builder->CreateGEP(int64_type,
            typed_bg_ad_elems, bg_k);
        builder->CreateStore(bg_node_int, bg_dst_slot);
        
        Value* bg_next_k = builder->CreateAdd(bg_k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(bg_next_k, bg_copy_idx);
        builder->CreateBr(bg_copy_cond);
        
        builder->SetInsertPoint(bg_copy_exit);
        
        // Call function
        Value* bg_ad_tensor_int = builder->CreatePtrToInt(typed_bg_ad_tensor, int64_type);
        Value* bg_ad_tensor_tagged = packPtrToTaggedValue(bg_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // PHASE 1 FIX: Set AD mode flag to true before calling lambda
        builder->CreateStore(ConstantInt::get(int1_type, 1), ad_mode_active);

        // CLOSURE FIX: Load captures for function call
        std::vector<Value*> bg_call_args = {bg_ad_tensor_tagged};
        std::vector<Value*> bg_captures = loadCapturesForAutodiff(func_ptr, "Hessian backward call");
        bg_call_args.insert(bg_call_args.end(), bg_captures.begin(), bg_captures.end());
        Value* bg_output_tagged = builder->CreateCall(func_ptr, bg_call_args);

        // PHASE 1 FIX: Set AD mode flag back to false after lambda call
        builder->CreateStore(ConstantInt::get(int1_type, 0), ad_mode_active);

        Value* bg_output_int = unpackInt64FromTaggedValue(bg_output_tagged);
        Value* bg_output_node = builder->CreateIntToPtr(bg_output_int, PointerType::getUnqual(*context));
        
        // Backward pass
        codegenBackward(bg_output_node, bg_tape);
        
        // Extract gradient for component bg_i
        Value* bg_active_slot = builder->CreateGEP(PointerType::getUnqual(*context),
            typed_bg_nodes, bg_i);
        Value* bg_active_node = builder->CreateLoad(PointerType::getUnqual(*context), bg_active_slot);
        Value* bg_partial = loadNodeGradient(bg_active_node);
        
        // Store in base gradient array
        Value* bg_store_ptr = builder->CreateGEP(double_type,
            typed_base_grad, bg_i);
        builder->CreateStore(bg_partial, bg_store_ptr);
        
        builder->CreateCall(getArenaTapeResetFunc(), {bg_tape});
        
        // Clear global tape pointer
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* bg_next_i = builder->CreateAdd(bg_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(bg_next_i, base_grad_idx);
        builder->CreateBr(base_grad_loop_cond);
        
        builder->SetInsertPoint(base_grad_loop_exit);
        
        // NUMERICAL DIFFERENTIATION: Compute Hessian H[i,j] = ∂²f/∂xᵢ∂xⱼ
        // Using finite difference: H[i,j] ≈ (∇ᵢf(v+ε·eⱼ) - ∇ᵢf(v)) / ε
        // Outer loop: for each column j (variable to perturb)
        
        // CRITICAL: Load arena_ptr ONCE before loops to ensure dominance
        Value* hess_arena_ptr = getArenaPtr();
        
        BasicBlock* hess_col_cond = BasicBlock::Create(*context, "hess_col_cond", current_func);
        BasicBlock* hess_col_body = BasicBlock::Create(*context, "hess_col_body", current_func);
        BasicBlock* hess_col_exit = BasicBlock::Create(*context, "hess_col_exit", current_func);
        
        Value* hess_j_idx = builder->CreateAlloca(int64_type, nullptr, "hess_j_col");
        builder->CreateStore(ConstantInt::get(int64_type, 0), hess_j_idx);
        builder->CreateBr(hess_col_cond);
        
        // Column loop condition: j < n
        builder->SetInsertPoint(hess_col_cond);
        Value* hess_j = builder->CreateLoad(int64_type, hess_j_idx);
        Value* hess_j_less_n = builder->CreateICmpULT(hess_j, n);
        builder->CreateCondBr(hess_j_less_n, hess_col_body, hess_col_exit);
        
        builder->SetInsertPoint(hess_col_body);
        
        // Step 1: Create perturbed vector v_j = v + ε·e_j
        Value* perturbed_vec_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* perturbed_vec_ptr = builder->CreateCall(malloc_func, {perturbed_vec_size});
        Value* typed_perturbed_vec = builder->CreatePointerCast(perturbed_vec_ptr, builder->getPtrTy());
        
        // Copy input vector and perturb j-th component
        BasicBlock* copy_loop_cond = BasicBlock::Create(*context, "hess_copy_cond", current_func);
        BasicBlock* copy_loop_body = BasicBlock::Create(*context, "hess_copy_body", current_func);
        BasicBlock* copy_loop_exit = BasicBlock::Create(*context, "hess_copy_exit", current_func);
        
        Value* copy_k_idx = builder->CreateAlloca(int64_type, nullptr, "copy_k");
        builder->CreateStore(ConstantInt::get(int64_type, 0), copy_k_idx);
        builder->CreateBr(copy_loop_cond);
        
        builder->SetInsertPoint(copy_loop_cond);
        Value* copy_k = builder->CreateLoad(int64_type, copy_k_idx);
        Value* copy_k_less_n = builder->CreateICmpULT(copy_k, n);
        builder->CreateCondBr(copy_k_less_n, copy_loop_body, copy_loop_exit);
        
        builder->SetInsertPoint(copy_loop_body);
        
        // Load input[k]
        Value* input_k_ptr = builder->CreateGEP(int64_type, typed_input_elements, copy_k);
        Value* input_k_int64 = builder->CreateLoad(int64_type, input_k_ptr);
        Value* input_k_double = builder->CreateBitCast(input_k_int64, double_type);
        
        // If k == j, add epsilon; otherwise copy as-is
        Value* k_is_j = builder->CreateICmpEQ(copy_k, hess_j);
        Value* perturbed_val = builder->CreateSelect(k_is_j,
            builder->CreateFAdd(input_k_double, epsilon),
            input_k_double);
        
        // Store in perturbed vector
        Value* pert_k_ptr = builder->CreateGEP(double_type, typed_perturbed_vec, copy_k);
        builder->CreateStore(perturbed_val, pert_k_ptr);
        
        Value* copy_k_next = builder->CreateAdd(copy_k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(copy_k_next, copy_k_idx);
        builder->CreateBr(copy_loop_cond);
        
        builder->SetInsertPoint(copy_loop_exit);
        
        // Step 2: Compute gradient at perturbed point
        // Create tape for perturbed gradient computation
        Value* pert_tape = builder->CreateCall(getArenaAllocateTapeFunc(),
            {hess_arena_ptr, ConstantInt::get(int64_type, 1024)});
        
        // Create AD variable nodes from perturbed vector
        Value* pert_nodes_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(void*)));
        Value* pert_nodes_ptr = builder->CreateCall(malloc_func, {pert_nodes_size});
        Value* typed_pert_nodes = builder->CreatePointerCast(pert_nodes_ptr, builder->getPtrTy());
        
        // Initialize perturbed variable nodes
        BasicBlock* pert_init_cond = BasicBlock::Create(*context, "pert_init_cond", current_func);
        BasicBlock* pert_init_body = BasicBlock::Create(*context, "pert_init_body", current_func);
        BasicBlock* pert_init_exit = BasicBlock::Create(*context, "pert_init_exit", current_func);
        
        Value* pert_init_idx = builder->CreateAlloca(int64_type, nullptr, "pert_init_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), pert_init_idx);
        builder->CreateBr(pert_init_cond);
        
        builder->SetInsertPoint(pert_init_cond);
        Value* pert_k = builder->CreateLoad(int64_type, pert_init_idx);
        Value* pert_k_less_n = builder->CreateICmpULT(pert_k, n);
        builder->CreateCondBr(pert_k_less_n, pert_init_body, pert_init_exit);
        
        builder->SetInsertPoint(pert_init_body);
        
        Value* pert_elem_ptr = builder->CreateGEP(double_type, typed_perturbed_vec, pert_k);
        Value* pert_elem_val = builder->CreateLoad(double_type, pert_elem_ptr);
        Value* hess_pert_var_node = createADVariable(pert_elem_val, 0);
        
        Value* hess_pert_node_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, pert_k);
        builder->CreateStore(hess_pert_var_node, hess_pert_node_slot);
        
        Value* pert_k_next = builder->CreateAdd(pert_k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(pert_k_next, pert_init_idx);
        builder->CreateBr(pert_init_cond);
        
        builder->SetInsertPoint(pert_init_exit);
        
        // Build AD tensor from perturbed nodes
        Value* pert_ad_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* pert_ad_tensor_ptr = builder->CreateCall(malloc_func, {pert_ad_tensor_size});
        Value* typed_pert_ad_tensor = builder->CreatePointerCast(pert_ad_tensor_ptr, builder->getPtrTy());
        
        // Set tensor dimensions
        Value* pert_ad_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* pert_ad_dims_ptr = builder->CreateCall(malloc_func, {pert_ad_dims_size});
        Value* typed_pert_ad_dims = builder->CreatePointerCast(pert_ad_dims_ptr, builder->getPtrTy());
        builder->CreateStore(n, typed_pert_ad_dims);
        
        builder->CreateStore(typed_pert_ad_dims,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 1));
        builder->CreateStore(n,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 3));
        
        // Allocate and fill AD tensor elements
        Value* pert_ad_elems_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(uint64_t)));
        Value* pert_ad_elems_ptr = builder->CreateCall(malloc_func, {pert_ad_elems_size});
        Value* typed_pert_ad_elems = builder->CreatePointerCast(pert_ad_elems_ptr, builder->getPtrTy());
        
        builder->CreateStore(typed_pert_ad_elems,
            builder->CreateStructGEP(tensor_type, typed_pert_ad_tensor, 2));
        
        // Copy perturbed node pointers into AD tensor
        BasicBlock* pert_copy_cond = BasicBlock::Create(*context, "pert_copy_cond", current_func);
        BasicBlock* pert_copy_body = BasicBlock::Create(*context, "pert_copy_body", current_func);
        BasicBlock* pert_copy_exit = BasicBlock::Create(*context, "pert_copy_exit", current_func);
        
        Value* pert_copy_idx = builder->CreateAlloca(int64_type, nullptr, "pert_copy_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), pert_copy_idx);
        builder->CreateBr(pert_copy_cond);
        
        builder->SetInsertPoint(pert_copy_cond);
        Value* pert_copy_k = builder->CreateLoad(int64_type, pert_copy_idx);
        Value* pert_copy_less_n = builder->CreateICmpULT(pert_copy_k, n);
        builder->CreateCondBr(pert_copy_less_n, pert_copy_body, pert_copy_exit);
        
        builder->SetInsertPoint(pert_copy_body);
        
        Value* pert_src_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, pert_copy_k);
        Value* pert_src_node = builder->CreateLoad(PointerType::getUnqual(*context), pert_src_slot);
        Value* pert_node_int = builder->CreatePtrToInt(pert_src_node, int64_type);
        
        Value* pert_dst_slot = builder->CreateGEP(int64_type, typed_pert_ad_elems, pert_copy_k);
        builder->CreateStore(pert_node_int, pert_dst_slot);
        
        Value* pert_copy_next = builder->CreateAdd(pert_copy_k, ConstantInt::get(int64_type, 1));
        builder->CreateStore(pert_copy_next, pert_copy_idx);
        builder->CreateBr(pert_copy_cond);
        
        builder->SetInsertPoint(pert_copy_exit);
        
        // Call function with perturbed AD tensor
        Value* pert_ad_tensor_int = builder->CreatePtrToInt(typed_pert_ad_tensor, int64_type);
        Value* pert_ad_tensor_tagged = packPtrToTaggedValue(pert_ad_tensor_int, ESHKOL_VALUE_TENSOR_PTR);
        
        // Set AD mode and tape
        builder->CreateStore(ConstantInt::get(int1_type, 1), ad_mode_active);
        builder->CreateStore(pert_tape, current_ad_tape);

        // CLOSURE FIX: Load captures for function call
        std::vector<Value*> pert_call_args = {pert_ad_tensor_tagged};
        std::vector<Value*> pert_captures = loadCapturesForAutodiff(func_ptr, "Hessian perturbation call");
        pert_call_args.insert(pert_call_args.end(), pert_captures.begin(), pert_captures.end());
        Value* pert_output_tagged = builder->CreateCall(func_ptr, pert_call_args);

        // Reset AD mode and tape
        builder->CreateStore(ConstantInt::get(int1_type, 0), ad_mode_active);
        builder->CreateStore(ConstantPointerNull::get(PointerType::getUnqual(*context)), current_ad_tape);
        
        Value* pert_output_int = unpackInt64FromTaggedValue(pert_output_tagged);
        Value* pert_output_node = builder->CreateIntToPtr(pert_output_int, PointerType::getUnqual(*context));
        
        // Run backward pass
        codegenBackward(pert_output_node, pert_tape);
        
        // Allocate array for perturbed gradient
        Value* pert_grad_size = builder->CreateMul(n,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* pert_grad_ptr = builder->CreateCall(malloc_func, {pert_grad_size});
        Value* typed_pert_grad = builder->CreatePointerCast(pert_grad_ptr, builder->getPtrTy());
        
        // Extract perturbed gradient into array
        BasicBlock* pert_extract_cond = BasicBlock::Create(*context, "pert_extract_cond", current_func);
        BasicBlock* pert_extract_body = BasicBlock::Create(*context, "pert_extract_body", current_func);
        BasicBlock* pert_extract_exit = BasicBlock::Create(*context, "pert_extract_exit", current_func);
        
        Value* pert_extract_idx = builder->CreateAlloca(int64_type, nullptr, "pert_extract_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), pert_extract_idx);
        builder->CreateBr(pert_extract_cond);
        
        builder->SetInsertPoint(pert_extract_cond);
        Value* extract_i = builder->CreateLoad(int64_type, pert_extract_idx);
        Value* extract_less_n = builder->CreateICmpULT(extract_i, n);
        builder->CreateCondBr(extract_less_n, pert_extract_body, pert_extract_exit);
        
        builder->SetInsertPoint(pert_extract_body);
        
        // Get gradient from variable node i
        Value* hess_pert_var_slot = builder->CreateGEP(PointerType::getUnqual(*context), typed_pert_nodes, extract_i);
        Value* hess_pert_var_node_load = builder->CreateLoad(PointerType::getUnqual(*context), hess_pert_var_slot);
        Value* hess_pert_grad_i = loadNodeGradient(hess_pert_var_node_load);
        
        // Store in perturbed gradient array
        Value* hess_pert_grad_store_ptr = builder->CreateGEP(double_type, typed_pert_grad, extract_i);
        builder->CreateStore(hess_pert_grad_i, hess_pert_grad_store_ptr);
        
        Value* extract_next = builder->CreateAdd(extract_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(extract_next, pert_extract_idx);
        builder->CreateBr(pert_extract_cond);
        
        builder->SetInsertPoint(pert_extract_exit);
        
        // Step 3: Compute H[i,j] for all rows i
        BasicBlock* hess_row_cond = BasicBlock::Create(*context, "hess_row_cond", current_func);
        BasicBlock* hess_row_body = BasicBlock::Create(*context, "hess_row_body", current_func);
        BasicBlock* hess_row_exit = BasicBlock::Create(*context, "hess_row_exit", current_func);
        
        Value* hess_i_idx = builder->CreateAlloca(int64_type, nullptr, "hess_i_row");
        builder->CreateStore(ConstantInt::get(int64_type, 0), hess_i_idx);
        builder->CreateBr(hess_row_cond);
        
        builder->SetInsertPoint(hess_row_cond);
        Value* hess_i = builder->CreateLoad(int64_type, hess_i_idx);
        Value* hess_i_less_n = builder->CreateICmpULT(hess_i, n);
        builder->CreateCondBr(hess_i_less_n, hess_row_body, hess_row_exit);
        
        builder->SetInsertPoint(hess_row_body);
        
        // Load base_grad[i]
        Value* base_grad_i_ptr = builder->CreateGEP(double_type, typed_base_grad, hess_i);
        Value* base_grad_i = builder->CreateLoad(double_type, base_grad_i_ptr);
        
        // Load pert_grad[i]
        Value* hess_pert_grad_i_ptr = builder->CreateGEP(double_type, typed_pert_grad, hess_i);
        Value* hess_pert_grad_i_val = builder->CreateLoad(double_type, hess_pert_grad_i_ptr);
        
        // Compute H[i,j] = (pert_grad[i] - base_grad[i]) / epsilon
        Value* grad_diff = builder->CreateFSub(hess_pert_grad_i_val, base_grad_i);
        Value* second_deriv = builder->CreateFDiv(grad_diff, epsilon);
        
        // Store H[i,j] in Hessian matrix (row-major: i*n + j)
        Value* hess_linear_idx = builder->CreateMul(hess_i, n);
        hess_linear_idx = builder->CreateAdd(hess_linear_idx, hess_j);
        Value* hess_store_ptr = builder->CreateGEP(double_type, typed_hess_elems, hess_linear_idx);
        builder->CreateStore(second_deriv, hess_store_ptr);
        
        Value* hess_i_next = builder->CreateAdd(hess_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(hess_i_next, hess_i_idx);
        builder->CreateBr(hess_row_cond);
        
        builder->SetInsertPoint(hess_row_exit);
        
        // Reset tape for next column
        builder->CreateCall(getArenaTapeResetFunc(), {pert_tape});
        
        // Next column
        Value* hess_j_next = builder->CreateAdd(hess_j, ConstantInt::get(int64_type, 1));
        builder->CreateStore(hess_j_next, hess_j_idx);
        builder->CreateBr(hess_col_cond);
        
        builder->SetInsertPoint(hess_col_exit);
        
        eshkol_info("Hessian computation complete");
        // Tag as TENSOR_PTR for proper display handling
        Value* hess_result_int = builder->CreatePtrToInt(typed_hess_ptr, int64_type);
        return packPtrToTaggedValue(hess_result_int, ESHKOL_VALUE_TENSOR_PTR);
    }
    // ===== N-DIMENSIONAL NULL VECTOR HELPER =====
    // Create n-dimensional null vector (all zeros) for error handling
    // Handles ANY dimension at runtime - NEVER hardcode dimensions!
    Value* createNullVectorTensor(Value* dimension) {
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for null vector creation");
            return ConstantInt::get(int64_type, 0);
        }
        
        Function* current_func = builder->GetInsertBlock()->getParent();
        
        // Allocate tensor structure
        Value* tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* tensor_ptr = builder->CreateCall(malloc_func, {tensor_size});
        Value* typed_tensor_ptr = builder->CreatePointerCast(tensor_ptr, builder->getPtrTy());
        
        // Allocate dimensions array (1D vector of given dimension)
        Value* dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* dims_ptr = builder->CreateCall(malloc_func, {dims_size});
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        builder->CreateStore(dimension, typed_dims_ptr);  // Runtime dimension!
        
        // Store tensor metadata
        builder->CreateStore(typed_dims_ptr,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 0));  // dimensions
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 1));  // num_dimensions = 1
        builder->CreateStore(dimension,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 3));  // total_elements = dimension
        
        // Allocate elements array (dimension * sizeof(double))
        Value* elems_size = builder->CreateMul(dimension,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* elems_ptr = builder->CreateCall(malloc_func, {elems_size});
        Value* typed_elems_ptr = builder->CreatePointerCast(elems_ptr, builder->getPtrTy());
        
        // Zero all elements using RUNTIME LOOP (n-dimensional!)
        BasicBlock* zero_cond = BasicBlock::Create(*context, "null_vec_zero_cond", current_func);
        BasicBlock* zero_body = BasicBlock::Create(*context, "null_vec_zero_body", current_func);
        BasicBlock* zero_exit = BasicBlock::Create(*context, "null_vec_zero_exit", current_func);
        
        Value* idx_ptr = builder->CreateAlloca(int64_type, nullptr, "zero_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), idx_ptr);
        builder->CreateBr(zero_cond);
        
        builder->SetInsertPoint(zero_cond);
        Value* idx = builder->CreateLoad(int64_type, idx_ptr);
        Value* idx_less = builder->CreateICmpULT(idx, dimension);
        builder->CreateCondBr(idx_less, zero_body, zero_exit);
        
        builder->SetInsertPoint(zero_body);
        Value* elem_ptr = builder->CreateGEP(double_type, typed_elems_ptr, idx);
        builder->CreateStore(ConstantFP::get(double_type, 0.0), elem_ptr);
        Value* next_idx = builder->CreateAdd(idx, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_idx, idx_ptr);
        builder->CreateBr(zero_cond);
        
        builder->SetInsertPoint(zero_exit);
        
        builder->CreateStore(typed_elems_ptr,
            builder->CreateStructGEP(tensor_type, typed_tensor_ptr, 2));  // elements
        
        // Return tensor pointer as i64
        return builder->CreatePtrToInt(typed_tensor_ptr, int64_type);
    }
    
    
    // Helper: Extract J[row,col] from Jacobian's nested list structure
    // Jacobian tensor elements are int64 list pointers (rows), not doubles!
    // Extract element from N-dimensional tensor at given indices
    // For 2D (Jacobian): indices = [row_idx, col_idx]
    // For ND: computes linear index using row-major ordering
    Value* extractTensorElement(Value* tensor_ptr, std::vector<Value*> indices) {
        // Get tensor dimensions
        Value* dims_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());

        Value* num_dims_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(int64_type, num_dims_field);

        // Get elements array
        Value* elements_field = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());

        // Compute linear index using row-major ordering
        // linear_idx = idx[0] * (dims[1] * dims[2] * ...) + idx[1] * (dims[2] * ...) + ... + idx[n-1]
        Value* linear_idx = ConstantInt::get(int64_type, 0);

        for (size_t i = 0; i < indices.size(); i++) {
            // Compute stride for dimension i (product of all subsequent dimensions)
            Value* stride = ConstantInt::get(int64_type, 1);
            for (size_t j = i + 1; j < indices.size(); j++) {
                Value* dim_j_ptr = builder->CreateGEP(int64_type, typed_dims,
                    ConstantInt::get(int64_type, j));
                Value* dim_j = builder->CreateLoad(int64_type, dim_j_ptr);
                stride = builder->CreateMul(stride, dim_j);
            }
            // Add idx[i] * stride to linear index
            Value* contribution = builder->CreateMul(indices[i], stride);
            linear_idx = builder->CreateAdd(linear_idx, contribution);
        }

        // Load element as int64 (bit pattern of double)
        Value* elem_ptr = builder->CreateGEP(int64_type, typed_elements, linear_idx);
        Value* elem_bits = builder->CreateLoad(int64_type, elem_ptr);

        // Convert int64 bit pattern back to double
        Value* elem_double = builder->CreateBitCast(elem_bits, double_type);

        return elem_double;
    }

    // Convenience wrapper for 2D tensors (Jacobian, Hessian)
    Value* extractJacobianElement(Value* jacobian_ptr, Value* row_idx, Value* col_idx, Value* n) {
        // Use the general N-dimensional extractor with 2 indices
        return extractTensorElement(jacobian_ptr, {row_idx, col_idx});
    }
    
    // ===== END PHASE 3 OPERATORS =====
    // ===== PHASE 4: VECTOR CALCULUS OPERATORS =====
    // Differential geometry operators for physics simulations and field theory
    
    // Divergence: ∇·F for vector field F: ℝⁿ → ℝⁿ
    // Returns scalar: ∇·F = ∂F₁/∂x₁ + ∂F₂/∂x₂ + ... + ∂Fₙ/∂xₙ
    // This is the trace of the Jacobian matrix
    Value* codegenDivergence(const eshkol_operations_t* op) {
        if (!op->divergence_op.function || !op->divergence_op.point) {
            eshkol_error("Invalid divergence operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing divergence of vector field");
        
        // The divergence is the sum of diagonal elements of the Jacobian
        // For F: ℝⁿ → ℝⁿ, Jacobian is n×n, divergence is trace(J)
        
        // Compute Jacobian matrix first
        eshkol_operations_t jacobian_temp;
        jacobian_temp.op = ESHKOL_JACOBIAN_OP;
        jacobian_temp.jacobian_op.function = op->divergence_op.function;
        jacobian_temp.jacobian_op.point = op->divergence_op.point;
        
        Value* jacobian_tagged = codegenJacobian(&jacobian_temp);
        if (!jacobian_tagged) {
            eshkol_error("Failed to compute Jacobian for divergence");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Jacobian is a valid tensor (same fix as Jacobian operator)
        Value* jacobian_type = getTaggedValueType(jacobian_tagged);
        Value* jacobian_base_type = builder->CreateAnd(jacobian_type,
            ConstantInt::get(int8_type, 0x0F));
        
        Value* jac_is_tensor_ptr = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* jac_is_ad_tensor = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* jac_is_valid = builder->CreateOr(jac_is_tensor_ptr, jac_is_ad_tensor);
        
        Function* div_current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* jacobian_valid = BasicBlock::Create(*context, "div_jac_valid", div_current_func);
        BasicBlock* jacobian_invalid = BasicBlock::Create(*context, "div_jac_invalid", div_current_func);
        BasicBlock* div_final = BasicBlock::Create(*context, "div_final", div_current_func);
        
        builder->CreateCondBr(jac_is_valid, jacobian_valid, jacobian_invalid);
        
        // Invalid jacobian: return 0.0 instead of crashing (only for genuinely invalid types)
        builder->SetInsertPoint(jacobian_invalid);
        eshkol_debug("Divergence: Jacobian returned non-tensor type, returning 0.0");
        Value* zero_result = ConstantFP::get(double_type, 0.0);
        builder->CreateBr(div_final);
        
        // Valid jacobian: continue with normal computation
        builder->SetInsertPoint(jacobian_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* jacobian_ptr_int = safeExtractInt64(jacobian_tagged);
        Value* jacobian_ptr = builder->CreateIntToPtr(jacobian_ptr_int, builder->getPtrTy());
        
        // Extract dimension n from Jacobian (it's n×n)
        Value* dims_field = builder->CreateStructGEP(tensor_type, jacobian_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(int64_type, typed_dims_ptr,
            ConstantInt::get(int64_type, 0));
        Value* n = builder->CreateLoad(int64_type, n_ptr);
        
        // Get Jacobian elements
        Value* elements_field = builder->CreateStructGEP(tensor_type, jacobian_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Sum diagonal elements: J[0,0] + J[1,1] + ... + J[n-1,n-1]
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* sum_loop_cond = BasicBlock::Create(*context, "div_sum_cond", current_func);
        BasicBlock* sum_loop_body = BasicBlock::Create(*context, "div_sum_body", current_func);
        BasicBlock* sum_loop_exit = BasicBlock::Create(*context, "div_sum_exit", current_func);
        
        Value* sum_idx = builder->CreateAlloca(int64_type, nullptr, "sum_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), sum_idx);
        
        Value* divergence_acc = builder->CreateAlloca(double_type, nullptr, "div_acc");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), divergence_acc);
        
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_cond);
        Value* i = builder->CreateLoad(int64_type, sum_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, sum_loop_body, sum_loop_exit);
        
        builder->SetInsertPoint(sum_loop_body);
        
        // Extract J[i,i] from nested list structure (not direct double access!)
        Value* diagonal_elem = extractJacobianElement(jacobian_ptr, i, i, n);
        
        // Add to accumulator
        Value* current_div = builder->CreateLoad(double_type, divergence_acc);
        Value* new_div = builder->CreateFAdd(current_div, diagonal_elem);
        builder->CreateStore(new_div, divergence_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, sum_idx);
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_exit);
        Value* divergence_result = builder->CreateLoad(double_type, divergence_acc);
        builder->CreateBr(div_final);
        
        // Merge valid and invalid paths
        builder->SetInsertPoint(div_final);
        PHINode* result_phi = builder->CreatePHI(double_type, 2, "div_result");
        result_phi->addIncoming(zero_result, jacobian_invalid);
        result_phi->addIncoming(divergence_result, sum_loop_exit);

        eshkol_info("Divergence computation complete");
        return packDoubleToTaggedValue(result_phi);
    }
    
    // Curl: ∇×F for vector field F: ℝ³ → ℝ³
    // Returns vector: (∇×F) = [∂F₃/∂x₂ - ∂F₂/∂x₃, ∂F₁/∂x₃ - ∂F₃/∂x₁, ∂F₂/∂x₁ - ∂F₁/∂x₂]
    // ONLY defined for 3D vector fields
    Value* codegenCurl(const eshkol_operations_t* op) {
        if (!op->curl_op.function || !op->curl_op.point) {
            eshkol_error("Invalid curl operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing curl of 3D vector field");
        
        // First, validate that input is 3D
        Value* vector_val = codegenAST(op->curl_op.point);
        if (!vector_val) {
            eshkol_error("Failed to evaluate curl point");
            return nullptr;
        }
        
        // CRITICAL FIX: Handle both tensor and Scheme vector inputs
        Value* curl_input_type = getTaggedValueType(vector_val);
        Value* curl_input_base_type = builder->CreateAnd(curl_input_type,
            ConstantInt::get(int8_type, 0x0F));
        Value* curl_is_scheme_vector = builder->CreateICmpEQ(curl_input_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* curl_scheme_input = BasicBlock::Create(*context, "curl_scheme_input", current_func);
        BasicBlock* curl_tensor_input = BasicBlock::Create(*context, "curl_tensor_input", current_func);
        BasicBlock* curl_merge_n = BasicBlock::Create(*context, "curl_merge_n", current_func);

        builder->CreateCondBr(curl_is_scheme_vector, curl_scheme_input, curl_tensor_input);

        // SCHEME VECTOR: Extract dimension from vector length
        builder->SetInsertPoint(curl_scheme_input);
        Value* curl_svec_ptr_int = unpackInt64FromTaggedValue(vector_val);
        Value* curl_svec_ptr = builder->CreateIntToPtr(curl_svec_ptr_int, builder->getPtrTy());
        Value* curl_svec_len_ptr = builder->CreateBitCast(curl_svec_ptr, PointerType::getUnqual(*context));
        Value* curl_svec_n = builder->CreateLoad(int64_type, curl_svec_len_ptr);
        builder->CreateBr(curl_merge_n);
        BasicBlock* curl_scheme_exit = builder->GetInsertBlock();

        // TENSOR: Extract dimension from tensor structure
        builder->SetInsertPoint(curl_tensor_input);
        Value* curl_tensor_ptr_int = safeExtractInt64(vector_val);
        Value* curl_tensor_ptr = builder->CreateIntToPtr(curl_tensor_ptr_int, builder->getPtrTy());
        Value* dims_field = builder->CreateStructGEP(tensor_type, curl_tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        Value* n_ptr = builder->CreateGEP(int64_type, typed_dims_ptr,
            ConstantInt::get(int64_type, 0));
        Value* curl_tensor_n = builder->CreateLoad(int64_type, n_ptr);
        builder->CreateBr(curl_merge_n);
        BasicBlock* curl_tensor_exit = builder->GetInsertBlock();

        // MERGE: Get n from whichever path
        builder->SetInsertPoint(curl_merge_n);
        PHINode* n = builder->CreatePHI(int64_type, 2, "curl_n");
        n->addIncoming(curl_svec_n, curl_scheme_exit);
        n->addIncoming(curl_tensor_n, curl_tensor_exit);

        // ENHANCED VALIDATION: Accept n>=2 for general differential 2-forms
        // Classic curl is 3D, but generalized exterior derivative works in any dimension >= 2
        Value* n_ge_2 = builder->CreateICmpUGE(n, ConstantInt::get(int64_type, 2));

        BasicBlock* dim_valid = BasicBlock::Create(*context, "curl_dim_valid", current_func);
        BasicBlock* dim_invalid = BasicBlock::Create(*context, "curl_dim_invalid", current_func);
        BasicBlock* curl_done = BasicBlock::Create(*context, "curl_done", current_func);
        
        builder->CreateCondBr(n_ge_2, dim_valid, dim_invalid);
        
        // Invalid dimension: return null vector for dim < 2
        builder->SetInsertPoint(dim_invalid);
        eshkol_debug("Curl: dimension < 2, differential forms require at least 2D");
        Value* null_result_int = createNullVectorTensor(n);  // Use actual dimension, not hardcoded 3
        Value* null_result = packPtrToTaggedValue(null_result_int, ESHKOL_VALUE_TENSOR_PTR);
        BasicBlock* dim_invalid_exit = builder->GetInsertBlock();
        builder->CreateBr(curl_done);
        
        // Valid dimension: compute curl (differential 2-form)
        // NOTE: For n!=3, this computes the generalized exterior derivative
        builder->SetInsertPoint(dim_valid);
        
        // Compute Jacobian matrix (3×3)
        eshkol_operations_t jacobian_temp;
        jacobian_temp.op = ESHKOL_JACOBIAN_OP;
        jacobian_temp.jacobian_op.function = op->curl_op.function;
        jacobian_temp.jacobian_op.point = op->curl_op.point;
        
        Value* jacobian_tagged = codegenJacobian(&jacobian_temp);
        if (!jacobian_tagged) {
            eshkol_error("Failed to compute Jacobian for curl");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Jacobian is a valid tensor (same fix as Jacobian operator)
        Value* jacobian_type = getTaggedValueType(jacobian_tagged);
        Value* jacobian_base_type = builder->CreateAnd(jacobian_type,
            ConstantInt::get(int8_type, 0x0F));
        
        Value* jac_is_tensor_ptr = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* jac_is_ad_tensor = builder->CreateICmpEQ(jacobian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* jac_is_valid = builder->CreateOr(jac_is_tensor_ptr, jac_is_ad_tensor);
        
        BasicBlock* jac_valid = BasicBlock::Create(*context, "curl_jac_valid", current_func);
        BasicBlock* jac_invalid = BasicBlock::Create(*context, "curl_jac_invalid", current_func);
        
        // If IS valid tensor type, proceed; if NOT, error path
        builder->CreateCondBr(jac_is_valid, jac_valid, jac_invalid);
        
        // Invalid jacobian: return null 3D vector (only for genuinely invalid types)
        builder->SetInsertPoint(jac_invalid);
        eshkol_debug("Curl: Jacobian returned non-tensor type, returning null vector");
        Value* null_curl_int = createNullVectorTensor(
            ConstantInt::get(int64_type, 3)
        );
        // Tag as TENSOR_PTR for proper display
        Value* null_curl = packPtrToTaggedValue(null_curl_int, ESHKOL_VALUE_TENSOR_PTR);
        BasicBlock* jac_invalid_exit = builder->GetInsertBlock(); // Capture actual exit block!
        builder->CreateBr(curl_done);
        
        // Valid jacobian: continue with normal computation
        builder->SetInsertPoint(jac_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* jacobian_ptr_int = safeExtractInt64(jacobian_tagged);
        Value* jacobian_ptr = builder->CreateIntToPtr(jacobian_ptr_int, builder->getPtrTy());
        Value* n_const = ConstantInt::get(int64_type, 3);
        
        // Extract specific partial derivatives from Jacobian's nested list structure
        // J[i,j] = ∂Fᵢ/∂xⱼ (row i, column j)
        // Jacobian elements are LIST POINTERS (rows), not doubles!
        
        // curl_x = ∂F₃/∂y - ∂F₂/∂z = J[2,1] - J[1,2]
        Value* dF3_dx2 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 2),  // row 2
            ConstantInt::get(int64_type, 1),  // col 1
            n_const);
        Value* dF2_dx3 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 1),  // row 1
            ConstantInt::get(int64_type, 2),  // col 2
            n_const);
        Value* curl_x = builder->CreateFSub(dF3_dx2, dF2_dx3);
        
        // curl_y = ∂F₁/∂z - ∂F₃/∂x = J[0,2] - J[2,0]
        Value* dF1_dx3 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 0),  // row 0
            ConstantInt::get(int64_type, 2),  // col 2
            n_const);
        Value* dF3_dx1 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 2),  // row 2
            ConstantInt::get(int64_type, 0),  // col 0
            n_const);
        Value* curl_y = builder->CreateFSub(dF1_dx3, dF3_dx1);
        
        // curl_z = ∂F₂/∂x - ∂F₁/∂y = J[1,0] - J[0,1]
        Value* dF2_dx1 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 1),  // row 1
            ConstantInt::get(int64_type, 0),  // col 0
            n_const);
        Value* dF1_dx2 = extractJacobianElement(jacobian_ptr,
            ConstantInt::get(int64_type, 0),  // row 0
            ConstantInt::get(int64_type, 1),  // col 1
            n_const);
        Value* curl_z = builder->CreateFSub(dF2_dx1, dF1_dx2);
        
        // Create result 3D vector
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for curl result");
            return nullptr;
        }
        
        // Allocate result tensor (3D vector)
        Value* result_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* result_ptr = builder->CreateCall(malloc_func, {result_tensor_size});
        Value* typed_result_ptr = builder->CreatePointerCast(result_ptr, builder->getPtrTy());
        
        // Set dimensions [3]
        Value* result_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* result_dims_ptr = builder->CreateCall(malloc_func, {result_dims_size});
        Value* typed_result_dims = builder->CreatePointerCast(result_dims_ptr, builder->getPtrTy());
        builder->CreateStore(ConstantInt::get(int64_type, 3), typed_result_dims);
        
        Value* result_dims_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 0);
        builder->CreateStore(typed_result_dims, result_dims_field);
        
        Value* result_num_dims_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 1);
        builder->CreateStore(ConstantInt::get(int64_type, 1), result_num_dims_field);
        
        Value* result_total_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 3);
        builder->CreateStore(ConstantInt::get(int64_type, 3), result_total_field);
        
        // Allocate and fill elements [curl_x, curl_y, curl_z]
        Value* result_elems_size = ConstantInt::get(int64_type, 3 * sizeof(double));
        Value* result_elems_ptr = builder->CreateCall(malloc_func, {result_elems_size});
        Value* typed_result_elems = builder->CreatePointerCast(result_elems_ptr, builder->getPtrTy());
        
        Value* result_elems_field = builder->CreateStructGEP(tensor_type, typed_result_ptr, 2);
        builder->CreateStore(typed_result_elems, result_elems_field);
        
        // Store curl components
        Value* elem0_ptr = builder->CreateGEP(double_type, typed_result_elems,
            ConstantInt::get(int64_type, 0));
        builder->CreateStore(curl_x, elem0_ptr);
        
        Value* elem1_ptr = builder->CreateGEP(double_type, typed_result_elems,
            ConstantInt::get(int64_type, 1));
        builder->CreateStore(curl_y, elem1_ptr);
        
        Value* elem2_ptr = builder->CreateGEP(double_type, typed_result_elems,
            ConstantInt::get(int64_type, 2));
        builder->CreateStore(curl_z, elem2_ptr);
        
        eshkol_info("Curl computation complete, returning 3D vector");
        Value* curl_result_int = builder->CreatePtrToInt(typed_result_ptr, int64_type);
        // Tag as TENSOR_PTR for proper display and type consistency
        Value* curl_result = packPtrToTaggedValue(curl_result_int, ESHKOL_VALUE_TENSOR_PTR);
        builder->CreateBr(curl_done);
        BasicBlock* dim_valid_exit = builder->GetInsertBlock(); // Capture actual predecessor!
        
        // Merge all paths with tagged_value results (type-consistent!)
        builder->SetInsertPoint(curl_done);
        PHINode* result_phi = builder->CreatePHI(tagged_value_type, 3, "curl_result");
        result_phi->addIncoming(null_result, dim_invalid_exit);   // Already tagged
        result_phi->addIncoming(null_curl, jac_invalid_exit);     // Already tagged
        result_phi->addIncoming(curl_result, dim_valid_exit);
        
        return result_phi;
    }
    
    // Laplacian: ∇²f for scalar field f: ℝⁿ → ℝ
    // Returns scalar: ∇²f = ∂²f/∂x₁² + ∂²f/∂x₂² + ... + ∂²f/∂xₙ²
    // This is the trace of the Hessian matrix
    Value* codegenLaplacian(const eshkol_operations_t* op) {
        if (!op->laplacian_op.function || !op->laplacian_op.point) {
            eshkol_error("Invalid laplacian operation - missing function or point");
            return nullptr;
        }
        
        eshkol_info("Computing Laplacian of scalar field");
        
        // The Laplacian is the sum of diagonal elements of the Hessian
        // For f: ℝⁿ → ℝ, Hessian is n×n, Laplacian is trace(H)
        
        // Compute Hessian matrix first
        eshkol_operations_t hessian_temp;
        hessian_temp.op = ESHKOL_HESSIAN_OP;
        hessian_temp.hessian_op.function = op->laplacian_op.function;
        hessian_temp.hessian_op.point = op->laplacian_op.point;
        
        Value* hessian_tagged = codegenHessian(&hessian_temp);
        if (!hessian_tagged) {
            eshkol_error("Failed to compute Hessian for Laplacian");
            return nullptr;
        }
        
        // ENHANCED TYPE CHECK: Verify Hessian is a valid tensor (same fix as Jacobian operator)
        Value* hessian_type = getTaggedValueType(hessian_tagged);
        Value* hessian_base_type = builder->CreateAnd(hessian_type,
            ConstantInt::get(int8_type, 0x0F));
        
        Value* hess_is_tensor_ptr = builder->CreateICmpEQ(hessian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
        Value* hess_is_ad_tensor = builder->CreateICmpEQ(hessian_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_AD_NODE_PTR));
        Value* hess_is_valid = builder->CreateOr(hess_is_tensor_ptr, hess_is_ad_tensor);
        
        Function* lap_current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* hessian_valid = BasicBlock::Create(*context, "lap_hess_valid", lap_current_func);
        BasicBlock* hessian_invalid = BasicBlock::Create(*context, "lap_hess_invalid", lap_current_func);
        BasicBlock* lap_final = BasicBlock::Create(*context, "lap_final", lap_current_func);
        
        builder->CreateCondBr(hess_is_valid, hessian_valid, hessian_invalid);
        
        // Invalid hessian: return 0.0 instead of crashing (only for genuinely invalid types)
        builder->SetInsertPoint(hessian_invalid);
        eshkol_debug("Laplacian: Hessian returned non-tensor type, returning 0.0");
        Value* zero_lap_result = ConstantFP::get(double_type, 0.0);
        builder->CreateBr(lap_final);
        
        // Valid hessian: continue with normal computation
        builder->SetInsertPoint(hessian_valid);
        
        // Extract tensor pointer from validated tagged value
        Value* hessian_ptr_int = safeExtractInt64(hessian_tagged);
        Value* hessian_ptr = builder->CreateIntToPtr(hessian_ptr_int, builder->getPtrTy());
        
        // Extract dimension n from Hessian (it's n×n)
        Value* dims_field = builder->CreateStructGEP(tensor_type, hessian_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* n_ptr = builder->CreateGEP(int64_type, typed_dims_ptr,
            ConstantInt::get(int64_type, 0));
        Value* n = builder->CreateLoad(int64_type, n_ptr);
        
        // Get Hessian elements
        Value* elements_field = builder->CreateStructGEP(tensor_type, hessian_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Sum diagonal elements: H[0,0] + H[1,1] + ... + H[n-1,n-1]
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* sum_loop_cond = BasicBlock::Create(*context, "lap_sum_cond", current_func);
        BasicBlock* sum_loop_body = BasicBlock::Create(*context, "lap_sum_body", current_func);
        BasicBlock* sum_loop_exit = BasicBlock::Create(*context, "lap_sum_exit", current_func);
        
        Value* sum_idx = builder->CreateAlloca(int64_type, nullptr, "sum_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), sum_idx);
        
        Value* laplacian_acc = builder->CreateAlloca(double_type, nullptr, "lap_acc");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), laplacian_acc);
        
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_cond);
        Value* i = builder->CreateLoad(int64_type, sum_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, sum_loop_body, sum_loop_exit);
        
        builder->SetInsertPoint(sum_loop_body);
        
        // Calculate diagonal index: i*n + i
        Value* linear_idx = builder->CreateMul(i, n);
        linear_idx = builder->CreateAdd(linear_idx, i);
        
        // Load H[i,i]
        Value* elem_ptr = builder->CreateGEP(double_type,
            typed_elements_ptr, linear_idx);
        Value* diagonal_elem = builder->CreateLoad(double_type, elem_ptr);
        
        // Add to accumulator
        Value* current_lap = builder->CreateLoad(double_type, laplacian_acc);
        Value* new_lap = builder->CreateFAdd(current_lap, diagonal_elem);
        builder->CreateStore(new_lap, laplacian_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, sum_idx);
        builder->CreateBr(sum_loop_cond);
        
        builder->SetInsertPoint(sum_loop_exit);
        Value* laplacian_result = builder->CreateLoad(double_type, laplacian_acc);
        builder->CreateBr(lap_final);
        
        // Merge valid and invalid paths
        builder->SetInsertPoint(lap_final);
        PHINode* lap_result_phi = builder->CreatePHI(double_type, 2, "lap_result");
        lap_result_phi->addIncoming(zero_lap_result, hessian_invalid);
        lap_result_phi->addIncoming(laplacian_result, sum_loop_exit);

        eshkol_info("Laplacian computation complete");
        return packDoubleToTaggedValue(lap_result_phi);
    }
    
    // Directional Derivative: D_v f = ∇f · v
    // Computes the derivative of scalar field f in direction v
    Value* codegenDirectionalDerivative(const eshkol_operations_t* op) {
        if (!op->directional_deriv_op.function || !op->directional_deriv_op.point ||
            !op->directional_deriv_op.direction) {
            eshkol_error("Invalid directional-derivative operation - missing function, point, or direction");
            return nullptr;
        }
        
        eshkol_info("Computing directional derivative");
        
        // Step 1: Compute gradient ∇f
        eshkol_operations_t gradient_temp;
        gradient_temp.op = ESHKOL_GRADIENT_OP;
        gradient_temp.gradient_op.function = op->directional_deriv_op.function;
        gradient_temp.gradient_op.point = op->directional_deriv_op.point;
        
        Value* gradient_tagged = codegenGradient(&gradient_temp);
        if (!gradient_tagged) {
            eshkol_error("Failed to compute gradient for directional derivative");
            return nullptr;
        }
        
        // CRITICAL FIX: Unpack tensor pointer from tagged_value
        Value* gradient_ptr_int = safeExtractInt64(gradient_tagged);
        
        // Step 2: Get direction vector
        Value* direction_val = codegenAST(op->directional_deriv_op.direction);
        if (!direction_val) {
            eshkol_error("Failed to evaluate direction vector");
            return nullptr;
        }

        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc not found for directional derivative");
            return nullptr;
        }

        // CRITICAL FIX: Handle Scheme VECTOR_PTR - convert to tensor format
        Function* current_func = builder->GetInsertBlock()->getParent();

        Value* dir_type = getTaggedValueType(direction_val);
        Value* dir_base_type = builder->CreateAnd(dir_type,
            ConstantInt::get(int8_type, 0x0F));

        Value* dir_is_scheme_vector = builder->CreateICmpEQ(dir_base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

        BasicBlock* dd_scheme_vector = BasicBlock::Create(*context, "dd_scheme_vector", current_func);
        BasicBlock* dd_tensor_input = BasicBlock::Create(*context, "dd_tensor_input", current_func);
        BasicBlock* dd_merge_input = BasicBlock::Create(*context, "dd_merge_input", current_func);

        builder->CreateCondBr(dir_is_scheme_vector, dd_scheme_vector, dd_tensor_input);

        // SCHEME VECTOR: Convert to tensor format
        builder->SetInsertPoint(dd_scheme_vector);

        Value* dd_scheme_vec_ptr_int = unpackInt64FromTaggedValue(direction_val);
        Value* dd_scheme_vec_ptr = builder->CreateIntToPtr(dd_scheme_vec_ptr_int, builder->getPtrTy());
        Value* dd_scheme_len_ptr = builder->CreateBitCast(dd_scheme_vec_ptr, PointerType::getUnqual(*context));
        Value* dd_scheme_len = builder->CreateLoad(int64_type, dd_scheme_len_ptr);

        // Allocate tensor
        Value* dd_scheme_tensor_size = ConstantInt::get(int64_type,
            module->getDataLayout().getTypeAllocSize(tensor_type));
        Value* dd_scheme_tensor_ptr = builder->CreateCall(malloc_func, {dd_scheme_tensor_size});
        Value* dd_typed_scheme_tensor = builder->CreatePointerCast(dd_scheme_tensor_ptr, builder->getPtrTy());

        // Set dimensions
        Value* dd_scheme_dims_size = ConstantInt::get(int64_type, sizeof(uint64_t));
        Value* dd_scheme_dims_ptr = builder->CreateCall(malloc_func, {dd_scheme_dims_size});
        Value* dd_typed_scheme_dims = builder->CreatePointerCast(dd_scheme_dims_ptr, builder->getPtrTy());
        builder->CreateStore(dd_scheme_len, dd_typed_scheme_dims);

        builder->CreateStore(dd_typed_scheme_dims, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 0));
        builder->CreateStore(ConstantInt::get(int64_type, 1),
            builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 1));
        builder->CreateStore(dd_scheme_len, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 3));

        // Allocate and copy elements
        Value* dd_scheme_elems_size = builder->CreateMul(dd_scheme_len,
            ConstantInt::get(int64_type, sizeof(double)));
        Value* dd_scheme_elems_ptr = builder->CreateCall(malloc_func, {dd_scheme_elems_size});
        Value* dd_typed_scheme_elems = builder->CreatePointerCast(dd_scheme_elems_ptr, builder->getPtrTy());
        builder->CreateStore(dd_typed_scheme_elems, builder->CreateStructGEP(tensor_type, dd_typed_scheme_tensor, 2));

        // Copy elements loop (extract doubles from tagged values)
        Value* dd_scheme_elem_base = builder->CreateGEP(int8_type, dd_scheme_vec_ptr,
            ConstantInt::get(int64_type, 8));
        Value* dd_scheme_elem_base_typed = builder->CreateBitCast(dd_scheme_elem_base, PointerType::getUnqual(*context));

        BasicBlock* dd_svec_copy_cond = BasicBlock::Create(*context, "dd_svec_copy_cond", current_func);
        BasicBlock* dd_svec_copy_body = BasicBlock::Create(*context, "dd_svec_copy_body", current_func);
        BasicBlock* dd_svec_copy_done = BasicBlock::Create(*context, "dd_svec_copy_done", current_func);

        Value* dd_svec_copy_i = builder->CreateAlloca(int64_type, nullptr, "dd_svec_copy_i");
        builder->CreateStore(ConstantInt::get(int64_type, 0), dd_svec_copy_i);
        builder->CreateBr(dd_svec_copy_cond);

        builder->SetInsertPoint(dd_svec_copy_cond);
        Value* dd_svec_i = builder->CreateLoad(int64_type, dd_svec_copy_i);
        Value* dd_svec_cond = builder->CreateICmpULT(dd_svec_i, dd_scheme_len);
        builder->CreateCondBr(dd_svec_cond, dd_svec_copy_body, dd_svec_copy_done);

        builder->SetInsertPoint(dd_svec_copy_body);
        Value* dd_svec_src_ptr = builder->CreateGEP(tagged_value_type, dd_scheme_elem_base_typed, dd_svec_i);
        Value* dd_svec_tagged_elem = builder->CreateLoad(tagged_value_type, dd_svec_src_ptr);
        Value* dd_svec_double_val = unpackDoubleFromTaggedValue(dd_svec_tagged_elem);
        Value* dd_svec_dst_ptr = builder->CreateGEP(double_type, dd_typed_scheme_elems, dd_svec_i);
        builder->CreateStore(dd_svec_double_val, dd_svec_dst_ptr);
        Value* dd_svec_next_i = builder->CreateAdd(dd_svec_i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(dd_svec_next_i, dd_svec_copy_i);
        builder->CreateBr(dd_svec_copy_cond);

        builder->SetInsertPoint(dd_svec_copy_done);
        Value* dd_scheme_tensor_int = builder->CreatePtrToInt(dd_typed_scheme_tensor, int64_type);
        builder->CreateBr(dd_merge_input);
        BasicBlock* dd_scheme_exit = builder->GetInsertBlock();

        // TENSOR INPUT: Use as-is
        builder->SetInsertPoint(dd_tensor_input);
        Value* dd_tensor_ptr_int = safeExtractInt64(direction_val);
        builder->CreateBr(dd_merge_input);
        BasicBlock* dd_tensor_exit = builder->GetInsertBlock();

        // MERGE
        builder->SetInsertPoint(dd_merge_input);
        PHINode* direction_ptr_int = builder->CreatePHI(int64_type, 2, "dd_dir_ptr");
        direction_ptr_int->addIncoming(dd_scheme_tensor_int, dd_scheme_exit);
        direction_ptr_int->addIncoming(dd_tensor_ptr_int, dd_tensor_exit);

        // Step 3: Compute dot product: ∇f · v
        // Use class member tensor_type (shared by all tensor operations)

        Value* gradient_ptr = builder->CreateIntToPtr(gradient_ptr_int, builder->getPtrTy());
        Value* direction_ptr = builder->CreateIntToPtr(direction_ptr_int, builder->getPtrTy());
        
        // Get gradient elements
        Value* grad_elements_field = builder->CreateStructGEP(tensor_type, gradient_ptr, 2);
        Value* grad_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), grad_elements_field);
        Value* typed_grad_elements = builder->CreatePointerCast(grad_elements_ptr, builder->getPtrTy());
        
        // Get direction elements
        Value* dir_elements_field = builder->CreateStructGEP(tensor_type, direction_ptr, 2);
        Value* dir_elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dir_elements_field);
        Value* typed_dir_elements = builder->CreatePointerCast(dir_elements_ptr, builder->getPtrTy());
        
        // Get dimension n
        Value* grad_total_field = builder->CreateStructGEP(tensor_type, gradient_ptr, 3);
        Value* n = builder->CreateLoad(int64_type, grad_total_field);
        
        // Compute dot product: sum(grad[i] * dir[i])
        // current_func already defined above
        BasicBlock* dot_loop_cond = BasicBlock::Create(*context, "dirderiv_dot_cond", current_func);
        BasicBlock* dot_loop_body = BasicBlock::Create(*context, "dirderiv_dot_body", current_func);
        BasicBlock* dot_loop_exit = BasicBlock::Create(*context, "dirderiv_dot_exit", current_func);
        
        Value* dot_idx = builder->CreateAlloca(int64_type, nullptr, "dot_idx");
        builder->CreateStore(ConstantInt::get(int64_type, 0), dot_idx);
        
        Value* dot_acc = builder->CreateAlloca(double_type, nullptr, "dot_acc");
        builder->CreateStore(ConstantFP::get(double_type, 0.0), dot_acc);
        
        builder->CreateBr(dot_loop_cond);
        
        builder->SetInsertPoint(dot_loop_cond);
        Value* i = builder->CreateLoad(int64_type, dot_idx);
        Value* i_less_n = builder->CreateICmpULT(i, n);
        builder->CreateCondBr(i_less_n, dot_loop_body, dot_loop_exit);
        
        builder->SetInsertPoint(dot_loop_body);
        
        // Load grad[i]
        Value* grad_elem_ptr = builder->CreateGEP(double_type,
            typed_grad_elements, i);
        Value* grad_elem = builder->CreateLoad(double_type, grad_elem_ptr);
        
        // Load dir[i]
        Value* dir_elem_ptr = builder->CreateGEP(double_type,
            typed_dir_elements, i);
        Value* dir_elem = builder->CreateLoad(double_type, dir_elem_ptr);
        
        // Multiply and accumulate
        Value* prod = builder->CreateFMul(grad_elem, dir_elem);
        Value* current_dot = builder->CreateLoad(double_type, dot_acc);
        Value* new_dot = builder->CreateFAdd(current_dot, prod);
        builder->CreateStore(new_dot, dot_acc);
        
        Value* next_i = builder->CreateAdd(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_i, dot_idx);
        builder->CreateBr(dot_loop_cond);
        
        builder->SetInsertPoint(dot_loop_exit);
        Value* result = builder->CreateLoad(double_type, dot_acc);

        eshkol_info("Directional derivative computation complete");
        return packDoubleToTaggedValue(result);
    }

    // ===== END PHASE 4: VECTOR CALCULUS OPERATORS =====

    // ===== OALR (Ownership-Aware Lexical Regions) CODEGEN =====

    // Codegen for (with-region body ...)
    // Creates a region, evaluates body expressions, then destroys the region
    Value* codegenWithRegion(const eshkol_operations_t* op) {
        if (!op || !op->with_region_op.body || op->with_region_op.num_body_exprs == 0) {
            eshkol_error("Invalid with-region: missing body");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating with-region (name: %s, size_hint: %zu, body exprs: %llu)",
                    op->with_region_op.name ? op->with_region_op.name : "(anonymous)",
                    op->with_region_op.size_hint,
                    (unsigned long long)op->with_region_op.num_body_exprs);

        // Get/declare the region runtime functions
        FunctionType* region_create_type = FunctionType::get(
            PointerType::get(*context, 0),  // Returns eshkol_region_t*
            {PointerType::get(*context, 0), // const char* name
             int64_type},   // size_t size_hint
            false);
        FunctionCallee region_create_fn = module->getOrInsertFunction("region_create", region_create_type);

        FunctionType* region_push_type = FunctionType::get(
            void_type,
            {PointerType::get(*context, 0)},  // eshkol_region_t*
            false);
        FunctionCallee region_push_fn = module->getOrInsertFunction("region_push", region_push_type);

        FunctionType* region_pop_type = FunctionType::get(
            void_type,
            {},
            false);
        FunctionCallee region_pop_fn = module->getOrInsertFunction("region_pop", region_pop_type);

        // Create the region name string (or null)
        Value* name_ptr;
        if (op->with_region_op.name) {
            name_ptr = builder->CreateGlobalString(op->with_region_op.name, "region_name");
        } else {
            name_ptr = ConstantPointerNull::get(PointerType::get(*context, 0));
        }

        // Create the size hint value
        Value* size_hint = ConstantInt::get(int64_type, op->with_region_op.size_hint);

        // Call region_create
        Value* region = builder->CreateCall(region_create_fn, {name_ptr, size_hint}, "region");

        // Call region_push to make this the current region
        builder->CreateCall(region_push_fn, {region});

        // Evaluate body expressions - last one is the result
        Value* result = nullptr;
        for (uint64_t i = 0; i < op->with_region_op.num_body_exprs; i++) {
            result = codegenAST(&op->with_region_op.body[i]);
        }

        // Call region_pop (this destroys the region and frees all its memory)
        builder->CreateCall(region_pop_fn, {});

        // Return the result of the last expression
        // Note: If the result was allocated in the region, it's now invalid!
        // Escape analysis will handle promoting escaping values later
        if (!result) {
            result = packNullToTaggedValue();
        }

        return result;
    }

    // Codegen for (owned expr) - marks a value as owned (linear type)
    // For now, this is a pass-through; ownership tracking is compile-time
    Value* codegenOwned(const eshkol_operations_t* op) {
        if (!op || !op->owned_op.value) {
            eshkol_error("Invalid owned expression: missing value");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating owned expression");

        // Evaluate the inner expression
        Value* value = codegenAST(op->owned_op.value);

        // For now, owned is a pass-through
        // Future: Add metadata or runtime tracking for ownership
        return value ? value : packNullToTaggedValue();
    }

    // Codegen for (move value) - transfers ownership
    // For now, this is a pass-through; actual ownership transfer is compile-time
    Value* codegenMove(const eshkol_operations_t* op) {
        if (!op || !op->move_op.value) {
            eshkol_error("Invalid move expression: missing value");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating move expression");

        // Evaluate the value being moved
        Value* value = codegenAST(op->move_op.value);

        // Future: Mark original binding as consumed
        return value ? value : packNullToTaggedValue();
    }

    // Codegen for (borrow value body ...) - temporary read-only access
    Value* codegenBorrow(const eshkol_operations_t* op) {
        if (!op || !op->borrow_op.value || !op->borrow_op.body) {
            eshkol_error("Invalid borrow expression: missing value or body");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating borrow expression with %llu body expressions",
                    (unsigned long long)op->borrow_op.num_body_exprs);

        // Evaluate the value being borrowed
        Value* borrowed_value = codegenAST(op->borrow_op.value);
        if (!borrowed_value) {
            return packNullToTaggedValue();
        }

        // Evaluate body expressions - the borrowed value is in scope
        // Future: Mark it as immutable during this scope
        Value* result = nullptr;
        for (uint64_t i = 0; i < op->borrow_op.num_body_exprs; i++) {
            result = codegenAST(&op->borrow_op.body[i]);
        }

        return result ? result : packNullToTaggedValue();
    }

    // Codegen for (shared expr) - creates a reference-counted value
    // For now, this is a pass-through until we implement ref-counting runtime
    Value* codegenShared(const eshkol_operations_t* op) {
        if (!op || !op->shared_op.value) {
            eshkol_error("Invalid shared expression: missing value");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating shared expression");

        // Evaluate the inner expression
        Value* value = codegenAST(op->shared_op.value);

        // Future: Wrap in ref-counted header
        // For now, just pass through
        return value ? value : packNullToTaggedValue();
    }

    // Codegen for (weak-ref value) - creates a weak reference
    // For now, this is a pass-through until we implement ref-counting runtime
    Value* codegenWeakRef(const eshkol_operations_t* op) {
        if (!op || !op->weak_ref_op.value) {
            eshkol_error("Invalid weak-ref expression: missing value");
            return packNullToTaggedValue();
        }

        eshkol_debug("Generating weak-ref expression");

        // Evaluate the shared value
        Value* value = codegenAST(op->weak_ref_op.value);

        // Future: Create weak reference to ref-counted value
        // For now, just pass through
        return value ? value : packNullToTaggedValue();
    }

    // ===== END OALR CODEGEN =====


    // Core symbolic differentiation function
    // Now works within lambda context - variable comes from lambda parameter
    Value* differentiate(const eshkol_ast_t* expr, const char* var) {
        if (!expr || !var) return nullptr;
        
        // Variable should already be in symbol table from lambda parameter
        // No need to create placeholder - we're building symbolic expressions!
        
        Value* result = nullptr;
        
        switch (expr->type) {
            case ESHKOL_INT64:
                // Derivative of integer constant is 0 (int64)
                result = ConstantInt::get(int64_type, 0);
                break;
                
            case ESHKOL_DOUBLE:
                // Derivative of double constant is 0.0 (double)
                result = ConstantFP::get(double_type, 0.0);
                break;
                
            case ESHKOL_VAR:
                // Derivative of variable
                if (expr->variable.id && strcmp(expr->variable.id, var) == 0) {
                    // d/dx(x) = 1
                    // Use int64 by default - type-aware ops will convert if needed
                    result = ConstantInt::get(int64_type, 1);
                } else {
                    // d/dx(y) = 0 (where y != x)
                    // Use int64 by default - type-aware ops will convert if needed
                    result = ConstantInt::get(int64_type, 0);
                }
                break;
                
            case ESHKOL_OP:
                result = differentiateOperation(&expr->operation, var);
                break;
                
            default:
                // Unsupported expression type - return 0
                result = ConstantInt::get(int64_type, 0);
                break;
        }
        
        // No symbol table restoration needed - variable stays from lambda context
        return result;
    }
    
    // Differentiate operations (arithmetic, functions, etc.)
    Value* differentiateOperation(const eshkol_operations_t* op, const char* var) {
        if (!op) return ConstantInt::get(int64_type, 0);
        
        if (op->op == ESHKOL_CALL_OP && op->call_op.func &&
            op->call_op.func->type == ESHKOL_VAR && op->call_op.func->variable.id) {
            
            std::string func_name = op->call_op.func->variable.id;
            
            // Construct reference AST for type detection (use first operand)
            const eshkol_ast_t* type_ref = (op->call_op.num_vars > 0) ?
                &op->call_op.variables[0] : nullptr;
            
            // Addition rule: d/dx(f + g) = f' + g'
            if (func_name == "+" && op->call_op.num_vars >= 2) {
                Value* result = differentiate(&op->call_op.variables[0], var);
                for (uint64_t i = 1; i < op->call_op.num_vars; i++) {
                    Value* term_derivative = differentiate(&op->call_op.variables[i], var);
                    // Type-aware addition
                    result = createTypedAdd(result, term_derivative, &op->call_op.variables[0]);
                }
                return result;
            }
            
            // Subtraction rule: d/dx(f - g) = f' - g'
            else if (func_name == "-" && op->call_op.num_vars == 2) {
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                return createTypedSub(f_prime, g_prime, &op->call_op.variables[0]);
            }
            
            // Product rule: d/dx(f * g) = f' * g + f * g'
            // PHASE 0 FIX: Complete product rule implementation with type handling
            else if (func_name == "*" && op->call_op.num_vars == 2) {
                // Compute derivatives
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                
                // Generate f and g values
                Value* f = codegenAST(&op->call_op.variables[0]);
                Value* g = codegenAST(&op->call_op.variables[1]);
                
                // FIX 2a: Unpack tagged_value if needed (codegenAST now returns tagged_value)
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                if (g && g->getType() == tagged_value_type) g = safeExtractInt64(g);
                
                if (!f || !g || !f_prime || !g_prime) {
                    return ConstantInt::get(int64_type, 0);
                }
                
                // General product rule: f' * g + f * g'
                // Handles all cases including x*x -> 1*x + x*1 = 2x
                Value* term1 = createTypedMul(f_prime, g, &op->call_op.variables[0]);
                Value* term2 = createTypedMul(f, g_prime, &op->call_op.variables[0]);
                return createTypedAdd(term1, term2, &op->call_op.variables[0]);
            }
            
            // Division rule: d/dx(f/g) = (f'g - fg')/g²
            // PHASE 0: NEW - Division rule implementation
            else if (func_name == "/" && op->call_op.num_vars == 2) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                Value* g = codegenAST(&op->call_op.variables[1]);
                
                // FIX 2b: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                if (g && g->getType() == tagged_value_type) g = safeExtractInt64(g);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                Value* g_prime = differentiate(&op->call_op.variables[1], var);
                
                if (!f || !g || !f_prime || !g_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // (f'*g - f*g') / g²
                Value* f_prime_g = createTypedMul(f_prime, g, &op->call_op.variables[0]);
                Value* f_g_prime = createTypedMul(f, g_prime, &op->call_op.variables[0]);
                Value* numerator = createTypedSub(f_prime_g, f_g_prime, &op->call_op.variables[0]);
                Value* g_squared = createTypedMul(g, g, &op->call_op.variables[0]);
                
                // Division always returns double
                return createTypedDiv(numerator, g_squared, &op->call_op.variables[0]);
            }
            
            // Sin: d/dx(sin(f)) = cos(f) * f'
            // PHASE 0 FIX: Proper chain rule with cos(f) multiplication
            else if (func_name == "sin" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2c: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // Convert f to double for trig functions
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, double_type);
                }
                
                // cos(f) * f'
                Value* cos_f = builder->CreateCall(function_table["cos"], {f});
                return createTypedMul(cos_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Cos: d/dx(cos(f)) = -sin(f) * f'
            // PHASE 0 FIX: Proper chain rule with -sin(f) multiplication
            else if (func_name == "cos" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2d: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // Convert f to double for trig functions
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, double_type);
                }
                
                // -sin(f) * f'
                Value* sin_f = builder->CreateCall(function_table["sin"], {f});
                Value* neg_sin_f = builder->CreateFNeg(sin_f);
                return createTypedMul(neg_sin_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Exponential: d/dx(exp(f)) = exp(f) * f'
            // PHASE 0: NEW - Exponential rule
            else if (func_name == "exp" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2e: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // Convert f to double for exp
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, double_type);
                }
                
                // Declare exp function if not already declared
                if (function_table.find("exp") == function_table.end()) {
                    std::vector<Type*> exp_args = {double_type};
                    FunctionType* exp_type = FunctionType::get(
                        double_type, exp_args, false);
                    Function* exp_func = Function::Create(
                        exp_type, Function::ExternalLinkage, "exp", module.get());
                    function_table["exp"] = exp_func;
                }
                
                // exp(f) * f'
                Value* exp_f = builder->CreateCall(function_table["exp"], {f});
                return createTypedMul(exp_f, f_prime, &op->call_op.variables[0]);
            }
            
            // Natural log: d/dx(log(f)) = f' / f
            // PHASE 0: NEW - Logarithm rule
            else if (func_name == "log" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2f: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // Convert f to double for log
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, double_type);
                }
                
                // Declare log function if not already declared
                if (function_table.find("log") == function_table.end()) {
                    std::vector<Type*> log_args = {double_type};
                    FunctionType* log_type = FunctionType::get(
                        double_type, log_args, false);
                    Function* log_func = Function::Create(
                        log_type, Function::ExternalLinkage, "log", module.get());
                    function_table["log"] = log_func;
                }
                
                // f' / f (division always returns double)
                return createTypedDiv(f_prime, f, &op->call_op.variables[0]);
            }
            
            // Power rule: d/dx(f^n) = n * f^(n-1) * f' (for constant exponent)
            // PHASE 0: NEW - Power rule (constant exponent only)
            else if (func_name == "pow" && op->call_op.num_vars == 2) {
                // Check if exponent is constant
                if (op->call_op.variables[1].type == ESHKOL_INT64 ||
                    op->call_op.variables[1].type == ESHKOL_DOUBLE) {
                    
                    Value* f = codegenAST(&op->call_op.variables[0]);
                    Value* n = codegenAST(&op->call_op.variables[1]);
                    
                    // FIX 2g: Unpack tagged_value if needed
                    if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                    if (n && n->getType() == tagged_value_type) n = safeExtractInt64(n);
                    
                    Value* f_prime = differentiate(&op->call_op.variables[0], var);
                    
                    if (!f || !n || !f_prime) {
                        return ConstantFP::get(double_type, 0.0);
                    }
                    
                    // Convert to double for pow
                    if (f->getType()->isIntegerTy()) {
                        f = builder->CreateSIToFP(f, double_type);
                    }
                    if (n->getType()->isIntegerTy()) {
                        n = builder->CreateSIToFP(n, double_type);
                    }
                    
                    // n * f^(n-1) * f'
                    Value* one = ConstantFP::get(double_type, 1.0);
                    Value* n_minus_1 = builder->CreateFSub(n, one);
                    Value* f_power = builder->CreateCall(function_table["pow"], {f, n_minus_1});
                    Value* n_times_power = builder->CreateFMul(n, f_power);
                    
                    // Result is always double for pow
                    if (f_prime->getType()->isIntegerTy()) {
                        f_prime = builder->CreateSIToFP(f_prime, double_type);
                    }
                    return builder->CreateFMul(n_times_power, f_prime);
                }
                // For non-constant exponent, return 0 for now (will implement in Phase 2)
                else {
                    eshkol_warn("Power rule with non-constant exponent not yet implemented");
                    return ConstantFP::get(double_type, 0.0);
                }
            }
            
            // Square root: d/dx(sqrt(f)) = f' / (2*sqrt(f))
            // PHASE 0: BONUS - Sqrt rule
            else if (func_name == "sqrt" && op->call_op.num_vars == 1) {
                Value* f = codegenAST(&op->call_op.variables[0]);
                
                // FIX 2h: Unpack tagged_value if needed
                if (f && f->getType() == tagged_value_type) f = safeExtractInt64(f);
                
                Value* f_prime = differentiate(&op->call_op.variables[0], var);
                
                if (!f || !f_prime) {
                    return ConstantFP::get(double_type, 0.0);
                }
                
                // Convert to double for sqrt
                if (f->getType()->isIntegerTy()) {
                    f = builder->CreateSIToFP(f, double_type);
                }
                
                // f' / (2*sqrt(f))
                Value* sqrt_f = builder->CreateCall(function_table["sqrt"], {f});
                Value* two = ConstantFP::get(double_type, 2.0);
                Value* two_sqrt_f = builder->CreateFMul(two, sqrt_f);
                
                if (f_prime->getType()->isIntegerTy()) {
                    f_prime = builder->CreateSIToFP(f_prime, double_type);
                }
                return builder->CreateFDiv(f_prime, two_sqrt_f);
            }
        }
        
        // Unknown operation - return 0
        return ConstantInt::get(int64_type, 0);
    }
    
    Value* codegenVectorToString(const eshkol_operations_t* op) {
        // vector-to-string: (vector-to-string vector)
        // Converts a vector to a string representation like "[1, 2, 3]"
        if (op->call_op.num_vars != 1) {
            eshkol_error("vector-to-string requires exactly 1 argument: vector");
            return nullptr;
        }

        Value* tensor_val = codegenAST(&op->call_op.variables[0]);
        if (!tensor_val) return nullptr;

        // Extract the tensor pointer from tagged value or load from pointer
        Value* tensor_ptr_int;
        if (tensor_val->getType() == tagged_value_type) {
            // It's a tagged value - extract the pointer directly
            tensor_ptr_int = unpackInt64FromTaggedValue(tensor_val);
        } else if (tensor_val->getType()->isPointerTy()) {
            // It's a pointer to tagged value - load it
            Value* loaded = builder->CreateLoad(tagged_value_type, tensor_val);
            tensor_ptr_int = unpackInt64FromTaggedValue(loaded);
        } else {
            // Assume it's already an int64 pointer value
            tensor_ptr_int = tensor_val;
        }

        // Use class member tensor_type (shared by all tensor operations)
        
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get tensor properties
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(int64_type, num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        Value* total_elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 3);
        Value* total_elements = builder->CreateLoad(int64_type, total_elements_field_ptr);
        
        // Check if it's actually a vector (1D tensor)
        Value* is_vector = builder->CreateICmpEQ(num_dims, ConstantInt::get(int64_type, 1));
        
        // For simplicity, allocate a fixed-size buffer for the string
        // In a full implementation, this would calculate the needed size
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        // Allocate buffer for result string (assuming max 1024 chars)
        Value* buffer_size = ConstantInt::get(int64_type, 1024);
        Value* string_buffer = builder->CreateCall(malloc_func, {buffer_size});
        Value* typed_string_buffer = builder->CreatePointerCast(string_buffer, builder->getPtrTy());
        
        // Start with opening bracket "["
        Value* bracket_str = codegenString("[");
        Function* strcpy_func = function_table["strcpy"];
        if (!strcpy_func) {
            // Create strcpy declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcpy_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcpy_func = Function::Create(strcpy_type, Function::ExternalLinkage, "strcpy", module.get());
            function_table["strcpy"] = strcpy_func;
        }
        Function* strcat_func = function_table["strcat"];
        if (!strcat_func) {
            // Create strcat declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcat_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcat_func = Function::Create(strcat_type, Function::ExternalLinkage, "strcat", module.get());
            function_table["strcat"] = strcat_func;
        }
        Function* sprintf_func = function_table["sprintf"];
        if (!sprintf_func) {
            // Create sprintf declaration if it doesn't exist
            Type* char_ptr_type = PointerType::getUnqual(*context);
            Type* int_type = int32_type;
            FunctionType* sprintf_type = FunctionType::get(int_type, {char_ptr_type, char_ptr_type}, true);
            sprintf_func = Function::Create(sprintf_type, Function::ExternalLinkage, "sprintf", module.get());
            function_table["sprintf"] = sprintf_func;
        }
        
        // Copy opening bracket to buffer
        builder->CreateCall(strcpy_func, {typed_string_buffer, bracket_str});
        
        // Create loop to add each element
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "vec_str_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "vec_str_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "vec_str_loop_exit", current_func);
        
        // Initialize loop counter
        Value* loop_counter = builder->CreateAlloca(int64_type, nullptr, "vec_str_counter");
        builder->CreateStore(ConstantInt::get(int64_type, 0), loop_counter);
        
        // Jump to loop condition
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < total_elements
        builder->SetInsertPoint(loop_condition);
        Value* current_index = builder->CreateLoad(int64_type, loop_counter);
        Value* loop_cmp = builder->CreateICmpULT(current_index, total_elements);
        builder->CreateCondBr(loop_cmp, loop_body, loop_exit);
        
        // Loop body: append current element to string
        builder->SetInsertPoint(loop_body);
        
        // Load current element
        Value* elem_ptr = builder->CreateGEP(int64_type, typed_elements_ptr, current_index);
        Value* current_elem = builder->CreateLoad(int64_type, elem_ptr);
        
        // Check if this is not the first element (add comma and space)
        Value* is_first = builder->CreateICmpEQ(current_index, ConstantInt::get(int64_type, 0));
        BasicBlock* add_comma = BasicBlock::Create(*context, "add_comma", current_func);
        BasicBlock* skip_comma = BasicBlock::Create(*context, "skip_comma", current_func);
        BasicBlock* add_number = BasicBlock::Create(*context, "add_number", current_func);
        
        builder->CreateCondBr(is_first, skip_comma, add_comma);
        
        // Add comma and space for non-first elements
        builder->SetInsertPoint(add_comma);
        Value* comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, comma_str});
        builder->CreateBr(add_number);
        
        // Skip comma for first element
        builder->SetInsertPoint(skip_comma);
        builder->CreateBr(add_number);
        
        // Add the number
        builder->SetInsertPoint(add_number);

        // Create a small buffer for the number string
        Value* num_buffer_size = ConstantInt::get(int64_type, 32);
        Value* num_buffer = builder->CreateCall(malloc_func, {num_buffer_size});
        Value* typed_num_buffer = builder->CreatePointerCast(num_buffer, builder->getPtrTy());

        // Tensor elements are stored as i64 bits of doubles - bitcast to double for formatting
        Value* elem_double = builder->CreateBitCast(current_elem, Type::getDoubleTy(*context));

        // Format number as string using sprintf with %g format for doubles
        Value* format_str = codegenString("%g");
        builder->CreateCall(sprintf_func, {typed_num_buffer, format_str, elem_double});
        
        // Concatenate number to result string
        builder->CreateCall(strcat_func, {typed_string_buffer, typed_num_buffer});
        
        // Increment loop counter
        Value* next_index = builder->CreateAdd(current_index, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_index, loop_counter);
        
        // Jump back to condition check
        builder->CreateBr(loop_condition);
        
        // Loop exit: add closing bracket
        builder->SetInsertPoint(loop_exit);
        Value* close_bracket_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, close_bracket_str});
        
        // Return string buffer as int64 (pointer)
        return builder->CreatePtrToInt(typed_string_buffer, int64_type);
    }
    
    Value* codegenMatrixToString(const eshkol_operations_t* op) {
        // matrix-to-string: (matrix-to-string matrix)
        // Converts a matrix to a string representation like "[[1, 2], [3, 4]]"
        if (op->call_op.num_vars != 1) {
            eshkol_error("matrix-to-string requires exactly 1 argument: matrix");
            return nullptr;
        }

        Value* tensor_val = codegenAST(&op->call_op.variables[0]);
        if (!tensor_val) return nullptr;

        // Extract the tensor pointer from tagged value or load from pointer
        Value* tensor_ptr_int;
        if (tensor_val->getType() == tagged_value_type) {
            // It's a tagged value - extract the pointer directly
            tensor_ptr_int = unpackInt64FromTaggedValue(tensor_val);
        } else if (tensor_val->getType()->isPointerTy()) {
            // It's a pointer to tagged value - load it
            Value* loaded = builder->CreateLoad(tagged_value_type, tensor_val);
            tensor_ptr_int = unpackInt64FromTaggedValue(loaded);
        } else {
            // Assume it's already an int64 pointer value
            tensor_ptr_int = tensor_val;
        }

        // Use class member tensor_type (shared by all tensor operations)
        Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
        
        // Get tensor properties
        Value* dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 0);
        Value* dims_ptr = builder->CreateLoad(PointerType::getUnqual(*context), dims_field_ptr);
        Value* typed_dims_ptr = builder->CreatePointerCast(dims_ptr, builder->getPtrTy());
        
        Value* num_dims_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 1);
        Value* num_dims = builder->CreateLoad(int64_type, num_dims_field_ptr);
        
        Value* elements_field_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
        Value* elements_ptr = builder->CreateLoad(PointerType::getUnqual(*context), elements_field_ptr);
        Value* typed_elements_ptr = builder->CreatePointerCast(elements_ptr, builder->getPtrTy());
        
        // Get dimensions (assuming 2D matrix)
        Value* rows_ptr = builder->CreateGEP(int64_type, typed_dims_ptr, 
                                            ConstantInt::get(int64_type, 0));
        Value* rows = builder->CreateLoad(int64_type, rows_ptr);
        
        Value* cols_ptr = builder->CreateGEP(int64_type, typed_dims_ptr, 
                                            ConstantInt::get(int64_type, 1));
        Value* cols = builder->CreateLoad(int64_type, cols_ptr);
        
        // Allocate buffer for result string (assuming max 2048 chars)
        Function* malloc_func = function_table["malloc"];
        if (!malloc_func) {
            eshkol_error("malloc function not found");
            return nullptr;
        }
        
        Value* buffer_size = ConstantInt::get(int64_type, 2048);
        Value* string_buffer = builder->CreateCall(malloc_func, {buffer_size});
        Value* typed_string_buffer = builder->CreatePointerCast(string_buffer, builder->getPtrTy());
        
        // Get string functions - create declarations if they don't exist
        Function* strcpy_func = function_table["strcpy"];
        if (!strcpy_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcpy_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcpy_func = Function::Create(strcpy_type, Function::ExternalLinkage, "strcpy", module.get());
            function_table["strcpy"] = strcpy_func;
        }
        
        Function* strcat_func = function_table["strcat"];
        if (!strcat_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            FunctionType* strcat_type = FunctionType::get(char_ptr_type, {char_ptr_type, char_ptr_type}, false);
            strcat_func = Function::Create(strcat_type, Function::ExternalLinkage, "strcat", module.get());
            function_table["strcat"] = strcat_func;
        }
        
        Function* sprintf_func = function_table["sprintf"];
        if (!sprintf_func) {
            Type* char_ptr_type = PointerType::getUnqual(*context);
            Type* int_type = int32_type;
            FunctionType* sprintf_type = FunctionType::get(int_type, {char_ptr_type, char_ptr_type}, true);
            sprintf_func = Function::Create(sprintf_type, Function::ExternalLinkage, "sprintf", module.get());
            function_table["sprintf"] = sprintf_func;
        }
        
        // Start with opening bracket "["
        Value* open_bracket_str = codegenString("[");
        builder->CreateCall(strcpy_func, {typed_string_buffer, open_bracket_str});
        
        // Create nested loops for rows and columns
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* outer_loop_cond = BasicBlock::Create(*context, "matrix_outer_cond", current_func);
        BasicBlock* outer_loop_body = BasicBlock::Create(*context, "matrix_outer_body", current_func);
        BasicBlock* inner_loop_cond = BasicBlock::Create(*context, "matrix_inner_cond", current_func);
        BasicBlock* inner_loop_body = BasicBlock::Create(*context, "matrix_inner_body", current_func);
        BasicBlock* inner_loop_exit = BasicBlock::Create(*context, "matrix_inner_exit", current_func);
        BasicBlock* outer_loop_exit = BasicBlock::Create(*context, "matrix_outer_exit", current_func);
        
        // Initialize row counter
        Value* row_counter = builder->CreateAlloca(int64_type, nullptr, "row_counter");
        builder->CreateStore(ConstantInt::get(int64_type, 0), row_counter);
        
        // Jump to outer loop condition
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop condition: check if row < rows
        builder->SetInsertPoint(outer_loop_cond);
        Value* current_row = builder->CreateLoad(int64_type, row_counter);
        Value* outer_cmp = builder->CreateICmpULT(current_row, rows);
        builder->CreateCondBr(outer_cmp, outer_loop_body, outer_loop_exit);
        
        // Outer loop body: process each row
        builder->SetInsertPoint(outer_loop_body);
        
        // Add comma for non-first rows
        Value* is_first_row = builder->CreateICmpEQ(current_row, ConstantInt::get(int64_type, 0));
        BasicBlock* add_row_comma = BasicBlock::Create(*context, "add_row_comma", current_func);
        BasicBlock* skip_row_comma = BasicBlock::Create(*context, "skip_row_comma", current_func);
        
        builder->CreateCondBr(is_first_row, skip_row_comma, add_row_comma);
        
        builder->SetInsertPoint(add_row_comma);
        Value* row_comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_comma_str});
        builder->CreateBr(skip_row_comma);
        
        builder->SetInsertPoint(skip_row_comma);
        
        // Add opening bracket for row
        Value* row_open_str = codegenString("[");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_open_str});
        
        // Initialize column counter
        Value* col_counter = builder->CreateAlloca(int64_type, nullptr, "col_counter");
        builder->CreateStore(ConstantInt::get(int64_type, 0), col_counter);
        
        // Jump to inner loop
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop condition: check if col < cols
        builder->SetInsertPoint(inner_loop_cond);
        Value* current_col = builder->CreateLoad(int64_type, col_counter);
        Value* inner_cmp = builder->CreateICmpULT(current_col, cols);
        builder->CreateCondBr(inner_cmp, inner_loop_body, inner_loop_exit);
        
        // Inner loop body: process each element
        builder->SetInsertPoint(inner_loop_body);
        
        // Add comma for non-first columns
        Value* is_first_col = builder->CreateICmpEQ(current_col, ConstantInt::get(int64_type, 0));
        BasicBlock* add_col_comma = BasicBlock::Create(*context, "add_col_comma", current_func);
        BasicBlock* skip_col_comma = BasicBlock::Create(*context, "skip_col_comma", current_func);
        BasicBlock* add_element = BasicBlock::Create(*context, "add_element", current_func);
        
        builder->CreateCondBr(is_first_col, skip_col_comma, add_col_comma);
        
        builder->SetInsertPoint(add_col_comma);
        Value* col_comma_str = codegenString(", ");
        builder->CreateCall(strcat_func, {typed_string_buffer, col_comma_str});
        builder->CreateBr(add_element);
        
        builder->SetInsertPoint(skip_col_comma);
        builder->CreateBr(add_element);
        
        builder->SetInsertPoint(add_element);
        
        // Calculate linear index: row * cols + col
        Value* linear_index = builder->CreateMul(current_row, cols);
        linear_index = builder->CreateAdd(linear_index, current_col);
        
        // Load element
        Value* elem_ptr = builder->CreateGEP(int64_type, typed_elements_ptr, linear_index);
        Value* current_elem = builder->CreateLoad(int64_type, elem_ptr);
        
        // Format element as string
        Value* num_buffer_size = ConstantInt::get(int64_type, 32);
        Value* num_buffer = builder->CreateCall(malloc_func, {num_buffer_size});
        Value* typed_num_buffer = builder->CreatePointerCast(num_buffer, builder->getPtrTy());

        // Tensor elements are stored as i64 bits of doubles - bitcast to double for formatting
        Value* elem_double = builder->CreateBitCast(current_elem, Type::getDoubleTy(*context));

        Value* format_str = codegenString("%g");
        builder->CreateCall(sprintf_func, {typed_num_buffer, format_str, elem_double});

        // Add element to result
        builder->CreateCall(strcat_func, {typed_string_buffer, typed_num_buffer});
        
        // Increment column counter
        Value* next_col = builder->CreateAdd(current_col, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_col, col_counter);
        
        // Jump back to inner condition
        builder->CreateBr(inner_loop_cond);
        
        // Inner loop exit: close row bracket
        builder->SetInsertPoint(inner_loop_exit);
        Value* row_close_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, row_close_str});
        
        // Increment row counter
        Value* next_row = builder->CreateAdd(current_row, ConstantInt::get(int64_type, 1));
        builder->CreateStore(next_row, row_counter);
        
        // Jump back to outer condition
        builder->CreateBr(outer_loop_cond);
        
        // Outer loop exit: close matrix bracket
        builder->SetInsertPoint(outer_loop_exit);
        Value* close_bracket_str = codegenString("]");
        builder->CreateCall(strcat_func, {typed_string_buffer, close_bracket_str});
        
        // Return string buffer as int64 (pointer)
        return builder->CreatePtrToInt(typed_string_buffer, int64_type);
    }
    
    // Production implementation: Compound car/cdr operations using TAGGED cons cells
    Value* codegenCompoundCarCdr(const eshkol_operations_t* op, const std::string& pattern) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("compound car/cdr requires exactly 1 argument");
            return nullptr;
        }

        Value* current = codegenAST(&op->call_op.variables[0]);
        if (!current) return nullptr;

        Function* current_func = builder->GetInsertBlock()->getParent();

        // VECTOR/TENSOR OPTIMIZATION: For flat vectors, compound accessors can directly index
        // Pattern like "ad" (cadr) = element 1, "add" (caddr) = element 2, etc.
        // Only works for patterns that end with 'a' (returning an element, not a sublist)
        if (current->getType() == tagged_value_type) {
            // Count 'd' operations to get the element index
            // For "ad": index = 1, for "add": index = 2, etc.
            int d_count = 0;
            bool ends_with_a = false;
            for (int i = pattern.length() - 1; i >= 0; i--) {
                if (pattern[i] == 'd') d_count++;
                else if (i == 0 && pattern[i] == 'a') ends_with_a = true;
            }

            // Only optimize simple patterns like cadr, caddr that access flat vectors
            if (ends_with_a && d_count > 0 && d_count == (int)pattern.length() - 1) {
                Value* input_type = getTaggedValueType(current);
                Value* input_base_type = builder->CreateAnd(input_type,
                    ConstantInt::get(int8_type, 0x0F));

                Value* is_scheme_vector = builder->CreateICmpEQ(input_base_type,
                    ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));
                Value* is_tensor = builder->CreateICmpEQ(input_base_type,
                    ConstantInt::get(int8_type, ESHKOL_VALUE_TENSOR_PTR));
                Value* is_vector_type = builder->CreateOr(is_scheme_vector, is_tensor);

                BasicBlock* vector_opt = BasicBlock::Create(*context, "compound_vector_opt", current_func);
                BasicBlock* list_fallback = BasicBlock::Create(*context, "compound_list_fallback", current_func);
                BasicBlock* compound_final = BasicBlock::Create(*context, "compound_final", current_func);

                builder->CreateCondBr(is_vector_type, vector_opt, list_fallback);

                // VECTOR OPTIMIZATION: Directly return element at index d_count
                builder->SetInsertPoint(vector_opt);

                BasicBlock* scheme_vec_opt = BasicBlock::Create(*context, "compound_scheme_vec", current_func);
                BasicBlock* tensor_opt = BasicBlock::Create(*context, "compound_tensor", current_func);
                BasicBlock* vector_merge = BasicBlock::Create(*context, "compound_vector_merge", current_func);

                builder->CreateCondBr(is_scheme_vector, scheme_vec_opt, tensor_opt);

                // Scheme vector: element at d_count
                // Layout: [length (8 bytes)][elem0 (16 bytes)][elem1 (16 bytes)]...
                builder->SetInsertPoint(scheme_vec_opt);
                Value* vec_ptr_int = unpackInt64FromTaggedValue(current);
                Value* vec_ptr = builder->CreateIntToPtr(vec_ptr_int, builder->getPtrTy());
                // Skip 8-byte length field to get to elements base
                Value* elem_base = builder->CreateGEP(int8_type, vec_ptr,
                    ConstantInt::get(int64_type, 8));
                Value* elem_offset = ConstantInt::get(int64_type, d_count);
                Value* elem_ptr = builder->CreateGEP(tagged_value_type, elem_base, elem_offset);
                Value* scheme_result = builder->CreateLoad(tagged_value_type, elem_ptr);
                builder->CreateBr(vector_merge);
                BasicBlock* scheme_exit = builder->GetInsertBlock();

                // Tensor: element at d_count with AD-awareness
                builder->SetInsertPoint(tensor_opt);
                Value* tensor_ptr_int = unpackInt64FromTaggedValue(current);
                Value* tensor_ptr = builder->CreateIntToPtr(tensor_ptr_int, builder->getPtrTy());
                Value* elems_ptr_ptr = builder->CreateStructGEP(tensor_type, tensor_ptr, 2);
                Value* elems_ptr = builder->CreateLoad(builder->getPtrTy(), elems_ptr_ptr);

                Value* idx_const = ConstantInt::get(int64_type, d_count);
                Value* tensor_elem_ptr = builder->CreateGEP(int64_type, elems_ptr, idx_const);
                Value* elem_as_int64 = builder->CreateLoad(int64_type, tensor_elem_ptr);

                // AD-aware: check if double or AD node
                Value* in_ad_mode = builder->CreateLoad(int1_type, ad_mode_active);

                BasicBlock* tensor_ad = BasicBlock::Create(*context, "compound_tensor_ad", current_func);
                BasicBlock* tensor_normal = BasicBlock::Create(*context, "compound_tensor_normal", current_func);
                BasicBlock* tensor_merge = BasicBlock::Create(*context, "compound_tensor_merge", current_func);

                builder->CreateCondBr(in_ad_mode, tensor_ad, tensor_normal);

                // AD mode
                builder->SetInsertPoint(tensor_ad);
                Value* ad_exp_mask = ConstantInt::get(int64_type, 0x7FF0000000000000ULL);
                Value* ad_exp_bits = builder->CreateAnd(elem_as_int64, ad_exp_mask);
                Value* ad_has_exp = builder->CreateICmpNE(ad_exp_bits,
                    ConstantInt::get(int64_type, 0));

                BasicBlock* ad_double = BasicBlock::Create(*context, "compound_ad_double", current_func);
                BasicBlock* ad_node = BasicBlock::Create(*context, "compound_ad_node", current_func);

                builder->CreateCondBr(ad_has_exp, ad_double, ad_node);

                builder->SetInsertPoint(ad_double);
                Value* ad_d = builder->CreateBitCast(elem_as_int64, double_type);
                Value* ad_double_tagged = packDoubleToTaggedValue(ad_d);
                builder->CreateBr(tensor_merge);
                BasicBlock* ad_double_exit = builder->GetInsertBlock();

                builder->SetInsertPoint(ad_node);
                Value* ad_ptr = builder->CreateIntToPtr(elem_as_int64, PointerType::getUnqual(*context));
                Value* ad_node_tagged = packPtrToTaggedValue(ad_ptr, ESHKOL_VALUE_AD_NODE_PTR);
                builder->CreateBr(tensor_merge);
                BasicBlock* ad_node_exit = builder->GetInsertBlock();

                // Normal mode
                builder->SetInsertPoint(tensor_normal);
                Value* normal_d = builder->CreateBitCast(elem_as_int64, double_type);
                Value* normal_double_tagged = packDoubleToTaggedValue(normal_d);
                builder->CreateBr(tensor_merge);
                BasicBlock* normal_exit = builder->GetInsertBlock();

                // Tensor merge
                builder->SetInsertPoint(tensor_merge);
                PHINode* tensor_phi = builder->CreatePHI(tagged_value_type, 3);
                tensor_phi->addIncoming(ad_double_tagged, ad_double_exit);
                tensor_phi->addIncoming(ad_node_tagged, ad_node_exit);
                tensor_phi->addIncoming(normal_double_tagged, normal_exit);
                builder->CreateBr(vector_merge);
                BasicBlock* tensor_exit = builder->GetInsertBlock();

                // Vector merge
                builder->SetInsertPoint(vector_merge);
                PHINode* vector_phi = builder->CreatePHI(tagged_value_type, 2);
                vector_phi->addIncoming(scheme_result, scheme_exit);
                vector_phi->addIncoming(tensor_phi, tensor_exit);
                builder->CreateBr(compound_final);
                BasicBlock* vector_merge_exit = builder->GetInsertBlock();

                // List fallback: use the original loop-based approach
                builder->SetInsertPoint(list_fallback);

                // We need to continue with the list-based approach here
                // Store the entry point for the list fallback
                Value* list_result = current;

                // Apply each operation in reverse order (right-to-left)
                for (int i = pattern.length() - 1; i >= 0; i--) {
                    char c = pattern[i];

                    // FIX: Check for NULL by type, not by data value
                    // A NULL tagged value has type=ESHKOL_VALUE_NULL, data is irrelevant
                    Value* result_type = getTaggedValueType(list_result);
                    Value* result_base_type = builder->CreateAnd(result_type,
                        ConstantInt::get(int8_type, 0x0F));
                    Value* is_null_type = builder->CreateICmpEQ(result_base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));

                    // Also check for CONS_PTR with null pointer (0)
                    Value* is_cons_type = builder->CreateICmpEQ(result_base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
                    Value* ptr_int = safeExtractInt64(list_result);
                    Value* is_null_ptr = builder->CreateICmpEQ(ptr_int,
                        ConstantInt::get(int64_type, 0));
                    Value* is_cons_null = builder->CreateAnd(is_cons_type, is_null_ptr);

                    // Either NULL type or cons with null pointer
                    Value* is_null = builder->CreateOr(is_null_type, is_cons_null);

                    BasicBlock* null_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_null", current_func);
                    BasicBlock* valid_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_valid", current_func);
                    BasicBlock* continue_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_continue", current_func);

                    builder->CreateCondBr(is_null, null_block, valid_block);

                    builder->SetInsertPoint(null_block);
                    // FIX: Use proper NULL tagged value, not Int64 with 0
                    Value* null_tagged = packNullToTaggedValue();
                    builder->CreateBr(continue_block);

                    builder->SetInsertPoint(valid_block);
                    Value* cons_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());

                    Value* is_car_op = ConstantInt::get(int1_type, (c == 'a') ? 0 : 1);
                    Value* field_type = builder->CreateCall(getTaggedConsGetTypeFunc(),
                        {cons_ptr, is_car_op});

                    Value* base_type = builder->CreateAnd(field_type,
                        ConstantInt::get(int8_type, 0x0F));

                    // Check for all value types (including NULL for list terminators)
                    Value* is_field_null = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
                    Value* is_double = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
                    Value* is_cons_ptr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
                    Value* is_string_ptr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
                    Value* is_lambda_sexpr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
                    Value* is_closure_ptr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
                    // BOOL FIX: Check for BOOL type
                    Value* is_bool = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL));
                    // HASH_PTR FIX: Check for HASH_PTR, VECTOR_PTR types
                    Value* is_hash_ptr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_HASH_PTR));
                    Value* is_vector_ptr = builder->CreateICmpEQ(base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

                    // Create all basic blocks for type dispatch
                    BasicBlock* field_null_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_field_null", current_func);
                    BasicBlock* check_double_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_double", current_func);
                    BasicBlock* double_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_double", current_func);
                    BasicBlock* check_cons_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_cons", current_func);
                    BasicBlock* cons_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_cons", current_func);
                    BasicBlock* check_string_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_string", current_func);
                    BasicBlock* string_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_string", current_func);
                    BasicBlock* check_lambda_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_lambda", current_func);
                    BasicBlock* lambda_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_lambda", current_func);
                    BasicBlock* check_closure_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_closure", current_func);
                    BasicBlock* closure_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_closure", current_func);
                    // BOOL FIX: Add bool blocks
                    BasicBlock* check_bool_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_bool", current_func);
                    BasicBlock* bool_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_bool", current_func);
                    // HASH_PTR FIX: Add hash and vector blocks
                    BasicBlock* check_hash_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_hash", current_func);
                    BasicBlock* hash_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_hash", current_func);
                    BasicBlock* check_vector_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_check_vector", current_func);
                    BasicBlock* vector_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_vector", current_func);
                    BasicBlock* int_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_int", current_func);
                    BasicBlock* merge_block = BasicBlock::Create(*context,
                        std::string("fb_") + c + "_merge", current_func);

                    // CRITICAL: Check for NULL first - cdr of last element is NULL
                    builder->CreateCondBr(is_field_null, field_null_block, check_double_block);

                    // NULL field path - return NULL tagged value
                    builder->SetInsertPoint(field_null_block);
                    Value* field_null_tagged = packNullToTaggedValue();
                    builder->CreateBr(merge_block);

                    builder->SetInsertPoint(check_double_block);
                    builder->CreateCondBr(is_double, double_block, check_cons_block);

                    // Double path
                    builder->SetInsertPoint(double_block);
                    Value* double_val = builder->CreateCall(getTaggedConsGetDoubleFunc(),
                        {cons_ptr, is_car_op});
                    Value* tagged_double = packDoubleToTaggedValue(double_val);
                    builder->CreateBr(merge_block);

                    // Cons ptr path
                    builder->SetInsertPoint(check_cons_block);
                    builder->CreateCondBr(is_cons_ptr, cons_block, check_string_block);

                    builder->SetInsertPoint(cons_block);
                    Value* cons_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                        {cons_ptr, is_car_op});
                    Value* tagged_cons = packPtrToTaggedValue(
                        builder->CreateIntToPtr(cons_val, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
                    builder->CreateBr(merge_block);

                    // String ptr path (symbols)
                    builder->SetInsertPoint(check_string_block);
                    builder->CreateCondBr(is_string_ptr, string_block, check_lambda_block);

                    builder->SetInsertPoint(string_block);
                    Value* string_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                        {cons_ptr, is_car_op});
                    Value* tagged_string = packPtrToTaggedValue(
                        builder->CreateIntToPtr(string_val, builder->getPtrTy()), ESHKOL_VALUE_STRING_PTR);
                    builder->CreateBr(merge_block);

                    // Lambda sexpr path
                    builder->SetInsertPoint(check_lambda_block);
                    builder->CreateCondBr(is_lambda_sexpr, lambda_block, check_closure_block);

                    builder->SetInsertPoint(lambda_block);
                    Value* lambda_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_op});
                    Value* lambda_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_op});
                    Value* lambda_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_op});
                    Value* tagged_lambda = packPtrToTaggedValueWithFlags(
                        builder->CreateIntToPtr(lambda_ptr, builder->getPtrTy()), lambda_type, lambda_flags);
                    builder->CreateBr(merge_block);

                    // Closure ptr path
                    builder->SetInsertPoint(check_closure_block);
                    builder->CreateCondBr(is_closure_ptr, closure_block, check_bool_block);

                    builder->SetInsertPoint(closure_block);
                    Value* closure_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_op});
                    Value* closure_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_op});
                    Value* closure_ptr_val = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_op});
                    Value* tagged_closure = packPtrToTaggedValueWithFlags(
                        builder->CreateIntToPtr(closure_ptr_val, builder->getPtrTy()), closure_type, closure_flags);
                    builder->CreateBr(merge_block);

                    // BOOL FIX: Check if bool
                    builder->SetInsertPoint(check_bool_block);
                    builder->CreateCondBr(is_bool, bool_block, check_hash_block);

                    // BOOL FIX: Extract bool (stored as int64, 0=false, 1=true)
                    builder->SetInsertPoint(bool_block);
                    Value* bool_int_val = builder->CreateCall(getTaggedConsGetInt64Func(),
                        {cons_ptr, is_car_op});
                    // Convert int to bool (i1)
                    Value* bool_val = builder->CreateICmpNE(bool_int_val, ConstantInt::get(int64_type, 0));
                    Value* tagged_bool = packBoolToTaggedValue(bool_val);
                    builder->CreateBr(merge_block);

                    // HASH_PTR FIX: Check if hash_ptr
                    builder->SetInsertPoint(check_hash_block);
                    builder->CreateCondBr(is_hash_ptr, hash_block, check_vector_block);

                    // HASH_PTR FIX: Extract hash_ptr
                    builder->SetInsertPoint(hash_block);
                    Value* hash_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                        {cons_ptr, is_car_op});
                    Value* tagged_hash = packPtrToTaggedValue(
                        builder->CreateIntToPtr(hash_val, builder->getPtrTy()), ESHKOL_VALUE_HASH_PTR);
                    builder->CreateBr(merge_block);

                    // VECTOR_PTR FIX: Check if vector_ptr
                    builder->SetInsertPoint(check_vector_block);
                    builder->CreateCondBr(is_vector_ptr, vector_block, int_block);

                    // VECTOR_PTR FIX: Extract vector_ptr
                    builder->SetInsertPoint(vector_block);
                    Value* vector_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                        {cons_ptr, is_car_op});
                    Value* tagged_vector = packPtrToTaggedValue(
                        builder->CreateIntToPtr(vector_val, builder->getPtrTy()), ESHKOL_VALUE_VECTOR_PTR);
                    builder->CreateBr(merge_block);

                    // Int path (fallback)
                    builder->SetInsertPoint(int_block);
                    Value* int_val = builder->CreateCall(getTaggedConsGetInt64Func(),
                        {cons_ptr, is_car_op});
                    Value* tagged_int = packInt64ToTaggedValue(int_val, true);
                    builder->CreateBr(merge_block);

                    builder->SetInsertPoint(merge_block);
                    PHINode* extract_phi = builder->CreatePHI(tagged_value_type, 11);  // HASH_PTR FIX: 11 incoming
                    extract_phi->addIncoming(field_null_tagged, field_null_block);
                    extract_phi->addIncoming(tagged_double, double_block);
                    extract_phi->addIncoming(tagged_cons, cons_block);
                    extract_phi->addIncoming(tagged_string, string_block);
                    extract_phi->addIncoming(tagged_lambda, lambda_block);
                    extract_phi->addIncoming(tagged_closure, closure_block);
                    extract_phi->addIncoming(tagged_bool, bool_block);  // BOOL FIX
                    extract_phi->addIncoming(tagged_hash, hash_block);  // HASH_PTR FIX
                    extract_phi->addIncoming(tagged_vector, vector_block);  // VECTOR_PTR FIX
                    extract_phi->addIncoming(tagged_int, int_block);
                    builder->CreateBr(continue_block);

                    builder->SetInsertPoint(continue_block);
                    PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2);
                    result_phi->addIncoming(null_tagged, null_block);
                    result_phi->addIncoming(extract_phi, merge_block);

                    list_result = result_phi;
                }

                builder->CreateBr(compound_final);
                BasicBlock* list_exit = builder->GetInsertBlock();

                // Final merge
                builder->SetInsertPoint(compound_final);
                PHINode* final_phi = builder->CreatePHI(tagged_value_type, 2);
                final_phi->addIncoming(vector_phi, vector_merge_exit);
                final_phi->addIncoming(list_result, list_exit);

                return final_phi;
            }
        }

        // Apply each operation in reverse order (right-to-left)
        // For cadr: apply 'd' (cdr) first, then 'a' (car)
        for (int i = pattern.length() - 1; i >= 0; i--) {
            char c = pattern[i];
            
            // CRITICAL FIX: Safely extract i64 from possibly-tagged value
            Value* ptr_int = safeExtractInt64(current);
            
            // NULL CHECK
            Value* is_null = builder->CreateICmpEQ(ptr_int,
                ConstantInt::get(int64_type, 0));
            
            BasicBlock* null_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_null", current_func);
            BasicBlock* valid_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_valid", current_func);
            BasicBlock* continue_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_continue", current_func);
            
            builder->CreateCondBr(is_null, null_block, valid_block);
            
            // NULL: return null tagged value
            builder->SetInsertPoint(null_block);
            // FIX: Use proper NULL tagged value, not Int64 with 0
            Value* null_tagged = packNullToTaggedValue();
            builder->CreateBr(continue_block);
            
            // VALID: extract car or cdr using tagged cons cell helpers
            builder->SetInsertPoint(valid_block);
            Value* cons_ptr = builder->CreateIntToPtr(ptr_int, builder->getPtrTy());
            
            Value* is_car_op = ConstantInt::get(int1_type, (c == 'a') ? 0 : 1);
            Value* field_type = builder->CreateCall(getTaggedConsGetTypeFunc(),
                {cons_ptr, is_car_op});
            
            // Mask to get base type
            Value* base_type = builder->CreateAnd(field_type,
                ConstantInt::get(int8_type, 0x0F));
            
            // Check type: NULL (for list terminators), double, cons_ptr, string_ptr, lambda_sexpr, closure_ptr, int64
            Value* is_field_null = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
            Value* is_double = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
            Value* is_cons_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
            // SYMBOL FIX: Check for STRING_PTR, LAMBDA_SEXPR, CLOSURE_PTR
            Value* is_string_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_STRING_PTR));
            Value* is_lambda_sexpr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
            Value* is_closure_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
            // BOOL FIX: Check for BOOL type
            Value* is_bool = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL));
            // HASH_PTR FIX: Check for HASH_PTR, VECTOR_PTR types
            Value* is_hash_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_HASH_PTR));
            Value* is_vector_ptr = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_VECTOR_PTR));

            BasicBlock* field_null_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_field_null", current_func);
            BasicBlock* check_double_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_double", current_func);
            BasicBlock* double_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_double", current_func);
            BasicBlock* check_cons_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_cons", current_func);
            BasicBlock* cons_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_cons", current_func);
            BasicBlock* check_string_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_string", current_func);
            BasicBlock* string_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_string", current_func);
            BasicBlock* check_lambda_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_lambda", current_func);
            BasicBlock* lambda_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_lambda", current_func);
            BasicBlock* check_closure_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_closure", current_func);
            BasicBlock* closure_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_closure", current_func);
            // BOOL FIX: Add bool blocks
            BasicBlock* check_bool_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_bool", current_func);
            BasicBlock* bool_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_bool", current_func);
            // HASH_PTR FIX: Add hash and vector blocks
            BasicBlock* check_hash_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_hash", current_func);
            BasicBlock* hash_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_hash", current_func);
            BasicBlock* check_vector_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_check_vector", current_func);
            BasicBlock* vector_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_vector", current_func);
            BasicBlock* int_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_int", current_func);
            BasicBlock* merge_block = BasicBlock::Create(*context,
                std::string("compound_") + c + "_merge", current_func);

            // CRITICAL: Check for NULL first - cdr of last element is NULL
            builder->CreateCondBr(is_field_null, field_null_block, check_double_block);

            // NULL field path - return NULL tagged value
            builder->SetInsertPoint(field_null_block);
            Value* field_null_tagged = packNullToTaggedValue();
            builder->CreateBr(merge_block);

            builder->SetInsertPoint(check_double_block);
            builder->CreateCondBr(is_double, double_block, check_cons_block);

            // Extract double
            builder->SetInsertPoint(double_block);
            Value* double_val = builder->CreateCall(getTaggedConsGetDoubleFunc(),
                {cons_ptr, is_car_op});
            Value* tagged_double = packDoubleToTaggedValue(double_val);
            builder->CreateBr(merge_block);

            // Check if cons_ptr
            builder->SetInsertPoint(check_cons_block);
            builder->CreateCondBr(is_cons_ptr, cons_block, check_string_block);

            // Extract cons_ptr
            builder->SetInsertPoint(cons_block);
            Value* cons_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                {cons_ptr, is_car_op});
            Value* tagged_cons = packPtrToTaggedValue(builder->CreateIntToPtr(cons_val, builder->getPtrTy()), ESHKOL_VALUE_CONS_PTR);
            builder->CreateBr(merge_block);

            // SYMBOL FIX: Check if string_ptr
            builder->SetInsertPoint(check_string_block);
            builder->CreateCondBr(is_string_ptr, string_block, check_lambda_block);

            // Extract string_ptr
            builder->SetInsertPoint(string_block);
            Value* string_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                {cons_ptr, is_car_op});
            Value* tagged_string = packPtrToTaggedValue(builder->CreateIntToPtr(string_val, builder->getPtrTy()), ESHKOL_VALUE_STRING_PTR);
            builder->CreateBr(merge_block);

            // Check if lambda_sexpr
            builder->SetInsertPoint(check_lambda_block);
            builder->CreateCondBr(is_lambda_sexpr, lambda_block, check_closure_block);

            // Extract lambda_sexpr
            builder->SetInsertPoint(lambda_block);
            Value* lambda_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_op});
            Value* lambda_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_op});
            Value* lambda_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_op});
            Value* tagged_lambda = packPtrToTaggedValueWithFlags(
                builder->CreateIntToPtr(lambda_ptr, builder->getPtrTy()),
                lambda_type, lambda_flags);
            builder->CreateBr(merge_block);

            // Check if closure_ptr
            builder->SetInsertPoint(check_closure_block);
            builder->CreateCondBr(is_closure_ptr, closure_block, check_bool_block);

            // Extract closure_ptr
            builder->SetInsertPoint(closure_block);
            Value* closure_type = builder->CreateCall(getTaggedConsGetTypeFunc(), {cons_ptr, is_car_op});
            Value* closure_flags = builder->CreateCall(getTaggedConsGetFlagsFunc(), {cons_ptr, is_car_op});
            Value* closure_ptr_val = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_car_op});
            Value* tagged_closure = packPtrToTaggedValueWithFlags(
                builder->CreateIntToPtr(closure_ptr_val, builder->getPtrTy()),
                closure_type, closure_flags);
            builder->CreateBr(merge_block);

            // BOOL FIX: Check if bool
            builder->SetInsertPoint(check_bool_block);
            builder->CreateCondBr(is_bool, bool_block, check_hash_block);

            // BOOL FIX: Extract bool (stored as int64, 0=false, 1=true)
            builder->SetInsertPoint(bool_block);
            Value* bool_int_val = builder->CreateCall(getTaggedConsGetInt64Func(),
                {cons_ptr, is_car_op});
            // Convert int to bool (i1)
            Value* bool_val = builder->CreateICmpNE(bool_int_val, ConstantInt::get(int64_type, 0));
            Value* tagged_bool = packBoolToTaggedValue(bool_val);
            builder->CreateBr(merge_block);

            // HASH_PTR FIX: Check if hash_ptr
            builder->SetInsertPoint(check_hash_block);
            builder->CreateCondBr(is_hash_ptr, hash_block, check_vector_block);

            // HASH_PTR FIX: Extract hash_ptr
            builder->SetInsertPoint(hash_block);
            Value* hash_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                {cons_ptr, is_car_op});
            Value* tagged_hash = packPtrToTaggedValue(
                builder->CreateIntToPtr(hash_val, builder->getPtrTy()), ESHKOL_VALUE_HASH_PTR);
            builder->CreateBr(merge_block);

            // VECTOR_PTR FIX: Check if vector_ptr
            builder->SetInsertPoint(check_vector_block);
            builder->CreateCondBr(is_vector_ptr, vector_block, int_block);

            // VECTOR_PTR FIX: Extract vector_ptr
            builder->SetInsertPoint(vector_block);
            Value* vector_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
                {cons_ptr, is_car_op});
            Value* tagged_vector = packPtrToTaggedValue(
                builder->CreateIntToPtr(vector_val, builder->getPtrTy()), ESHKOL_VALUE_VECTOR_PTR);
            builder->CreateBr(merge_block);

            // Extract int64
            builder->SetInsertPoint(int_block);
            Value* int_val = builder->CreateCall(getTaggedConsGetInt64Func(),
                {cons_ptr, is_car_op});
            Value* tagged_int = packInt64ToTaggedValue(int_val, true);
            builder->CreateBr(merge_block);

            // Merge all types
            builder->SetInsertPoint(merge_block);
            PHINode* extract_phi = builder->CreatePHI(tagged_value_type, 11);  // HASH_PTR FIX: increased to 11
            extract_phi->addIncoming(field_null_tagged, field_null_block);
            extract_phi->addIncoming(tagged_double, double_block);
            extract_phi->addIncoming(tagged_cons, cons_block);
            extract_phi->addIncoming(tagged_string, string_block);
            extract_phi->addIncoming(tagged_lambda, lambda_block);
            extract_phi->addIncoming(tagged_closure, closure_block);
            extract_phi->addIncoming(tagged_bool, bool_block);  // BOOL FIX: add bool case
            extract_phi->addIncoming(tagged_hash, hash_block);  // HASH_PTR FIX
            extract_phi->addIncoming(tagged_vector, vector_block);  // VECTOR_PTR FIX
            extract_phi->addIncoming(tagged_int, int_block);
            builder->CreateBr(continue_block);
            
            // Continue: merge null and valid results
            builder->SetInsertPoint(continue_block);
            PHINode* result_phi = builder->CreatePHI(tagged_value_type, 2);
            result_phi->addIncoming(null_tagged, null_block);
            result_phi->addIncoming(extract_phi, merge_block);
            
            current = result_phi;
        }
        
        return current;
    }
    
    // Production implementation: List length
    // codegenLength removed - now in stdlib.esk (core/list/query.esk)

    // Random number generation: (random) returns double in [0.0, 1.0)
    Value* codegenRandom(const eshkol_operations_t* op) {
        // Get or create global flag for random seed initialization
        // This is a RUNTIME flag, not a compile-time flag
        GlobalVariable* random_seeded = module->getNamedGlobal("__random_seeded__");
        if (!random_seeded) {
            random_seeded = new GlobalVariable(
                *module, int8_type, false,
                GlobalValue::InternalLinkage,
                ConstantInt::get(int8_type, 0),  // Initially not seeded
                "__random_seeded__"
            );
        }

        // Check at runtime if we need to seed
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* seed_block = BasicBlock::Create(*context, "random_seed", current_func);
        BasicBlock* continue_block = BasicBlock::Create(*context, "random_continue", current_func);

        Value* is_seeded = builder->CreateLoad(int8_type, random_seeded);
        Value* need_seed = builder->CreateICmpEQ(is_seeded, ConstantInt::get(int8_type, 0));
        builder->CreateCondBr(need_seed, seed_block, continue_block);

        // Seed block - only executed once per program run
        builder->SetInsertPoint(seed_block);
        Function* time_func = function_table["time"];
        Function* srand48_func = function_table["srand48"];
        if (time_func && srand48_func) {
            Value* time_val = builder->CreateCall(time_func,
                {ConstantPointerNull::get(PointerType::get(*context, 0))});
            builder->CreateCall(srand48_func, {time_val});
        }
        // Mark as seeded
        builder->CreateStore(ConstantInt::get(int8_type, 1), random_seeded);
        builder->CreateBr(continue_block);

        // Continue block - generate random number
        builder->SetInsertPoint(continue_block);

        // Call drand48() to get random double
        Function* drand48_func = function_table["drand48"];
        if (!drand48_func) {
            eshkol_error("drand48 function not found");
            return nullptr;
        }

        Value* random_val = builder->CreateCall(drand48_func, {});
        return packDoubleToTaggedValue(random_val);
    }

    // Quantum random number generation: (quantum-random) returns double in [0.0, 1.0)
    // Uses quantum-inspired RNG for higher quality randomness
    Value* codegenQuantumRandom(const eshkol_operations_t* op) {
        Function* qrng_double_func = function_table["eshkol_qrng_double"];
        if (!qrng_double_func) {
            eshkol_error("eshkol_qrng_double function not found");
            return nullptr;
        }
        Value* random_val = builder->CreateCall(qrng_double_func, {});
        return packDoubleToTaggedValue(random_val);
    }

    // Quantum random integer: (quantum-random-int) returns uint64
    Value* codegenQuantumRandomInt(const eshkol_operations_t* op) {
        Function* qrng_uint64_func = function_table["eshkol_qrng_uint64"];
        if (!qrng_uint64_func) {
            eshkol_error("eshkol_qrng_uint64 function not found");
            return nullptr;
        }
        Value* random_val = builder->CreateCall(qrng_uint64_func, {});
        return random_val;  // Return raw int64
    }

    // Quantum random range: (quantum-random-range min max) returns int in [min, max]
    Value* codegenQuantumRandomRange(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("quantum-random-range requires exactly 2 arguments (min max)");
            return nullptr;
        }

        Function* qrng_range_func = function_table["eshkol_qrng_range"];
        if (!qrng_range_func) {
            eshkol_error("eshkol_qrng_range function not found");
            return nullptr;
        }

        // Get min and max arguments
        TypedValue tv_min = codegenTypedAST(&op->call_op.variables[0]);
        TypedValue tv_max = codegenTypedAST(&op->call_op.variables[1]);
        if (!tv_min.llvm_value || !tv_max.llvm_value) return nullptr;

        Value* min_val = tv_min.llvm_value;
        Value* max_val = tv_max.llvm_value;

        // Convert to int64 if needed
        if (min_val->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(min_val);
            min_val = builder->CreateFPToSI(extracted, int64_type);
        } else if (min_val->getType()->isDoubleTy()) {
            min_val = builder->CreateFPToSI(min_val, int64_type);
        }

        if (max_val->getType() == tagged_value_type) {
            Value* extracted = extractDoubleFromTagged(max_val);
            max_val = builder->CreateFPToSI(extracted, int64_type);
        } else if (max_val->getType()->isDoubleTy()) {
            max_val = builder->CreateFPToSI(max_val, int64_type);
        }

        Value* result = builder->CreateCall(qrng_range_func, {min_val, max_val});
        return result;  // Return raw int64
    }

    // codegenRange removed - now in stdlib.esk (core/list/generate.esk)
    // codegenZip removed - now in stdlib.esk (core/list/generate.esk)

    // Helper: Iteratively reverse a list (takes int64 list pointer, returns int64 list pointer)
    // This is used internally by functions like unzip that build lists in reverse
    Value* codegenIterativeReverse(Value* list_ptr) {
        Function* current_func = builder->GetInsertBlock()->getParent();
        BasicBlock* loop_condition = BasicBlock::Create(*context, "rev_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "rev_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "rev_loop_exit", current_func);

        // Initialize result (accumulator) and current pointer
        Value* result = builder->CreateAlloca(int64_type, nullptr, "rev_result");
        builder->CreateStore(ConstantInt::get(int64_type, 0), result); // Start with empty list

        Value* current_ptr = builder->CreateAlloca(int64_type, nullptr, "rev_current");
        builder->CreateStore(list_ptr, current_ptr);

        // Jump to loop condition
        builder->CreateBr(loop_condition);

        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(int64_type, current_ptr);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);

        // Loop body: cons car onto result and move to cdr
        builder->SetInsertPoint(loop_body);

        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());

        // Extract car as tagged_value
        Value* car_tagged = extractCarAsTaggedValue(current_val);

        // Get result as tagged value - check if NULL or CONS_PTR
        Value* result_val = builder->CreateLoad(int64_type, result);
        Value* result_is_null = builder->CreateICmpEQ(result_val,
            ConstantInt::get(int64_type, 0));

        // Pack result correctly based on whether it's null or cons pointer
        Value* null_tagged_result = packNullToTaggedValue();
        Value* ptr_tagged_result = packPtrToTaggedValue(
            builder->CreateIntToPtr(result_val, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);
        Value* result_tagged = builder->CreateSelect(result_is_null,
            null_tagged_result, ptr_tagged_result);

        // Create new cons cell directly from tagged values (preserves types!)
        Value* new_result = codegenTaggedArenaConsCellFromTaggedValue(
            car_tagged, result_tagged);
        builder->CreateStore(new_result, result);

        // Move to cdr using tagged helper
        Value* is_cdr_get = ConstantInt::get(int1_type, 1);
        Value* cdr_val = builder->CreateCall(getTaggedConsGetPtrFunc(),
            {cons_ptr, is_cdr_get});
        builder->CreateStore(cdr_val, current_ptr);

        // Jump back to condition
        builder->CreateBr(loop_condition);

        // Loop exit: return result (as int64)
        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(int64_type, result);
    }

    // Unzip: Convert list of pairs into pair of lists
    // (unzip '((a 1) (b 2) (c 3))) => ((a b c) (1 2 3))
    Value* codegenUnzip(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("unzip requires exactly 1 argument");
            return nullptr;
        }

        Value* list = codegenAST(&op->call_op.variables[0]);
        if (!list) return nullptr;

        list = safeExtractInt64(list);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Build two result lists in reverse, then reverse them
        Value* firsts_ptr = builder->CreateAlloca(int64_type, nullptr, "unzip_firsts");
        Value* seconds_ptr = builder->CreateAlloca(int64_type, nullptr, "unzip_seconds");
        Value* curr_ptr = builder->CreateAlloca(int64_type, nullptr, "unzip_curr");

        builder->CreateStore(ConstantInt::get(int64_type, 0), firsts_ptr);
        builder->CreateStore(ConstantInt::get(int64_type, 0), seconds_ptr);
        builder->CreateStore(list, curr_ptr);

        BasicBlock* loop_cond = BasicBlock::Create(*context, "unzip_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "unzip_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "unzip_exit", current_func);

        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* curr = builder->CreateLoad(int64_type, curr_ptr);
        Value* is_not_null = builder->CreateICmpNE(curr, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        curr = builder->CreateLoad(int64_type, curr_ptr);

        // Get the pair (car of current)
        Value* pair_tagged = extractCarAsTaggedValue(curr);
        Value* pair_data = builder->CreateExtractValue(pair_tagged, {4});

        // Get first element (car of pair)
        Value* first_tagged = extractCarAsTaggedValue(pair_data);

        // Get second element (cadr of pair = car of cdr of pair)
        Value* pair_cons_ptr = builder->CreateIntToPtr(pair_data, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        Value* pair_cdr = builder->CreateCall(getTaggedConsGetPtrFunc(), {pair_cons_ptr, is_cdr});
        Value* second_tagged = extractCarAsTaggedValue(pair_cdr);

        // Cons first onto firsts list
        Value* firsts = builder->CreateLoad(int64_type, firsts_ptr);
        TypedValue first_tv = taggedValueToTypedValue(first_tagged);
        TypedValue firsts_cdr = TypedValue(firsts, ESHKOL_VALUE_CONS_PTR);
        Value* new_firsts = codegenTaggedArenaConsCell(first_tv, firsts_cdr);
        builder->CreateStore(new_firsts, firsts_ptr);

        // Cons second onto seconds list
        Value* seconds = builder->CreateLoad(int64_type, seconds_ptr);
        TypedValue second_tv = taggedValueToTypedValue(second_tagged);
        TypedValue seconds_cdr = TypedValue(seconds, ESHKOL_VALUE_CONS_PTR);
        Value* new_seconds = codegenTaggedArenaConsCell(second_tv, seconds_cdr);
        builder->CreateStore(new_seconds, seconds_ptr);

        // Move to next element
        Value* curr_cons_ptr = builder->CreateIntToPtr(curr, builder->getPtrTy());
        Value* next = builder->CreateCall(getTaggedConsGetPtrFunc(), {curr_cons_ptr, is_cdr});
        builder->CreateStore(next, curr_ptr);

        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);

        // Reverse both lists (they were built in reverse order)
        Value* firsts_rev = builder->CreateLoad(int64_type, firsts_ptr);
        Value* seconds_rev = builder->CreateLoad(int64_type, seconds_ptr);
        firsts_rev = codegenIterativeReverse(firsts_rev);
        seconds_rev = codegenIterativeReverse(seconds_rev);

        // Create result pair: (firsts . (seconds . null))
        TypedValue null_tv = TypedValue(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);
        TypedValue seconds_tv = TypedValue(safeExtractInt64(seconds_rev), ESHKOL_VALUE_CONS_PTR);
        Value* inner = codegenTaggedArenaConsCell(seconds_tv, null_tv);
        TypedValue firsts_tv = TypedValue(safeExtractInt64(firsts_rev), ESHKOL_VALUE_CONS_PTR);
        TypedValue inner_tv = TypedValue(inner, ESHKOL_VALUE_CONS_PTR);
        Value* result = codegenTaggedArenaConsCell(firsts_tv, inner_tv);

        return result;
    }

    // sort is now implemented in stdlib.esk



    // Iota: Generate a sequence of numbers
    // (iota count) => (0 1 2 ... count-1)
    // (iota count start) => (start start+1 ... start+count-1)
    // (iota count start step) => (start start+step start+2*step ...)
    Value* codegenIota(const eshkol_operations_t* op) {
        if (op->call_op.num_vars < 1 || op->call_op.num_vars > 3) {
            eshkol_error("iota requires 1-3 arguments: count [start [step]]");
            return nullptr;
        }

        Value* count_val = codegenAST(&op->call_op.variables[0]);
        if (!count_val) return nullptr;
        Value* count = unpackInt64FromTaggedValue(count_val);

        Value* start = ConstantInt::get(int64_type, 0);
        Value* step = ConstantInt::get(int64_type, 1);

        if (op->call_op.num_vars >= 2) {
            Value* start_val = codegenAST(&op->call_op.variables[1]);
            if (start_val) start = unpackInt64FromTaggedValue(start_val);
        }
        if (op->call_op.num_vars >= 3) {
            Value* step_val = codegenAST(&op->call_op.variables[2]);
            if (step_val) step = unpackInt64FromTaggedValue(step_val);
        }

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Build list in reverse, then reverse it
        Value* result_ptr = builder->CreateAlloca(int64_type, nullptr, "iota_result");
        Value* i_ptr = builder->CreateAlloca(int64_type, nullptr, "iota_i");
        Value* val_ptr = builder->CreateAlloca(int64_type, nullptr, "iota_val");

        builder->CreateStore(ConstantInt::get(int64_type, 0), result_ptr);
        // Start from count-1 and go down to 0
        Value* last_idx = builder->CreateSub(count, ConstantInt::get(int64_type, 1));
        builder->CreateStore(last_idx, i_ptr);

        BasicBlock* loop_cond = BasicBlock::Create(*context, "iota_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "iota_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "iota_exit", current_func);

        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_cond);
        Value* i = builder->CreateLoad(int64_type, i_ptr);
        Value* i_ge_zero = builder->CreateICmpSGE(i, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(i_ge_zero, loop_body, loop_exit);

        builder->SetInsertPoint(loop_body);
        i = builder->CreateLoad(int64_type, i_ptr);

        // Calculate value: start + i * step
        Value* offset = builder->CreateMul(i, step);
        Value* val = builder->CreateAdd(start, offset);

        // Cons value onto result
        Value* result = builder->CreateLoad(int64_type, result_ptr);
        TypedValue val_tv = TypedValue(val, ESHKOL_VALUE_INT64);
        TypedValue result_tv = TypedValue(result, result_ptr ? ESHKOL_VALUE_CONS_PTR : ESHKOL_VALUE_NULL);
        Value* new_result = codegenTaggedArenaConsCell(val_tv, result_tv);
        builder->CreateStore(new_result, result_ptr);

        // Decrement i
        Value* new_i = builder->CreateSub(i, ConstantInt::get(int64_type, 1));
        builder->CreateStore(new_i, i_ptr);

        builder->CreateBr(loop_cond);

        builder->SetInsertPoint(loop_exit);
        return builder->CreateLoad(int64_type, result_ptr);
    }

    // Reduce/Fold: Left fold with explicit initial value
    // (reduce f init list) => fold-left style
    // Also supports (reduce f list) which uses first element as initial value
    Value* codegenReduce(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2 && op->call_op.num_vars != 3) {
            eshkol_error("reduce requires 2 or 3 arguments: (reduce f list) or (reduce f init list)");
            return nullptr;
        }

        Value* proc = resolveLambdaFunction(&op->call_op.variables[0], 2);
        if (!proc) {
            eshkol_error("Failed to resolve function for reduce");
            return nullptr;
        }

        Function* proc_fn = dyn_cast<Function>(proc);
        if (!proc_fn) {
            eshkol_error("reduce function must be a procedure");
            return nullptr;
        }

        Value* init_val = nullptr;
        Value* list = nullptr;
        bool has_explicit_init = (op->call_op.num_vars == 3);

        if (has_explicit_init) {
            // 3 args: (reduce f init list)
            init_val = codegenAST(&op->call_op.variables[1]);
            list = codegenAST(&op->call_op.variables[2]);
        } else {
            // 2 args: (reduce f list) - use first element as init
            list = codegenAST(&op->call_op.variables[1]);
        }
        if (!list) return nullptr;
        list = safeExtractInt64(list);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check for empty list
        BasicBlock* entry_block = builder->GetInsertBlock();
        BasicBlock* not_empty = BasicBlock::Create(*context, "reduce_not_empty", current_func);
        BasicBlock* reduce_done = BasicBlock::Create(*context, "reduce_done", current_func);

        Value* is_empty = builder->CreateICmpEQ(list, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_empty, reduce_done, not_empty);

        builder->SetInsertPoint(not_empty);

        Value* acc_tagged;
        Value* rest;
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        Value* list_cons = builder->CreateIntToPtr(list, builder->getPtrTy());

        if (has_explicit_init) {
            // Use provided init value as accumulator, iterate over entire list
            if (init_val->getType() == tagged_value_type) {
                acc_tagged = init_val;
            } else {
                acc_tagged = packInt64ToTaggedValue(safeExtractInt64(init_val), true);
            }
            rest = list;
        } else {
            // Get first element as initial accumulator
            acc_tagged = extractCarAsTaggedValue(list);
            // Get rest of list
            rest = builder->CreateCall(getTaggedConsGetPtrFunc(), {list_cons, is_cdr});
        }

        // Now fold over rest
        Value* acc_ptr = builder->CreateAlloca(tagged_value_type, nullptr, "reduce_acc");
        Value* curr_ptr = builder->CreateAlloca(int64_type, nullptr, "reduce_curr");

        builder->CreateStore(acc_tagged, acc_ptr);
        builder->CreateStore(rest, curr_ptr);

        BasicBlock* fold_cond = BasicBlock::Create(*context, "reduce_fold_cond", current_func);
        BasicBlock* fold_body = BasicBlock::Create(*context, "reduce_fold_body", current_func);
        BasicBlock* fold_exit = BasicBlock::Create(*context, "reduce_fold_exit", current_func);

        builder->CreateBr(fold_cond);

        builder->SetInsertPoint(fold_cond);
        Value* curr = builder->CreateLoad(int64_type, curr_ptr);
        Value* curr_not_null = builder->CreateICmpNE(curr, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(curr_not_null, fold_body, fold_exit);

        builder->SetInsertPoint(fold_body);
        curr = builder->CreateLoad(int64_type, curr_ptr);
        Value* elem = extractCarAsTaggedValue(curr);
        Value* acc = builder->CreateLoad(tagged_value_type, acc_ptr);

        // Call proc(acc, elem)
        Value* new_acc = builder->CreateCall(proc_fn, {acc, elem});
        builder->CreateStore(new_acc, acc_ptr);

        // Move to next
        Value* curr_cons = builder->CreateIntToPtr(curr, builder->getPtrTy());
        Value* next = builder->CreateCall(getTaggedConsGetPtrFunc(), {curr_cons, is_cdr});
        builder->CreateStore(next, curr_ptr);

        builder->CreateBr(fold_cond);

        builder->SetInsertPoint(fold_exit);
        Value* final_acc = builder->CreateLoad(tagged_value_type, acc_ptr);
        Value* final_result = safeExtractInt64(final_acc);
        builder->CreateBr(reduce_done);
        BasicBlock* fold_exit_end = builder->GetInsertBlock();

        builder->SetInsertPoint(reduce_done);
        PHINode* result = builder->CreatePHI(int64_type, 2, "reduce_result");
        // For empty list with explicit init, return init; otherwise return 0
        Value* empty_result = has_explicit_init ? safeExtractInt64(init_val) : ConstantInt::get(int64_type, 0);
        result->addIncoming(empty_result, entry_block);
        result->addIncoming(final_result, fold_exit_end);

        return result;
    }

    // Boolean predicate: checks if value is #t or #f
    Value* codegenBooleanPredicate(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("boolean? requires exactly 1 argument");
            return nullptr;
        }

        Value* val = codegenAST(&op->call_op.variables[0]);
        if (!val) return nullptr;

        // Booleans have type tag ESHKOL_VALUE_BOOL
        Value* type_tag = getTaggedValueType(val);
        Value* is_bool = builder->CreateICmpEQ(type_tag,
            ConstantInt::get(int8_type, ESHKOL_VALUE_BOOL));

        return packBoolToTaggedValue(is_bool);
    }

    // Procedure predicate: checks if value is a function
    Value* codegenProcedurePredicate(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_error("procedure? requires exactly 1 argument");
            return nullptr;
        }

        Value* val = codegenAST(&op->call_op.variables[0]);
        if (!val) return nullptr;

        // Check if it's a procedure (either lambda s-expression or closure)
        Value* type_tag = getTaggedValueType(val);
        Value* base_type = builder->CreateAnd(type_tag,
            ConstantInt::get(int8_type, 0x0F));  // Mask off flags

        // A procedure can be either LAMBDA_SEXPR or CLOSURE_PTR
        Value* is_lambda = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_LAMBDA_SEXPR));
        Value* is_closure = builder->CreateICmpEQ(base_type,
            ConstantInt::get(int8_type, ESHKOL_VALUE_CLOSURE_PTR));
        Value* is_procedure = builder->CreateOr(is_lambda, is_closure);

        return packBoolToTaggedValue(is_procedure);
    }

    // codegenAppend removed - now in stdlib.esk (core/list/transform.esk)
    
    // codegenIterativeAppend removed - now in stdlib.esk (core/list/transform.esk)
    
    // codegenReverse removed - now in stdlib.esk (core/list/transform.esk)

    // codegenListRef removed - now in stdlib.esk (core/list/search.esk)
    // codegenListTail removed - now in stdlib.esk (core/list/search.esk)

    // Production implementation: Set car (mutable)
    Value* codegenSetCar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("set-car! requires exactly 2 arguments: pair and new-value");
            return nullptr;
        }
        
        Value* pair = codegenAST(&op->call_op.variables[0]);
        Value* new_value = codegenAST(&op->call_op.variables[1]);
        if (!pair || !new_value) return nullptr;

        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        Value* pair_int = safeExtractInt64(pair);

        // Mutate the car of the pair using tagged helper
        Value* cons_ptr = builder->CreateIntToPtr(pair_int, builder->getPtrTy());
        
        // Detect new value type and use appropriate setter
        TypedValue new_val_typed = detectValueType(new_value);
        Value* is_car = ConstantInt::get(int1_type, 0);
        uint8_t type_tag = new_val_typed.type;
        
        if (new_val_typed.isInt64()) {
            builder->CreateCall(getTaggedConsSetInt64Func(),
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        } else if (new_val_typed.isDouble()) {
            builder->CreateCall(getTaggedConsSetDoubleFunc(),
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        } else {
            // Pointer/other types
            builder->CreateCall(getTaggedConsSetPtrFunc(),
                {cons_ptr, is_car, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        }
        
        // Return the new value (Scheme convention)
        return new_value;
    }
    
    // Production implementation: Set cdr (mutable)
    Value* codegenSetCdr(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("set-cdr! requires exactly 2 arguments: pair and new-value");
            return nullptr;
        }

        Value* pair = codegenAST(&op->call_op.variables[0]);
        Value* new_value = codegenAST(&op->call_op.variables[1]);
        if (!pair || !new_value) return nullptr;

        // TYPE SYSTEM FIX: Use safeExtractInt64 to handle tagged_value structs
        Value* pair_int = safeExtractInt64(pair);

        // Mutate the cdr of the pair using tagged helper
        Value* cons_ptr = builder->CreateIntToPtr(pair_int, builder->getPtrTy());
        
        // Detect new value type and use appropriate setter
        TypedValue new_val_typed = detectValueType(new_value);
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        uint8_t type_tag = new_val_typed.type;
        
        if (new_val_typed.isInt64()) {
            builder->CreateCall(getTaggedConsSetInt64Func(),
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        } else if (new_val_typed.isDouble()) {
            builder->CreateCall(getTaggedConsSetDoubleFunc(),
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        } else {
            // Pointer/other types
            builder->CreateCall(getTaggedConsSetPtrFunc(),
                {cons_ptr, is_cdr, new_val_typed.llvm_value,
                 ConstantInt::get(int8_type, type_tag)});
        }
        
        // Return the new value (Scheme convention)
        return new_value;
    }
    
    // Create a wrapper function for indirect calls through function parameters
    // This enables higher-order functions where functions are passed as arguments
    // The wrapper takes the function pointer as its first argument (captured from outer scope)
    // followed by the actual arguments for the function call
    Value* codegenIndirectFunctionCall(Argument* func_arg, size_t arity) {
        // Create wrapper function type:
        // First param is the function pointer (as tagged_value)
        // Remaining params are the actual arguments (tagged_value each)
        std::vector<Type*> wrapper_param_types;
        wrapper_param_types.push_back(tagged_value_type);  // Function pointer
        for (size_t i = 0; i < arity; i++) {
            wrapper_param_types.push_back(tagged_value_type);  // Arguments
        }
        FunctionType* wrapper_type = FunctionType::get(tagged_value_type, wrapper_param_types, false);

        static int indirect_counter = 0;
        std::string wrapper_name = "indirect_call_" + std::to_string(indirect_counter++);

        Function* wrapper_func = Function::Create(
            wrapper_type,
            Function::InternalLinkage,
            wrapper_name,
            module.get()
        );

        BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        builder->SetInsertPoint(entry);

        // Get arguments
        auto arg_it = wrapper_func->arg_begin();
        Value* func_tagged = &*arg_it++;  // First arg is the function pointer

        // Extract the function pointer from the tagged_value
        Value* func_ptr_int = unpackInt64FromTaggedValue(func_tagged);
        Value* func_ptr = builder->CreateIntToPtr(func_ptr_int, PointerType::getUnqual(*context));

        // Create the function type for the indirect call (just the actual args, not the func ptr)
        std::vector<Type*> callee_param_types(arity, tagged_value_type);
        FunctionType* callee_type = FunctionType::get(tagged_value_type, callee_param_types, false);

        // Create function pointer type
        PointerType* func_ptr_type = PointerType::getUnqual(*context);
        Value* typed_func_ptr = builder->CreateBitCast(func_ptr, func_ptr_type);

        // Gather the actual arguments (skip the first which is the function pointer)
        std::vector<Value*> call_args;
        while (arg_it != wrapper_func->arg_end()) {
            call_args.push_back(&*arg_it++);
        }

        // Create indirect call
        Value* result = builder->CreateCall(callee_type, typed_func_ptr, call_args);
        builder->CreateRet(result);

        builder->restoreIP(old_point);

        // Store the function argument reference for later use when calling the wrapper
        // We need to capture the actual function value to pass to the wrapper
        symbol_table["__indirect_func_arg__"] = func_arg;

        return wrapper_func;
    }

    // Production implementation: Map function
    // REFACTORED: Delegates to MapCodegen module
    Value* codegenMap(const eshkol_operations_t* op) {
        return map_->map(op);
    }

    
    // Helper function to resolve lambda/function from AST with arity-specific builtin handling
    Value* resolveLambdaFunction(const eshkol_ast_t* func_ast, size_t required_arity = 0) {
        if (!func_ast) {
            eshkol_error("resolveLambdaFunction: func_ast is nullptr");
            return nullptr;
        }
        
        // Handle inline lambda expressions
        if (func_ast->type == ESHKOL_OP && func_ast->operation.op == ESHKOL_LAMBDA_OP) {
            eshkol_debug("Generating inline lambda for map/gradient/jacobian/etc.");
            Value* lambda_result = codegenLambda(&func_ast->operation);
            if (!lambda_result) {
                eshkol_error("codegenLambda returned nullptr for inline lambda");
                return nullptr;
            }

            // CLOSURE FIX FOR MAP: If codegenLambda returned a closure (packed pointer),
            // we need to get the actual Function* from the last generated lambda.
            // This allows map to call the function with the captures as additional arguments.
            if (!isa<Function>(lambda_result)) {
                // Lambda has captures and returned a closure - get the underlying function
                // The last generated lambda name is stored in last_generated_lambda_name
                if (!last_generated_lambda_name.empty()) {
                    // Check function_table first
                    auto func_it = function_table.find(last_generated_lambda_name);
                    if (func_it != function_table.end() && func_it->second) {
                        eshkol_debug("Retrieved Function* %s from function_table for map",
                                    last_generated_lambda_name.c_str());
                        return func_it->second;
                    }
                    // Also check global_symbol_table (lambdas are stored here)
                    auto global_it = global_symbol_table.find(last_generated_lambda_name);
                    if (global_it != global_symbol_table.end() && global_it->second) {
                        if (isa<Function>(global_it->second)) {
                            eshkol_debug("Retrieved Function* %s from global_symbol_table for map",
                                        last_generated_lambda_name.c_str());
                            return global_it->second;
                        }
                    }
                }
                eshkol_warn("Could not extract function from closure for inline lambda");
            }

            eshkol_debug("Successfully generated inline lambda: %p", lambda_result);
            return lambda_result;
        }

        // Handle arithmetic operators as first-class functions (e.g., (map + v1 v2))
        if (func_ast->type == ESHKOL_OP) {
            switch (func_ast->operation.op) {
                case ESHKOL_ADD_OP:
                    return createBuiltinArithmeticFunction("+", required_arity > 0 ? required_arity : 2);
                case ESHKOL_SUB_OP:
                    return createBuiltinArithmeticFunction("-", required_arity > 0 ? required_arity : 2);
                case ESHKOL_MUL_OP:
                    return createBuiltinArithmeticFunction("*", required_arity > 0 ? required_arity : 2);
                case ESHKOL_DIV_OP:
                    return createBuiltinArithmeticFunction("/", required_arity > 0 ? required_arity : 2);
                default:
                    break;
            }
        }

        if (func_ast->type == ESHKOL_VAR) {
            std::string func_name = func_ast->variable.id;
            eshkol_debug("resolveLambdaFunction: looking for variable '%s'", func_name.c_str());

            // BUILTIN FIRST-CLASS FIX: Check for builtin math functions FIRST before raw function_table lookup
            // These need wrapper functions that take/return tagged_value_type
            static const std::set<std::string> math_builtins = {
                "sin", "cos", "tan", "exp", "log", "sqrt", "abs", "fabs",
                "asin", "acos", "atan", "sinh", "cosh", "tanh",
                "asinh", "acosh", "atanh", "exp2", "log2", "log10",
                "floor", "ceil", "round", "trunc", "cbrt",
                "ceiling", "truncate"  // Scheme-style names
            };
            if (math_builtins.count(func_name)) {
                eshkol_debug("resolveLambdaFunction: '%s' is a math builtin, creating wrapper", func_name.c_str());
                return createBuiltinUnaryMathFunction(func_name);
            }

            // Strategy 0: Check function_table for regular defined functions (NOT raw C builtins)
            auto direct_it = function_table.find(func_name);
            if (direct_it != function_table.end() && direct_it->second) {
                // SAFETY: Skip raw C functions - they need wrappers for first-class use
                Function* found_func = direct_it->second;
                FunctionType* ft = found_func->getFunctionType();
                // A raw C math function has signature: double -> double
                // A wrapped function has signature: tagged_value -> tagged_value
                bool is_raw_c_func = (ft->getNumParams() > 0 &&
                                      ft->getParamType(0)->isDoubleTy() &&
                                      ft->getReturnType()->isDoubleTy());
                if (!is_raw_c_func) {
                    eshkol_debug("resolveLambdaFunction: found '%s' in function_table", func_name.c_str());
                    return found_func;
                }
                // Otherwise, fall through to other strategies or wrapper creation
                eshkol_debug("resolveLambdaFunction: '%s' is raw C function, skipping", func_name.c_str());
            }

            // SCOPED LOOKUP FIX: Try scoped key FIRST to resolve local lambdas correctly
            // This prevents conflicts when multiple functions define local variables with the same name
            // (e.g., each test function defining a local 'f' lambda)
            std::string func_key = func_name + "_func";
            if (current_function) {
                std::string scoped_func_key = current_function->getName().str() + "." + func_key;
                auto scoped_it = symbol_table.find(scoped_func_key);
                if (scoped_it != symbol_table.end() && scoped_it->second) {
                    eshkol_debug("resolveLambdaFunction: found '%s' in symbol_table (scoped)", scoped_func_key.c_str());
                    if (isa<Function>(scoped_it->second)) {
                        return scoped_it->second;
                    }
                }
                scoped_it = global_symbol_table.find(scoped_func_key);
                if (scoped_it != global_symbol_table.end() && scoped_it->second) {
                    eshkol_debug("resolveLambdaFunction: found '%s' in global_symbol_table (scoped)", scoped_func_key.c_str());
                    if (isa<Function>(scoped_it->second)) {
                        return scoped_it->second;
                    }
                }
            }

            // Strategy 1: Try to find lambda function directly with _func suffix in LOCAL table
            auto func_it = symbol_table.find(func_key);
            if (func_it != symbol_table.end() && func_it->second) {
                eshkol_debug("resolveLambdaFunction: found '%s' in symbol_table", func_key.c_str());
                if (isa<Function>(func_it->second)) {
                    return func_it->second;
                }
                eshkol_debug("resolveLambdaFunction: '%s' is not a Function*", func_key.c_str());
            }

            // Strategy 2: Try global symbol table
            func_it = global_symbol_table.find(func_key);
            if (func_it != global_symbol_table.end() && func_it->second) {
                eshkol_debug("resolveLambdaFunction: found '%s' in global_symbol_table", func_key.c_str());
                if (isa<Function>(func_it->second)) {
                    return func_it->second;
                }
                eshkol_debug("resolveLambdaFunction: '%s' in global is not a Function*", func_key.c_str());
            }

            eshkol_debug("resolveLambdaFunction: '%s' not found in symbol tables", func_key.c_str());

            // Strategy 3: Try REPL context (for cross-evaluation function calls)
            Function* repl_func = tryResolveReplFunction(func_name);
            if (repl_func) {
                return repl_func;
            }
            repl_func = tryResolveReplFunction(func_key);
            if (repl_func) {
                return repl_func;
            }

            // Handle builtin functions using polymorphic arithmetic (Phase 2.4)
            // Note: For now we only support binary operations (arity 2)
            if (func_name == "+" && required_arity == 2) {
                return polymorphicAdd();
            }
            if (func_name == "*" && required_arity == 2) {
                return polymorphicMul();
            }
            if (func_name == "-" && required_arity == 2) {
                return polymorphicSub();
            }
            if (func_name == "/" && required_arity == 2) {
                return polymorphicDiv();
            }
            
            // Handle all arities with polymorphic functions
            if (func_name == "+" || func_name == "*" || func_name == "-" || func_name == "/") {
                return createBuiltinArithmeticFunction(func_name, required_arity);
            }

            // Handle comparison operators as first-class functions (for sort, etc.)
            if (func_name == "<" || func_name == ">" || func_name == "<=" ||
                func_name == ">=" || func_name == "=") {
                return createBuiltinComparisonFunction(func_name);
            }

            // Handle predicates as first-class functions (for filter, etc.)
            if (func_name == "even?" || func_name == "odd?" || func_name == "zero?" ||
                func_name == "positive?" || func_name == "negative?" || func_name == "null?" ||
                func_name == "pair?") {
                return createBuiltinPredicateFunction(func_name);
            }

            // Handle unary math functions as first-class functions (for map, etc.)
            if (func_name == "abs" || func_name == "sin" || func_name == "cos" ||
                func_name == "tan" || func_name == "exp" || func_name == "log" ||
                func_name == "sqrt" || func_name == "floor" || func_name == "ceiling" ||
                func_name == "truncate" || func_name == "round") {
                return createBuiltinUnaryMathFunction(func_name);
            }

            // Handle car builtin function (for use with map)
            if (func_name == "car") {
                static int car_counter = 0;
                std::string wrapper_name = "builtin_car_" + std::to_string(car_counter++);

                FunctionType* wrapper_type = FunctionType::get(
                    tagged_value_type,
                    {tagged_value_type},
                    false
                );

                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );

                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);

                Value* arg = &*wrapper_func->arg_begin();
                // Use the existing extractCarAsTaggedValue which handles all types correctly
                Value* cons_ptr_int = unpackInt64FromTaggedValue(arg);
                Value* result = extractCarAsTaggedValue(cons_ptr_int);
                builder->CreateRet(result);

                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                return wrapper_func;
            }

            // Handle cadr builtin function (for use with map) - car of cdr
            if (func_name == "cadr") {
                static int cadr_counter = 0;
                std::string wrapper_name = "builtin_cadr_" + std::to_string(cadr_counter++);

                FunctionType* wrapper_type = FunctionType::get(
                    tagged_value_type,
                    {tagged_value_type},
                    false
                );

                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );

                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);

                Value* arg = &*wrapper_func->arg_begin();
                Value* cons_ptr_int = unpackInt64FromTaggedValue(arg);
                Value* cons_ptr = builder->CreateIntToPtr(cons_ptr_int, builder->getPtrTy());

                // Get cdr first (is_cdr=true)
                Value* get_cdr = ConstantInt::get(int1_type, true);
                Value* cdr_ptr = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, get_cdr});

                // Then get car of cdr using extractCarAsTaggedValue
                Value* result = extractCarAsTaggedValue(cdr_ptr);
                builder->CreateRet(result);

                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                return wrapper_func;
            }

            // Handle cdr builtin function (for use with map)
            if (func_name == "cdr") {
                static int cdr_counter = 0;
                std::string wrapper_name = "builtin_cdr_" + std::to_string(cdr_counter++);

                FunctionType* wrapper_type = FunctionType::get(
                    tagged_value_type,
                    {tagged_value_type},
                    false
                );

                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );

                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);

                Value* arg = &*wrapper_func->arg_begin();
                Value* cons_ptr_int = unpackInt64FromTaggedValue(arg);
                // Use extractCdrAsTaggedValue for proper type handling
                Value* result = extractCdrAsTaggedValue(cons_ptr_int);
                builder->CreateRet(result);

                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                return wrapper_func;
            }

            // Handle cons builtin function (for use with fold-right, etc.)
            if (func_name == "cons") {
                static int cons_counter = 0;
                std::string wrapper_name = "builtin_cons_" + std::to_string(cons_counter++);

                FunctionType* wrapper_type = FunctionType::get(
                    tagged_value_type,
                    {tagged_value_type, tagged_value_type},
                    false
                );

                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );

                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);

                auto args_it = wrapper_func->arg_begin();
                Value* car_val = &*args_it++;
                Value* cdr_val = &*args_it;

                // Create cons cell with car and cdr
                Value* new_cons = codegenTaggedArenaConsCellFromTaggedValue(car_val, cdr_val);
                Value* result = packPtrToTaggedValue(
                    builder->CreateIntToPtr(new_cons, builder->getPtrTy()),
                    ESHKOL_VALUE_CONS_PTR);
                builder->CreateRet(result);

                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                return wrapper_func;
            }

            // Handle list builtin function (for use with map to create pairs)
            if (func_name == "list") {
                static int list_counter = 0;
                std::string wrapper_name = "builtin_list_" + std::to_string(list_counter++);

                // Create function that takes N tagged_values and returns a list
                std::vector<Type*> param_types;
                size_t arity = required_arity > 0 ? required_arity : 2;
                for (size_t i = 0; i < arity; i++) {
                    param_types.push_back(tagged_value_type);
                }

                FunctionType* wrapper_type = FunctionType::get(
                    tagged_value_type,
                    param_types,
                    false
                );

                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );

                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);

                // Build list from back to front: (list a b c) = (cons a (cons b (cons c nil)))
                Value* result = packInt64ToTaggedValue(
                    ConstantInt::get(int64_type, 0), true);  // nil

                // Iterate args in reverse
                std::vector<Value*> args;
                for (auto& arg : wrapper_func->args()) {
                    args.push_back(&arg);
                }

                for (auto it = args.rbegin(); it != args.rend(); ++it) {
                    Value* elem = *it;
                    // Create cons cell with elem as car and result as cdr
                    Value* new_cons = codegenTaggedArenaConsCellFromTaggedValue(elem, result);
                    result = packPtrToTaggedValue(
                        builder->CreateIntToPtr(new_cons, builder->getPtrTy()),
                        ESHKOL_VALUE_CONS_PTR
                    );
                }

                builder->CreateRet(result);

                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                return wrapper_func;
            }

            // append builtin wrapper removed - now in stdlib.esk (core/list/transform.esk)

            // Handle display builtin function
            if (func_name == "display") {
                // Create wrapper for display that takes tagged_value and returns 0
                static int display_counter = 0;
                std::string wrapper_name = "builtin_display_" + std::to_string(display_counter++);
                
                // FIX: Accept tagged_value parameter, not i64
                FunctionType* wrapper_type = FunctionType::get(
                    int64_type,
                    {tagged_value_type},  // FIXED: Accept tagged_value
                    false
                );
                
                Function* wrapper_func = Function::Create(
                    wrapper_type,
                    Function::ExternalLinkage,
                    wrapper_name,
                    module.get()
                );
                
                BasicBlock* entry = BasicBlock::Create(*context, "entry", wrapper_func);
                IRBuilderBase::InsertPoint old_point = builder->saveIP();
                builder->SetInsertPoint(entry);
                
                // Call display function with tagged_value
                Value* arg_tagged = &*wrapper_func->arg_begin();
                Function* printf_func = function_table["printf"];
                if (printf_func) {
                    // Extract type and value from tagged_value
                    Value* arg_type = getTaggedValueType(arg_tagged);
                    Value* arg_base_type = builder->CreateAnd(arg_type,
                        ConstantInt::get(int8_type, 0x0F));
                    Value* is_double = builder->CreateICmpEQ(arg_base_type,
                        ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));
                    
                    BasicBlock* double_display = BasicBlock::Create(*context, "display_double", wrapper_func);
                    BasicBlock* int_display = BasicBlock::Create(*context, "display_int", wrapper_func);
                    BasicBlock* display_done = BasicBlock::Create(*context, "display_done", wrapper_func);
                    
                    builder->CreateCondBr(is_double, double_display, int_display);
                    
                    builder->SetInsertPoint(double_display);
                    Value* double_val = unpackDoubleFromTaggedValue(arg_tagged);
                    builder->CreateCall(printf_func, {codegenString("%g"), double_val});
                    builder->CreateBr(display_done);
                    
                    builder->SetInsertPoint(int_display);
                    Value* int_val = unpackInt64FromTaggedValue(arg_tagged);
                    builder->CreateCall(printf_func, {codegenString("%lld"), int_val});
                    builder->CreateBr(display_done);
                    
                    builder->SetInsertPoint(display_done);
                }
                builder->CreateRet(ConstantInt::get(int64_type, 0));
                
                builder->restoreIP(old_point);
                registerContextFunction(wrapper_name, wrapper_func);
                
                return wrapper_func;
            }
            
        }
        
        return nullptr;
    }

    // Production implementation: Apply function
    // (apply fn args-list) - calls fn with arguments from args-list
    // REFACTORED: Delegates to CallApplyCodegen module
    Value* codegenApply(const eshkol_operations_t* op) {
        return call_apply_->apply(op);
    }

    // codegenAssoc removed - now in stdlib.esk (core/list/search.esk)

    // Production implementation: List* (improper list constructor)
    Value* codegenListStar(const eshkol_operations_t* op) {
        if (op->call_op.num_vars == 0) {
            eshkol_warn("list* requires at least 1 argument");
            return nullptr;
        }
        
        // Single argument case: just return the argument itself
        if (op->call_op.num_vars == 1) {
            return codegenAST(&op->call_op.variables[0]);
        }
        
        // Multiple arguments: build improper list where last element is the terminal
        // (list* 1 2 3 4) => (1 . (2 . (3 . 4)))  (4 is terminal, not null)
        
        // Start with the last element as terminal
        Value* result = codegenAST(&op->call_op.variables[op->call_op.num_vars - 1]);
        if (!result) return ConstantInt::get(int64_type, 0);
        
        // Build cons chain from second-to-last element backwards to first
        for (int64_t i = op->call_op.num_vars - 2; i >= 0; i--) {
            Value* element = codegenAST(&op->call_op.variables[i]);
            if (element) {
                // Create cons cell: (element . result) with type preservation
                TypedValue element_typed = detectValueType(element);
                TypedValue result_typed = detectValueType(result);
                result = codegenTaggedArenaConsCell(element_typed, result_typed);
            }
        }
        
        return result;
    }
    
    // Production implementation: Acons (association constructor)
    Value* codegenAcons(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 3) {
            eshkol_warn("acons requires exactly 3 arguments: key, value, and alist");
            return nullptr;
        }
        
        Value* key = codegenAST(&op->call_op.variables[0]);
        Value* value = codegenAST(&op->call_op.variables[1]);
        Value* alist = codegenAST(&op->call_op.variables[2]);
        
        if (!key || !value || !alist) return nullptr;
        
        // Create new key-value pair: (key . value) with type preservation
        TypedValue key_typed = detectValueType(key);
        TypedValue value_typed = detectValueType(value);
        Value* new_pair = codegenTaggedArenaConsCell(key_typed, value_typed);
        
        // Cons the new pair onto the existing alist: ((key . value) . alist)
        TypedValue pair_typed = TypedValue(new_pair, ESHKOL_VALUE_CONS_PTR, true);
        TypedValue alist_typed = detectValueType(alist);
        Value* new_alist = codegenTaggedArenaConsCell(pair_typed, alist_typed);
        
        return new_alist;
    }
    
    // codegenTake removed - now in stdlib.esk (core/list/query.esk)
    // codegenDrop removed - now in stdlib.esk (core/list/query.esk)
    // codegenFind removed - now in stdlib.esk (core/list/query.esk)

    // Production implementation: Partition function (split list by predicate)
    Value* codegenPartition(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("partition requires exactly 2 arguments: predicate and list");
            return nullptr;
        }
        
        // Get predicate function
        Value* predicate = resolveLambdaFunction(&op->call_op.variables[0]);
        if (!predicate) {
            eshkol_error("Failed to resolve predicate for partition");
            return nullptr;
        }
        
        Function* pred_func = dyn_cast<Function>(predicate);
        if (!pred_func) {
            eshkol_error("partition predicate must be a function");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - partition results must persist
        // Arena scoping causes memory corruption by resetting used pointer
        
        // Initialize two result lists: true_list and false_list
        Value* true_head = builder->CreateAlloca(int64_type, nullptr, "partition_true_head");
        Value* true_tail = builder->CreateAlloca(int64_type, nullptr, "partition_true_tail");
        Value* false_head = builder->CreateAlloca(int64_type, nullptr, "partition_false_head");
        Value* false_tail = builder->CreateAlloca(int64_type, nullptr, "partition_false_tail");
        Value* current_input = builder->CreateAlloca(int64_type, nullptr, "partition_current");
        
        builder->CreateStore(ConstantInt::get(int64_type, 0), true_head);
        builder->CreateStore(ConstantInt::get(int64_type, 0), true_tail);
        builder->CreateStore(ConstantInt::get(int64_type, 0), false_head);
        builder->CreateStore(ConstantInt::get(int64_type, 0), false_tail);
        builder->CreateStore(list, current_input);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "partition_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "partition_loop_body", current_func);
        BasicBlock* add_to_true = BasicBlock::Create(*context, "partition_add_true", current_func);
        BasicBlock* add_to_false = BasicBlock::Create(*context, "partition_add_false", current_func);
        BasicBlock* continue_partition = BasicBlock::Create(*context, "partition_continue", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "partition_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(int64_type, current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);
        
        // Loop body: get current element and check predicate
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value - polymorphic functions expect tagged_value!
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        
        // Apply predicate to current element (pass tagged_value directly)
        Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});
        
        // Predicate returns tagged_value - unpack to check boolean result
        Value* pred_result_int = unpackInt64FromTaggedValue(pred_result);
        
        // Check if predicate returned true (non-zero)
        Value* pred_is_true = builder->CreateICmpNE(pred_result_int, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(pred_is_true, add_to_true, add_to_false);
        
        // Add element to true list if predicate is true
        builder->SetInsertPoint(add_to_true);
        TypedValue elem_typed_true = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null_true = TypedValue(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);
        Value* new_true_cons = codegenTaggedArenaConsCell(elem_typed_true, cdr_null_true);
        
        // Update true list
        Value* true_head_val = builder->CreateLoad(int64_type, true_head);
        Value* true_head_empty = builder->CreateICmpEQ(true_head_val, ConstantInt::get(int64_type, 0));
        
        BasicBlock* set_true_head = BasicBlock::Create(*context, "partition_set_true_head", current_func);
        BasicBlock* update_true_tail = BasicBlock::Create(*context, "partition_update_true_tail", current_func);
        
        builder->CreateCondBr(true_head_empty, set_true_head, update_true_tail);
        
        builder->SetInsertPoint(set_true_head);
        builder->CreateStore(new_true_cons, true_head);
        builder->CreateStore(new_true_cons, true_tail);
        builder->CreateBr(continue_partition);
        
        builder->SetInsertPoint(update_true_tail);
        Value* true_tail_val = builder->CreateLoad(int64_type, true_tail);
        Value* true_tail_cons_ptr = builder->CreateIntToPtr(true_tail_val, builder->getPtrTy());
        
        // Use getTaggedConsSetPtrFunc() to set cdr
        Value* is_cdr_set_true = ConstantInt::get(int1_type, 1);
        Value* ptr_type_tag = ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {true_tail_cons_ptr, is_cdr_set_true, new_true_cons, ptr_type_tag});
        builder->CreateStore(new_true_cons, true_tail);
        builder->CreateBr(continue_partition);
        
        // Add element to false list if predicate is false
        builder->SetInsertPoint(add_to_false);
        TypedValue elem_typed_false = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null_false = TypedValue(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);
        Value* new_false_cons = codegenTaggedArenaConsCell(elem_typed_false, cdr_null_false);
        
        // Update false list
        Value* false_head_val = builder->CreateLoad(int64_type, false_head);
        Value* false_head_empty = builder->CreateICmpEQ(false_head_val, ConstantInt::get(int64_type, 0));
        
        BasicBlock* set_false_head = BasicBlock::Create(*context, "partition_set_false_head", current_func);
        BasicBlock* update_false_tail = BasicBlock::Create(*context, "partition_update_false_tail", current_func);
        
        builder->CreateCondBr(false_head_empty, set_false_head, update_false_tail);
        
        builder->SetInsertPoint(set_false_head);
        builder->CreateStore(new_false_cons, false_head);
        builder->CreateStore(new_false_cons, false_tail);
        builder->CreateBr(continue_partition);
        
        builder->SetInsertPoint(update_false_tail);
        Value* false_tail_val = builder->CreateLoad(int64_type, false_tail);
        Value* false_tail_cons_ptr = builder->CreateIntToPtr(false_tail_val, builder->getPtrTy());
        
        // Use getTaggedConsSetPtrFunc() to set cdr
        Value* is_cdr_set_false = ConstantInt::get(int1_type, 1);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {false_tail_cons_ptr, is_cdr_set_false, new_false_cons, ptr_type_tag});
        builder->CreateStore(new_false_cons, false_tail);
        builder->CreateBr(continue_partition);
        
        // Continue: move to next input element using tagged helper
        builder->SetInsertPoint(continue_partition);
        Value* is_cdr_get = ConstantInt::get(int1_type, 1);
        Value* input_cdr = builder->CreateCall(getTaggedConsGetPtrFunc(),
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return pair of (true_list . false_list)
        builder->SetInsertPoint(loop_exit);
        Value* final_true_list = builder->CreateLoad(int64_type, true_head);
        Value* final_false_list = builder->CreateLoad(int64_type, false_head);
        
        // Create result pair: (true_list . false_list) with type preservation
        TypedValue true_typed = TypedValue(final_true_list,
            final_true_list == ConstantInt::get(int64_type, 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        TypedValue false_typed = TypedValue(final_false_list,
            final_false_list == ConstantInt::get(int64_type, 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        Value* result_pair = codegenTaggedArenaConsCell(true_typed, false_typed);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return result_pair;
    }
    
    // Production implementation: Split-at function (split list at index)
    Value* codegenSplitAt(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("split-at requires exactly 2 arguments: list and index");
            return nullptr;
        }
        
        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        Value* index_raw = codegenAST(&op->call_op.variables[1]);
        if (!list_raw || !index_raw) return nullptr;

        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);
        Value* index = safeExtractInt64(index_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - split-at results must persist
        // Arena scoping causes memory corruption by resetting used pointer

        // Initialize result lists: prefix and suffix
        Value* prefix_head = builder->CreateAlloca(int64_type, nullptr, "splitat_prefix_head");
        Value* prefix_tail = builder->CreateAlloca(int64_type, nullptr, "splitat_prefix_tail");
        Value* current_input = builder->CreateAlloca(int64_type, nullptr, "splitat_current");
        Value* counter = builder->CreateAlloca(int64_type, nullptr, "splitat_counter");
        
        builder->CreateStore(ConstantInt::get(int64_type, 0), prefix_head);
        builder->CreateStore(ConstantInt::get(int64_type, 0), prefix_tail);
        builder->CreateStore(list, current_input);
        builder->CreateStore(ConstantInt::get(int64_type, 0), counter);
        
        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "splitat_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "splitat_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "splitat_loop_exit", current_func);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if counter < index AND current != null
        builder->SetInsertPoint(loop_condition);
        Value* count_val = builder->CreateLoad(int64_type, counter);
        Value* current_val = builder->CreateLoad(int64_type, current_input);
        
        Value* count_less = builder->CreateICmpULT(count_val, index);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(int64_type, 0));
        Value* continue_loop = builder->CreateAnd(count_less, current_not_null);
        
        builder->CreateCondBr(continue_loop, loop_body, loop_exit);
        
        // Loop body: take current element for prefix and advance
        builder->SetInsertPoint(loop_body);
        
        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        
        // Extract car as tagged_value and convert to TypedValue
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        TypedValue input_element_typed = taggedValueToTypedValue(input_element_tagged);
        
        // Create new cons cell for prefix with type preservation
        TypedValue cdr_null = TypedValue(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);
        Value* new_prefix_cons = codegenTaggedArenaConsCell(input_element_typed, cdr_null);
        
        // Update prefix list (similar to take)
        Value* prefix_head_val = builder->CreateLoad(int64_type, prefix_head);
        Value* prefix_head_empty = builder->CreateICmpEQ(prefix_head_val, ConstantInt::get(int64_type, 0));
        
        BasicBlock* set_prefix_head = BasicBlock::Create(*context, "splitat_set_prefix_head", current_func);
        BasicBlock* update_prefix_tail = BasicBlock::Create(*context, "splitat_update_prefix_tail", current_func);
        BasicBlock* continue_splitat = BasicBlock::Create(*context, "splitat_continue", current_func);
        
        builder->CreateCondBr(prefix_head_empty, set_prefix_head, update_prefix_tail);
        
        builder->SetInsertPoint(set_prefix_head);
        builder->CreateStore(new_prefix_cons, prefix_head);
        builder->CreateStore(new_prefix_cons, prefix_tail);
        builder->CreateBr(continue_splitat);
        
        builder->SetInsertPoint(update_prefix_tail);
        Value* prefix_tail_val = builder->CreateLoad(int64_type, prefix_tail);
        Value* prefix_tail_cons_ptr = builder->CreateIntToPtr(prefix_tail_val, builder->getPtrTy());
        
        // Use getTaggedConsSetPtrFunc() to set cdr
        Value* is_cdr_set = ConstantInt::get(int1_type, 1);
        Value* ptr_type_tag = ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {prefix_tail_cons_ptr, is_cdr_set, new_prefix_cons, ptr_type_tag});
        builder->CreateStore(new_prefix_cons, prefix_tail);
        builder->CreateBr(continue_splitat);
        
        // Continue: move to next input element and increment counter
        builder->SetInsertPoint(continue_splitat);
        
        // Use getTaggedConsGetPtrFunc() to get cdr
        Value* is_cdr_get = ConstantInt::get(int1_type, 1);
        Value* input_cdr = builder->CreateCall(getTaggedConsGetPtrFunc(),
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        Value* new_count = builder->CreateAdd(count_val, ConstantInt::get(int64_type, 1));
        builder->CreateStore(new_count, counter);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return pair of (prefix . suffix)
        builder->SetInsertPoint(loop_exit);
        Value* final_prefix = builder->CreateLoad(int64_type, prefix_head);
        Value* final_suffix = builder->CreateLoad(int64_type, current_input);
        
        // Create result pair: (prefix . suffix) with type preservation
        TypedValue prefix_typed = TypedValue(final_prefix,
            final_prefix == ConstantInt::get(int64_type, 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        TypedValue suffix_typed = TypedValue(final_suffix,
            final_suffix == ConstantInt::get(int64_type, 0) ? ESHKOL_VALUE_NULL : ESHKOL_VALUE_CONS_PTR, true);
        Value* result_pair = codegenTaggedArenaConsCell(prefix_typed, suffix_typed);
        
        // CRITICAL FIX: No arena scope cleanup - cons cells must persist
        
        return result_pair;
    }
    
    // Production implementation: Remove function family (remove elements that match)
    // Supports both element-based removal: (remove 2 '(1 2 3)) => (1 3)
    // and predicate-based removal: (remove even? '(1 2 3 4)) => (1 3)
    Value* codegenRemove(const eshkol_operations_t* op, const std::string& comparison_type) {
        if (op->call_op.num_vars != 2) {
            eshkol_warn("remove requires exactly 2 arguments: item/predicate and list");
            return nullptr;
        }

        // Check if first argument is a predicate (lambda or function reference)
        const eshkol_ast_t* first_arg = &op->call_op.variables[0];
        bool is_predicate = false;
        Function* pred_func = nullptr;

        if (first_arg->type == ESHKOL_OP && first_arg->operation.op == ESHKOL_LAMBDA_OP) {
            // Inline lambda - resolve it
            is_predicate = true;
            Value* proc = resolveLambdaFunction(first_arg);
            pred_func = proc ? dyn_cast<Function>(proc) : nullptr;
        } else if (first_arg->type == ESHKOL_VAR) {
            // Variable - check if it's a function
            std::string var_name = first_arg->variable.id;
            // Check function table first
            auto func_it = function_table.find(var_name);
            if (func_it != function_table.end() && func_it->second) {
                is_predicate = true;
                pred_func = func_it->second;
            } else {
                // Check for lambda reference
                auto sym_it = symbol_table.find(var_name + "_func");
                if (sym_it != symbol_table.end()) {
                    pred_func = dyn_cast<Function>(sym_it->second);
                    is_predicate = (pred_func != nullptr);
                }
            }
        }

        Value* list = codegenAST(&op->call_op.variables[1]);
        if (!list) return nullptr;
        Value* list_int = safeExtractInt64(list);

        // For element-based removal, get the item value
        Value* item_int = nullptr;
        if (!is_predicate) {
            Value* item = codegenAST(&op->call_op.variables[0]);
            if (!item) return nullptr;
            item_int = safeExtractInt64(item);
        }

        Function* current_func = builder->GetInsertBlock()->getParent();

        // CRITICAL FIX: Do not use arena scoping - remove results must persist
        // Arena scoping causes memory corruption by resetting used pointer

        // Initialize result list
        Value* result_head = builder->CreateAlloca(int64_type, nullptr, "remove_result_head");
        Value* result_tail = builder->CreateAlloca(int64_type, nullptr, "remove_result_tail");
        Value* current_input = builder->CreateAlloca(int64_type, nullptr, "remove_current");

        builder->CreateStore(ConstantInt::get(int64_type, 0), result_head);
        builder->CreateStore(ConstantInt::get(int64_type, 0), result_tail);
        builder->CreateStore(list_int, current_input);

        // Create loop blocks
        BasicBlock* loop_condition = BasicBlock::Create(*context, "remove_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "remove_loop_body", current_func);
        BasicBlock* skip_element = BasicBlock::Create(*context, "remove_skip_elem", current_func);
        BasicBlock* keep_element = BasicBlock::Create(*context, "remove_keep_elem", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "remove_loop_exit", current_func);

        builder->CreateBr(loop_condition);

        // Loop condition: check if current_input != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(int64_type, current_input);
        Value* is_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(is_not_null, loop_body, loop_exit);

        // Loop body: get current element and check if it should be removed
        builder->SetInsertPoint(loop_body);

        Value* input_cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());

        // Extract car as tagged_value
        Value* input_element_tagged = extractCarAsTaggedValue(current_val);
        Value* input_element = unpackInt64FromTaggedValue(input_element_tagged);

        // Determine if element should be removed
        Value* is_match = nullptr;
        if (is_predicate && pred_func) {
            // Predicate-based removal: call predicate and check if result is truthy
            Value* pred_result = builder->CreateCall(pred_func, {input_element_tagged});
            // Check if result is truthy (non-zero, non-false)
            Value* pred_result_int = safeExtractInt64(pred_result);
            is_match = builder->CreateICmpNE(pred_result_int, ConstantInt::get(int64_type, 0));
        } else if (comparison_type == "equal" || comparison_type == "eqv") {
            // Element-based: Value equality comparison
            is_match = builder->CreateICmpEQ(input_element, item_int);
        } else if (comparison_type == "eq") {
            // Element-based: Pointer equality comparison
            is_match = builder->CreateICmpEQ(input_element, item_int);
        }

        // If it matches (predicate true or equals item), skip it; otherwise keep it
        builder->CreateCondBr(is_match, skip_element, keep_element);
        
        // Keep element (doesn't match item to remove)
        builder->SetInsertPoint(keep_element);
        TypedValue elem_typed = taggedValueToTypedValue(input_element_tagged);
        TypedValue cdr_null = TypedValue(ConstantInt::get(int64_type, 0), ESHKOL_VALUE_NULL);
        Value* new_result_cons = codegenTaggedArenaConsCell(elem_typed, cdr_null);
        
        // Update result list
        Value* head_val = builder->CreateLoad(int64_type, result_head);
        Value* head_is_empty = builder->CreateICmpEQ(head_val, ConstantInt::get(int64_type, 0));
        
        BasicBlock* set_head = BasicBlock::Create(*context, "remove_set_head", current_func);
        BasicBlock* update_tail = BasicBlock::Create(*context, "remove_update_tail", current_func);
        
        builder->CreateCondBr(head_is_empty, set_head, update_tail);
        
        builder->SetInsertPoint(set_head);
        builder->CreateStore(new_result_cons, result_head);
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        builder->SetInsertPoint(update_tail);
        Value* tail_val = builder->CreateLoad(int64_type, result_tail);
        Value* tail_cons_ptr = builder->CreateIntToPtr(tail_val, builder->getPtrTy());
        
        // Use getTaggedConsSetPtrFunc() to set cdr
        Value* is_cdr_set = ConstantInt::get(int1_type, 1);
        Value* ptr_type_tag = ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR);
        builder->CreateCall(getTaggedConsSetPtrFunc(),
            {tail_cons_ptr, is_cdr_set, new_result_cons, ptr_type_tag});
        builder->CreateStore(new_result_cons, result_tail);
        builder->CreateBr(skip_element);
        
        // Skip element: move to next input element (for both keep and remove cases)
        builder->SetInsertPoint(skip_element);
        
        // Use getTaggedConsGetPtrFunc() to get cdr
        Value* is_cdr_get = ConstantInt::get(int1_type, 1);
        Value* input_cdr = builder->CreateCall(getTaggedConsGetPtrFunc(),
            {input_cons_ptr, is_cdr_get});
        builder->CreateStore(input_cdr, current_input);
        
        builder->CreateBr(loop_condition);
        
        // Loop exit: return result
        builder->SetInsertPoint(loop_exit);
        Value* final_result = builder->CreateLoad(int64_type, result_head);

        // CRITICAL FIX: No arena scope cleanup - cons cells must persist

        // FIX: Pack result as proper tagged value
        // Empty result returns NULL type, non-empty returns CONS_PTR type
        Value* result_is_empty = builder->CreateICmpEQ(final_result, ConstantInt::get(int64_type, 0));

        // Create null tagged value
        Value* null_tagged = packNullToTaggedValue();

        // Create CONS_PTR tagged value
        Value* cons_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(final_result, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);

        // Select appropriate tagged value
        Value* result = builder->CreateSelect(result_is_empty, null_tagged, cons_tagged);

        return result;
    }

    // Production implementation: Last function (return last element)
    Value* codegenLast(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("last requires exactly 1 argument: list");
            return nullptr;
        }

        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list is empty
        Value* list_is_empty = builder->CreateICmpEQ(list, ConstantInt::get(int64_type, 0));
        
        BasicBlock* empty_case = BasicBlock::Create(*context, "last_empty", current_func);
        BasicBlock* traverse_case = BasicBlock::Create(*context, "last_traverse", current_func);
        BasicBlock* loop_condition = BasicBlock::Create(*context, "last_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "last_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "last_loop_exit", current_func);
        BasicBlock* final_block = BasicBlock::Create(*context, "last_final", current_func);
        
        builder->CreateCondBr(list_is_empty, empty_case, traverse_case);
        
        // Empty case: return null (0)
        builder->SetInsertPoint(empty_case);
        Value* null_tagged_for_empty = packNullToTaggedValue();  // CRITICAL FIX: Create before branching!
        builder->CreateBr(final_block);
        
        // Traverse case: find last element
        builder->SetInsertPoint(traverse_case);
        
        // Initialize current and previous pointers
        Value* current_ptr = builder->CreateAlloca(int64_type, nullptr, "last_current");
        Value* previous_ptr = builder->CreateAlloca(int64_type, nullptr, "last_previous");
        
        builder->CreateStore(list, current_ptr);
        builder->CreateStore(ConstantInt::get(int64_type, 0), previous_ptr);
        
        builder->CreateBr(loop_condition);
        
        // Loop condition: check if current != null
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(int64_type, current_ptr);
        Value* current_not_null = builder->CreateICmpNE(current_val, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(current_not_null, loop_body, loop_exit);
        
        // Loop body: advance to next element
        builder->SetInsertPoint(loop_body);
        
        // Store current as previous
        builder->CreateStore(current_val, previous_ptr);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        Value* cdr_val = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        builder->CreateStore(cdr_val, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        builder->SetInsertPoint(loop_exit);
        Value* last_cons = builder->CreateLoad(int64_type, previous_ptr);
        
        // CRITICAL FIX: Use extractCarAsTaggedValue - no bitcast needed!
        // Extract last element as tagged_value (preserves type correctly)
        Value* last_element_tagged = extractCarAsTaggedValue(last_cons);
        BasicBlock* actual_loop_exit = builder->GetInsertBlock();  // CAPTURE ACTUAL PREDECESSOR!
        builder->CreateBr(final_block);
        
        // Final result selection - return tagged_value
        // CRITICAL FIX: PHI nodes must be first in basic block!
        builder->SetInsertPoint(final_block);
        PHINode* phi = builder->CreatePHI(tagged_value_type, 2, "last_result");
        phi->addIncoming(null_tagged_for_empty, empty_case); // null for empty list
        phi->addIncoming(last_element_tagged, actual_loop_exit);  // USE ACTUAL PREDECESSOR!
        
        return phi;
    }
    
    // Production implementation: Last-pair function (return last cons cell)
    Value* codegenLastPair(const eshkol_operations_t* op) {
        if (op->call_op.num_vars != 1) {
            eshkol_warn("last-pair requires exactly 1 argument: list");
            return nullptr;
        }

        Value* list_raw = codegenAST(&op->call_op.variables[0]);
        if (!list_raw) return nullptr;
        // CRITICAL FIX: Safely extract i64 from possibly-tagged value
        Value* list = safeExtractInt64(list_raw);

        Function* current_func = builder->GetInsertBlock()->getParent();

        // Check if list is empty
        Value* list_is_empty = builder->CreateICmpEQ(list, ConstantInt::get(int64_type, 0));
        
        BasicBlock* empty_case = BasicBlock::Create(*context, "lastpair_empty", current_func);
        BasicBlock* traverse_case = BasicBlock::Create(*context, "lastpair_traverse", current_func);
        BasicBlock* loop_condition = BasicBlock::Create(*context, "lastpair_loop_cond", current_func);
        BasicBlock* loop_body = BasicBlock::Create(*context, "lastpair_loop_body", current_func);
        BasicBlock* loop_exit = BasicBlock::Create(*context, "lastpair_loop_exit", current_func);
        BasicBlock* final_block = BasicBlock::Create(*context, "lastpair_final", current_func);
        
        builder->CreateCondBr(list_is_empty, empty_case, traverse_case);
        
        // Empty case: return null (0)
        builder->SetInsertPoint(empty_case);
        builder->CreateBr(final_block);
        
        // Traverse case: find last pair (cons cell where cdr is null)
        builder->SetInsertPoint(traverse_case);
        
        // Initialize current pointer
        Value* current_ptr = builder->CreateAlloca(int64_type, nullptr, "lastpair_current");
        builder->CreateStore(list, current_ptr);
        
        builder->CreateBr(loop_condition);
        
        builder->SetInsertPoint(loop_condition);
        Value* current_val = builder->CreateLoad(int64_type, current_ptr);
        
        Value* cons_ptr = builder->CreateIntToPtr(current_val, builder->getPtrTy());
        Value* is_cdr = ConstantInt::get(int1_type, 1);
        Value* cdr_val = builder->CreateCall(getTaggedConsGetPtrFunc(), {cons_ptr, is_cdr});
        
        // Check if cdr is null (this is the last pair)
        Value* cdr_is_null = builder->CreateICmpEQ(cdr_val, ConstantInt::get(int64_type, 0));
        builder->CreateCondBr(cdr_is_null, loop_exit, loop_body);
        
        // Loop body: advance to next element
        builder->SetInsertPoint(loop_body);
        builder->CreateStore(cdr_val, current_ptr);
        builder->CreateBr(loop_condition);
        
        // Loop exit: current contains the last pair
        builder->SetInsertPoint(loop_exit);
        Value* last_pair = builder->CreateLoad(int64_type, current_ptr);
        builder->CreateBr(final_block);
        
        // Final result selection
        builder->SetInsertPoint(final_block);
        PHINode* phi = builder->CreatePHI(int64_type, 2, "lastpair_result");
        phi->addIncoming(ConstantInt::get(int64_type, 0), empty_case); // null for empty list
        phi->addIncoming(last_pair, loop_exit);

        // FIX: Pack result as proper tagged value
        // Empty list returns NULL type, non-empty returns CONS_PTR type
        Value* result_is_empty = builder->CreateICmpEQ(phi, ConstantInt::get(int64_type, 0));

        // Create null tagged value
        Value* null_tagged = packNullToTaggedValue();

        // Create CONS_PTR tagged value
        Value* cons_tagged = packPtrToTaggedValue(
            builder->CreateIntToPtr(phi, builder->getPtrTy()),
            ESHKOL_VALUE_CONS_PTR);

        // Select appropriate tagged value
        Value* result = builder->CreateSelect(result_is_empty, null_tagged, cons_tagged);

        return result;
    }
    
    // Production implementation: Create arity-specific builtin arithmetic functions (POLYMORPHIC)
    Function* createBuiltinArithmeticFunction(const std::string& operation, size_t arity) {
        // FIX: For arity=0, just use arity=2 (fold will call with 2 args anyway)
        if (arity == 0) {
            eshkol_debug("Arity 0 requested for %s, using arity 2 instead", operation.c_str());
            arity = 2;
        }
        
        // Use deterministic names based on operation and arity only
        std::string func_name = "builtin_" + operation + "_" + std::to_string(arity) + "arg";
        
        // Check if function already exists
        auto existing_it = function_table.find(func_name);
        if (existing_it != function_table.end()) {
            return existing_it->second;
        }
        
        // Create polymorphic function type with tagged_value parameters
        std::vector<Type*> param_types(arity, tagged_value_type);
        FunctionType* func_type = FunctionType::get(
            tagged_value_type,  // Return tagged_value
            param_types,
            false // not varargs
        );
        
        Function* builtin_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );
        
        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();
        
        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", builtin_func);
        builder->SetInsertPoint(entry);
        
        // Apply polymorphic operation to all arguments (binary reduction)
        auto arg_it = builtin_func->arg_begin();
        Value* result = &*arg_it++;

        // Handle unary minus: (- x) => 0 - x
        if (arity == 1 && operation == "-") {
            Value* zero = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
            result = polymorphicSub(zero, &*builtin_func->arg_begin());
        }
        // Handle unary plus: (+ x) => x (identity, result is already set)
        else if (arity == 1 && operation == "+") {
            // result is already the single argument, just return it
        }
        // Binary and n-ary operations
        else {
            for (size_t i = 1; i < arity && arg_it != builtin_func->arg_end(); ++i, ++arg_it) {
                Value* operand = &*arg_it;

                if (operation == "+") {
                    result = polymorphicAdd(result, operand);
                } else if (operation == "-") {
                    result = polymorphicSub(result, operand);
                } else if (operation == "*") {
                    result = polymorphicMul(result, operand);
                } else if (operation == "/") {
                    result = polymorphicDiv(result, operand);
                } else {
                    eshkol_error("Unknown arithmetic operation: %s", operation.c_str());
                    result = packInt64ToTaggedValue(ConstantInt::get(int64_type, 0), true);
                    break;
                }
            }
        }
        
        builder->CreateRet(result);
        
        // Restore IRBuilder state
        if (old_point.isSet()) {
            builder->restoreIP(old_point);
        }
        
        // Add to function table
        registerContextFunction(func_name, builtin_func);
        
        eshkol_debug("Created polymorphic builtin function: %s for operation '%s' with arity %zu",
                    func_name.c_str(), operation.c_str(), arity);

        return builtin_func;
    }

    // Create builtin comparison function for use as first-class value (sort, etc.)
    // Comparison operators take 2 tagged values and return a tagged boolean
    Function* createBuiltinComparisonFunction(const std::string& operation) {
        std::string func_name = "builtin_cmp_" + operation;

        // Sanitize special characters in function name for LLVM
        for (char& c : func_name) {
            if (c == '<') c = 'L';
            else if (c == '>') c = 'G';
            else if (c == '=') c = 'E';
        }

        // Check if function already exists
        auto existing_it = function_table.find(func_name);
        if (existing_it != function_table.end()) {
            return existing_it->second;
        }

        // Create function type: (tagged_value, tagged_value) -> tagged_value
        std::vector<Type*> param_types = {tagged_value_type, tagged_value_type};
        FunctionType* func_type = FunctionType::get(
            tagged_value_type,  // Return tagged boolean
            param_types,
            false
        );

        Function* builtin_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", builtin_func);
        builder->SetInsertPoint(entry);

        auto arg_it = builtin_func->arg_begin();
        Value* arg1 = &*arg_it++;
        Value* arg2 = &*arg_it;

        // Extract values as doubles for comparison (handles both int and float)
        Value* val1 = extractDoubleFromTagged(arg1);
        Value* val2 = extractDoubleFromTagged(arg2);

        // Perform comparison
        Value* cmp_result;
        if (operation == "<") {
            cmp_result = builder->CreateFCmpOLT(val1, val2, "cmp_lt");
        } else if (operation == ">") {
            cmp_result = builder->CreateFCmpOGT(val1, val2, "cmp_gt");
        } else if (operation == "<=") {
            cmp_result = builder->CreateFCmpOLE(val1, val2, "cmp_le");
        } else if (operation == ">=") {
            cmp_result = builder->CreateFCmpOGE(val1, val2, "cmp_ge");
        } else if (operation == "=") {
            cmp_result = builder->CreateFCmpOEQ(val1, val2, "cmp_eq");
        } else {
            eshkol_error("Unknown comparison operation: %s", operation.c_str());
            cmp_result = ConstantInt::get(int1_type, 0);
        }

        // Convert boolean to tagged value (int64 0 or 1)
        Value* int_result = builder->CreateZExt(cmp_result, int64_type);
        Value* result = packInt64ToTaggedValue(int_result, true);

        builder->CreateRet(result);

        // Restore IRBuilder state
        if (old_point.isSet()) {
            builder->restoreIP(old_point);
        }

        // Add to function table
        registerContextFunction(func_name, builtin_func);

        eshkol_debug("Created builtin comparison function: %s for operation '%s'",
                    func_name.c_str(), operation.c_str());

        return builtin_func;
    }

    // Create wrapper function for builtin predicates (even?, odd?, zero?, etc.)
    Function* createBuiltinPredicateFunction(const std::string& pred_name) {
        std::string func_name = "builtin_pred_" + pred_name;

        // Sanitize special characters in function name for LLVM
        for (char& c : func_name) {
            if (c == '?') c = 'Q';
        }

        // Check if function already exists
        auto existing_it = function_table.find(func_name);
        if (existing_it != function_table.end()) {
            return existing_it->second;
        }

        // Create function type: (tagged_value) -> tagged_value
        std::vector<Type*> param_types = {tagged_value_type};
        FunctionType* func_type = FunctionType::get(
            tagged_value_type,
            param_types,
            false
        );

        Function* builtin_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", builtin_func);
        builder->SetInsertPoint(entry);

        Value* arg = &*builtin_func->arg_begin();

        Value* result;
        if (pred_name == "even?") {
            Value* val = unpackInt64FromTaggedValue(arg);
            Value* remainder = builder->CreateSRem(val, ConstantInt::get(int64_type, 2));
            Value* is_even = builder->CreateICmpEQ(remainder, ConstantInt::get(int64_type, 0));
            result = packBoolToTaggedValue(is_even);
        } else if (pred_name == "odd?") {
            Value* val = unpackInt64FromTaggedValue(arg);
            Value* remainder = builder->CreateSRem(val, ConstantInt::get(int64_type, 2));
            Value* is_odd = builder->CreateICmpNE(remainder, ConstantInt::get(int64_type, 0));
            result = packBoolToTaggedValue(is_odd);
        } else if (pred_name == "zero?") {
            Value* val = unpackInt64FromTaggedValue(arg);
            Value* is_zero = builder->CreateICmpEQ(val, ConstantInt::get(int64_type, 0));
            result = packBoolToTaggedValue(is_zero);
        } else if (pred_name == "positive?") {
            Value* val = extractDoubleFromTagged(arg);
            Value* is_pos = builder->CreateFCmpOGT(val, ConstantFP::get(double_type, 0.0));
            result = packBoolToTaggedValue(is_pos);
        } else if (pred_name == "negative?") {
            Value* val = extractDoubleFromTagged(arg);
            Value* is_neg = builder->CreateFCmpOLT(val, ConstantFP::get(double_type, 0.0));
            result = packBoolToTaggedValue(is_neg);
        } else if (pred_name == "null?") {
            Value* type_tag = getTaggedValueType(arg);
            Value* base_type = builder->CreateAnd(type_tag, ConstantInt::get(int8_type, 0x0F));
            // Check for NULL type or CONS_PTR with null pointer
            Value* is_null_type = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_NULL));
            Value* is_cons_type = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
            Value* data_val = unpackInt64FromTaggedValue(arg);
            Value* is_null_ptr = builder->CreateICmpEQ(data_val,
                ConstantInt::get(int64_type, 0));
            Value* is_cons_null = builder->CreateAnd(is_cons_type, is_null_ptr);
            Value* is_null = builder->CreateOr(is_null_type, is_cons_null);
            result = packBoolToTaggedValue(is_null);
        } else if (pred_name == "pair?") {
            Value* type_tag = getTaggedValueType(arg);
            Value* base_type = builder->CreateAnd(type_tag, ConstantInt::get(int8_type, 0x0F));
            // Check for CONS_PTR with non-null pointer
            Value* is_cons_type = builder->CreateICmpEQ(base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_CONS_PTR));
            Value* data_val = unpackInt64FromTaggedValue(arg);
            Value* is_not_null = builder->CreateICmpNE(data_val,
                ConstantInt::get(int64_type, 0));
            Value* is_pair = builder->CreateAnd(is_cons_type, is_not_null);
            result = packBoolToTaggedValue(is_pair);
        } else {
            eshkol_error("Unknown predicate: %s", pred_name.c_str());
            result = packBoolToTaggedValue(ConstantInt::getFalse(*context));
        }

        builder->CreateRet(result);

        // Restore IRBuilder state
        if (old_point.isSet()) {
            builder->restoreIP(old_point);
        }

        // Add to function table
        registerContextFunction(func_name, builtin_func);

        eshkol_debug("Created builtin predicate function: %s for predicate '%s'",
                    func_name.c_str(), pred_name.c_str());

        return builtin_func;
    }

    // Create wrapper function for builtin unary math functions (abs, etc.)
    Function* createBuiltinUnaryMathFunction(const std::string& func_name_in) {
        std::string func_name = "builtin_math_" + func_name_in;

        // Check if function already exists
        auto existing_it = function_table.find(func_name);
        if (existing_it != function_table.end()) {
            return existing_it->second;
        }

        // Create function type: (tagged_value) -> tagged_value
        std::vector<Type*> param_types = {tagged_value_type};
        FunctionType* func_type = FunctionType::get(
            tagged_value_type,
            param_types,
            false
        );

        Function* builtin_func = Function::Create(
            func_type,
            Function::ExternalLinkage,
            func_name,
            module.get()
        );

        // Save current insertion point
        IRBuilderBase::InsertPoint old_point = builder->saveIP();

        // Create function body
        BasicBlock* entry = BasicBlock::Create(*context, "entry", builtin_func);
        builder->SetInsertPoint(entry);

        Value* arg = &*builtin_func->arg_begin();

        // UNIFIED MATH BUILTIN HANDLING: All math functions use the same pattern
        // Map Scheme-style names to C library names
        std::string c_func_name = func_name_in;
        if (func_name_in == "abs") c_func_name = "fabs";
        else if (func_name_in == "ceiling") c_func_name = "ceil";
        else if (func_name_in == "truncate") c_func_name = "trunc";

        // Get or declare the C math function
        Function* c_math_func = nullptr;
        auto c_it = function_table.find(c_func_name);
        if (c_it != function_table.end()) {
            c_math_func = c_it->second;
        } else {
            // Declare it
            FunctionType* math_type = FunctionType::get(double_type, {double_type}, false);
            c_math_func = Function::Create(math_type, Function::ExternalLinkage, c_func_name, module.get());
            function_table[c_func_name] = c_math_func;
        }

        Value* result;
        if (c_math_func) {
            // POLYMORPHIC INPUT: Handle both int64 and double inputs
            // Get the type tag from the argument
            Value* arg_type = getTaggedValueType(arg);
            Value* arg_base_type = builder->CreateAnd(arg_type,
                ConstantInt::get(int8_type, 0x0F));
            Value* arg_is_double = builder->CreateICmpEQ(arg_base_type,
                ConstantInt::get(int8_type, ESHKOL_VALUE_DOUBLE));

            // Convert to double: if double, BitCast; if int64, SIToFP
            Value* double_val = builder->CreateSelect(arg_is_double,
                unpackDoubleFromTaggedValue(arg),
                builder->CreateSIToFP(unpackInt64FromTaggedValue(arg), double_type));

            Value* math_result = builder->CreateCall(c_math_func, {double_val});
            result = packDoubleToTaggedValue(math_result);
        } else {
            eshkol_error("Unknown unary math function: %s", func_name_in.c_str());
            result = tagged_->packNull();
        }

        builder->CreateRet(result);

        // Restore IRBuilder state
        if (old_point.isSet()) {
            builder->restoreIP(old_point);
        }

        // Add to function table
        registerContextFunction(func_name, builtin_func);

        eshkol_debug("Created builtin unary math function: %s for '%s'",
                    func_name.c_str(), func_name_in.c_str());

        return builtin_func;
    }
};

// ============================================================================
// ControlFlowCodegen Callback Implementations
// ============================================================================

namespace ControlFlowCallbacks {
    // Thread-local storage for TypedValue to handle reentrant calls
    // When control flow operations are nested (e.g., begin inside cond inside and),
    // each level needs its own TypedValue storage
    // CRITICAL: Using std::deque instead of std::vector because deque does NOT
    // invalidate pointers to existing elements when push_back is called.
    // This prevents pointer invalidation during nested control flow operations.
    static thread_local std::deque<TypedValue> typed_value_stack;

    llvm::Value* codegenASTWrapper(const void* ast, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->codegenAST(static_cast<const eshkol_ast_t*>(ast));
    }

    void* codegenTypedASTWrapper(const void* ast, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        // Push a new TypedValue onto the stack to handle reentrancy
        typed_value_stack.push_back(codegen->codegenTypedAST(static_cast<const eshkol_ast_t*>(ast)));
        return &typed_value_stack.back();
    }

    llvm::Value* typedToTaggedWrapper(void* typed_value, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        auto* tv = static_cast<TypedValue*>(typed_value);
        llvm::Value* result = codegen->typedValueToTaggedValue(*tv);
        // Pop the TypedValue we pushed in codegenTypedASTWrapper
        // Only pop if the pointer matches the top (safety check)
        if (!typed_value_stack.empty() && tv == &typed_value_stack.back()) {
            typed_value_stack.pop_back();
        }
        return result;
    }

    void codegenFuncDefineWrapper(const void* op, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        codegen->codegenNestedFunctionDefinition(static_cast<const eshkol_operations_t*>(op));
    }

    void codegenVarDefineWrapper(const void* op, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        // REFACTOR: Use new BindingCodegen for variable definitions
        codegen->binding_->define(static_cast<const eshkol_operations_t*>(op));
    }

    llvm::Value* eqvCompareWrapper(llvm::Value* a, llvm::Value* b, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->callBuiltinEqv(a, b);
    }

    llvm::Value* detectAndPackWrapper(llvm::Value* val, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        // Use detectValueType to properly identify CONS_PTR from PtrToInt values
        TypedValue tv = codegen->detectValueType(val);
        return codegen->typedValueToTaggedValue(tv);
    }

    llvm::Value* consCreateWrapper(llvm::Value* car, llvm::Value* cdr, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->codegenTaggedArenaConsCellFromTaggedValue(car, cdr);
    }

    int getTypedValueTypeWrapper(void* typed_value, void* context) {
        auto* tv = static_cast<TypedValue*>(typed_value);
        return static_cast<int>(tv->type);
    }

    void registerFuncBindingWrapper(const char* var_name, void* typed_value, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        auto* tv = static_cast<TypedValue*>(typed_value);

        if (!tv || !tv->llvm_value) return;

        // Try to recover the Function* from the value
        Function* matching_func = nullptr;

        // Check if the value is a direct Function*
        if (isa<Function>(tv->llvm_value)) {
            matching_func = dyn_cast<Function>(tv->llvm_value);
        }
        // Check if it's a PtrToInt of a Function*
        else if (PtrToIntInst* ptoi = dyn_cast<PtrToIntInst>(tv->llvm_value)) {
            if (Function* func = dyn_cast<Function>(ptoi->getPointerOperand())) {
                matching_func = func;
            }
        }
        // Check if it's a ConstantExpr (PtrToInt)
        else if (ConstantExpr* ce = dyn_cast<ConstantExpr>(tv->llvm_value)) {
            if (ce->getOpcode() == Instruction::PtrToInt) {
                if (Function* func = dyn_cast<Function>(ce->getOperand(0))) {
                    matching_func = func;
                }
            }
        }
        // NOTE: Removed dangerous fallback that used last_generated_lambda_name
        // This fallback was causing incorrect function registration for closures
        // returned from function calls (e.g., (define quadruple (apply-twice double))
        // would incorrectly register quadruple_func -> double instead of the closure's function)

        if (matching_func) {
            std::string func_key = std::string(var_name) + "_func";

            // Store function reference
            codegen->symbol_table[func_key] = matching_func;
            codegen->global_symbol_table[func_key] = matching_func;

            // Also store scoped key if inside a function
            if (codegen->current_function) {
                std::string scoped_key = codegen->current_function->getName().str() + "." + func_key;
                codegen->symbol_table[scoped_key] = matching_func;
                codegen->global_symbol_table[scoped_key] = matching_func;
                eshkol_debug("registerFuncBindingWrapper: stored scoped %s -> %s",
                            scoped_key.c_str(), matching_func->getName().str().c_str());
            }

            eshkol_debug("registerFuncBindingWrapper: stored %s -> %s",
                        func_key.c_str(), matching_func->getName().str().c_str());
        }
    }

    llvm::Value* extractConsCarWrapper(llvm::Value* cons_ptr, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        // Use extractCarAsTaggedValue which handles i64-to-ptr conversion
        // (not extractConsCarAsTaggedValue which expects ptr directly)
        return codegen->extractCarAsTaggedValue(cons_ptr);
    }

    llvm::Function* getConsAccessorWrapper(void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->getTaggedConsGetPtrFunc();
    }

    llvm::Value* codegenASTTypedWrapper(const eshkol_ast_t* ast, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->codegenAST(ast);
    }

    // MapCodegen callbacks
    llvm::Value* codegenLambdaWrapper(const eshkol_operations_t* op, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->codegenLambda(op);
    }

    llvm::Value* closureCallWrapper(llvm::Value* closure, const std::vector<llvm::Value*>& args, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->codegenClosureCall(closure, args);
    }

    llvm::Function* getConsSetPtrWrapper(void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->getTaggedConsSetPtrFunc();
    }

    llvm::Value* resolveLambdaWrapper(const eshkol_ast_t* ast, size_t arity, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        return codegen->resolveLambdaFunction(ast, arity);
    }

    llvm::Value* indirectCallWrapper(llvm::Value* arg, size_t arity, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        // Cast Value* to Argument* - this is only called with actual function arguments
        return codegen->codegenIndirectFunctionCall(llvm::cast<llvm::Argument>(arg), arity);
    }

    void pushFunctionContextWrapper(void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        codegen->pushFunctionContext();
    }

    void popFunctionContextWrapper(void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        codegen->popFunctionContext();
    }

    bool isSelfTailRecursiveWrapper(const void* lambda_op, const char* func_name, void* context) {
        auto* codegen = static_cast<EshkolLLVMCodeGen*>(context);
        const eshkol_operations_t* op = static_cast<const eshkol_operations_t*>(lambda_op);
        return codegen->isSelfTailRecursive(op, func_name ? func_name : "");
    }
}

extern "C" {

void eshkol_set_uses_stdlib(int uses_stdlib) {
    g_uses_stdlib = (uses_stdlib != 0);
    eshkol_debug("Set uses_stdlib flag to %s", g_uses_stdlib ? "true" : "false");
}

LLVMModuleRef eshkol_generate_llvm_ir(const eshkol_ast_t* asts, size_t num_asts, const char* module_name) {
    try {
        EshkolLLVMCodeGen codegen(module_name, false);  // not library mode
        auto result = codegen.generateIR(asts, num_asts);

        if (!result.first || !result.second) {
            return nullptr;
        }

        // Create wrapper and store in global map for lifetime management
        Module* raw_module = result.first.get();
        LLVMModuleRef module_ref = wrap(raw_module);

        auto wrapper = std::make_unique<EshkolLLVMModule>(std::move(result.first), std::move(result.second));
        g_llvm_modules[module_ref] = std::move(wrapper);

        return module_ref;
    } catch (const std::exception& e) {
        eshkol_error("Failed to generate LLVM IR: %s", e.what());
        return nullptr;
    }
}

LLVMModuleRef eshkol_generate_llvm_ir_library(const eshkol_ast_t* asts, size_t num_asts, const char* module_name) {
    try {
        EshkolLLVMCodeGen codegen(module_name, true);  // library mode
        auto result = codegen.generateIR(asts, num_asts);

        if (!result.first || !result.second) {
            return nullptr;
        }

        // Create wrapper and store in global map for lifetime management
        Module* raw_module = result.first.get();
        LLVMModuleRef module_ref = wrap(raw_module);

        auto wrapper = std::make_unique<EshkolLLVMModule>(std::move(result.first), std::move(result.second));
        g_llvm_modules[module_ref] = std::move(wrapper);

        return module_ref;
    } catch (const std::exception& e) {
        eshkol_error("Failed to generate LLVM IR (library mode): %s", e.what());
        return nullptr;
    }
}

// REPL MODE API FUNCTIONS

void eshkol_repl_enable() {
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_mode_enabled = true;
}

void eshkol_repl_disable() {
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_mode_enabled = false;
    g_repl_symbol_addresses.clear();
    g_repl_function_addresses.clear();
    g_repl_function_arities.clear();
}

void eshkol_repl_register_symbol(const char* name, uint64_t address) {
    if (!name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_symbol_addresses[name] = address;
}

void eshkol_repl_register_function(const char* name, uint64_t address, size_t arity) {
    if (!name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_function_addresses[name] = address;
    g_repl_function_arities[name] = arity;
}

void eshkol_repl_register_lambda_name(const char* var_name, const char* lambda_name) {
    if (!var_name || !lambda_name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_lambda_names[var_name] = lambda_name;
}

void eshkol_repl_register_sexpr(const char* sexpr_name, uint64_t sexpr_value) {
    if (!sexpr_name) return;
    std::lock_guard<std::mutex> lock(g_repl_mutex);
    g_repl_sexpr_values[sexpr_name] = sexpr_value;
}

void eshkol_register_external_functions(const eshkol_ast_t* asts, size_t num_asts) {
    // Stub - library compilation is not yet implemented
    (void)asts;
    (void)num_asts;
}

void eshkol_print_llvm_ir(LLVMModuleRef module_ref) {
    if (!module_ref) return;
    
    Module* module = unwrap(module_ref);
    module->print(outs(), nullptr);
}

int eshkol_dump_llvm_ir_to_file(LLVMModuleRef module_ref, const char* filename) {
    if (!module_ref || !filename) return -1;
    
    Module* module = unwrap(module_ref);
    
    std::error_code ec;
    raw_fd_ostream file(filename, ec, sys::fs::OF_None);
    
    if (ec) {
        eshkol_error("Failed to open file %s: %s", filename, ec.message().c_str());
        return -1;
    }
    
    module->print(file, nullptr);
    return 0;
}

int eshkol_compile_llvm_ir_to_object(LLVMModuleRef module_ref, const char* filename) {
    if (!module_ref || !filename) return -1;
    
    auto it = g_llvm_modules.find(module_ref);
    if (it == g_llvm_modules.end()) {
        eshkol_error("Invalid LLVM module reference");
        return -1;
    }
    
    Module* module = it->second->module.get();
    LLVMContext* context = it->second->context.get();

    try {
        // Verify module before attempting object generation (debug builds only for speed)
        #ifndef NDEBUG
        std::string verify_error;
        raw_string_ostream verify_stream(verify_error);
        if (verifyModule(*module, &verify_stream)) {
            eshkol_error("Module verification failed before object generation: %s", verify_error.c_str());
            return -1;
        }
        #endif

        // Initialize target (use cached values for speed)
        if (!g_target_info_cached) {
            g_cached_target_triple = sys::getDefaultTargetTriple();
            g_cached_cpu_name = sys::getHostCPUName().str();
            SubtargetFeatures features;
            auto host_features = sys::getHostCPUFeatures();
            for (auto& f : host_features) {
                features.AddFeature(f.first(), f.second);
            }
            g_cached_features = features.getString();
            g_target_info_cached = true;
        }

        Triple target_triple(g_cached_target_triple);
        module->setTargetTriple(target_triple);

        std::string error;
        const Target* target = TargetRegistry::lookupTarget(g_cached_target_triple, error);
        if (!target) {
            eshkol_error("Failed to lookup target: %s", error.c_str());
            return -1;
        }

        // Create target machine with cached CPU info and size optimization
        TargetOptions target_options;
        std::unique_ptr<TargetMachine> target_machine(
            target->createTargetMachine(target_triple, g_cached_cpu_name, g_cached_features,
                                       target_options, Reloc::PIC_, std::nullopt,
                                       CodeGenOptLevel::Default));

        if (!target_machine) {
            eshkol_error("Failed to create target machine for %s", g_cached_target_triple.c_str());
            return -1;
        }

        // Set data layout
        module->setDataLayout(target_machine->createDataLayout());

        // Open output file
        std::error_code ec;
        raw_fd_ostream dest(filename, ec, sys::fs::OF_None);
        if (ec) {
            eshkol_error("Failed to open object file %s: %s", filename, ec.message().c_str());
            return -1;
        }

        // Create pass manager and emit object file
        legacy::PassManager pass_manager;
        if (target_machine->addPassesToEmitFile(pass_manager, dest, nullptr,
                                              CodeGenFileType::ObjectFile)) {
            eshkol_error("Target machine cannot emit object files");
            return -1;
        }

        bool result = pass_manager.run(*module);
        dest.flush();

        // Check if output file is empty (indicates silent failure)
        dest.close();
        std::ifstream check_file(filename, std::ios::ate | std::ios::binary);
        if (check_file.good()) {
            auto size = check_file.tellg();
            check_file.close();
            if (size == 0) {
                eshkol_error("Object file generation produced empty file - module may be invalid");
                return -1;
            }
        }

        eshkol_info("Successfully generated object file: %s", filename);
        return 0;
        
    } catch (const std::exception& e) {
        eshkol_error("Exception during object file generation: %s", e.what());
        return -1;
    }
}

int eshkol_compile_llvm_ir_to_executable(LLVMModuleRef module_ref, const char* filename, 
                                        const char* const* lib_paths, size_t num_lib_paths,
                                        const char* const* linked_libs, size_t num_linked_libs) {
    if (!module_ref || !filename) return -1;
    
    // First compile to temporary object file
    std::string temp_obj = std::string(filename) + ".tmp.o";
    if (eshkol_compile_llvm_ir_to_object(module_ref, temp_obj.c_str()) != 0) {
        return -1;
    }
    
    try {
        // Get absolute path to build directory where libeshkol-static.a is located
        char cwd[4096];
        if (getcwd(cwd, sizeof(cwd)) != nullptr) {
            std::string build_dir = std::string(cwd) + "/build";
            eshkol_debug("Adding library search path: %s", build_dir.c_str());
        }
        
        // Use system linker to create executable
        std::string link_cmd = "c++ -fPIE " + temp_obj + " -lm";
        
        // Add library search paths FIRST (before -l flags)
        if (lib_paths && num_lib_paths > 0) {
            for (size_t i = 0; i < num_lib_paths; i++) {
                if (lib_paths[i]) {
                    link_cmd += " -L" + std::string(lib_paths[i]);
                }
            }
        }
        
        // CRITICAL FIX: Use direct path to library file instead of -L flag
        // This avoids directory search path issues
        char build_path[4096];
        if (getcwd(build_path, sizeof(build_path)) != nullptr) {
            std::string cwd_str = std::string(build_path);
            std::string lib_path;
            // Check if we're already in the build directory
            if (cwd_str.length() >= 5 && cwd_str.substr(cwd_str.length() - 5) == "build") {
                lib_path = cwd_str + "/libeshkol-static.a";
            } else {
                lib_path = cwd_str + "/build/libeshkol-static.a";
            }
            link_cmd += " " + lib_path;
            eshkol_debug("Linking with library: %s", lib_path.c_str());
        } else {
            // Fallback to search path method
            link_cmd += " -L./build -leshkol-static";
        }
        
        // Add linked libraries
        if (linked_libs && num_linked_libs > 0) {
            for (size_t i = 0; i < num_linked_libs; i++) {
                if (linked_libs[i]) {
                    link_cmd += " -l" + std::string(linked_libs[i]);
                }
            }
        }
        
        link_cmd += " -o " + std::string(filename);
        
        eshkol_info("Linking executable: %s", link_cmd.c_str());
        int result = system(link_cmd.c_str());
        
        // Clean up temporary object file
        std::remove(temp_obj.c_str());
        
        if (result != 0) {
            eshkol_error("Linking failed with exit code %d", result);
            return -1;
        }
        
        eshkol_info("Successfully generated executable: %s", filename);
        return 0;
        
    } catch (const std::exception& e) {
        eshkol_error("Exception during executable generation: %s", e.what());
        // Clean up temp file on error
        std::remove(temp_obj.c_str());
        return -1;
    }
}

void eshkol_dispose_llvm_module(LLVMModuleRef module_ref) {
    if (!module_ref) return;

    auto it = g_llvm_modules.find(module_ref);
    if (it != g_llvm_modules.end()) {
        // This will automatically destroy both the module and context
        g_llvm_modules.erase(it);
    }
}

void eshkol_release_module_for_jit(LLVMModuleRef module_ref) {
    if (!module_ref) return;

    auto it = g_llvm_modules.find(module_ref);
    if (it != g_llvm_modules.end()) {
        // Release ownership of the module (JIT will take it)
        // But keep the context alive by not erasing the entry, just releasing the module pointer
        it->second->module.release();  // Don't delete module - JIT owns it now
        // Note: Context stays alive in g_llvm_modules until process exit
        // This is intentional - the context must outlive the JIT-compiled code
    }
}

} // extern "C"

#endif // ESHKOL_LLVM_BACKEND_ENABLED

