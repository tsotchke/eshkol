;;; Eshkol Math Library
;;; Numerical algorithms implemented in Eshkol itself
;;; For linear algebra, statistics, and numerical methods

;;; ============================================================
;;; Constants
;;; ============================================================

(define pi 3.141592653589793)
(define e 2.718281828459045)
(define epsilon 1e-15)

;;; ============================================================
;;; Matrix Element Access Helpers
;;; ============================================================

;; Get element at (row, col) from n×m matrix stored as flat tensor
(define (mat-ref M cols row col)
  (vref M (+ (* row cols) col)))

;; Create a mutable copy of a tensor as a vector
(define (tensor-copy T)
  (let* ((total (vector-length T))
         (V (make-vector total 0.0)))
    (letrec ((copy-loop (lambda (i)
      (if (< i total)
          (begin
            (vector-set! V i (vref T i))
            (copy-loop (+ i 1)))
          V))))
      (copy-loop 0))))

;;; ============================================================
;;; Determinant via LU Decomposition
;;; ============================================================

;; det: Compute determinant of n×n matrix using Gaussian elimination
;; with partial pivoting. O(n³) complexity.
;; Note: Uses mutable state for sign and result tracking
(define (det M n)
  (let* ((A (tensor-copy M))
         (state (make-vector 2 0.0)))  ;; state[0] = sign, state[1] = result
    (vector-set! state 0 1.0)  ;; sign = 1.0
    (vector-set! state 1 1.0)  ;; result = 1.0
    (letrec
      ((find-pivot (lambda (k i max-idx max-val)
         (if (< i n)
             (let ((val (abs (vref A (+ (* i n) k)))))
               (if (> val max-val)
                   (find-pivot k (+ i 1) i val)
                   (find-pivot k (+ i 1) max-idx max-val)))
             max-idx)))

       (swap-cols (lambda (k max-idx j)
         (if (< j n)
             (let ((tmp (vref A (+ (* k n) j))))
               (vector-set! A (+ (* k n) j)
                           (vref A (+ (* max-idx n) j)))
               (vector-set! A (+ (* max-idx n) j) tmp)
               (swap-cols k max-idx (+ j 1))))))

       (elim-col (lambda (k i factor j)
         (if (< j n)
             (begin
               (vector-set! A (+ (* i n) j)
                 (- (vref A (+ (* i n) j))
                    (* factor (vref A (+ (* k n) j)))))
               (elim-col k i factor (+ j 1))))))

       (elim-row (lambda (k pivot i)
         (if (< i n)
             (let ((factor (/ (vref A (+ (* i n) k)) pivot)))
               (elim-col k i factor k)
               (elim-row k pivot (+ i 1))))))

       (eliminate (lambda (k)
         (if (>= k n)
             (* (vref state 1) (vref state 0))  ;; Done - return result * sign
             (let* ((max-idx (find-pivot k (+ k 1) k (abs (vref A (+ (* k n) k))))))
               ;; Swap rows if needed
               (if (not (= max-idx k))
                   (begin
                     (vector-set! state 0 (- 0.0 (vref state 0)))  ;; Flip sign
                     (swap-cols k max-idx 0)))
               ;; Get pivot and update result
               (let ((pivot (vref A (+ (* k n) k))))
                 (vector-set! state 1 (* (vref state 1) pivot))
                 ;; Check for singular
                 (if (< (abs pivot) epsilon)
                     0.0  ;; Singular matrix
                     (begin
                       (elim-row k pivot (+ k 1))
                       (eliminate (+ k 1))))))))))

      (eliminate 0))))

;;; ============================================================
;;; Matrix Inverse via Gauss-Jordan Elimination
;;; ============================================================

;; inv: Compute inverse of n×n matrix using Gauss-Jordan elimination
;; Returns #f if matrix is singular
(define (inv M n)
  (let ((A (tensor-copy M))
        (I (tensor-copy (eye n))))

    (letrec
      ((find-pivot (lambda (k i max-idx max-val)
         (if (< i n)
             (let ((val (abs (vref A (+ (* i n) k)))))
               (if (> val max-val)
                   (find-pivot k (+ i 1) i val)
                   (find-pivot k (+ i 1) max-idx max-val)))
             max-idx)))

       (swap-row (lambda (k max-idx j)
         (if (< j n)
             (let ((tmp-a (vref A (+ (* k n) j)))
                   (tmp-i (vref I (+ (* k n) j))))
               (vector-set! A (+ (* k n) j)
                           (vref A (+ (* max-idx n) j)))
               (vector-set! A (+ (* max-idx n) j) tmp-a)
               (vector-set! I (+ (* k n) j)
                           (vref I (+ (* max-idx n) j)))
               (vector-set! I (+ (* max-idx n) j) tmp-i)
               (swap-row k max-idx (+ j 1))))))

       (scale-row (lambda (k pivot j)
         (if (< j n)
             (begin
               (vector-set! A (+ (* k n) j)
                 (/ (vref A (+ (* k n) j)) pivot))
               (vector-set! I (+ (* k n) j)
                 (/ (vref I (+ (* k n) j)) pivot))
               (scale-row k pivot (+ j 1))))))

       (elim-col (lambda (k i factor j)
         (if (< j n)
             (begin
               (vector-set! A (+ (* i n) j)
                 (- (vref A (+ (* i n) j))
                    (* factor (vref A (+ (* k n) j)))))
               (vector-set! I (+ (* i n) j)
                 (- (vref I (+ (* i n) j))
                    (* factor (vref I (+ (* k n) j)))))
               (elim-col k i factor (+ j 1))))))

       (elim-row (lambda (k i)
         (if (< i n)
             (begin
               (if (not (= i k))
                   (let ((factor (vref A (+ (* i n) k))))
                     (elim-col k i factor 0)))
               (elim-row k (+ i 1))))))

       (forward (lambda (k)
         (if (>= k n)
             #t
             (let ((max-idx (find-pivot k (+ k 1) k (abs (vref A (+ (* k n) k))))))
               (if (< (abs (vref A (+ (* max-idx n) k))) epsilon)
                   #f  ;; Singular
                   (begin
                     (if (not (= max-idx k))
                         (swap-row k max-idx 0))
                     (let ((pivot (vref A (+ (* k n) k))))
                       (scale-row k pivot 0))
                     (elim-row k 0)
                     (forward (+ k 1)))))))))

      (if (forward 0)
          I
          #f))))

;;; ============================================================
;;; Solve Linear System Ax = b
;;; ============================================================

;; solve: Solve Ax = b for x using LU decomposition with partial pivoting
;; A is n×n matrix, b is n-vector
;; Returns solution vector x, or #f if singular
(define (solve A b n)
  (let ((M (tensor-copy A))
        (x (tensor-copy b)))

    (letrec
      ((find-pivot (lambda (k i max-idx max-val)
         (if (< i n)
             (let ((val (abs (vref M (+ (* i n) k)))))
               (if (> val max-val)
                   (find-pivot k (+ i 1) i val)
                   (find-pivot k (+ i 1) max-idx max-val)))
             max-idx)))

       (swap-col (lambda (k max-idx j)
         (if (< j n)
             (let ((tmp (vref M (+ (* k n) j))))
               (vector-set! M (+ (* k n) j)
                           (vref M (+ (* max-idx n) j)))
               (vector-set! M (+ (* max-idx n) j) tmp)
               (swap-col k max-idx (+ j 1))))))

       (elim-col (lambda (k i factor j)
         (if (< j n)
             (begin
               (vector-set! M (+ (* i n) j)
                 (- (vref M (+ (* i n) j))
                    (* factor (vref M (+ (* k n) j)))))
               (elim-col k i factor (+ j 1))))))

       (elim-row (lambda (k i)
         (if (< i n)
             (let ((factor (/ (vref M (+ (* i n) k)) (vref M (+ (* k n) k)))))
               (vector-set! x i (- (vref x i) (* factor (vref x k))))
               (elim-col k i factor k)
               (elim-row k (+ i 1))))))

       (forward (lambda (k)
         (if (>= k n)
             #t
             (let ((max-idx (find-pivot k (+ k 1) k (abs (vref M (+ (* k n) k))))))
               (if (< (abs (vref M (+ (* max-idx n) k))) epsilon)
                   #f
                   (begin
                     (if (not (= max-idx k))
                         (begin
                           (let ((tmp-x (vref x k)))
                             (vector-set! x k (vref x max-idx))
                             (vector-set! x max-idx tmp-x))
                           (swap-col k max-idx 0)))
                     (elim-row k (+ k 1))
                     (forward (+ k 1))))))))

       (sum-row (lambda (k j acc)
         (if (< j n)
             (sum-row k (+ j 1) (+ acc (* (vref M (+ (* k n) j)) (vref x j))))
             acc)))

       (back-sub (lambda (k)
         (if (< k 0)
             #t
             (begin
               (vector-set! x k
                 (/ (- (vref x k) (sum-row k (+ k 1) 0.0))
                    (vref M (+ (* k n) k))))
               (back-sub (- k 1)))))))

      (if (forward 0)
          (begin
            (back-sub (- n 1))
            x)
          #f))))

;;; ============================================================
;;; Cross Product (3D vectors only)
;;; ============================================================

(define (cross u v)
  (vector (- (* (vref u 1) (vref v 2)) (* (vref u 2) (vref v 1)))
          (- (* (vref u 2) (vref v 0)) (* (vref u 0) (vref v 2)))
          (- (* (vref u 0) (vref v 1)) (* (vref u 1) (vref v 0)))))

;;; ============================================================
;;; Vector Operations
;;; ============================================================

;; dot: Dot product of two vectors
(define (dot u v)
  (let ((len (vector-length u)))
    (letrec ((loop (lambda (i acc)
      (if (< i len)
          (loop (+ i 1) (+ acc (* (vref u i) (vref v i))))
          acc))))
      (loop 0 0.0))))

;; normalize: Return unit vector in same direction
(define (normalize v)
  (let ((n (norm v)))
    (if (< n epsilon)
        v
        (let* ((len (vector-length v))
               (result (make-vector len 0.0)))
          (letrec ((loop (lambda (i)
            (if (< i len)
                (begin
                  (vector-set! result i (/ (vref v i) n))
                  (loop (+ i 1)))
                result))))
            (loop 0))))))

;;; ============================================================
;;; Eigenvalue Estimation (Power Method)
;;; ============================================================

;; Matrix-vector multiplication helper (defined first for power-iteration)
(define (mat-vec-mul A x rows cols)
  (let ((result (make-vector rows 0.0)))
    (letrec
      ((col-loop (lambda (i j acc)
         (if (< j cols)
             (col-loop i (+ j 1) (+ acc (* (vref A (+ (* i cols) j)) (vref x j))))
             acc)))

       (row-loop (lambda (i)
         (if (< i rows)
             (begin
               (vector-set! result i (col-loop i 0 0.0))
               (row-loop (+ i 1)))
             result))))

      (row-loop 0))))

;; Estimate dominant eigenvalue using power iteration
(define (power-iteration A n max-iters tolerance)
  (let ((x (make-vector n 1.0))
        (lambda-state (make-vector 1 0.0)))  ;; lambda-old

    (letrec
      ((normalize-loop (lambda (y norm-y i)
         (if (< i n)
             (begin
               (vector-set! x i (/ (vref y i) norm-y))
               (normalize-loop y norm-y (+ i 1))))))

       (iterate (lambda (k)
         (if (>= k max-iters)
             (dot x (mat-vec-mul A x n n))
             (let* ((y (mat-vec-mul A x n n))
                    (norm-y (norm y)))
               (normalize-loop y norm-y 0)
               (let ((lambda-new (dot x (mat-vec-mul A x n n))))
                 (if (< (abs (- lambda-new (vref lambda-state 0))) tolerance)
                     lambda-new
                     (begin
                       (vector-set! lambda-state 0 lambda-new)
                       (iterate (+ k 1))))))))))

      (iterate 0))))

;;; ============================================================
;;; Numerical Integration (Simpson's Rule)
;;; ============================================================

;; integrate: Numerical integration using Simpson's rule
;; f is the function, a and b are bounds, n is number of intervals (must be even)
(define (integrate f a b n)
  (let* ((h (/ (- b a) n))
         (sum-state (make-vector 1 0.0)))
    (vector-set! sum-state 0 (+ (f a) (f b)))
    (letrec ((loop (lambda (i)
      (if (< i n)
          (let ((x-val (+ a (* i h))))
            (if (even? i)
                (vector-set! sum-state 0 (+ (vref sum-state 0) (* 2.0 (f x-val))))
                (vector-set! sum-state 0 (+ (vref sum-state 0) (* 4.0 (f x-val)))))
            (loop (+ i 1)))
          (* (/ h 3.0) (vref sum-state 0))))))
      (loop 1))))

;;; ============================================================
;;; Root Finding (Newton-Raphson)
;;; ============================================================

;; newton: Find root of f using Newton-Raphson method
;; df is the derivative of f
(define (newton f df x0 tolerance max-iters)
  (letrec ((iterate (lambda (x k)
    (if (>= k max-iters)
        x
        (let ((fx (f x))
              (dfx (df x)))
          (if (< (abs dfx) epsilon)
              x
              (let ((x-new (- x (/ fx dfx))))
                (if (< (abs (- x-new x)) tolerance)
                    x-new
                    (iterate x-new (+ k 1))))))))))
    (iterate x0 0)))

;;; ============================================================
;;; Statistics
;;; ============================================================

;; variance: Compute variance of a vector
(define (variance v)
  (let* ((len (vector-length v))
         (mean (tensor-mean v)))
    (letrec ((loop (lambda (i acc)
      (if (< i len)
          (loop (+ i 1) (+ acc (* (- (vref v i) mean)
                                  (- (vref v i) mean))))
          (/ acc len)))))
      (loop 0 0.0))))

;; std: Standard deviation
(define (std v)
  (sqrt (variance v)))

;; covariance: Compute covariance of two vectors
(define (covariance u v)
  (let* ((len (vector-length u))
         (mean-u (tensor-mean u))
         (mean-v (tensor-mean v)))
    (letrec ((loop (lambda (i acc)
      (if (< i len)
          (loop (+ i 1) (+ acc (* (- (vref u i) mean-u)
                                  (- (vref v i) mean-v))))
          (/ acc len)))))
      (loop 0 0.0))))
