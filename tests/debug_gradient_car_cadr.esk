;; Debug test: gradient with car/cadr on vectors
;; Expected: gradient of f(x,y) = x^2 + y^2 at (3,4) is (6,8)

(require stdlib)

;; Test 1: Just extract elements with car/cadr (no gradient)
(define test-vec (vector 3.0 4.0))
(display "test-vec: ")
(display test-vec)
(newline)
(display "car test-vec: ")
(display (car test-vec))
(newline)
(display "cadr test-vec: ")
(display (cadr test-vec))
(newline)
(newline)

;; Test 2: Function using car/cadr
(define (f v)
  (let ((x (car v))
        (y (cadr v)))
    (+ (* x x) (* y y))))

(display "f(test-vec) = ")
(display (f (list 3.0 4.0)))
(newline)
(newline)

;; Test 3: Gradient computation
(display "Computing gradient of f at (3.0, 4.0)...")
(newline)
(define grad-result (gradient f (vector 3.0 4.0)))
(display "Gradient: ")
(display grad-result)
(display " (expected: #(6 8))")
(newline)
(newline)

;; Test 4: Try with simpler function - just y^2
(define (g v)
  (let ((y (cadr v)))
    (* y y)))

(display "g(v) = y^2")
(newline)
(display "Gradient of g at (3.0, 4.0): ")
(display (gradient g (vector 3.0 4.0)))
(display " (expected: #(0 8))")
(newline)
(newline)

;; Test 5: Try with just x^2
(define (h v)
  (let ((x (car v)))
    (* x x)))

(display "h(v) = x^2")
(newline)
(display "Gradient of h at (3.0, 4.0): ")
(display (gradient h (vector 3.0 4.0)))
(display " (expected: #(6 0))")
(newline)
(newline)

;; Test 6: Use vref instead of car/cadr
(define (f-vref v)
  (let ((x (vref v 0))
        (y (vref v 1)))
    (+ (* x x) (* y y))))

(display "Using vref instead of car/cadr:")
(newline)
(display "Gradient of f-vref at (3.0, 4.0): ")
(display (gradient f-vref (vector 3.0 4.0)))
(display " (expected: #(6 8))")
(newline)

0
